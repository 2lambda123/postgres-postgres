CREATE ROLE role_admin LOGIN SUPERUSER;
\connect postgres role_admin
CREATE FUNCTION check_memberships()
 RETURNS TABLE (role name, member name, grantor name, admin_option boolean, datname name)
 AS $$
SELECT
  r.rolname as role,
  m.rolname as member,
  g.rolname as grantor,
  admin_option,
  d.datname
FROM pg_auth_members a
LEFT JOIN pg_roles r ON r.oid = a.roleid
LEFT JOIN pg_roles m ON m.oid = a.member
LEFT JOIN pg_roles g ON g.oid = a.grantor
LEFT JOIN pg_database d ON d.oid = a.dbid
WHERE
  m.rolname LIKE 'role__'
ORDER BY
  1, 2, 5
$$ LANGUAGE SQL;
CREATE ROLE role_a;
CREATE ROLE role_b;
CREATE ROLE role_c;
CREATE ROLE role_d;
CREATE ROLE role_e NOINHERIT;
\connect template1
CREATE TABLE data AS SELECT generate_series(1, 3);
CREATE DATABASE db_1;
CREATE DATABASE db_2;
CREATE DATABASE db_3;
CREATE DATABASE db_4;
-- Initial GRANT statements
GRANT pg_read_all_data TO role_a WITH ADMIN OPTION;
GRANT pg_read_all_data TO role_b IN DATABASE db_1;
GRANT role_a TO role_d IN DATABASE db_1;
GRANT role_a TO role_e;
GRANT role_a TO role_e IN DATABASE db_1;
\connect db_2 role_admin
GRANT pg_read_all_data TO role_b IN CURRENT DATABASE;
GRANT pg_read_all_data TO role_c IN CURRENT DATABASE WITH ADMIN OPTION;
GRANT pg_read_all_data TO role_c IN DATABASE db_4 GRANTED BY role_a;
\connect postgres role_admin
-- Grant should fail if target database does not exist
GRANT pg_read_all_data TO role_e IN DATABASE non_existent;
ERROR:  database "non_existent" does not exist
SELECT * FROM check_memberships();
       role       | member |  grantor   | admin_option | datname 
------------------+--------+------------+--------------+---------
 pg_read_all_data | role_a | role_admin | t            | 
 pg_read_all_data | role_b | role_admin | f            | db_1
 pg_read_all_data | role_b | role_admin | f            | db_2
 pg_read_all_data | role_c | role_admin | t            | db_2
 pg_read_all_data | role_c | role_a     | f            | db_4
 role_a           | role_d | role_admin | f            | db_1
 role_a           | role_e | role_admin | f            | db_1
 role_a           | role_e | role_admin | f            | 
(8 rows)

-- Ensure GRANT warning messages for duplicate grants
GRANT pg_read_all_data TO role_a; -- notice
NOTICE:  role "role_a" is already a member of role "pg_read_all_data"
GRANT pg_read_all_data TO role_b IN DATABASE db_2; -- notice
NOTICE:  role "role_b" is already a member of role "pg_read_all_data" in database "db_2"
-- Ensure with admin option can still be granted without warning (unless already granted)
GRANT pg_read_all_data TO role_b IN DATABASE db_3 WITH ADMIN OPTION; -- silent
GRANT pg_read_all_data TO role_b IN DATABASE db_3 WITH ADMIN OPTION; -- notice
NOTICE:  role "role_b" is already a member of role "pg_read_all_data" in database "db_3"
GRANT pg_read_all_data TO role_b IN DATABASE db_4 WITH ADMIN OPTION; -- silent
GRANT pg_read_all_data TO role_d IN DATABASE db_4 WITH ADMIN OPTION; -- silent
SELECT * FROM check_memberships();
       role       | member |  grantor   | admin_option | datname 
------------------+--------+------------+--------------+---------
 pg_read_all_data | role_a | role_admin | t            | 
 pg_read_all_data | role_b | role_admin | f            | db_1
 pg_read_all_data | role_b | role_admin | f            | db_2
 pg_read_all_data | role_b | role_admin | t            | db_3
 pg_read_all_data | role_b | role_admin | t            | db_4
 pg_read_all_data | role_c | role_admin | t            | db_2
 pg_read_all_data | role_c | role_a     | f            | db_4
 pg_read_all_data | role_d | role_admin | t            | db_4
 role_a           | role_d | role_admin | f            | db_1
 role_a           | role_e | role_admin | f            | db_1
 role_a           | role_e | role_admin | f            | 
(11 rows)

-- Test membership privileges
\connect db_1
SET ROLE role_a;
SELECT * FROM data; -- success (read-all cluster-wide)
 generate_series 
-----------------
               1
               2
               3
(3 rows)

SET ROLE role_b;
SELECT * FROM data; -- success (read-all in database)
 generate_series 
-----------------
               1
               2
               3
(3 rows)

SET ROLE role_c;
SELECT * FROM data; -- error (not granted)
ERROR:  permission denied for table data
SET ROLE role_d;
SELECT * FROM data; -- success (inherited from role_a)
 generate_series 
-----------------
               1
               2
               3
(3 rows)

SET ROLE role_e;
SELECT * FROM data; -- error (no inherit)
ERROR:  permission denied for table data
\connect db_2
SET ROLE role_a;
SELECT * FROM data; -- success (read-all cluster-wide)
 generate_series 
-----------------
               1
               2
               3
(3 rows)

SET ROLE role_b;
SELECT * FROM data; -- success (read-all in database)
 generate_series 
-----------------
               1
               2
               3
(3 rows)

SET ROLE role_c;
SELECT * FROM data; -- success (read-all in database)
 generate_series 
-----------------
               1
               2
               3
(3 rows)

SET ROLE role_d;
SELECT * FROM data; -- error (not granted)
ERROR:  permission denied for table data
SET ROLE role_e;
SELECT * FROM data; -- error (no inherit)
ERROR:  permission denied for table data
-- Ensure ADMIN OPTION can grant cluster-wide and within any DB if cluster-wide
\connect template1
CREATE ROLE role_f;
CREATE ROLE role_g;
GRANT role_b TO role_g;
-- Test cluster-wide membership
SET ROLE role_a;
GRANT pg_write_all_data TO role_f; -- error (no admin option)
ERROR:  must have admin option on role "pg_write_all_data"
GRANT pg_read_all_data TO role_f; -- success (cluster-wide admin option)
REVOKE pg_read_all_data FROM role_f;
GRANT pg_read_all_data TO role_f IN DATABASE db_4; -- success (cluster-wide admin option)
REVOKE pg_read_all_data FROM role_f IN DATABASE db_4;
-- Ensure ADMIN OPTION grnats are denied if not cluster-wide or if not in the same database when database-specific
SET ROLE role_b;
GRANT pg_read_all_data TO role_f; -- error (no cluster-wide admin option)
ERROR:  must have admin option on role "pg_read_all_data"
GRANT pg_read_all_data TO role_f IN DATABASE db_3; -- error (if admin option is not cluster-wide, database-specific grants are not allowed across databases)
ERROR:  must have admin option on role "pg_read_all_data"
-- Ensure ADMIN OPTION can grant only within same database if database-specific
\connect db_3
SET SESSION AUTHORIZATION role_b;
GRANT pg_read_all_data TO role_f; -- error (no cluster-wide admin option)
ERROR:  must have admin option on role "pg_read_all_data"
GRANT pg_read_all_data TO role_f IN DATABASE db_2; -- error (no admin option for the target database)
ERROR:  must have admin option on role "pg_read_all_data"
GRANT pg_read_all_data TO role_f IN CURRENT DATABASE; -- success (database-specific admin option within the same database)
\connect db_4
SET SESSION AUTHORIZATION role_b;
GRANT pg_read_all_data TO role_f IN DATABASE db_4; -- success (database-specific admin option within the same database)
-- Ensure grant privileges inherit
\connect db_3
SET SESSION AUTHORIZATION role_e;
GRANT pg_read_all_data TO role_f; -- success (cluster-wide admin option through role_a membership)
GRANT pg_read_all_data TO role_f IN DATABASE db_2; -- success (cluster-wide admin option through role_a membership)
\connect db_4
SET SESSION AUTHORIZATION role_g;
GRANT pg_read_all_data TO role_f; -- error (no cluster-wide admin option)
ERROR:  must have admin option on role "pg_read_all_data"
REVOKE pg_read_all_data FROM role_f IN CURRENT DATABASE; -- success (database-specific admin option was inherited from role_b)
GRANT pg_read_all_data TO role_f IN CURRENT DATABASE; -- success (database-specific admin option was inherited from role_b)
\connect postgres role_admin
SELECT * FROM check_memberships();
       role       | member |  grantor   | admin_option | datname 
------------------+--------+------------+--------------+---------
 pg_read_all_data | role_a | role_admin | t            | 
 pg_read_all_data | role_b | role_admin | f            | db_1
 pg_read_all_data | role_b | role_admin | f            | db_2
 pg_read_all_data | role_b | role_admin | t            | db_3
 pg_read_all_data | role_b | role_admin | t            | db_4
 pg_read_all_data | role_c | role_admin | t            | db_2
 pg_read_all_data | role_c | role_a     | f            | db_4
 pg_read_all_data | role_d | role_admin | t            | db_4
 pg_read_all_data | role_f | role_e     | f            | db_2
 pg_read_all_data | role_f | role_b     | f            | db_3
 pg_read_all_data | role_f | role_g     | f            | db_4
 pg_read_all_data | role_f | role_e     | f            | 
 role_a           | role_d | role_admin | f            | db_1
 role_a           | role_e | role_admin | f            | db_1
 role_a           | role_e | role_admin | f            | 
 role_b           | role_g | role_admin | f            | 
(16 rows)

-- Test cluster-wide role membership
GRANT role_a TO role_g IN DATABASE db_1;
GRANT role_a TO role_g IN DATABASE db_2;
GRANT role_d TO role_a IN DATABASE db_2;
GRANT role_c TO role_b;
GRANT role_e TO role_a; -- error (directly cyclical)
ERROR:  role "role_e" is a member of role "role_a"
GRANT role_e TO role_a IN DATABASE db_2; -- error (directly cyclical)
ERROR:  role "role_e" is a member of role "role_a"
SET SESSION AUTHORIZATION role_g;
SET ROLE role_a; -- error
ERROR:  permission denied to set role "role_a"
SET ROLE role_b; -- success (cluster-wide direct member)
SET ROLE role_c; -- success (inherited through role_b)
SET ROLE role_d; -- error
ERROR:  permission denied to set role "role_d"
SET ROLE role_e; -- error
ERROR:  permission denied to set role "role_e"
SET ROLE role_g; -- success (self)
SET ROLE pg_read_all_data; -- error
ERROR:  permission denied to set role "pg_read_all_data"
-- Test database-specific role membership
\connect db_1
SET SESSION AUTHORIZATION role_g;
SET ROLE role_a; -- success (database-specific direct member)
SET ROLE role_b; -- success (cluster-wide direct member)
SET ROLE role_c; -- success (inherited through role_b)
SET ROLE role_d; -- error
ERROR:  permission denied to set role "role_d"
SET ROLE role_e; -- error
ERROR:  permission denied to set role "role_e"
SET ROLE role_f; -- error
ERROR:  permission denied to set role "role_f"
SET ROLE pg_read_all_data; -- success (inherted through role_b)
\connect db_2
SET SESSION AUTHORIZATION role_g;
SET ROLE role_a; -- success (database-specific direct member)
SET ROLE role_b; -- success
SET ROLE role_c; -- success
SET ROLE role_d; -- success (inherited through role_a)
SET ROLE role_e; -- error
ERROR:  permission denied to set role "role_e"
SET ROLE role_f; -- error
ERROR:  permission denied to set role "role_f"
SET ROLE pg_read_all_data; -- success (inherited through role_b)
-- test REVOKE works
-- test revoke error (non-existing)
-- test removing admin option
-- Ensure that DROP DATABASE cleans up the relevant memberships
\connect postgres role_admin
DROP DATABASE db_3;
SELECT * FROM check_memberships();
       role       | member |  grantor   | admin_option | datname 
------------------+--------+------------+--------------+---------
 pg_read_all_data | role_a | role_admin | t            | 
 pg_read_all_data | role_b | role_admin | f            | db_1
 pg_read_all_data | role_b | role_admin | f            | db_2
 pg_read_all_data | role_b | role_admin | t            | db_4
 pg_read_all_data | role_c | role_admin | t            | db_2
 pg_read_all_data | role_c | role_a     | f            | db_4
 pg_read_all_data | role_d | role_admin | t            | db_4
 pg_read_all_data | role_f | role_e     | f            | db_2
 pg_read_all_data | role_f | role_g     | f            | db_4
 pg_read_all_data | role_f | role_e     | f            | 
 role_a           | role_d | role_admin | f            | db_1
 role_a           | role_e | role_admin | f            | db_1
 role_a           | role_e | role_admin | f            | 
 role_a           | role_g | role_admin | f            | db_1
 role_a           | role_g | role_admin | f            | db_2
 role_b           | role_g | role_admin | f            | 
 role_c           | role_b | role_admin | f            | 
 role_d           | role_a | role_admin | f            | db_2
(18 rows)

