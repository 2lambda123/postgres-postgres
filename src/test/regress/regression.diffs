diff -U3 /Users/kenaniah/workspace/postgres/src/test/regress/expected/tablespace.out /Users/kenaniah/workspace/postgres/src/test/regress/results/tablespace.out
--- /Users/kenaniah/workspace/postgres/src/test/regress/expected/tablespace.out	2021-10-03 20:08:03.000000000 -0700
+++ /Users/kenaniah/workspace/postgres/src/test/regress/results/tablespace.out	2021-10-03 20:08:07.000000000 -0700
@@ -242,697 +242,11 @@
 
 -- check \d output
 \d testschema.foo
-              Table "testschema.foo"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- i      | integer |           |          | 
-Indexes:
-    "foo_idx" btree (i), tablespace "regress_tblspace"
-Tablespace: "regress_tblspace"
+dyld: lazy symbol binding failed: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
+
+dyld: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
 
-\d testschema.foo_idx
-      Index "testschema.foo_idx"
- Column |  Type   | Key? | Definition 
---------+---------+------+------------
- i      | integer | yes  | i
-btree, for table "testschema.foo"
-Tablespace: "regress_tblspace"
-
---
--- partitioned table
---
-CREATE TABLE testschema.part (a int) PARTITION BY LIST (a);
-SET default_tablespace TO pg_global;
-CREATE TABLE testschema.part_1 PARTITION OF testschema.part FOR VALUES IN (1);
-ERROR:  only shared relations can be placed in pg_global tablespace
-RESET default_tablespace;
-CREATE TABLE testschema.part_1 PARTITION OF testschema.part FOR VALUES IN (1);
-SET default_tablespace TO regress_tblspace;
-CREATE TABLE testschema.part_2 PARTITION OF testschema.part FOR VALUES IN (2);
-SET default_tablespace TO pg_global;
-CREATE TABLE testschema.part_3 PARTITION OF testschema.part FOR VALUES IN (3);
-ERROR:  only shared relations can be placed in pg_global tablespace
-ALTER TABLE testschema.part SET TABLESPACE regress_tblspace;
-CREATE TABLE testschema.part_3 PARTITION OF testschema.part FOR VALUES IN (3);
-CREATE TABLE testschema.part_4 PARTITION OF testschema.part FOR VALUES IN (4)
-  TABLESPACE pg_default;
-CREATE TABLE testschema.part_56 PARTITION OF testschema.part FOR VALUES IN (5, 6)
-  PARTITION BY LIST (a);
-ALTER TABLE testschema.part SET TABLESPACE pg_default;
-CREATE TABLE testschema.part_78 PARTITION OF testschema.part FOR VALUES IN (7, 8)
-  PARTITION BY LIST (a);
-ERROR:  only shared relations can be placed in pg_global tablespace
-CREATE TABLE testschema.part_910 PARTITION OF testschema.part FOR VALUES IN (9, 10)
-  PARTITION BY LIST (a) TABLESPACE regress_tblspace;
-RESET default_tablespace;
-CREATE TABLE testschema.part_78 PARTITION OF testschema.part FOR VALUES IN (7, 8)
-  PARTITION BY LIST (a);
-SELECT relname, spcname FROM pg_catalog.pg_class c
-    JOIN pg_catalog.pg_namespace n ON (c.relnamespace = n.oid)
-    LEFT JOIN pg_catalog.pg_tablespace t ON c.reltablespace = t.oid
-    where c.relname LIKE 'part%' AND n.nspname = 'testschema' order by relname;
- relname  |     spcname      
-----------+------------------
- part     | 
- part_1   | 
- part_2   | regress_tblspace
- part_3   | regress_tblspace
- part_4   | 
- part_56  | regress_tblspace
- part_78  | 
- part_910 | regress_tblspace
-(8 rows)
-
-RESET default_tablespace;
-DROP TABLE testschema.part;
--- partitioned index
-CREATE TABLE testschema.part (a int) PARTITION BY LIST (a);
-CREATE TABLE testschema.part1 PARTITION OF testschema.part FOR VALUES IN (1);
-CREATE INDEX part_a_idx ON testschema.part (a) TABLESPACE regress_tblspace;
-CREATE TABLE testschema.part2 PARTITION OF testschema.part FOR VALUES IN (2);
-SELECT relname, spcname FROM pg_catalog.pg_tablespace t, pg_catalog.pg_class c
-    where c.reltablespace = t.oid AND c.relname LIKE 'part%_idx';
-   relname   |     spcname      
--------------+------------------
- part1_a_idx | regress_tblspace
- part2_a_idx | regress_tblspace
- part_a_idx  | regress_tblspace
-(3 rows)
-
-\d testschema.part
-        Partitioned table "testschema.part"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
-Partition key: LIST (a)
-Indexes:
-    "part_a_idx" btree (a), tablespace "regress_tblspace"
-Number of partitions: 2 (Use \d+ to list them.)
-
-\d+ testschema.part
-                           Partitioned table "testschema.part"
- Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
---------+---------+-----------+----------+---------+---------+--------------+-------------
- a      | integer |           |          |         | plain   |              | 
-Partition key: LIST (a)
-Indexes:
-    "part_a_idx" btree (a), tablespace "regress_tblspace"
-Partitions: testschema.part1 FOR VALUES IN (1),
-            testschema.part2 FOR VALUES IN (2)
-
-\d testschema.part1
-             Table "testschema.part1"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
-Partition of: testschema.part FOR VALUES IN (1)
-Indexes:
-    "part1_a_idx" btree (a), tablespace "regress_tblspace"
-
-\d+ testschema.part1
-                                 Table "testschema.part1"
- Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
---------+---------+-----------+----------+---------+---------+--------------+-------------
- a      | integer |           |          |         | plain   |              | 
-Partition of: testschema.part FOR VALUES IN (1)
-Partition constraint: ((a IS NOT NULL) AND (a = 1))
-Indexes:
-    "part1_a_idx" btree (a), tablespace "regress_tblspace"
-
-\d testschema.part_a_idx
-Partitioned index "testschema.part_a_idx"
- Column |  Type   | Key? | Definition 
---------+---------+------+------------
- a      | integer | yes  | a
-btree, for table "testschema.part"
-Number of partitions: 2 (Use \d+ to list them.)
-Tablespace: "regress_tblspace"
-
-\d+ testschema.part_a_idx
-           Partitioned index "testschema.part_a_idx"
- Column |  Type   | Key? | Definition | Storage | Stats target 
---------+---------+------+------------+---------+--------------
- a      | integer | yes  | a          | plain   | 
-btree, for table "testschema.part"
-Partitions: testschema.part1_a_idx,
-            testschema.part2_a_idx
-Tablespace: "regress_tblspace"
-
--- partitioned rels cannot specify the default tablespace.  These fail:
-CREATE TABLE testschema.dflt (a int PRIMARY KEY) PARTITION BY LIST (a) TABLESPACE pg_default;
-ERROR:  cannot specify default tablespace for partitioned relations
-CREATE TABLE testschema.dflt (a int PRIMARY KEY USING INDEX TABLESPACE pg_default) PARTITION BY LIST (a);
-ERROR:  cannot specify default tablespace for partitioned relations
-SET default_tablespace TO 'pg_default';
-CREATE TABLE testschema.dflt (a int PRIMARY KEY) PARTITION BY LIST (a) TABLESPACE regress_tblspace;
-ERROR:  cannot specify default tablespace for partitioned relations
-CREATE TABLE testschema.dflt (a int PRIMARY KEY USING INDEX TABLESPACE regress_tblspace) PARTITION BY LIST (a);
-ERROR:  cannot specify default tablespace for partitioned relations
--- but these work:
-CREATE TABLE testschema.dflt (a int PRIMARY KEY USING INDEX TABLESPACE regress_tblspace) PARTITION BY LIST (a) TABLESPACE regress_tblspace;
-SET default_tablespace TO '';
-CREATE TABLE testschema.dflt2 (a int PRIMARY KEY) PARTITION BY LIST (a);
-DROP TABLE testschema.dflt, testschema.dflt2;
--- check that default_tablespace doesn't affect ALTER TABLE index rebuilds
-CREATE TABLE testschema.test_default_tab(id bigint) TABLESPACE regress_tblspace;
-INSERT INTO testschema.test_default_tab VALUES (1);
-CREATE INDEX test_index1 on testschema.test_default_tab (id);
-CREATE INDEX test_index2 on testschema.test_default_tab (id) TABLESPACE regress_tblspace;
-ALTER TABLE testschema.test_default_tab ADD CONSTRAINT test_index3 PRIMARY KEY (id);
-ALTER TABLE testschema.test_default_tab ADD CONSTRAINT test_index4 UNIQUE (id) USING INDEX TABLESPACE regress_tblspace;
-\d testschema.test_index1
-   Index "testschema.test_index1"
- Column |  Type  | Key? | Definition 
---------+--------+------+------------
- id     | bigint | yes  | id
-btree, for table "testschema.test_default_tab"
-
-\d testschema.test_index2
-   Index "testschema.test_index2"
- Column |  Type  | Key? | Definition 
---------+--------+------+------------
- id     | bigint | yes  | id
-btree, for table "testschema.test_default_tab"
-Tablespace: "regress_tblspace"
-
-\d testschema.test_index3
-   Index "testschema.test_index3"
- Column |  Type  | Key? | Definition 
---------+--------+------+------------
- id     | bigint | yes  | id
-primary key, btree, for table "testschema.test_default_tab"
-
-\d testschema.test_index4
-   Index "testschema.test_index4"
- Column |  Type  | Key? | Definition 
---------+--------+------+------------
- id     | bigint | yes  | id
-unique, btree, for table "testschema.test_default_tab"
-Tablespace: "regress_tblspace"
-
--- use a custom tablespace for default_tablespace
-SET default_tablespace TO regress_tblspace;
--- tablespace should not change if no rewrite
-ALTER TABLE testschema.test_default_tab ALTER id TYPE bigint;
-\d testschema.test_index1
-   Index "testschema.test_index1"
- Column |  Type  | Key? | Definition 
---------+--------+------+------------
- id     | bigint | yes  | id
-btree, for table "testschema.test_default_tab"
-
-\d testschema.test_index2
-   Index "testschema.test_index2"
- Column |  Type  | Key? | Definition 
---------+--------+------+------------
- id     | bigint | yes  | id
-btree, for table "testschema.test_default_tab"
-Tablespace: "regress_tblspace"
-
-\d testschema.test_index3
-   Index "testschema.test_index3"
- Column |  Type  | Key? | Definition 
---------+--------+------+------------
- id     | bigint | yes  | id
-primary key, btree, for table "testschema.test_default_tab"
-
-\d testschema.test_index4
-   Index "testschema.test_index4"
- Column |  Type  | Key? | Definition 
---------+--------+------+------------
- id     | bigint | yes  | id
-unique, btree, for table "testschema.test_default_tab"
-Tablespace: "regress_tblspace"
-
-SELECT * FROM testschema.test_default_tab;
- id 
-----
-  1
-(1 row)
-
--- tablespace should not change even if there is an index rewrite
-ALTER TABLE testschema.test_default_tab ALTER id TYPE int;
-\d testschema.test_index1
-    Index "testschema.test_index1"
- Column |  Type   | Key? | Definition 
---------+---------+------+------------
- id     | integer | yes  | id
-btree, for table "testschema.test_default_tab"
-
-\d testschema.test_index2
-    Index "testschema.test_index2"
- Column |  Type   | Key? | Definition 
---------+---------+------+------------
- id     | integer | yes  | id
-btree, for table "testschema.test_default_tab"
-Tablespace: "regress_tblspace"
-
-\d testschema.test_index3
-    Index "testschema.test_index3"
- Column |  Type   | Key? | Definition 
---------+---------+------+------------
- id     | integer | yes  | id
-primary key, btree, for table "testschema.test_default_tab"
-
-\d testschema.test_index4
-    Index "testschema.test_index4"
- Column |  Type   | Key? | Definition 
---------+---------+------+------------
- id     | integer | yes  | id
-unique, btree, for table "testschema.test_default_tab"
-Tablespace: "regress_tblspace"
-
-SELECT * FROM testschema.test_default_tab;
- id 
-----
-  1
-(1 row)
-
--- now use the default tablespace for default_tablespace
-SET default_tablespace TO '';
--- tablespace should not change if no rewrite
-ALTER TABLE testschema.test_default_tab ALTER id TYPE int;
-\d testschema.test_index1
-    Index "testschema.test_index1"
- Column |  Type   | Key? | Definition 
---------+---------+------+------------
- id     | integer | yes  | id
-btree, for table "testschema.test_default_tab"
-
-\d testschema.test_index2
-    Index "testschema.test_index2"
- Column |  Type   | Key? | Definition 
---------+---------+------+------------
- id     | integer | yes  | id
-btree, for table "testschema.test_default_tab"
-Tablespace: "regress_tblspace"
-
-\d testschema.test_index3
-    Index "testschema.test_index3"
- Column |  Type   | Key? | Definition 
---------+---------+------+------------
- id     | integer | yes  | id
-primary key, btree, for table "testschema.test_default_tab"
-
-\d testschema.test_index4
-    Index "testschema.test_index4"
- Column |  Type   | Key? | Definition 
---------+---------+------+------------
- id     | integer | yes  | id
-unique, btree, for table "testschema.test_default_tab"
-Tablespace: "regress_tblspace"
-
--- tablespace should not change even if there is an index rewrite
-ALTER TABLE testschema.test_default_tab ALTER id TYPE bigint;
-\d testschema.test_index1
-   Index "testschema.test_index1"
- Column |  Type  | Key? | Definition 
---------+--------+------+------------
- id     | bigint | yes  | id
-btree, for table "testschema.test_default_tab"
-
-\d testschema.test_index2
-   Index "testschema.test_index2"
- Column |  Type  | Key? | Definition 
---------+--------+------+------------
- id     | bigint | yes  | id
-btree, for table "testschema.test_default_tab"
-Tablespace: "regress_tblspace"
-
-\d testschema.test_index3
-   Index "testschema.test_index3"
- Column |  Type  | Key? | Definition 
---------+--------+------+------------
- id     | bigint | yes  | id
-primary key, btree, for table "testschema.test_default_tab"
-
-\d testschema.test_index4
-   Index "testschema.test_index4"
- Column |  Type  | Key? | Definition 
---------+--------+------+------------
- id     | bigint | yes  | id
-unique, btree, for table "testschema.test_default_tab"
-Tablespace: "regress_tblspace"
-
-DROP TABLE testschema.test_default_tab;
--- check that default_tablespace doesn't affect ALTER TABLE index rebuilds
--- (this time with a partitioned table)
-CREATE TABLE testschema.test_default_tab_p(id bigint, val bigint)
-    PARTITION BY LIST (id) TABLESPACE regress_tblspace;
-CREATE TABLE testschema.test_default_tab_p1 PARTITION OF testschema.test_default_tab_p
-    FOR VALUES IN (1);
-INSERT INTO testschema.test_default_tab_p VALUES (1);
-CREATE INDEX test_index1 on testschema.test_default_tab_p (val);
-CREATE INDEX test_index2 on testschema.test_default_tab_p (val) TABLESPACE regress_tblspace;
-ALTER TABLE testschema.test_default_tab_p ADD CONSTRAINT test_index3 PRIMARY KEY (id);
-ALTER TABLE testschema.test_default_tab_p ADD CONSTRAINT test_index4 UNIQUE (id) USING INDEX TABLESPACE regress_tblspace;
-\d testschema.test_index1
-Partitioned index "testschema.test_index1"
- Column |  Type  | Key? | Definition 
---------+--------+------+------------
- val    | bigint | yes  | val
-btree, for table "testschema.test_default_tab_p"
-Number of partitions: 1 (Use \d+ to list them.)
-
-\d testschema.test_index2
-Partitioned index "testschema.test_index2"
- Column |  Type  | Key? | Definition 
---------+--------+------+------------
- val    | bigint | yes  | val
-btree, for table "testschema.test_default_tab_p"
-Number of partitions: 1 (Use \d+ to list them.)
-Tablespace: "regress_tblspace"
-
-\d testschema.test_index3
-Partitioned index "testschema.test_index3"
- Column |  Type  | Key? | Definition 
---------+--------+------+------------
- id     | bigint | yes  | id
-primary key, btree, for table "testschema.test_default_tab_p"
-Number of partitions: 1 (Use \d+ to list them.)
-
-\d testschema.test_index4
-Partitioned index "testschema.test_index4"
- Column |  Type  | Key? | Definition 
---------+--------+------+------------
- id     | bigint | yes  | id
-unique, btree, for table "testschema.test_default_tab_p"
-Number of partitions: 1 (Use \d+ to list them.)
-Tablespace: "regress_tblspace"
-
--- use a custom tablespace for default_tablespace
-SET default_tablespace TO regress_tblspace;
--- tablespace should not change if no rewrite
-ALTER TABLE testschema.test_default_tab_p ALTER val TYPE bigint;
-\d testschema.test_index1
-Partitioned index "testschema.test_index1"
- Column |  Type  | Key? | Definition 
---------+--------+------+------------
- val    | bigint | yes  | val
-btree, for table "testschema.test_default_tab_p"
-Number of partitions: 1 (Use \d+ to list them.)
-
-\d testschema.test_index2
-Partitioned index "testschema.test_index2"
- Column |  Type  | Key? | Definition 
---------+--------+------+------------
- val    | bigint | yes  | val
-btree, for table "testschema.test_default_tab_p"
-Number of partitions: 1 (Use \d+ to list them.)
-Tablespace: "regress_tblspace"
-
-\d testschema.test_index3
-Partitioned index "testschema.test_index3"
- Column |  Type  | Key? | Definition 
---------+--------+------+------------
- id     | bigint | yes  | id
-primary key, btree, for table "testschema.test_default_tab_p"
-Number of partitions: 1 (Use \d+ to list them.)
-
-\d testschema.test_index4
-Partitioned index "testschema.test_index4"
- Column |  Type  | Key? | Definition 
---------+--------+------+------------
- id     | bigint | yes  | id
-unique, btree, for table "testschema.test_default_tab_p"
-Number of partitions: 1 (Use \d+ to list them.)
-Tablespace: "regress_tblspace"
-
-SELECT * FROM testschema.test_default_tab_p;
- id | val 
-----+-----
-  1 |    
-(1 row)
-
--- tablespace should not change even if there is an index rewrite
-ALTER TABLE testschema.test_default_tab_p ALTER val TYPE int;
-\d testschema.test_index1
-Partitioned index "testschema.test_index1"
- Column |  Type   | Key? | Definition 
---------+---------+------+------------
- val    | integer | yes  | val
-btree, for table "testschema.test_default_tab_p"
-Number of partitions: 1 (Use \d+ to list them.)
-
-\d testschema.test_index2
-Partitioned index "testschema.test_index2"
- Column |  Type   | Key? | Definition 
---------+---------+------+------------
- val    | integer | yes  | val
-btree, for table "testschema.test_default_tab_p"
-Number of partitions: 1 (Use \d+ to list them.)
-Tablespace: "regress_tblspace"
-
-\d testschema.test_index3
-Partitioned index "testschema.test_index3"
- Column |  Type  | Key? | Definition 
---------+--------+------+------------
- id     | bigint | yes  | id
-primary key, btree, for table "testschema.test_default_tab_p"
-Number of partitions: 1 (Use \d+ to list them.)
-
-\d testschema.test_index4
-Partitioned index "testschema.test_index4"
- Column |  Type  | Key? | Definition 
---------+--------+------+------------
- id     | bigint | yes  | id
-unique, btree, for table "testschema.test_default_tab_p"
-Number of partitions: 1 (Use \d+ to list them.)
-Tablespace: "regress_tblspace"
-
-SELECT * FROM testschema.test_default_tab_p;
- id | val 
-----+-----
-  1 |    
-(1 row)
-
--- now use the default tablespace for default_tablespace
-SET default_tablespace TO '';
--- tablespace should not change if no rewrite
-ALTER TABLE testschema.test_default_tab_p ALTER val TYPE int;
-\d testschema.test_index1
-Partitioned index "testschema.test_index1"
- Column |  Type   | Key? | Definition 
---------+---------+------+------------
- val    | integer | yes  | val
-btree, for table "testschema.test_default_tab_p"
-Number of partitions: 1 (Use \d+ to list them.)
-
-\d testschema.test_index2
-Partitioned index "testschema.test_index2"
- Column |  Type   | Key? | Definition 
---------+---------+------+------------
- val    | integer | yes  | val
-btree, for table "testschema.test_default_tab_p"
-Number of partitions: 1 (Use \d+ to list them.)
-Tablespace: "regress_tblspace"
-
-\d testschema.test_index3
-Partitioned index "testschema.test_index3"
- Column |  Type  | Key? | Definition 
---------+--------+------+------------
- id     | bigint | yes  | id
-primary key, btree, for table "testschema.test_default_tab_p"
-Number of partitions: 1 (Use \d+ to list them.)
-
-\d testschema.test_index4
-Partitioned index "testschema.test_index4"
- Column |  Type  | Key? | Definition 
---------+--------+------+------------
- id     | bigint | yes  | id
-unique, btree, for table "testschema.test_default_tab_p"
-Number of partitions: 1 (Use \d+ to list them.)
-Tablespace: "regress_tblspace"
-
--- tablespace should not change even if there is an index rewrite
-ALTER TABLE testschema.test_default_tab_p ALTER val TYPE bigint;
-\d testschema.test_index1
-Partitioned index "testschema.test_index1"
- Column |  Type  | Key? | Definition 
---------+--------+------+------------
- val    | bigint | yes  | val
-btree, for table "testschema.test_default_tab_p"
-Number of partitions: 1 (Use \d+ to list them.)
-
-\d testschema.test_index2
-Partitioned index "testschema.test_index2"
- Column |  Type  | Key? | Definition 
---------+--------+------+------------
- val    | bigint | yes  | val
-btree, for table "testschema.test_default_tab_p"
-Number of partitions: 1 (Use \d+ to list them.)
-Tablespace: "regress_tblspace"
-
-\d testschema.test_index3
-Partitioned index "testschema.test_index3"
- Column |  Type  | Key? | Definition 
---------+--------+------+------------
- id     | bigint | yes  | id
-primary key, btree, for table "testschema.test_default_tab_p"
-Number of partitions: 1 (Use \d+ to list them.)
-
-\d testschema.test_index4
-Partitioned index "testschema.test_index4"
- Column |  Type  | Key? | Definition 
---------+--------+------+------------
- id     | bigint | yes  | id
-unique, btree, for table "testschema.test_default_tab_p"
-Number of partitions: 1 (Use \d+ to list them.)
-Tablespace: "regress_tblspace"
-
-DROP TABLE testschema.test_default_tab_p;
--- check that default_tablespace affects index additions in ALTER TABLE
-CREATE TABLE testschema.test_tab(id int) TABLESPACE regress_tblspace;
-INSERT INTO testschema.test_tab VALUES (1);
-SET default_tablespace TO regress_tblspace;
-ALTER TABLE testschema.test_tab ADD CONSTRAINT test_tab_unique UNIQUE (id);
-SET default_tablespace TO '';
-ALTER TABLE testschema.test_tab ADD CONSTRAINT test_tab_pkey PRIMARY KEY (id);
-\d testschema.test_tab_unique
-  Index "testschema.test_tab_unique"
- Column |  Type   | Key? | Definition 
---------+---------+------+------------
- id     | integer | yes  | id
-unique, btree, for table "testschema.test_tab"
-Tablespace: "regress_tblspace"
-
-\d testschema.test_tab_pkey
-   Index "testschema.test_tab_pkey"
- Column |  Type   | Key? | Definition 
---------+---------+------+------------
- id     | integer | yes  | id
-primary key, btree, for table "testschema.test_tab"
-
-SELECT * FROM testschema.test_tab;
- id 
-----
-  1
-(1 row)
-
-DROP TABLE testschema.test_tab;
--- check that default_tablespace is handled correctly by multi-command
--- ALTER TABLE that includes a tablespace-preserving rewrite
-CREATE TABLE testschema.test_tab(a int, b int, c int);
-SET default_tablespace TO regress_tblspace;
-ALTER TABLE testschema.test_tab ADD CONSTRAINT test_tab_unique UNIQUE (a);
-CREATE INDEX test_tab_a_idx ON testschema.test_tab (a);
-SET default_tablespace TO '';
-CREATE INDEX test_tab_b_idx ON testschema.test_tab (b);
-\d testschema.test_tab_unique
-  Index "testschema.test_tab_unique"
- Column |  Type   | Key? | Definition 
---------+---------+------+------------
- a      | integer | yes  | a
-unique, btree, for table "testschema.test_tab"
-Tablespace: "regress_tblspace"
-
-\d testschema.test_tab_a_idx
-  Index "testschema.test_tab_a_idx"
- Column |  Type   | Key? | Definition 
---------+---------+------+------------
- a      | integer | yes  | a
-btree, for table "testschema.test_tab"
-Tablespace: "regress_tblspace"
-
-\d testschema.test_tab_b_idx
-  Index "testschema.test_tab_b_idx"
- Column |  Type   | Key? | Definition 
---------+---------+------+------------
- b      | integer | yes  | b
-btree, for table "testschema.test_tab"
-
-ALTER TABLE testschema.test_tab ALTER b TYPE bigint, ADD UNIQUE (c);
-\d testschema.test_tab_unique
-  Index "testschema.test_tab_unique"
- Column |  Type   | Key? | Definition 
---------+---------+------+------------
- a      | integer | yes  | a
-unique, btree, for table "testschema.test_tab"
-Tablespace: "regress_tblspace"
-
-\d testschema.test_tab_a_idx
-  Index "testschema.test_tab_a_idx"
- Column |  Type   | Key? | Definition 
---------+---------+------+------------
- a      | integer | yes  | a
-btree, for table "testschema.test_tab"
-Tablespace: "regress_tblspace"
-
-\d testschema.test_tab_b_idx
-  Index "testschema.test_tab_b_idx"
- Column |  Type  | Key? | Definition 
---------+--------+------+------------
- b      | bigint | yes  | b
-btree, for table "testschema.test_tab"
-
-DROP TABLE testschema.test_tab;
--- let's try moving a table from one place to another
-CREATE TABLE testschema.atable AS VALUES (1), (2);
-CREATE UNIQUE INDEX anindex ON testschema.atable(column1);
-ALTER TABLE testschema.atable SET TABLESPACE regress_tblspace;
-ALTER INDEX testschema.anindex SET TABLESPACE regress_tblspace;
-ALTER INDEX testschema.part_a_idx SET TABLESPACE pg_global;
-ERROR:  only shared relations can be placed in pg_global tablespace
-ALTER INDEX testschema.part_a_idx SET TABLESPACE pg_default;
-ALTER INDEX testschema.part_a_idx SET TABLESPACE regress_tblspace;
-INSERT INTO testschema.atable VALUES(3);	-- ok
-INSERT INTO testschema.atable VALUES(1);	-- fail (checks index)
-ERROR:  duplicate key value violates unique constraint "anindex"
-DETAIL:  Key (column1)=(1) already exists.
-SELECT COUNT(*) FROM testschema.atable;		-- checks heap
- count 
--------
-     3
-(1 row)
-
--- Will fail with bad path
-CREATE TABLESPACE regress_badspace LOCATION '/no/such/location';
-ERROR:  directory "/no/such/location" does not exist
--- No such tablespace
-CREATE TABLE bar (i int) TABLESPACE regress_nosuchspace;
-ERROR:  tablespace "regress_nosuchspace" does not exist
--- Fail, in use for some partitioned object
-DROP TABLESPACE regress_tblspace;
-ERROR:  tablespace "regress_tblspace" cannot be dropped because some objects depend on it
-DETAIL:  tablespace for index testschema.part_a_idx
-ALTER INDEX testschema.part_a_idx SET TABLESPACE pg_default;
--- Fail, not empty
-DROP TABLESPACE regress_tblspace;
-ERROR:  tablespace "regress_tblspace" is not empty
-CREATE ROLE regress_tablespace_user1 login;
-CREATE ROLE regress_tablespace_user2 login;
-GRANT USAGE ON SCHEMA testschema TO regress_tablespace_user2;
-ALTER TABLESPACE regress_tblspace OWNER TO regress_tablespace_user1;
-CREATE TABLE testschema.tablespace_acl (c int);
--- new owner lacks permission to create this index from scratch
-CREATE INDEX k ON testschema.tablespace_acl (c) TABLESPACE regress_tblspace;
-ALTER TABLE testschema.tablespace_acl OWNER TO regress_tablespace_user2;
-SET SESSION ROLE regress_tablespace_user2;
-CREATE TEMP TABLE tablespace_table (i int) TABLESPACE regress_tblspace; -- fail
-ERROR:  permission denied for tablespace regress_tblspace
-ALTER TABLE testschema.tablespace_acl ALTER c TYPE bigint;
-REINDEX (TABLESPACE regress_tblspace) TABLE tablespace_table; -- fail
-ERROR:  permission denied for tablespace regress_tblspace
-REINDEX (TABLESPACE regress_tblspace, CONCURRENTLY) TABLE tablespace_table; -- fail
-ERROR:  permission denied for tablespace regress_tblspace
-RESET ROLE;
-ALTER TABLESPACE regress_tblspace RENAME TO regress_tblspace_renamed;
-ALTER TABLE ALL IN TABLESPACE regress_tblspace_renamed SET TABLESPACE pg_default;
-ALTER INDEX ALL IN TABLESPACE regress_tblspace_renamed SET TABLESPACE pg_default;
--- Should show notice that nothing was done
-ALTER TABLE ALL IN TABLESPACE regress_tblspace_renamed SET TABLESPACE pg_default;
-NOTICE:  no matching relations in tablespace "regress_tblspace_renamed" found
--- Should succeed
-DROP TABLESPACE regress_tblspace_renamed;
-DROP SCHEMA testschema CASCADE;
-NOTICE:  drop cascades to 6 other objects
-DETAIL:  drop cascades to table testschema.foo
-drop cascades to table testschema.asselect
-drop cascades to table testschema.asexecute
-drop cascades to table testschema.part
-drop cascades to table testschema.atable
-drop cascades to table testschema.tablespace_acl
-DROP ROLE regress_tablespace_user1;
-DROP ROLE regress_tablespace_user2;
--- Rest of this suite can use the public schema freely.
-GRANT ALL ON SCHEMA public TO public;
diff -U3 /Users/kenaniah/workspace/postgres/src/test/regress/expected/bit.out /Users/kenaniah/workspace/postgres/src/test/regress/results/bit.out
--- /Users/kenaniah/workspace/postgres/src/test/regress/expected/bit.out	2021-10-03 17:41:49.000000000 -0700
+++ /Users/kenaniah/workspace/postgres/src/test/regress/results/bit.out	2021-10-03 20:08:07.000000000 -0700
@@ -731,18 +731,11 @@
   b4 bit varying(5) DEFAULT B'0101'
 );
 \d bit_defaults
-                     Table "public.bit_defaults"
- Column |      Type      | Collation | Nullable |       Default       
---------+----------------+-----------+----------+---------------------
- b1     | bit(4)         |           |          | '1001'::"bit"
- b2     | bit(4)         |           |          | '0101'::"bit"
- b3     | bit varying(5) |           |          | '1001'::bit varying
- b4     | bit varying(5) |           |          | '0101'::"bit"
+dyld: lazy symbol binding failed: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
 
-INSERT INTO bit_defaults DEFAULT VALUES;
-TABLE bit_defaults;
-  b1  |  b2  |  b3  |  b4  
-------+------+------+------
- 1001 | 0101 | 1001 | 0101
-(1 row)
+dyld: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
 
diff -U3 /Users/kenaniah/workspace/postgres/src/test/regress/expected/numeric.out /Users/kenaniah/workspace/postgres/src/test/regress/results/numeric.out
--- /Users/kenaniah/workspace/postgres/src/test/regress/expected/numeric.out	2021-10-03 18:09:17.000000000 -0700
+++ /Users/kenaniah/workspace/postgres/src/test/regress/results/numeric.out	2021-10-03 20:08:07.000000000 -0700
@@ -2210,1124 +2210,11 @@
   millionths numeric(3, 6)
 );
 \d num_typemod_test
-               Table "public.num_typemod_test"
-   Column    |     Type      | Collation | Nullable | Default 
--------------+---------------+-----------+----------+---------
- millions    | numeric(3,-6) |           |          | 
- thousands   | numeric(3,-3) |           |          | 
- units       | numeric(3,0)  |           |          | 
- thousandths | numeric(3,3)  |           |          | 
- millionths  | numeric(3,6)  |           |          | 
+dyld: lazy symbol binding failed: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
+
+dyld: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
 
--- rounding of valid inputs
-INSERT INTO num_typemod_test VALUES (123456, 123, 0.123, 0.000123, 0.000000123);
-INSERT INTO num_typemod_test VALUES (654321, 654, 0.654, 0.000654, 0.000000654);
-INSERT INTO num_typemod_test VALUES (2345678, 2345, 2.345, 0.002345, 0.000002345);
-INSERT INTO num_typemod_test VALUES (7654321, 7654, 7.654, 0.007654, 0.000007654);
-INSERT INTO num_typemod_test VALUES (12345678, 12345, 12.345, 0.012345, 0.000012345);
-INSERT INTO num_typemod_test VALUES (87654321, 87654, 87.654, 0.087654, 0.000087654);
-INSERT INTO num_typemod_test VALUES (123456789, 123456, 123.456, 0.123456, 0.000123456);
-INSERT INTO num_typemod_test VALUES (987654321, 987654, 987.654, 0.987654, 0.000987654);
-INSERT INTO num_typemod_test VALUES ('NaN', 'NaN', 'NaN', 'NaN', 'NaN');
-SELECT scale(millions), * FROM num_typemod_test ORDER BY millions;
- scale | millions  | thousands | units | thousandths | millionths 
--------+-----------+-----------+-------+-------------+------------
-     0 |         0 |         0 |     0 |       0.000 |   0.000000
-     0 |   1000000 |      1000 |     1 |       0.001 |   0.000001
-     0 |   2000000 |      2000 |     2 |       0.002 |   0.000002
-     0 |   8000000 |      8000 |     8 |       0.008 |   0.000008
-     0 |  12000000 |     12000 |    12 |       0.012 |   0.000012
-     0 |  88000000 |     88000 |    88 |       0.088 |   0.000088
-     0 | 123000000 |    123000 |   123 |       0.123 |   0.000123
-     0 | 988000000 |    988000 |   988 |       0.988 |   0.000988
-       |       NaN |       NaN |   NaN |         NaN |        NaN
-(9 rows)
-
--- invalid inputs
-INSERT INTO num_typemod_test (millions) VALUES ('inf');
-ERROR:  numeric field overflow
-DETAIL:  A field with precision 3, scale -6 cannot hold an infinite value.
-INSERT INTO num_typemod_test (millions) VALUES (999500000);
-ERROR:  numeric field overflow
-DETAIL:  A field with precision 3, scale -6 must round to an absolute value less than 10^9.
-INSERT INTO num_typemod_test (thousands) VALUES (999500);
-ERROR:  numeric field overflow
-DETAIL:  A field with precision 3, scale -3 must round to an absolute value less than 10^6.
-INSERT INTO num_typemod_test (units) VALUES (999.5);
-ERROR:  numeric field overflow
-DETAIL:  A field with precision 3, scale 0 must round to an absolute value less than 10^3.
-INSERT INTO num_typemod_test (thousandths) VALUES (0.9995);
-ERROR:  numeric field overflow
-DETAIL:  A field with precision 3, scale 3 must round to an absolute value less than 1.
-INSERT INTO num_typemod_test (millionths) VALUES (0.0009995);
-ERROR:  numeric field overflow
-DETAIL:  A field with precision 3, scale 6 must round to an absolute value less than 10^-3.
---
--- Test some corner cases for multiplication
---
-select 4790999999999999999999999999999999999999999999999999999999999999999999999999999999999999 * 9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999;
-                                                                                     ?column?                                                                                     
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
- 47909999999999999999999999999999999999999999999999999999999999999999999999999999999999985209000000000000000000000000000000000000000000000000000000000000000000000000000000000001
-(1 row)
-
-select 4789999999999999999999999999999999999999999999999999999999999999999999999999999999999999 * 9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999;
-                                                                                     ?column?                                                                                     
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
- 47899999999999999999999999999999999999999999999999999999999999999999999999999999999999985210000000000000000000000000000000000000000000000000000000000000000000000000000000000001
-(1 row)
-
-select 4770999999999999999999999999999999999999999999999999999999999999999999999999999999999999 * 9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999;
-                                                                                     ?column?                                                                                     
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
- 47709999999999999999999999999999999999999999999999999999999999999999999999999999999999985229000000000000000000000000000000000000000000000000000000000000000000000000000000000001
-(1 row)
-
-select 4769999999999999999999999999999999999999999999999999999999999999999999999999999999999999 * 9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999;
-                                                                                     ?column?                                                                                     
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
- 47699999999999999999999999999999999999999999999999999999999999999999999999999999999999985230000000000000000000000000000000000000000000000000000000000000000000000000000000000001
-(1 row)
-
-select trim_scale((0.1 - 2e-16383) * (0.1 - 3e-16383));
- trim_scale 
-------------
-       0.01
-(1 row)
-
---
--- Test some corner cases for division
---
-select 999999999999999999999::numeric/1000000000000000000000;
-        ?column?        
-------------------------
- 1.00000000000000000000
-(1 row)
-
-select div(999999999999999999999::numeric,1000000000000000000000);
- div 
------
-   0
-(1 row)
-
-select mod(999999999999999999999::numeric,1000000000000000000000);
-          mod          
------------------------
- 999999999999999999999
-(1 row)
-
-select div(-9999999999999999999999::numeric,1000000000000000000000);
- div 
------
-  -9
-(1 row)
-
-select mod(-9999999999999999999999::numeric,1000000000000000000000);
-          mod           
-------------------------
- -999999999999999999999
-(1 row)
-
-select div(-9999999999999999999999::numeric,1000000000000000000000)*1000000000000000000000 + mod(-9999999999999999999999::numeric,1000000000000000000000);
-        ?column?         
--------------------------
- -9999999999999999999999
-(1 row)
-
-select mod (70.0,70) ;
- mod 
------
- 0.0
-(1 row)
-
-select div (70.0,70) ;
- div 
------
-   1
-(1 row)
-
-select 70.0 / 70 ;
-        ?column?        
-------------------------
- 1.00000000000000000000
-(1 row)
-
-select 12345678901234567890 % 123;
- ?column? 
-----------
-       78
-(1 row)
-
-select 12345678901234567890 / 123;
-      ?column?      
---------------------
- 100371373180768845
-(1 row)
-
-select div(12345678901234567890, 123);
-        div         
---------------------
- 100371373180768844
-(1 row)
-
-select div(12345678901234567890, 123) * 123 + 12345678901234567890 % 123;
-       ?column?       
-----------------------
- 12345678901234567890
-(1 row)
-
---
--- Test some corner cases for square root
---
-select sqrt(1.000000000000003::numeric);
-       sqrt        
--------------------
- 1.000000000000001
-(1 row)
-
-select sqrt(1.000000000000004::numeric);
-       sqrt        
--------------------
- 1.000000000000002
-(1 row)
-
-select sqrt(96627521408608.56340355805::numeric);
-        sqrt         
----------------------
- 9829929.87811248648
-(1 row)
-
-select sqrt(96627521408608.56340355806::numeric);
-        sqrt         
----------------------
- 9829929.87811248649
-(1 row)
-
-select sqrt(515549506212297735.073688290367::numeric);
-          sqrt          
-------------------------
- 718017761.766585921184
-(1 row)
-
-select sqrt(515549506212297735.073688290368::numeric);
-          sqrt          
-------------------------
- 718017761.766585921185
-(1 row)
-
-select sqrt(8015491789940783531003294973900306::numeric);
-       sqrt        
--------------------
- 89529278953540017
-(1 row)
-
-select sqrt(8015491789940783531003294973900307::numeric);
-       sqrt        
--------------------
- 89529278953540018
-(1 row)
-
---
--- Test code path for raising to integer powers
---
-select 10.0 ^ -2147483648 as rounds_to_zero;
-   rounds_to_zero   
---------------------
- 0.0000000000000000
-(1 row)
-
-select 10.0 ^ -2147483647 as rounds_to_zero;
-   rounds_to_zero   
---------------------
- 0.0000000000000000
-(1 row)
-
-select 10.0 ^ 2147483647 as overflows;
-ERROR:  value overflows numeric format
-select 117743296169.0 ^ 1000000000 as overflows;
-ERROR:  value overflows numeric format
--- cases that used to return inaccurate results
-select 3.789 ^ 21;
-            ?column?            
---------------------------------
- 1409343026052.8716016316022141
-(1 row)
-
-select 3.789 ^ 35;
-                ?column?                
-----------------------------------------
- 177158169650516670809.3820586142670135
-(1 row)
-
-select 1.2 ^ 345;
-                   ?column?                    
------------------------------------------------
- 2077446682327378559843444695.5827049735727869
-(1 row)
-
-select 0.12 ^ (-20);
-               ?column?               
---------------------------------------
- 2608405330458882702.5529619561355838
-(1 row)
-
-select 1.000000000123 ^ (-2147483648);
-      ?column?      
---------------------
- 0.7678656556403084
-(1 row)
-
-select coalesce(nullif(0.9999999999 ^ 23300000000000, 0), 0) as rounds_to_zero;
- rounds_to_zero 
-----------------
-              0
-(1 row)
-
--- cases that used to error out
-select 0.12 ^ (-25);
-                 ?column?                  
--------------------------------------------
- 104825960103961013959336.4983657883169110
-(1 row)
-
-select 0.5678 ^ (-85);
-                ?column?                
-----------------------------------------
- 782333637740774446257.7719390061997396
-(1 row)
-
-select coalesce(nullif(0.9999999999 ^ 70000000000000, 0), 0) as underflows;
- underflows 
-------------
-          0
-(1 row)
-
--- negative base to integer powers
-select (-1.0) ^ 2147483646;
-      ?column?      
---------------------
- 1.0000000000000000
-(1 row)
-
-select (-1.0) ^ 2147483647;
-      ?column?       
----------------------
- -1.0000000000000000
-(1 row)
-
-select (-1.0) ^ 2147483648;
-      ?column?      
---------------------
- 1.0000000000000000
-(1 row)
-
-select (-1.0) ^ 1000000000000000;
-      ?column?      
---------------------
- 1.0000000000000000
-(1 row)
-
-select (-1.0) ^ 1000000000000001;
-      ?column?       
----------------------
- -1.0000000000000000
-(1 row)
-
---
--- Tests for raising to non-integer powers
---
--- special cases
-select 0.0 ^ 0.0;
-      ?column?      
---------------------
- 1.0000000000000000
-(1 row)
-
-select (-12.34) ^ 0.0;
-      ?column?      
---------------------
- 1.0000000000000000
-(1 row)
-
-select 12.34 ^ 0.0;
-      ?column?      
---------------------
- 1.0000000000000000
-(1 row)
-
-select 0.0 ^ 12.34;
-      ?column?      
---------------------
- 0.0000000000000000
-(1 row)
-
--- NaNs
-select 'NaN'::numeric ^ 'NaN'::numeric;
- ?column? 
-----------
-      NaN
-(1 row)
-
-select 'NaN'::numeric ^ 0;
- ?column? 
-----------
-        1
-(1 row)
-
-select 'NaN'::numeric ^ 1;
- ?column? 
-----------
-      NaN
-(1 row)
-
-select 0 ^ 'NaN'::numeric;
- ?column? 
-----------
-      NaN
-(1 row)
-
-select 1 ^ 'NaN'::numeric;
- ?column? 
-----------
-        1
-(1 row)
-
--- invalid inputs
-select 0.0 ^ (-12.34);
-ERROR:  zero raised to a negative power is undefined
-select (-12.34) ^ 1.2;
-ERROR:  a negative number raised to a non-integer power yields a complex result
--- cases that used to generate inaccurate results
-select 32.1 ^ 9.8;
-      ?column?      
---------------------
- 580429286790711.10
-(1 row)
-
-select 32.1 ^ (-9.8);
-             ?column?             
-----------------------------------
- 0.000000000000001722862754788209
-(1 row)
-
-select 12.3 ^ 45.6;
-                       ?column?                       
-------------------------------------------------------
- 50081010321492803393171165777624533697036806969694.9
-(1 row)
-
-select 12.3 ^ (-45.6);
-                              ?column?                               
----------------------------------------------------------------------
- 0.00000000000000000000000000000000000000000000000001996764828785491
-(1 row)
-
--- big test
-select 1.234 ^ 5678;
-                                                                                                                                                                                                                                                                         ?column?                                                                                                                                                                                                                                                                         
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
- 307239295662090741644584872593956173493568238595074141254349565406661439636598896798876823220904084953233015553994854875890890858118656468658643918169805277399402542281777901029346337707622181574346585989613344285010764501017625366742865066948856161360224801370482171458030533346309750557140549621313515752078638620714732831815297168231790779296290266207315344008883935010274044001522606235576584215999260117523114297033944018699691024106823438431754073086813382242140602291215149759520833200152654884259619588924545324.5973362312547382
-(1 row)
-
---
--- Tests for EXP()
---
--- special cases
-select exp(0.0);
-        exp         
---------------------
- 1.0000000000000000
-(1 row)
-
-select exp(1.0);
-        exp         
---------------------
- 2.7182818284590452
-(1 row)
-
-select exp(1.0::numeric(71,70));
-                                   exp                                    
---------------------------------------------------------------------------
- 2.7182818284590452353602874713526624977572470936999595749669676277240766
-(1 row)
-
-select exp('nan'::numeric);
- exp 
------
- NaN
-(1 row)
-
-select exp('inf'::numeric);
-   exp    
-----------
- Infinity
-(1 row)
-
-select exp('-inf'::numeric);
- exp 
------
-   0
-(1 row)
-
-select coalesce(nullif(exp(-5000::numeric), 0), 0) as rounds_to_zero;
- rounds_to_zero 
-----------------
-              0
-(1 row)
-
-select coalesce(nullif(exp(-10000::numeric), 0), 0) as underflows;
- underflows 
-------------
-          0
-(1 row)
-
--- cases that used to generate inaccurate results
-select exp(32.999);
-         exp         
----------------------
- 214429043492155.053
-(1 row)
-
-select exp(-32.999);
-               exp                
-----------------------------------
- 0.000000000000004663547361468248
-(1 row)
-
-select exp(123.456);
-                            exp                             
-------------------------------------------------------------
- 413294435277809344957685441227343146614594393746575438.725
-(1 row)
-
-select exp(-123.456);
-                                   exp                                   
--------------------------------------------------------------------------
- 0.000000000000000000000000000000000000000000000000000002419582541264601
-(1 row)
-
--- big test
-select exp(1234.5678);
-                                                                                                                                                                                                                                                                              exp                                                                                                                                                                                                                                                                               
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
- 146549072930959479983482138503979804217622199675223653966270157446954995433819741094410764947112047906012815540251009949604426069672532417736057033099274204598385314594846509975629046864798765888104789074984927709616261452461385220475510438783429612447831614003668421849727379202555580791042606170523016207262965336641214601082882495255771621327088265411334088968112458492660609809762865582162764292604697957813514621259353683899630997077707406305730694385703091201347848855199354307506425820147289848677003277208302716466011827836279231.9667
-(1 row)
-
---
--- Tests for generate_series
---
-select * from generate_series(0.0::numeric, 4.0::numeric);
- generate_series 
------------------
-             0.0
-             1.0
-             2.0
-             3.0
-             4.0
-(5 rows)
-
-select * from generate_series(0.1::numeric, 4.0::numeric, 1.3::numeric);
- generate_series 
------------------
-             0.1
-             1.4
-             2.7
-             4.0
-(4 rows)
-
-select * from generate_series(4.0::numeric, -1.5::numeric, -2.2::numeric);
- generate_series 
------------------
-             4.0
-             1.8
-            -0.4
-(3 rows)
-
--- Trigger errors
-select * from generate_series(-100::numeric, 100::numeric, 0::numeric);
-ERROR:  step size cannot equal zero
-select * from generate_series(-100::numeric, 100::numeric, 'nan'::numeric);
-ERROR:  step size cannot be NaN
-select * from generate_series('nan'::numeric, 100::numeric, 10::numeric);
-ERROR:  start value cannot be NaN
-select * from generate_series(0::numeric, 'nan'::numeric, 10::numeric);
-ERROR:  stop value cannot be NaN
-select * from generate_series('inf'::numeric, 'inf'::numeric, 10::numeric);
-ERROR:  start value cannot be infinity
-select * from generate_series(0::numeric, 'inf'::numeric, 10::numeric);
-ERROR:  stop value cannot be infinity
-select * from generate_series(0::numeric, '42'::numeric, '-inf'::numeric);
-ERROR:  step size cannot be infinity
--- Checks maximum, output is truncated
-select (i / (10::numeric ^ 131071))::numeric(1,0)
-	from generate_series(6 * (10::numeric ^ 131071),
-			     9 * (10::numeric ^ 131071),
-			     10::numeric ^ 131071) as a(i);
- numeric 
----------
-       6
-       7
-       8
-       9
-(4 rows)
-
--- Check usage with variables
-select * from generate_series(1::numeric, 3::numeric) i, generate_series(i,3) j;
- i | j 
----+---
- 1 | 1
- 1 | 2
- 1 | 3
- 2 | 2
- 2 | 3
- 3 | 3
-(6 rows)
-
-select * from generate_series(1::numeric, 3::numeric) i, generate_series(1,i) j;
- i | j 
----+---
- 1 | 1
- 2 | 1
- 2 | 2
- 3 | 1
- 3 | 2
- 3 | 3
-(6 rows)
-
-select * from generate_series(1::numeric, 3::numeric) i, generate_series(1,5,i) j;
- i | j 
----+---
- 1 | 1
- 1 | 2
- 1 | 3
- 1 | 4
- 1 | 5
- 2 | 1
- 2 | 3
- 2 | 5
- 3 | 1
- 3 | 4
-(10 rows)
-
---
--- Tests for LN()
---
--- Invalid inputs
-select ln(-12.34);
-ERROR:  cannot take logarithm of a negative number
-select ln(0.0);
-ERROR:  cannot take logarithm of zero
--- Some random tests
-select ln(1.2345678e-28);
-                   ln                    
------------------------------------------
- -64.26166165451762991204894255882820859
-(1 row)
-
-select ln(0.0456789);
-         ln          
----------------------
- -3.0861187944847439
-(1 row)
-
-select ln(0.349873948359354029493948309745709580730482050975);
-                         ln                          
------------------------------------------------------
- -1.050182336912082775693991697979750253056317885460
-(1 row)
-
-select ln(0.99949452);
-           ln            
--------------------------
- -0.00050560779808326467
-(1 row)
-
-select ln(1.00049687395);
-           ln           
-------------------------
- 0.00049675054901370394
-(1 row)
-
-select ln(1234.567890123456789);
-         ln         
---------------------
- 7.1184763012977896
-(1 row)
-
-select ln(5.80397490724e5);
-         ln         
---------------------
- 13.271468476626518
-(1 row)
-
-select ln(9.342536355e34);
-         ln         
---------------------
- 80.522470935524187
-(1 row)
-
---
--- Tests for LOG() (base 10)
---
--- invalid inputs
-select log(-12.34);
-ERROR:  cannot take logarithm of a negative number
-CONTEXT:  SQL function "log" statement 1
-select log(0.0);
-ERROR:  cannot take logarithm of zero
-CONTEXT:  SQL function "log" statement 1
--- some random tests
-select log(1.234567e-89);
-                                                 log                                                 
------------------------------------------------------------------------------------------------------
- -88.90848533591373725637496492944925187293052336306443143312825869985819779294142441287021741054275
-(1 row)
-
-select log(3.4634998359873254962349856073435545);
-                 log                  
---------------------------------------
- 0.5395151714070134409152404011959981
-(1 row)
-
-select log(9.999999999999999999);
-         log          
-----------------------
- 1.000000000000000000
-(1 row)
-
-select log(10.00000000000000000);
-         log         
----------------------
- 1.00000000000000000
-(1 row)
-
-select log(10.00000000000000001);
-         log         
----------------------
- 1.00000000000000000
-(1 row)
-
-select log(590489.45235237);
-        log        
--------------------
- 5.771212144411727
-(1 row)
-
---
--- Tests for LOG() (arbitrary base)
---
--- invalid inputs
-select log(-12.34, 56.78);
-ERROR:  cannot take logarithm of a negative number
-select log(-12.34, -56.78);
-ERROR:  cannot take logarithm of a negative number
-select log(12.34, -56.78);
-ERROR:  cannot take logarithm of a negative number
-select log(0.0, 12.34);
-ERROR:  cannot take logarithm of zero
-select log(12.34, 0.0);
-ERROR:  cannot take logarithm of zero
-select log(1.0, 12.34);
-ERROR:  division by zero
--- some random tests
-select log(1.23e-89, 6.4689e45);
-                                              log                                               
-------------------------------------------------------------------------------------------------
- -0.5152489207781856983977054971756484879653568168479201885425588841094788842469115325262329756
-(1 row)
-
-select log(0.99923, 4.58934e34);
-         log         
----------------------
- -103611.55579544132
-(1 row)
-
-select log(1.000016, 8.452010e18);
-        log         
---------------------
- 2723830.2877097365
-(1 row)
-
-select log(3.1954752e47, 9.4792021e-73);
-                                         log                                         
--------------------------------------------------------------------------------------
- -1.51613372350688302142917386143459361608600157692779164475351842333265418126982165
-(1 row)
-
---
--- Tests for scale()
---
-select scale(numeric 'NaN');
- scale 
--------
-      
-(1 row)
-
-select scale(numeric 'inf');
- scale 
--------
-      
-(1 row)
-
-select scale(NULL::numeric);
- scale 
--------
-      
-(1 row)
-
-select scale(1.12);
- scale 
--------
-     2
-(1 row)
-
-select scale(0);
- scale 
--------
-     0
-(1 row)
-
-select scale(0.00);
- scale 
--------
-     2
-(1 row)
-
-select scale(1.12345);
- scale 
--------
-     5
-(1 row)
-
-select scale(110123.12475871856128);
- scale 
--------
-    14
-(1 row)
-
-select scale(-1123.12471856128);
- scale 
--------
-    11
-(1 row)
-
-select scale(-13.000000000000000);
- scale 
--------
-    15
-(1 row)
-
---
--- Tests for min_scale()
---
-select min_scale(numeric 'NaN') is NULL; -- should be true
- ?column? 
-----------
- t
-(1 row)
-
-select min_scale(numeric 'inf') is NULL; -- should be true
- ?column? 
-----------
- t
-(1 row)
-
-select min_scale(0);                     -- no digits
- min_scale 
------------
-         0
-(1 row)
-
-select min_scale(0.00);                  -- no digits again
- min_scale 
------------
-         0
-(1 row)
-
-select min_scale(1.0);                   -- no scale
- min_scale 
------------
-         0
-(1 row)
-
-select min_scale(1.1);                   -- scale 1
- min_scale 
------------
-         1
-(1 row)
-
-select min_scale(1.12);                  -- scale 2
- min_scale 
------------
-         2
-(1 row)
-
-select min_scale(1.123);                 -- scale 3
- min_scale 
------------
-         3
-(1 row)
-
-select min_scale(1.1234);                -- scale 4, filled digit
- min_scale 
------------
-         4
-(1 row)
-
-select min_scale(1.12345);               -- scale 5, 2 NDIGITS
- min_scale 
------------
-         5
-(1 row)
-
-select min_scale(1.1000);                -- 1 pos in NDIGITS
- min_scale 
------------
-         1
-(1 row)
-
-select min_scale(1e100);                 -- very big number
- min_scale 
------------
-         0
-(1 row)
-
---
--- Tests for trim_scale()
---
-select trim_scale(numeric 'NaN');
- trim_scale 
-------------
-        NaN
-(1 row)
-
-select trim_scale(numeric 'inf');
- trim_scale 
-------------
-   Infinity
-(1 row)
-
-select trim_scale(1.120);
- trim_scale 
-------------
-       1.12
-(1 row)
-
-select trim_scale(0);
- trim_scale 
-------------
-          0
-(1 row)
-
-select trim_scale(0.00);
- trim_scale 
-------------
-          0
-(1 row)
-
-select trim_scale(1.1234500);
- trim_scale 
-------------
-    1.12345
-(1 row)
-
-select trim_scale(110123.12475871856128000);
-      trim_scale       
------------------------
- 110123.12475871856128
-(1 row)
-
-select trim_scale(-1123.124718561280000000);
-    trim_scale     
--------------------
- -1123.12471856128
-(1 row)
-
-select trim_scale(-13.00000000000000000000);
- trim_scale 
-------------
-        -13
-(1 row)
-
-select trim_scale(1e100);
-                                              trim_scale                                               
--------------------------------------------------------------------------------------------------------
- 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
-(1 row)
-
---
--- Tests for SUM()
---
--- cases that need carry propagation
-SELECT SUM(9999::numeric) FROM generate_series(1, 100000);
-    sum    
------------
- 999900000
-(1 row)
-
-SELECT SUM((-9999)::numeric) FROM generate_series(1, 100000);
-    sum     
-------------
- -999900000
-(1 row)
-
---
--- Tests for VARIANCE()
---
-CREATE TABLE num_variance (a numeric);
-INSERT INTO num_variance VALUES (0);
-INSERT INTO num_variance VALUES (3e-500);
-INSERT INTO num_variance VALUES (-3e-500);
-INSERT INTO num_variance VALUES (4e-500 - 1e-16383);
-INSERT INTO num_variance VALUES (-4e-500 + 1e-16383);
--- variance is just under 12.5e-1000 and so should round down to 12e-1000
-SELECT trim_scale(variance(a) * 1e1000) FROM num_variance;
- trim_scale 
-------------
-         12
-(1 row)
-
--- check that parallel execution produces the same result
-BEGIN;
-ALTER TABLE num_variance SET (parallel_workers = 4);
-SET LOCAL parallel_setup_cost = 0;
-SET LOCAL max_parallel_workers_per_gather = 4;
-SELECT trim_scale(variance(a) * 1e1000) FROM num_variance;
- trim_scale 
-------------
-         12
-(1 row)
-
-ROLLBACK;
--- case where sum of squares would overflow but variance does not
-DELETE FROM num_variance;
-INSERT INTO num_variance SELECT 9e131071 + x FROM generate_series(1, 5) x;
-SELECT variance(a) FROM num_variance;
-      variance      
---------------------
- 2.5000000000000000
-(1 row)
-
--- check that parallel execution produces the same result
-BEGIN;
-ALTER TABLE num_variance SET (parallel_workers = 4);
-SET LOCAL parallel_setup_cost = 0;
-SET LOCAL max_parallel_workers_per_gather = 4;
-SELECT variance(a) FROM num_variance;
-      variance      
---------------------
- 2.5000000000000000
-(1 row)
-
-ROLLBACK;
-DROP TABLE num_variance;
---
--- Tests for GCD()
---
-SELECT a, b, gcd(a, b), gcd(a, -b), gcd(-b, a), gcd(-b, -a)
-FROM (VALUES (0::numeric, 0::numeric),
-             (0::numeric, numeric 'NaN'),
-             (0::numeric, 46375::numeric),
-             (433125::numeric, 46375::numeric),
-             (43312.5::numeric, 4637.5::numeric),
-             (4331.250::numeric, 463.75000::numeric),
-             ('inf', '0'),
-             ('inf', '42'),
-             ('inf', 'inf')
-     ) AS v(a, b);
-    a     |     b     |   gcd   |   gcd   |   gcd   |   gcd   
-----------+-----------+---------+---------+---------+---------
-        0 |         0 |       0 |       0 |       0 |       0
-        0 |       NaN |     NaN |     NaN |     NaN |     NaN
-        0 |     46375 |   46375 |   46375 |   46375 |   46375
-   433125 |     46375 |     875 |     875 |     875 |     875
-  43312.5 |    4637.5 |    87.5 |    87.5 |    87.5 |    87.5
- 4331.250 | 463.75000 | 8.75000 | 8.75000 | 8.75000 | 8.75000
- Infinity |         0 |     NaN |     NaN |     NaN |     NaN
- Infinity |        42 |     NaN |     NaN |     NaN |     NaN
- Infinity |  Infinity |     NaN |     NaN |     NaN |     NaN
-(9 rows)
-
---
--- Tests for LCM()
---
-SELECT a,b, lcm(a, b), lcm(a, -b), lcm(-b, a), lcm(-b, -a)
-FROM (VALUES (0::numeric, 0::numeric),
-             (0::numeric, numeric 'NaN'),
-             (0::numeric, 13272::numeric),
-             (13272::numeric, 13272::numeric),
-             (423282::numeric, 13272::numeric),
-             (42328.2::numeric, 1327.2::numeric),
-             (4232.820::numeric, 132.72000::numeric),
-             ('inf', '0'),
-             ('inf', '42'),
-             ('inf', 'inf')
-     ) AS v(a, b);
-    a     |     b     |     lcm      |     lcm      |     lcm      |     lcm      
-----------+-----------+--------------+--------------+--------------+--------------
-        0 |         0 |            0 |            0 |            0 |            0
-        0 |       NaN |          NaN |          NaN |          NaN |          NaN
-        0 |     13272 |            0 |            0 |            0 |            0
-    13272 |     13272 |        13272 |        13272 |        13272 |        13272
-   423282 |     13272 |     11851896 |     11851896 |     11851896 |     11851896
-  42328.2 |    1327.2 |    1185189.6 |    1185189.6 |    1185189.6 |    1185189.6
- 4232.820 | 132.72000 | 118518.96000 | 118518.96000 | 118518.96000 | 118518.96000
- Infinity |         0 |          NaN |          NaN |          NaN |          NaN
- Infinity |        42 |          NaN |          NaN |          NaN |          NaN
- Infinity |  Infinity |          NaN |          NaN |          NaN |          NaN
-(10 rows)
-
-SELECT lcm(9999 * (10::numeric)^131068 + (10::numeric^131068 - 1), 2); -- overflow
-ERROR:  value overflows numeric format
---
--- Tests for factorial
---
-SELECT factorial(4);
- factorial 
------------
-        24
-(1 row)
-
-SELECT factorial(15);
-   factorial   
----------------
- 1307674368000
-(1 row)
-
-SELECT factorial(100000);
-ERROR:  value overflows numeric format
-SELECT factorial(0);
- factorial 
------------
-         1
-(1 row)
-
-SELECT factorial(-4);
-ERROR:  factorial of a negative number is undefined
---
--- Tests for pg_lsn()
---
-SELECT pg_lsn(23783416::numeric);
-  pg_lsn   
------------
- 0/16AE7F8
-(1 row)
-
-SELECT pg_lsn(0::numeric);
- pg_lsn 
---------
- 0/0
-(1 row)
-
-SELECT pg_lsn(18446744073709551615::numeric);
-      pg_lsn       
--------------------
- FFFFFFFF/FFFFFFFF
-(1 row)
-
-SELECT pg_lsn(-1::numeric);
-ERROR:  pg_lsn out of range
-SELECT pg_lsn(18446744073709551616::numeric);
-ERROR:  pg_lsn out of range
-SELECT pg_lsn('NaN'::numeric);
-ERROR:  cannot convert NaN to pg_lsn
diff -U3 /Users/kenaniah/workspace/postgres/src/test/regress/expected/expressions.out /Users/kenaniah/workspace/postgres/src/test/regress/results/expressions.out
--- /Users/kenaniah/workspace/postgres/src/test/regress/expected/expressions.out	2021-10-03 18:09:17.000000000 -0700
+++ /Users/kenaniah/workspace/postgres/src/test/regress/results/expressions.out	2021-10-03 20:08:08.000000000 -0700
@@ -169,231 +169,11 @@
     f2, f2::numeric(16,4) as f2164, f2::numeric as f2n
   from numeric_tbl;
 \d+ numeric_view
-                           View "public.numeric_view"
- Column |     Type      | Collation | Nullable | Default | Storage | Description 
---------+---------------+-----------+----------+---------+---------+-------------
- f1     | numeric(18,3) |           |          |         | main    | 
- f1164  | numeric(16,4) |           |          |         | main    | 
- f1n    | numeric       |           |          |         | main    | 
- f2     | numeric       |           |          |         | main    | 
- f2164  | numeric(16,4) |           |          |         | main    | 
- f2n    | numeric       |           |          |         | main    | 
-View definition:
- SELECT numeric_tbl.f1,
-    numeric_tbl.f1::numeric(16,4) AS f1164,
-    numeric_tbl.f1::numeric AS f1n,
-    numeric_tbl.f2,
-    numeric_tbl.f2::numeric(16,4) AS f2164,
-    numeric_tbl.f2 AS f2n
-   FROM numeric_tbl;
+dyld: lazy symbol binding failed: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
+
+dyld: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
 
-explain (verbose, costs off) select * from numeric_view;
-                                                                      QUERY PLAN                                                                       
--------------------------------------------------------------------------------------------------------------------------------------------------------
- Seq Scan on public.numeric_tbl
-   Output: numeric_tbl.f1, (numeric_tbl.f1)::numeric(16,4), (numeric_tbl.f1)::numeric, numeric_tbl.f2, (numeric_tbl.f2)::numeric(16,4), numeric_tbl.f2
-(2 rows)
-
-rollback;
---
--- Tests for ScalarArrayOpExpr with a hashfn
---
--- create a stable function so that the tests below are not
--- evaluated using the planner's constant folding.
-begin;
-create function return_int_input(int) returns int as $$
-begin
-	return $1;
-end;
-$$ language plpgsql stable;
-create function return_text_input(text) returns text as $$
-begin
-	return $1;
-end;
-$$ language plpgsql stable;
-select return_int_input(1) in (10, 9, 2, 8, 3, 7, 4, 6, 5, 1);
- ?column? 
-----------
- t
-(1 row)
-
-select return_int_input(1) in (10, 9, 2, 8, 3, 7, 4, 6, 5, null);
- ?column? 
-----------
- 
-(1 row)
-
-select return_int_input(1) in (null, null, null, null, null, null, null, null, null, null, null);
- ?column? 
-----------
- 
-(1 row)
-
-select return_int_input(1) in (10, 9, 2, 8, 3, 7, 4, 6, 5, 1, null);
- ?column? 
-----------
- t
-(1 row)
-
-select return_int_input(null::int) in (10, 9, 2, 8, 3, 7, 4, 6, 5, 1);
- ?column? 
-----------
- 
-(1 row)
-
-select return_int_input(null::int) in (10, 9, 2, 8, 3, 7, 4, 6, 5, null);
- ?column? 
-----------
- 
-(1 row)
-
-select return_text_input('a') in ('a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j');
- ?column? 
-----------
- t
-(1 row)
-
--- NOT IN
-select return_int_input(1) not in (10, 9, 2, 8, 3, 7, 4, 6, 5, 1);
- ?column? 
-----------
- f
-(1 row)
-
-select return_int_input(1) not in (10, 9, 2, 8, 3, 7, 4, 6, 5, 0);
- ?column? 
-----------
- t
-(1 row)
-
-select return_int_input(1) not in (10, 9, 2, 8, 3, 7, 4, 6, 5, 2, null);
- ?column? 
-----------
- 
-(1 row)
-
-select return_int_input(1) not in (10, 9, 2, 8, 3, 7, 4, 6, 5, 1, null);
- ?column? 
-----------
- f
-(1 row)
-
-select return_int_input(1) not in (null, null, null, null, null, null, null, null, null, null, null);
- ?column? 
-----------
- 
-(1 row)
-
-select return_int_input(null::int) not in (10, 9, 2, 8, 3, 7, 4, 6, 5, 1);
- ?column? 
-----------
- 
-(1 row)
-
-select return_int_input(null::int) not in (10, 9, 2, 8, 3, 7, 4, 6, 5, null);
- ?column? 
-----------
- 
-(1 row)
-
-select return_text_input('a') not in ('a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j');
- ?column? 
-----------
- f
-(1 row)
-
-rollback;
--- Test with non-strict equality function.
--- We need to create our own type for this.
-begin;
-create type myint;
-create function myintin(cstring) returns myint strict immutable language
-  internal as 'int4in';
-NOTICE:  return type myint is only a shell
-create function myintout(myint) returns cstring strict immutable language
-  internal as 'int4out';
-NOTICE:  argument type myint is only a shell
-create function myinthash(myint) returns integer strict immutable language
-  internal as 'hashint4';
-NOTICE:  argument type myint is only a shell
-create type myint (input = myintin, output = myintout, like = int4);
-create cast (int4 as myint) without function;
-create cast (myint as int4) without function;
-create function myinteq(myint, myint) returns bool as $$
-begin
-  if $1 is null and $2 is null then
-    return true;
-  else
-    return $1::int = $2::int;
-  end if;
-end;
-$$ language plpgsql immutable;
-create function myintne(myint, myint) returns bool as $$
-begin
-  return not myinteq($1, $2);
-end;
-$$ language plpgsql immutable;
-create operator = (
-  leftarg    = myint,
-  rightarg   = myint,
-  commutator = =,
-  negator    = <>,
-  procedure  = myinteq,
-  restrict   = eqsel,
-  join       = eqjoinsel,
-  merges
-);
-create operator <> (
-  leftarg    = myint,
-  rightarg   = myint,
-  commutator = <>,
-  negator    = =,
-  procedure  = myintne,
-  restrict   = eqsel,
-  join       = eqjoinsel,
-  merges
-);
-create operator class myint_ops
-default for type myint using hash as
-  operator    1   =  (myint, myint),
-  function    1   myinthash(myint);
-create table inttest (a myint);
-insert into inttest values(1::myint),(null);
--- try an array with enough elements to cause hashing
-select * from inttest where a in (1::myint,2::myint,3::myint,4::myint,5::myint,6::myint,7::myint,8::myint,9::myint, null);
- a 
----
- 1
- 
-(2 rows)
-
-select * from inttest where a not in (1::myint,2::myint,3::myint,4::myint,5::myint,6::myint,7::myint,8::myint,9::myint, null);
- a 
----
-(0 rows)
-
-select * from inttest where a not in (0::myint,2::myint,3::myint,4::myint,5::myint,6::myint,7::myint,8::myint,9::myint, null);
- a 
----
-(0 rows)
-
--- ensure the result matched with the non-hashed version.  We simply remove
--- some array elements so that we don't reach the hashing threshold.
-select * from inttest where a in (1::myint,2::myint,3::myint,4::myint,5::myint, null);
- a 
----
- 1
- 
-(2 rows)
-
-select * from inttest where a not in (1::myint,2::myint,3::myint,4::myint,5::myint, null);
- a 
----
-(0 rows)
-
-select * from inttest where a not in (0::myint,2::myint,3::myint,4::myint,5::myint, null);
- a 
----
-(0 rows)
-
-rollback;
diff -U3 /Users/kenaniah/workspace/postgres/src/test/regress/expected/create_table.out /Users/kenaniah/workspace/postgres/src/test/regress/results/create_table.out
--- /Users/kenaniah/workspace/postgres/src/test/regress/expected/create_table.out	2021-10-03 17:41:49.000000000 -0700
+++ /Users/kenaniah/workspace/postgres/src/test/regress/results/create_table.out	2021-10-03 20:08:12.000000000 -0700
@@ -487,835 +487,11 @@
 ERROR:  cannot inherit from partitioned table "partitioned2"
 -- Partition key in describe output
 \d partitioned
-      Partitioned table "public.partitioned"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
- b      | integer |           |          | 
- c      | text    |           |          | 
- d      | text    |           |          | 
-Partition key: RANGE (a oid_ops, plusone(b), c, d COLLATE "C")
-Number of partitions: 0
+dyld: lazy symbol binding failed: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
+
+dyld: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
 
-\d+ partitioned2
-                          Partitioned table "public.partitioned2"
- Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
---------+---------+-----------+----------+---------+----------+--------------+-------------
- a      | integer |           |          |         | plain    |              | 
- b      | text    |           |          |         | extended |              | 
-Partition key: RANGE (((a + 1)), substr(b, 1, 5))
-Number of partitions: 0
-
-INSERT INTO partitioned2 VALUES (1, 'hello');
-ERROR:  no partition of relation "partitioned2" found for row
-DETAIL:  Partition key of the failing row contains ((a + 1), substr(b, 1, 5)) = (2, hello).
-CREATE TABLE part2_1 PARTITION OF partitioned2 FOR VALUES FROM (-1, 'aaaaa') TO (100, 'ccccc');
-\d+ part2_1
-                                  Table "public.part2_1"
- Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
---------+---------+-----------+----------+---------+----------+--------------+-------------
- a      | integer |           |          |         | plain    |              | 
- b      | text    |           |          |         | extended |              | 
-Partition of: partitioned2 FOR VALUES FROM ('-1', 'aaaaa') TO (100, 'ccccc')
-Partition constraint: (((a + 1) IS NOT NULL) AND (substr(b, 1, 5) IS NOT NULL) AND (((a + 1) > '-1'::integer) OR (((a + 1) = '-1'::integer) AND (substr(b, 1, 5) >= 'aaaaa'::text))) AND (((a + 1) < 100) OR (((a + 1) = 100) AND (substr(b, 1, 5) < 'ccccc'::text))))
-
-DROP TABLE partitioned, partitioned2;
--- check reference to partitioned table's rowtype in partition descriptor
-create table partitioned (a int, b int)
-  partition by list ((row(a, b)::partitioned));
-create table partitioned1
-  partition of partitioned for values in ('(1,2)'::partitioned);
-create table partitioned2
-  partition of partitioned for values in ('(2,4)'::partitioned);
-explain (costs off)
-select * from partitioned where row(a,b)::partitioned = '(1,2)'::partitioned;
-                        QUERY PLAN                         
------------------------------------------------------------
- Seq Scan on partitioned1 partitioned
-   Filter: (ROW(a, b)::partitioned = '(1,2)'::partitioned)
-(2 rows)
-
-drop table partitioned;
--- whole-row Var in partition key works too
-create table partitioned (a int, b int)
-  partition by list ((partitioned));
-create table partitioned1
-  partition of partitioned for values in ('(1,2)');
-create table partitioned2
-  partition of partitioned for values in ('(2,4)');
-explain (costs off)
-select * from partitioned where partitioned = '(1,2)'::partitioned;
-                           QUERY PLAN                            
------------------------------------------------------------------
- Seq Scan on partitioned1 partitioned
-   Filter: ((partitioned.*)::partitioned = '(1,2)'::partitioned)
-(2 rows)
-
-\d+ partitioned1
-                               Table "public.partitioned1"
- Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
---------+---------+-----------+----------+---------+---------+--------------+-------------
- a      | integer |           |          |         | plain   |              | 
- b      | integer |           |          |         | plain   |              | 
-Partition of: partitioned FOR VALUES IN ('(1,2)')
-Partition constraint: (((partitioned1.*)::partitioned IS DISTINCT FROM NULL) AND ((partitioned1.*)::partitioned = '(1,2)'::partitioned))
-
-drop table partitioned;
--- check that dependencies of partition columns are handled correctly
-create domain intdom1 as int;
-create table partitioned (
-	a intdom1,
-	b text
-) partition by range (a);
-alter table partitioned drop column a;  -- fail
-ERROR:  cannot drop column "a" because it is part of the partition key of relation "partitioned"
-drop domain intdom1;  -- fail, requires cascade
-ERROR:  cannot drop type intdom1 because other objects depend on it
-DETAIL:  table partitioned depends on type intdom1
-HINT:  Use DROP ... CASCADE to drop the dependent objects too.
-drop domain intdom1 cascade;
-NOTICE:  drop cascades to table partitioned
-table partitioned;  -- gone
-ERROR:  relation "partitioned" does not exist
-LINE 1: table partitioned;
-              ^
--- likewise for columns used in partition expressions
-create domain intdom1 as int;
-create table partitioned (
-	a intdom1,
-	b text
-) partition by range (plusone(a));
-alter table partitioned drop column a;  -- fail
-ERROR:  cannot drop column "a" because it is part of the partition key of relation "partitioned"
-drop domain intdom1;  -- fail, requires cascade
-ERROR:  cannot drop type intdom1 because other objects depend on it
-DETAIL:  table partitioned depends on type intdom1
-HINT:  Use DROP ... CASCADE to drop the dependent objects too.
-drop domain intdom1 cascade;
-NOTICE:  drop cascades to table partitioned
-table partitioned;  -- gone
-ERROR:  relation "partitioned" does not exist
-LINE 1: table partitioned;
-              ^
---
--- Partitions
---
--- check partition bound syntax
-CREATE TABLE list_parted (
-	a int
-) PARTITION BY LIST (a);
-CREATE TABLE part_p1 PARTITION OF list_parted FOR VALUES IN ('1');
-CREATE TABLE part_p2 PARTITION OF list_parted FOR VALUES IN (2);
-CREATE TABLE part_p3 PARTITION OF list_parted FOR VALUES IN ((2+1));
-CREATE TABLE part_null PARTITION OF list_parted FOR VALUES IN (null);
-\d+ list_parted
-                          Partitioned table "public.list_parted"
- Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
---------+---------+-----------+----------+---------+---------+--------------+-------------
- a      | integer |           |          |         | plain   |              | 
-Partition key: LIST (a)
-Partitions: part_null FOR VALUES IN (NULL),
-            part_p1 FOR VALUES IN (1),
-            part_p2 FOR VALUES IN (2),
-            part_p3 FOR VALUES IN (3)
-
--- forbidden expressions for partition bound with list partitioned table
-CREATE TABLE part_bogus_expr_fail PARTITION OF list_parted FOR VALUES IN (somename);
-ERROR:  cannot use column reference in partition bound expression
-LINE 1: ...expr_fail PARTITION OF list_parted FOR VALUES IN (somename);
-                                                             ^
-CREATE TABLE part_bogus_expr_fail PARTITION OF list_parted FOR VALUES IN (somename.somename);
-ERROR:  cannot use column reference in partition bound expression
-LINE 1: ...expr_fail PARTITION OF list_parted FOR VALUES IN (somename.s...
-                                                             ^
-CREATE TABLE part_bogus_expr_fail PARTITION OF list_parted FOR VALUES IN (a);
-ERROR:  cannot use column reference in partition bound expression
-LINE 1: ..._bogus_expr_fail PARTITION OF list_parted FOR VALUES IN (a);
-                                                                    ^
-CREATE TABLE part_bogus_expr_fail PARTITION OF list_parted FOR VALUES IN (sum(a));
-ERROR:  cannot use column reference in partition bound expression
-LINE 1: ...s_expr_fail PARTITION OF list_parted FOR VALUES IN (sum(a));
-                                                                   ^
-CREATE TABLE part_bogus_expr_fail PARTITION OF list_parted FOR VALUES IN (sum(somename));
-ERROR:  cannot use column reference in partition bound expression
-LINE 1: ..._fail PARTITION OF list_parted FOR VALUES IN (sum(somename))...
-                                                             ^
-CREATE TABLE part_bogus_expr_fail PARTITION OF list_parted FOR VALUES IN (sum(1));
-ERROR:  aggregate functions are not allowed in partition bound
-LINE 1: ...s_expr_fail PARTITION OF list_parted FOR VALUES IN (sum(1));
-                                                               ^
-CREATE TABLE part_bogus_expr_fail PARTITION OF list_parted FOR VALUES IN ((select 1));
-ERROR:  cannot use subquery in partition bound
-LINE 1: ...expr_fail PARTITION OF list_parted FOR VALUES IN ((select 1)...
-                                                             ^
-CREATE TABLE part_bogus_expr_fail PARTITION OF list_parted FOR VALUES IN (generate_series(4, 6));
-ERROR:  set-returning functions are not allowed in partition bound
-LINE 1: ...expr_fail PARTITION OF list_parted FOR VALUES IN (generate_s...
-                                                             ^
-CREATE TABLE part_bogus_expr_fail PARTITION OF list_parted FOR VALUES IN ((1+1) collate "POSIX");
-ERROR:  collations are not supported by type integer
-LINE 1: ...ail PARTITION OF list_parted FOR VALUES IN ((1+1) collate "P...
-                                                             ^
--- syntax does not allow empty list of values for list partitions
-CREATE TABLE fail_part PARTITION OF list_parted FOR VALUES IN ();
-ERROR:  syntax error at or near ")"
-LINE 1: ...E TABLE fail_part PARTITION OF list_parted FOR VALUES IN ();
-                                                                     ^
--- trying to specify range for list partitioned table
-CREATE TABLE fail_part PARTITION OF list_parted FOR VALUES FROM (1) TO (2);
-ERROR:  invalid bound specification for a list partition
-LINE 1: ...BLE fail_part PARTITION OF list_parted FOR VALUES FROM (1) T...
-                                                             ^
--- trying to specify modulus and remainder for list partitioned table
-CREATE TABLE fail_part PARTITION OF list_parted FOR VALUES WITH (MODULUS 10, REMAINDER 1);
-ERROR:  invalid bound specification for a list partition
-LINE 1: ...BLE fail_part PARTITION OF list_parted FOR VALUES WITH (MODU...
-                                                             ^
--- check default partition cannot be created more than once
-CREATE TABLE part_default PARTITION OF list_parted DEFAULT;
-CREATE TABLE fail_default_part PARTITION OF list_parted DEFAULT;
-ERROR:  partition "fail_default_part" conflicts with existing default partition "part_default"
-LINE 1: ...TE TABLE fail_default_part PARTITION OF list_parted DEFAULT;
-                                                               ^
--- specified literal can't be cast to the partition column data type
-CREATE TABLE bools (
-	a bool
-) PARTITION BY LIST (a);
-CREATE TABLE bools_true PARTITION OF bools FOR VALUES IN (1);
-ERROR:  specified value cannot be cast to type boolean for column "a"
-LINE 1: ...REATE TABLE bools_true PARTITION OF bools FOR VALUES IN (1);
-                                                                    ^
-DROP TABLE bools;
--- specified literal can be cast, and the cast might not be immutable
-CREATE TABLE moneyp (
-	a money
-) PARTITION BY LIST (a);
-CREATE TABLE moneyp_10 PARTITION OF moneyp FOR VALUES IN (10);
-CREATE TABLE moneyp_11 PARTITION OF moneyp FOR VALUES IN ('11');
-CREATE TABLE moneyp_12 PARTITION OF moneyp FOR VALUES IN (to_char(12, '99')::int);
-DROP TABLE moneyp;
--- cast is immutable
-CREATE TABLE bigintp (
-	a bigint
-) PARTITION BY LIST (a);
-CREATE TABLE bigintp_10 PARTITION OF bigintp FOR VALUES IN (10);
--- fails due to overlap:
-CREATE TABLE bigintp_10_2 PARTITION OF bigintp FOR VALUES IN ('10');
-ERROR:  partition "bigintp_10_2" would overlap partition "bigintp_10"
-LINE 1: ...ABLE bigintp_10_2 PARTITION OF bigintp FOR VALUES IN ('10');
-                                                                 ^
-DROP TABLE bigintp;
-CREATE TABLE range_parted (
-	a date
-) PARTITION BY RANGE (a);
--- forbidden expressions for partition bounds with range partitioned table
-CREATE TABLE part_bogus_expr_fail PARTITION OF range_parted
-  FOR VALUES FROM (somename) TO ('2019-01-01');
-ERROR:  cannot use column reference in partition bound expression
-LINE 2:   FOR VALUES FROM (somename) TO ('2019-01-01');
-                           ^
-CREATE TABLE part_bogus_expr_fail PARTITION OF range_parted
-  FOR VALUES FROM (somename.somename) TO ('2019-01-01');
-ERROR:  cannot use column reference in partition bound expression
-LINE 2:   FOR VALUES FROM (somename.somename) TO ('2019-01-01');
-                           ^
-CREATE TABLE part_bogus_expr_fail PARTITION OF range_parted
-  FOR VALUES FROM (a) TO ('2019-01-01');
-ERROR:  cannot use column reference in partition bound expression
-LINE 2:   FOR VALUES FROM (a) TO ('2019-01-01');
-                           ^
-CREATE TABLE part_bogus_expr_fail PARTITION OF range_parted
-  FOR VALUES FROM (max(a)) TO ('2019-01-01');
-ERROR:  cannot use column reference in partition bound expression
-LINE 2:   FOR VALUES FROM (max(a)) TO ('2019-01-01');
-                               ^
-CREATE TABLE part_bogus_expr_fail PARTITION OF range_parted
-  FOR VALUES FROM (max(somename)) TO ('2019-01-01');
-ERROR:  cannot use column reference in partition bound expression
-LINE 2:   FOR VALUES FROM (max(somename)) TO ('2019-01-01');
-                               ^
-CREATE TABLE part_bogus_expr_fail PARTITION OF range_parted
-  FOR VALUES FROM (max('2019-02-01'::date)) TO ('2019-01-01');
-ERROR:  aggregate functions are not allowed in partition bound
-LINE 2:   FOR VALUES FROM (max('2019-02-01'::date)) TO ('2019-01-01'...
-                           ^
-CREATE TABLE part_bogus_expr_fail PARTITION OF range_parted
-  FOR VALUES FROM ((select 1)) TO ('2019-01-01');
-ERROR:  cannot use subquery in partition bound
-LINE 2:   FOR VALUES FROM ((select 1)) TO ('2019-01-01');
-                           ^
-CREATE TABLE part_bogus_expr_fail PARTITION OF range_parted
-  FOR VALUES FROM (generate_series(1, 3)) TO ('2019-01-01');
-ERROR:  set-returning functions are not allowed in partition bound
-LINE 2:   FOR VALUES FROM (generate_series(1, 3)) TO ('2019-01-01');
-                           ^
--- trying to specify list for range partitioned table
-CREATE TABLE fail_part PARTITION OF range_parted FOR VALUES IN ('a');
-ERROR:  invalid bound specification for a range partition
-LINE 1: ...BLE fail_part PARTITION OF range_parted FOR VALUES IN ('a');
-                                                              ^
--- trying to specify modulus and remainder for range partitioned table
-CREATE TABLE fail_part PARTITION OF range_parted FOR VALUES WITH (MODULUS 10, REMAINDER 1);
-ERROR:  invalid bound specification for a range partition
-LINE 1: ...LE fail_part PARTITION OF range_parted FOR VALUES WITH (MODU...
-                                                             ^
--- each of start and end bounds must have same number of values as the
--- length of the partition key
-CREATE TABLE fail_part PARTITION OF range_parted FOR VALUES FROM ('a', 1) TO ('z');
-ERROR:  FROM must specify exactly one value per partitioning column
-CREATE TABLE fail_part PARTITION OF range_parted FOR VALUES FROM ('a') TO ('z', 1);
-ERROR:  TO must specify exactly one value per partitioning column
--- cannot specify null values in range bounds
-CREATE TABLE fail_part PARTITION OF range_parted FOR VALUES FROM (null) TO (maxvalue);
-ERROR:  cannot specify NULL in range bound
--- trying to specify modulus and remainder for range partitioned table
-CREATE TABLE fail_part PARTITION OF range_parted FOR VALUES WITH (MODULUS 10, REMAINDER 1);
-ERROR:  invalid bound specification for a range partition
-LINE 1: ...LE fail_part PARTITION OF range_parted FOR VALUES WITH (MODU...
-                                                             ^
--- check partition bound syntax for the hash partition
-CREATE TABLE hash_parted (
-	a int
-) PARTITION BY HASH (a);
-CREATE TABLE hpart_1 PARTITION OF hash_parted FOR VALUES WITH (MODULUS 10, REMAINDER 0);
-CREATE TABLE hpart_2 PARTITION OF hash_parted FOR VALUES WITH (MODULUS 50, REMAINDER 1);
-CREATE TABLE hpart_3 PARTITION OF hash_parted FOR VALUES WITH (MODULUS 200, REMAINDER 2);
-CREATE TABLE hpart_4 PARTITION OF hash_parted FOR VALUES WITH (MODULUS 10, REMAINDER 3);
--- modulus 25 is factor of modulus of 50 but 10 is not a factor of 25.
-CREATE TABLE fail_part PARTITION OF hash_parted FOR VALUES WITH (MODULUS 25, REMAINDER 3);
-ERROR:  every hash partition modulus must be a factor of the next larger modulus
-DETAIL:  The new modulus 25 is not divisible by 10, the modulus of existing partition "hpart_4".
--- previous modulus 50 is factor of 150 but this modulus is not a factor of next modulus 200.
-CREATE TABLE fail_part PARTITION OF hash_parted FOR VALUES WITH (MODULUS 150, REMAINDER 3);
-ERROR:  every hash partition modulus must be a factor of the next larger modulus
-DETAIL:  The new modulus 150 is not a factor of 200, the modulus of existing partition "hpart_3".
--- overlapping remainders
-CREATE TABLE fail_part PARTITION OF hash_parted FOR VALUES WITH (MODULUS 100, REMAINDER 3);
-ERROR:  partition "fail_part" would overlap partition "hpart_4"
-LINE 1: ...BLE fail_part PARTITION OF hash_parted FOR VALUES WITH (MODU...
-                                                             ^
--- trying to specify range for the hash partitioned table
-CREATE TABLE fail_part PARTITION OF hash_parted FOR VALUES FROM ('a', 1) TO ('z');
-ERROR:  invalid bound specification for a hash partition
-LINE 1: ...BLE fail_part PARTITION OF hash_parted FOR VALUES FROM ('a',...
-                                                             ^
--- trying to specify list value for the hash partitioned table
-CREATE TABLE fail_part PARTITION OF hash_parted FOR VALUES IN (1000);
-ERROR:  invalid bound specification for a hash partition
-LINE 1: ...BLE fail_part PARTITION OF hash_parted FOR VALUES IN (1000);
-                                                             ^
--- trying to create default partition for the hash partitioned table
-CREATE TABLE fail_default_part PARTITION OF hash_parted DEFAULT;
-ERROR:  a hash-partitioned table may not have a default partition
--- check if compatible with the specified parent
--- cannot create as partition of a non-partitioned table
-CREATE TABLE unparted (
-	a int
-);
-CREATE TABLE fail_part PARTITION OF unparted FOR VALUES IN ('a');
-ERROR:  "unparted" is not partitioned
-CREATE TABLE fail_part PARTITION OF unparted FOR VALUES WITH (MODULUS 2, REMAINDER 1);
-ERROR:  "unparted" is not partitioned
-DROP TABLE unparted;
--- cannot create a permanent rel as partition of a temp rel
-CREATE TEMP TABLE temp_parted (
-	a int
-) PARTITION BY LIST (a);
-CREATE TABLE fail_part PARTITION OF temp_parted FOR VALUES IN ('a');
-ERROR:  cannot create a permanent relation as partition of temporary relation "temp_parted"
-DROP TABLE temp_parted;
--- check for partition bound overlap and other invalid specifications
-CREATE TABLE list_parted2 (
-	a varchar
-) PARTITION BY LIST (a);
-CREATE TABLE part_null_z PARTITION OF list_parted2 FOR VALUES IN (null, 'z');
-CREATE TABLE part_ab PARTITION OF list_parted2 FOR VALUES IN ('a', 'b');
-CREATE TABLE list_parted2_def PARTITION OF list_parted2 DEFAULT;
-CREATE TABLE fail_part PARTITION OF list_parted2 FOR VALUES IN (null);
-ERROR:  partition "fail_part" would overlap partition "part_null_z"
-LINE 1: ...LE fail_part PARTITION OF list_parted2 FOR VALUES IN (null);
-                                                                 ^
-CREATE TABLE fail_part PARTITION OF list_parted2 FOR VALUES IN ('b', 'c');
-ERROR:  partition "fail_part" would overlap partition "part_ab"
-LINE 1: ...ail_part PARTITION OF list_parted2 FOR VALUES IN ('b', 'c');
-                                                             ^
--- check default partition overlap
-INSERT INTO list_parted2 VALUES('X');
-CREATE TABLE fail_part PARTITION OF list_parted2 FOR VALUES IN ('W', 'X', 'Y');
-ERROR:  updated partition constraint for default partition "list_parted2_def" would be violated by some row
-CREATE TABLE range_parted2 (
-	a int
-) PARTITION BY RANGE (a);
--- trying to create range partition with empty range
-CREATE TABLE fail_part PARTITION OF range_parted2 FOR VALUES FROM (1) TO (0);
-ERROR:  empty range bound specified for partition "fail_part"
-LINE 1: ..._part PARTITION OF range_parted2 FOR VALUES FROM (1) TO (0);
-                                                             ^
-DETAIL:  Specified lower bound (1) is greater than or equal to upper bound (0).
--- note that the range '[1, 1)' has no elements
-CREATE TABLE fail_part PARTITION OF range_parted2 FOR VALUES FROM (1) TO (1);
-ERROR:  empty range bound specified for partition "fail_part"
-LINE 1: ..._part PARTITION OF range_parted2 FOR VALUES FROM (1) TO (1);
-                                                             ^
-DETAIL:  Specified lower bound (1) is greater than or equal to upper bound (1).
-CREATE TABLE part0 PARTITION OF range_parted2 FOR VALUES FROM (minvalue) TO (1);
-CREATE TABLE fail_part PARTITION OF range_parted2 FOR VALUES FROM (minvalue) TO (2);
-ERROR:  partition "fail_part" would overlap partition "part0"
-LINE 1: ..._part PARTITION OF range_parted2 FOR VALUES FROM (minvalue) ...
-                                                             ^
-CREATE TABLE part1 PARTITION OF range_parted2 FOR VALUES FROM (1) TO (10);
-CREATE TABLE fail_part PARTITION OF range_parted2 FOR VALUES FROM (-1) TO (1);
-ERROR:  partition "fail_part" would overlap partition "part0"
-LINE 1: ..._part PARTITION OF range_parted2 FOR VALUES FROM (-1) TO (1)...
-                                                             ^
-CREATE TABLE fail_part PARTITION OF range_parted2 FOR VALUES FROM (9) TO (maxvalue);
-ERROR:  partition "fail_part" would overlap partition "part1"
-LINE 1: ..._part PARTITION OF range_parted2 FOR VALUES FROM (9) TO (max...
-                                                             ^
-CREATE TABLE part2 PARTITION OF range_parted2 FOR VALUES FROM (20) TO (30);
-CREATE TABLE part3 PARTITION OF range_parted2 FOR VALUES FROM (30) TO (40);
-CREATE TABLE fail_part PARTITION OF range_parted2 FOR VALUES FROM (10) TO (30);
-ERROR:  partition "fail_part" would overlap partition "part2"
-LINE 1: ...art PARTITION OF range_parted2 FOR VALUES FROM (10) TO (30);
-                                                                   ^
-CREATE TABLE fail_part PARTITION OF range_parted2 FOR VALUES FROM (10) TO (50);
-ERROR:  partition "fail_part" would overlap partition "part2"
-LINE 1: ...art PARTITION OF range_parted2 FOR VALUES FROM (10) TO (50);
-                                                                   ^
--- Create a default partition for range partitioned table
-CREATE TABLE range2_default PARTITION OF range_parted2 DEFAULT;
--- More than one default partition is not allowed, so this should give error
-CREATE TABLE fail_default_part PARTITION OF range_parted2 DEFAULT;
-ERROR:  partition "fail_default_part" conflicts with existing default partition "range2_default"
-LINE 1: ... TABLE fail_default_part PARTITION OF range_parted2 DEFAULT;
-                                                               ^
--- Check if the range for default partitions overlap
-INSERT INTO range_parted2 VALUES (85);
-CREATE TABLE fail_part PARTITION OF range_parted2 FOR VALUES FROM (80) TO (90);
-ERROR:  updated partition constraint for default partition "range2_default" would be violated by some row
-CREATE TABLE part4 PARTITION OF range_parted2 FOR VALUES FROM (90) TO (100);
--- now check for multi-column range partition key
-CREATE TABLE range_parted3 (
-	a int,
-	b int
-) PARTITION BY RANGE (a, (b+1));
-CREATE TABLE part00 PARTITION OF range_parted3 FOR VALUES FROM (0, minvalue) TO (0, maxvalue);
-CREATE TABLE fail_part PARTITION OF range_parted3 FOR VALUES FROM (0, minvalue) TO (0, 1);
-ERROR:  partition "fail_part" would overlap partition "part00"
-LINE 1: ..._part PARTITION OF range_parted3 FOR VALUES FROM (0, minvalu...
-                                                             ^
-CREATE TABLE part10 PARTITION OF range_parted3 FOR VALUES FROM (1, minvalue) TO (1, 1);
-CREATE TABLE part11 PARTITION OF range_parted3 FOR VALUES FROM (1, 1) TO (1, 10);
-CREATE TABLE part12 PARTITION OF range_parted3 FOR VALUES FROM (1, 10) TO (1, maxvalue);
-CREATE TABLE fail_part PARTITION OF range_parted3 FOR VALUES FROM (1, 10) TO (1, 20);
-ERROR:  partition "fail_part" would overlap partition "part12"
-LINE 1: ...rt PARTITION OF range_parted3 FOR VALUES FROM (1, 10) TO (1,...
-                                                             ^
-CREATE TABLE range3_default PARTITION OF range_parted3 DEFAULT;
--- cannot create a partition that says column b is allowed to range
--- from -infinity to +infinity, while there exist partitions that have
--- more specific ranges
-CREATE TABLE fail_part PARTITION OF range_parted3 FOR VALUES FROM (1, minvalue) TO (1, maxvalue);
-ERROR:  partition "fail_part" would overlap partition "part10"
-LINE 1: ..._part PARTITION OF range_parted3 FOR VALUES FROM (1, minvalu...
-                                                             ^
--- check for partition bound overlap and other invalid specifications for the hash partition
-CREATE TABLE hash_parted2 (
-	a varchar
-) PARTITION BY HASH (a);
-CREATE TABLE h2part_1 PARTITION OF hash_parted2 FOR VALUES WITH (MODULUS 4, REMAINDER 2);
-CREATE TABLE h2part_2 PARTITION OF hash_parted2 FOR VALUES WITH (MODULUS 8, REMAINDER 0);
-CREATE TABLE h2part_3 PARTITION OF hash_parted2 FOR VALUES WITH (MODULUS 8, REMAINDER 4);
-CREATE TABLE h2part_4 PARTITION OF hash_parted2 FOR VALUES WITH (MODULUS 8, REMAINDER 5);
--- overlap with part_4
-CREATE TABLE fail_part PARTITION OF hash_parted2 FOR VALUES WITH (MODULUS 2, REMAINDER 1);
-ERROR:  partition "fail_part" would overlap partition "h2part_4"
-LINE 1: ...LE fail_part PARTITION OF hash_parted2 FOR VALUES WITH (MODU...
-                                                             ^
--- modulus must be greater than zero
-CREATE TABLE fail_part PARTITION OF hash_parted2 FOR VALUES WITH (MODULUS 0, REMAINDER 1);
-ERROR:  modulus for hash partition must be an integer value greater than zero
--- remainder must be greater than or equal to zero and less than modulus
-CREATE TABLE fail_part PARTITION OF hash_parted2 FOR VALUES WITH (MODULUS 8, REMAINDER 8);
-ERROR:  remainder for hash partition must be less than modulus
--- check schema propagation from parent
-CREATE TABLE parted (
-	a text,
-	b int NOT NULL DEFAULT 0,
-	CONSTRAINT check_a CHECK (length(a) > 0)
-) PARTITION BY LIST (a);
-CREATE TABLE part_a PARTITION OF parted FOR VALUES IN ('a');
--- only inherited attributes (never local ones)
-SELECT attname, attislocal, attinhcount FROM pg_attribute
-  WHERE attrelid = 'part_a'::regclass and attnum > 0
-  ORDER BY attnum;
- attname | attislocal | attinhcount 
----------+------------+-------------
- a       | f          |           1
- b       | f          |           1
-(2 rows)
-
--- able to specify column default, column constraint, and table constraint
--- first check the "column specified more than once" error
-CREATE TABLE part_b PARTITION OF parted (
-	b NOT NULL,
-	b DEFAULT 1,
-	b CHECK (b >= 0),
-	CONSTRAINT check_a CHECK (length(a) > 0)
-) FOR VALUES IN ('b');
-ERROR:  column "b" specified more than once
-CREATE TABLE part_b PARTITION OF parted (
-	b NOT NULL DEFAULT 1,
-	CONSTRAINT check_a CHECK (length(a) > 0),
-	CONSTRAINT check_b CHECK (b >= 0)
-) FOR VALUES IN ('b');
-NOTICE:  merging constraint "check_a" with inherited definition
--- conislocal should be false for any merged constraints, true otherwise
-SELECT conislocal, coninhcount FROM pg_constraint WHERE conrelid = 'part_b'::regclass ORDER BY conislocal, coninhcount;
- conislocal | coninhcount 
-------------+-------------
- f          |           1
- t          |           0
-(2 rows)
-
--- Once check_b is added to the parent, it should be made non-local for part_b
-ALTER TABLE parted ADD CONSTRAINT check_b CHECK (b >= 0);
-NOTICE:  merging constraint "check_b" with inherited definition
-SELECT conislocal, coninhcount FROM pg_constraint WHERE conrelid = 'part_b'::regclass;
- conislocal | coninhcount 
-------------+-------------
- f          |           1
- f          |           1
-(2 rows)
-
--- Neither check_a nor check_b are droppable from part_b
-ALTER TABLE part_b DROP CONSTRAINT check_a;
-ERROR:  cannot drop inherited constraint "check_a" of relation "part_b"
-ALTER TABLE part_b DROP CONSTRAINT check_b;
-ERROR:  cannot drop inherited constraint "check_b" of relation "part_b"
--- And dropping it from parted should leave no trace of them on part_b, unlike
--- traditional inheritance where they will be left behind, because they would
--- be local constraints.
-ALTER TABLE parted DROP CONSTRAINT check_a, DROP CONSTRAINT check_b;
-SELECT conislocal, coninhcount FROM pg_constraint WHERE conrelid = 'part_b'::regclass;
- conislocal | coninhcount 
-------------+-------------
-(0 rows)
-
--- specify PARTITION BY for a partition
-CREATE TABLE fail_part_col_not_found PARTITION OF parted FOR VALUES IN ('c') PARTITION BY RANGE (c);
-ERROR:  column "c" named in partition key does not exist
-LINE 1: ...TITION OF parted FOR VALUES IN ('c') PARTITION BY RANGE (c);
-                                                                    ^
-CREATE TABLE part_c PARTITION OF parted (b WITH OPTIONS NOT NULL DEFAULT 0) FOR VALUES IN ('c') PARTITION BY RANGE ((b));
--- create a level-2 partition
-CREATE TABLE part_c_1_10 PARTITION OF part_c FOR VALUES FROM (1) TO (10);
--- check that NOT NULL and default value are inherited correctly
-create table parted_notnull_inh_test (a int default 1, b int not null default 0) partition by list (a);
-create table parted_notnull_inh_test1 partition of parted_notnull_inh_test (a not null, b default 1) for values in (1);
-insert into parted_notnull_inh_test (b) values (null);
-ERROR:  null value in column "b" of relation "parted_notnull_inh_test1" violates not-null constraint
-DETAIL:  Failing row contains (1, null).
--- note that while b's default is overriden, a's default is preserved
-\d parted_notnull_inh_test1
-      Table "public.parted_notnull_inh_test1"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           | not null | 1
- b      | integer |           | not null | 1
-Partition of: parted_notnull_inh_test FOR VALUES IN (1)
-
-drop table parted_notnull_inh_test;
--- check that collations are assigned in partition bound expressions
-create table parted_boolean_col (a bool, b text) partition by list(a);
-create table parted_boolean_less partition of parted_boolean_col
-  for values in ('foo' < 'bar');
-create table parted_boolean_greater partition of parted_boolean_col
-  for values in ('foo' > 'bar');
-drop table parted_boolean_col;
--- check for a conflicting COLLATE clause
-create table parted_collate_must_match (a text collate "C", b text collate "C")
-  partition by range (a);
--- on the partition key
-create table parted_collate_must_match1 partition of parted_collate_must_match
-  (a collate "POSIX") for values from ('a') to ('m');
--- on another column
-create table parted_collate_must_match2 partition of parted_collate_must_match
-  (b collate "POSIX") for values from ('m') to ('z');
-drop table parted_collate_must_match;
--- check that non-matching collations for partition bound
--- expressions are coerced to the right collation
-create table test_part_coll_posix (a text) partition by range (a collate "POSIX");
--- ok, collation is implicitly coerced
-create table test_part_coll partition of test_part_coll_posix for values from ('a' collate "C") to ('g');
--- ok
-create table test_part_coll2 partition of test_part_coll_posix for values from ('g') to ('m');
--- ok, collation is implicitly coerced
-create table test_part_coll_cast partition of test_part_coll_posix for values from (name 'm' collate "C") to ('s');
--- ok; partition collation silently overrides the default collation of type 'name'
-create table test_part_coll_cast2 partition of test_part_coll_posix for values from (name 's') to ('z');
-drop table test_part_coll_posix;
--- Partition bound in describe output
-\d+ part_b
-                                   Table "public.part_b"
- Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
---------+---------+-----------+----------+---------+----------+--------------+-------------
- a      | text    |           |          |         | extended |              | 
- b      | integer |           | not null | 1       | plain    |              | 
-Partition of: parted FOR VALUES IN ('b')
-Partition constraint: ((a IS NOT NULL) AND (a = 'b'::text))
-
--- Both partition bound and partition key in describe output
-\d+ part_c
-                             Partitioned table "public.part_c"
- Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
---------+---------+-----------+----------+---------+----------+--------------+-------------
- a      | text    |           |          |         | extended |              | 
- b      | integer |           | not null | 0       | plain    |              | 
-Partition of: parted FOR VALUES IN ('c')
-Partition constraint: ((a IS NOT NULL) AND (a = 'c'::text))
-Partition key: RANGE (b)
-Partitions: part_c_1_10 FOR VALUES FROM (1) TO (10)
-
--- a level-2 partition's constraint will include the parent's expressions
-\d+ part_c_1_10
-                                Table "public.part_c_1_10"
- Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
---------+---------+-----------+----------+---------+----------+--------------+-------------
- a      | text    |           |          |         | extended |              | 
- b      | integer |           | not null | 0       | plain    |              | 
-Partition of: part_c FOR VALUES FROM (1) TO (10)
-Partition constraint: ((a IS NOT NULL) AND (a = 'c'::text) AND (b IS NOT NULL) AND (b >= 1) AND (b < 10))
-
--- Show partition count in the parent's describe output
--- Tempted to include \d+ output listing partitions with bound info but
--- output could vary depending on the order in which partition oids are
--- returned.
-\d parted
-         Partitioned table "public.parted"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | text    |           |          | 
- b      | integer |           | not null | 0
-Partition key: LIST (a)
-Number of partitions: 3 (Use \d+ to list them.)
-
-\d hash_parted
-      Partitioned table "public.hash_parted"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
-Partition key: HASH (a)
-Number of partitions: 4 (Use \d+ to list them.)
-
--- check that we get the expected partition constraints
-CREATE TABLE range_parted4 (a int, b int, c int) PARTITION BY RANGE (abs(a), abs(b), c);
-CREATE TABLE unbounded_range_part PARTITION OF range_parted4 FOR VALUES FROM (MINVALUE, MINVALUE, MINVALUE) TO (MAXVALUE, MAXVALUE, MAXVALUE);
-\d+ unbounded_range_part
-                           Table "public.unbounded_range_part"
- Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
---------+---------+-----------+----------+---------+---------+--------------+-------------
- a      | integer |           |          |         | plain   |              | 
- b      | integer |           |          |         | plain   |              | 
- c      | integer |           |          |         | plain   |              | 
-Partition of: range_parted4 FOR VALUES FROM (MINVALUE, MINVALUE, MINVALUE) TO (MAXVALUE, MAXVALUE, MAXVALUE)
-Partition constraint: ((abs(a) IS NOT NULL) AND (abs(b) IS NOT NULL) AND (c IS NOT NULL))
-
-DROP TABLE unbounded_range_part;
-CREATE TABLE range_parted4_1 PARTITION OF range_parted4 FOR VALUES FROM (MINVALUE, MINVALUE, MINVALUE) TO (1, MAXVALUE, MAXVALUE);
-\d+ range_parted4_1
-                              Table "public.range_parted4_1"
- Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
---------+---------+-----------+----------+---------+---------+--------------+-------------
- a      | integer |           |          |         | plain   |              | 
- b      | integer |           |          |         | plain   |              | 
- c      | integer |           |          |         | plain   |              | 
-Partition of: range_parted4 FOR VALUES FROM (MINVALUE, MINVALUE, MINVALUE) TO (1, MAXVALUE, MAXVALUE)
-Partition constraint: ((abs(a) IS NOT NULL) AND (abs(b) IS NOT NULL) AND (c IS NOT NULL) AND (abs(a) <= 1))
-
-CREATE TABLE range_parted4_2 PARTITION OF range_parted4 FOR VALUES FROM (3, 4, 5) TO (6, 7, MAXVALUE);
-\d+ range_parted4_2
-                              Table "public.range_parted4_2"
- Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
---------+---------+-----------+----------+---------+---------+--------------+-------------
- a      | integer |           |          |         | plain   |              | 
- b      | integer |           |          |         | plain   |              | 
- c      | integer |           |          |         | plain   |              | 
-Partition of: range_parted4 FOR VALUES FROM (3, 4, 5) TO (6, 7, MAXVALUE)
-Partition constraint: ((abs(a) IS NOT NULL) AND (abs(b) IS NOT NULL) AND (c IS NOT NULL) AND ((abs(a) > 3) OR ((abs(a) = 3) AND (abs(b) > 4)) OR ((abs(a) = 3) AND (abs(b) = 4) AND (c >= 5))) AND ((abs(a) < 6) OR ((abs(a) = 6) AND (abs(b) <= 7))))
-
-CREATE TABLE range_parted4_3 PARTITION OF range_parted4 FOR VALUES FROM (6, 8, MINVALUE) TO (9, MAXVALUE, MAXVALUE);
-\d+ range_parted4_3
-                              Table "public.range_parted4_3"
- Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
---------+---------+-----------+----------+---------+---------+--------------+-------------
- a      | integer |           |          |         | plain   |              | 
- b      | integer |           |          |         | plain   |              | 
- c      | integer |           |          |         | plain   |              | 
-Partition of: range_parted4 FOR VALUES FROM (6, 8, MINVALUE) TO (9, MAXVALUE, MAXVALUE)
-Partition constraint: ((abs(a) IS NOT NULL) AND (abs(b) IS NOT NULL) AND (c IS NOT NULL) AND ((abs(a) > 6) OR ((abs(a) = 6) AND (abs(b) >= 8))) AND (abs(a) <= 9))
-
-DROP TABLE range_parted4;
--- user-defined operator class in partition key
-CREATE FUNCTION my_int4_sort(int4,int4) RETURNS int LANGUAGE sql
-  AS $$ SELECT CASE WHEN $1 = $2 THEN 0 WHEN $1 > $2 THEN 1 ELSE -1 END; $$;
-CREATE OPERATOR CLASS test_int4_ops FOR TYPE int4 USING btree AS
-  OPERATOR 1 < (int4,int4), OPERATOR 2 <= (int4,int4),
-  OPERATOR 3 = (int4,int4), OPERATOR 4 >= (int4,int4),
-  OPERATOR 5 > (int4,int4), FUNCTION 1 my_int4_sort(int4,int4);
-CREATE TABLE partkey_t (a int4) PARTITION BY RANGE (a test_int4_ops);
-CREATE TABLE partkey_t_1 PARTITION OF partkey_t FOR VALUES FROM (0) TO (1000);
-INSERT INTO partkey_t VALUES (100);
-INSERT INTO partkey_t VALUES (200);
--- cleanup
-DROP TABLE parted, list_parted, range_parted, list_parted2, range_parted2, range_parted3;
-DROP TABLE partkey_t, hash_parted, hash_parted2;
-DROP OPERATOR CLASS test_int4_ops USING btree;
-DROP FUNCTION my_int4_sort(int4,int4);
--- comments on partitioned tables columns
-CREATE TABLE parted_col_comment (a int, b text) PARTITION BY LIST (a);
-COMMENT ON TABLE parted_col_comment IS 'Am partitioned table';
-COMMENT ON COLUMN parted_col_comment.a IS 'Partition key';
-SELECT obj_description('parted_col_comment'::regclass);
-   obj_description    
-----------------------
- Am partitioned table
-(1 row)
-
-\d+ parted_col_comment
-                        Partitioned table "public.parted_col_comment"
- Column |  Type   | Collation | Nullable | Default | Storage  | Stats target |  Description  
---------+---------+-----------+----------+---------+----------+--------------+---------------
- a      | integer |           |          |         | plain    |              | Partition key
- b      | text    |           |          |         | extended |              | 
-Partition key: LIST (a)
-Number of partitions: 0
-
-DROP TABLE parted_col_comment;
--- list partitioning on array type column
-CREATE TABLE arrlp (a int[]) PARTITION BY LIST (a);
-CREATE TABLE arrlp12 PARTITION OF arrlp FOR VALUES IN ('{1}', '{2}');
-\d+ arrlp12
-                                   Table "public.arrlp12"
- Column |   Type    | Collation | Nullable | Default | Storage  | Stats target | Description 
---------+-----------+-----------+----------+---------+----------+--------------+-------------
- a      | integer[] |           |          |         | extended |              | 
-Partition of: arrlp FOR VALUES IN ('{1}', '{2}')
-Partition constraint: ((a IS NOT NULL) AND ((a = '{1}'::integer[]) OR (a = '{2}'::integer[])))
-
-DROP TABLE arrlp;
--- partition on boolean column
-create table boolspart (a bool) partition by list (a);
-create table boolspart_t partition of boolspart for values in (true);
-create table boolspart_f partition of boolspart for values in (false);
-\d+ boolspart
-                           Partitioned table "public.boolspart"
- Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
---------+---------+-----------+----------+---------+---------+--------------+-------------
- a      | boolean |           |          |         | plain   |              | 
-Partition key: LIST (a)
-Partitions: boolspart_f FOR VALUES IN (false),
-            boolspart_t FOR VALUES IN (true)
-
-drop table boolspart;
--- partitions mixing temporary and permanent relations
-create table perm_parted (a int) partition by list (a);
-create temporary table temp_parted (a int) partition by list (a);
-create table perm_part partition of temp_parted default; -- error
-ERROR:  cannot create a permanent relation as partition of temporary relation "temp_parted"
-create temp table temp_part partition of perm_parted default; -- error
-ERROR:  cannot create a temporary relation as partition of permanent relation "perm_parted"
-create temp table temp_part partition of temp_parted default; -- ok
-drop table perm_parted cascade;
-drop table temp_parted cascade;
--- check that adding partitions to a table while it is being used is prevented
-create table tab_part_create (a int) partition by list (a);
-create or replace function func_part_create() returns trigger
-  language plpgsql as $$
-  begin
-    execute 'create table tab_part_create_1 partition of tab_part_create for values in (1)';
-    return null;
-  end $$;
-create trigger trig_part_create before insert on tab_part_create
-  for each statement execute procedure func_part_create();
-insert into tab_part_create values (1);
-ERROR:  cannot CREATE TABLE .. PARTITION OF "tab_part_create" because it is being used by active queries in this session
-CONTEXT:  SQL statement "create table tab_part_create_1 partition of tab_part_create for values in (1)"
-PL/pgSQL function func_part_create() line 3 at EXECUTE
-drop table tab_part_create;
-drop function func_part_create();
--- test using a volatile expression as partition bound
-create table volatile_partbound_test (partkey timestamp) partition by range (partkey);
-create table volatile_partbound_test1 partition of volatile_partbound_test for values from (minvalue) to (current_timestamp);
-create table volatile_partbound_test2 partition of volatile_partbound_test for values from (current_timestamp) to (maxvalue);
--- this should go into the partition volatile_partbound_test2
-insert into volatile_partbound_test values (current_timestamp);
-select tableoid::regclass from volatile_partbound_test;
-         tableoid         
---------------------------
- volatile_partbound_test2
-(1 row)
-
-drop table volatile_partbound_test;
--- test the case where a check constraint on default partition allows
--- to avoid scanning it when adding a new partition
-create table defcheck (a int, b int) partition by list (b);
-create table defcheck_def (a int, c int, b int);
-alter table defcheck_def drop c;
-alter table defcheck attach partition defcheck_def default;
-alter table defcheck_def add check (b <= 0 and b is not null);
-create table defcheck_1 partition of defcheck for values in (1, null);
--- test that complex default partition constraints are enforced correctly
-insert into defcheck_def values (0, 0);
-create table defcheck_0 partition of defcheck for values in (0);
-ERROR:  updated partition constraint for default partition "defcheck_def" would be violated by some row
-drop table defcheck;
--- tests of column drop with partition tables and indexes using
--- predicates and expressions.
-create table part_column_drop (
-  useless_1 int,
-  id int,
-  useless_2 int,
-  d int,
-  b int,
-  useless_3 int
-) partition by range (id);
-alter table part_column_drop drop column useless_1;
-alter table part_column_drop drop column useless_2;
-alter table part_column_drop drop column useless_3;
-create index part_column_drop_b_pred on part_column_drop(b) where b = 1;
-create index part_column_drop_b_expr on part_column_drop((b = 1));
-create index part_column_drop_d_pred on part_column_drop(d) where d = 2;
-create index part_column_drop_d_expr on part_column_drop((d = 2));
-create table part_column_drop_1_10 partition of
-  part_column_drop for values from (1) to (10);
-\d part_column_drop
-    Partitioned table "public.part_column_drop"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- id     | integer |           |          | 
- d      | integer |           |          | 
- b      | integer |           |          | 
-Partition key: RANGE (id)
-Indexes:
-    "part_column_drop_b_expr" btree ((b = 1))
-    "part_column_drop_b_pred" btree (b) WHERE b = 1
-    "part_column_drop_d_expr" btree ((d = 2))
-    "part_column_drop_d_pred" btree (d) WHERE d = 2
-Number of partitions: 1 (Use \d+ to list them.)
-
-\d part_column_drop_1_10
-       Table "public.part_column_drop_1_10"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- id     | integer |           |          | 
- d      | integer |           |          | 
- b      | integer |           |          | 
-Partition of: part_column_drop FOR VALUES FROM (1) TO (10)
-Indexes:
-    "part_column_drop_1_10_b_idx" btree (b) WHERE b = 1
-    "part_column_drop_1_10_d_idx" btree (d) WHERE d = 2
-    "part_column_drop_1_10_expr_idx" btree ((b = 1))
-    "part_column_drop_1_10_expr_idx1" btree ((d = 2))
-
-drop table part_column_drop;
diff -U3 /Users/kenaniah/workspace/postgres/src/test/regress/expected/copyselect.out /Users/kenaniah/workspace/postgres/src/test/regress/results/copyselect.out
--- /Users/kenaniah/workspace/postgres/src/test/regress/expected/copyselect.out	2021-10-03 17:41:49.000000000 -0700
+++ /Users/kenaniah/workspace/postgres/src/test/regress/results/copyselect.out	2021-10-03 20:08:12.000000000 -0700
@@ -113,39 +113,11 @@
 -- Test \copy (select ...)
 --
 \copy (select "id",'id','id""'||t,(id + 1)*id,t,"test1"."t" from test1 where id=3) to stdout
-3	id	id""c	12	c	c
---
--- Drop everything
---
-drop table test2;
-drop view v_test1;
-drop table test1;
--- psql handling of COPY in multi-command strings
-copy (select 1) to stdout\; select 1/0;	-- row, then error
-1
-ERROR:  division by zero
-select 1/0\; copy (select 1) to stdout; -- error only
-ERROR:  division by zero
-copy (select 1) to stdout\; copy (select 2) to stdout\; select 0\; select 3; -- 1 2 3
-1
-2
- ?column? 
-----------
-        3
-(1 row)
-
-create table test3 (c int);
-select 0\; copy test3 from stdin\; copy test3 from stdin\; select 1; -- 1
- ?column? 
-----------
-        1
-(1 row)
+dyld: lazy symbol binding failed: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
 
-select * from test3;
- c 
----
- 1
- 2
-(2 rows)
+dyld: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
 
-drop table test3;
diff -U3 /Users/kenaniah/workspace/postgres/src/test/regress/expected/copydml.out /Users/kenaniah/workspace/postgres/src/test/regress/results/copydml.out
--- /Users/kenaniah/workspace/postgres/src/test/regress/expected/copydml.out	2021-10-03 17:41:49.000000000 -0700
+++ /Users/kenaniah/workspace/postgres/src/test/regress/results/copydml.out	2021-10-03 20:08:12.000000000 -0700
@@ -20,93 +20,11 @@
 -- Test \copy (insert/update/delete ...)
 --
 \copy (insert into copydml_test (t) values ('f') returning id) to stdout;
-7
-\copy (update copydml_test set t = 'g' where t = 'f' returning id) to stdout;
-7
-\copy (delete from copydml_test where t = 'g' returning id) to stdout;
-7
--- Error cases
-copy (insert into copydml_test default values) to stdout;
-ERROR:  COPY query must have a RETURNING clause
-copy (update copydml_test set t = 'g') to stdout;
-ERROR:  COPY query must have a RETURNING clause
-copy (delete from copydml_test) to stdout;
-ERROR:  COPY query must have a RETURNING clause
-create rule qqq as on insert to copydml_test do instead nothing;
-copy (insert into copydml_test default values) to stdout;
-ERROR:  DO INSTEAD NOTHING rules are not supported for COPY
-drop rule qqq on copydml_test;
-create rule qqq as on insert to copydml_test do also delete from copydml_test;
-copy (insert into copydml_test default values) to stdout;
-ERROR:  DO ALSO rules are not supported for the COPY
-drop rule qqq on copydml_test;
-create rule qqq as on insert to copydml_test do instead (delete from copydml_test; delete from copydml_test);
-copy (insert into copydml_test default values) to stdout;
-ERROR:  multi-statement DO INSTEAD rules are not supported for COPY
-drop rule qqq on copydml_test;
-create rule qqq as on insert to copydml_test where new.t <> 'f' do instead delete from copydml_test;
-copy (insert into copydml_test default values) to stdout;
-ERROR:  conditional DO INSTEAD rules are not supported for COPY
-drop rule qqq on copydml_test;
-create rule qqq as on update to copydml_test do instead nothing;
-copy (update copydml_test set t = 'f') to stdout;
-ERROR:  DO INSTEAD NOTHING rules are not supported for COPY
-drop rule qqq on copydml_test;
-create rule qqq as on update to copydml_test do also delete from copydml_test;
-copy (update copydml_test set t = 'f') to stdout;
-ERROR:  DO ALSO rules are not supported for the COPY
-drop rule qqq on copydml_test;
-create rule qqq as on update to copydml_test do instead (delete from copydml_test; delete from copydml_test);
-copy (update copydml_test set t = 'f') to stdout;
-ERROR:  multi-statement DO INSTEAD rules are not supported for COPY
-drop rule qqq on copydml_test;
-create rule qqq as on update to copydml_test where new.t <> 'f' do instead delete from copydml_test;
-copy (update copydml_test set t = 'f') to stdout;
-ERROR:  conditional DO INSTEAD rules are not supported for COPY
-drop rule qqq on copydml_test;
-create rule qqq as on delete to copydml_test do instead nothing;
-copy (delete from copydml_test) to stdout;
-ERROR:  DO INSTEAD NOTHING rules are not supported for COPY
-drop rule qqq on copydml_test;
-create rule qqq as on delete to copydml_test do also insert into copydml_test default values;
-copy (delete from copydml_test) to stdout;
-ERROR:  DO ALSO rules are not supported for the COPY
-drop rule qqq on copydml_test;
-create rule qqq as on delete to copydml_test do instead (insert into copydml_test default values; insert into copydml_test default values);
-copy (delete from copydml_test) to stdout;
-ERROR:  multi-statement DO INSTEAD rules are not supported for COPY
-drop rule qqq on copydml_test;
-create rule qqq as on delete to copydml_test where old.t <> 'f' do instead insert into copydml_test default values;
-copy (delete from copydml_test) to stdout;
-ERROR:  conditional DO INSTEAD rules are not supported for COPY
-drop rule qqq on copydml_test;
--- triggers
-create function qqq_trig() returns trigger as $$
-begin
-if tg_op in ('INSERT', 'UPDATE') then
-    raise notice '% % %', tg_when, tg_op, new.id;
-    return new;
-else
-    raise notice '% % %', tg_when, tg_op, old.id;
-    return old;
-end if;
-end
-$$ language plpgsql;
-create trigger qqqbef before insert or update or delete on copydml_test
-    for each row execute procedure qqq_trig();
-create trigger qqqaf after insert or update or delete on copydml_test
-    for each row execute procedure qqq_trig();
-copy (insert into copydml_test (t) values ('f') returning id) to stdout;
-NOTICE:  BEFORE INSERT 8
-8
-NOTICE:  AFTER INSERT 8
-copy (update copydml_test set t = 'g' where t = 'f' returning id) to stdout;
-NOTICE:  BEFORE UPDATE 8
-8
-NOTICE:  AFTER UPDATE 8
-copy (delete from copydml_test where t = 'g' returning id) to stdout;
-NOTICE:  BEFORE DELETE 8
-8
-NOTICE:  AFTER DELETE 8
-drop table copydml_test;
-drop function qqq_trig();
+dyld: lazy symbol binding failed: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
+
+dyld: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
+
diff -U3 /Users/kenaniah/workspace/postgres/src/test/regress/expected/insert.out /Users/kenaniah/workspace/postgres/src/test/regress/results/insert.out
--- /Users/kenaniah/workspace/postgres/src/test/regress/expected/insert.out	2021-10-03 17:41:49.000000000 -0700
+++ /Users/kenaniah/workspace/postgres/src/test/regress/results/insert.out	2021-10-03 20:08:12.000000000 -0700
@@ -163,842 +163,11 @@
   insert into inserttest (f4[1].if1, f4[1].if2[2])
   select new.f1, new.f2;
 \d+ inserttest2
-                                Table "public.inserttest2"
- Column |  Type  | Collation | Nullable | Default | Storage  | Stats target | Description 
---------+--------+-----------+----------+---------+----------+--------------+-------------
- f1     | bigint |           |          |         | plain    |              | 
- f2     | text   |           |          |         | extended |              | 
-Rules:
-    irule1 AS
-    ON INSERT TO inserttest2 DO  INSERT INTO inserttest (f3.if2[1], f3.if2[2])
-  VALUES (new.f1, new.f2)
-    irule2 AS
-    ON INSERT TO inserttest2 DO  INSERT INTO inserttest (f4[1].if1, f4[1].if2[2]) VALUES (1,'fool'::text), (new.f1,new.f2)
-    irule3 AS
-    ON INSERT TO inserttest2 DO  INSERT INTO inserttest (f4[1].if1, f4[1].if2[2])  SELECT new.f1,
-            new.f2
+dyld: lazy symbol binding failed: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
+
+dyld: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
 
-drop table inserttest2;
-drop table inserttest;
-drop type insert_test_type;
--- direct partition inserts should check partition bound constraint
-create table range_parted (
-	a text,
-	b int
-) partition by range (a, (b+0));
--- no partitions, so fail
-insert into range_parted values ('a', 11);
-ERROR:  no partition of relation "range_parted" found for row
-DETAIL:  Partition key of the failing row contains (a, (b + 0)) = (a, 11).
-create table part1 partition of range_parted for values from ('a', 1) to ('a', 10);
-create table part2 partition of range_parted for values from ('a', 10) to ('a', 20);
-create table part3 partition of range_parted for values from ('b', 1) to ('b', 10);
-create table part4 partition of range_parted for values from ('b', 10) to ('b', 20);
--- fail
-insert into part1 values ('a', 11);
-ERROR:  new row for relation "part1" violates partition constraint
-DETAIL:  Failing row contains (a, 11).
-insert into part1 values ('b', 1);
-ERROR:  new row for relation "part1" violates partition constraint
-DETAIL:  Failing row contains (b, 1).
--- ok
-insert into part1 values ('a', 1);
--- fail
-insert into part4 values ('b', 21);
-ERROR:  new row for relation "part4" violates partition constraint
-DETAIL:  Failing row contains (b, 21).
-insert into part4 values ('a', 10);
-ERROR:  new row for relation "part4" violates partition constraint
-DETAIL:  Failing row contains (a, 10).
--- ok
-insert into part4 values ('b', 10);
--- fail (partition key a has a NOT NULL constraint)
-insert into part1 values (null);
-ERROR:  new row for relation "part1" violates partition constraint
-DETAIL:  Failing row contains (null, null).
--- fail (expression key (b+0) cannot be null either)
-insert into part1 values (1);
-ERROR:  new row for relation "part1" violates partition constraint
-DETAIL:  Failing row contains (1, null).
-create table list_parted (
-	a text,
-	b int
-) partition by list (lower(a));
-create table part_aa_bb partition of list_parted FOR VALUES IN ('aa', 'bb');
-create table part_cc_dd partition of list_parted FOR VALUES IN ('cc', 'dd');
-create table part_null partition of list_parted FOR VALUES IN (null);
--- fail
-insert into part_aa_bb values ('cc', 1);
-ERROR:  new row for relation "part_aa_bb" violates partition constraint
-DETAIL:  Failing row contains (cc, 1).
-insert into part_aa_bb values ('AAa', 1);
-ERROR:  new row for relation "part_aa_bb" violates partition constraint
-DETAIL:  Failing row contains (AAa, 1).
-insert into part_aa_bb values (null);
-ERROR:  new row for relation "part_aa_bb" violates partition constraint
-DETAIL:  Failing row contains (null, null).
--- ok
-insert into part_cc_dd values ('cC', 1);
-insert into part_null values (null, 0);
--- check in case of multi-level partitioned table
-create table part_ee_ff partition of list_parted for values in ('ee', 'ff') partition by range (b);
-create table part_ee_ff1 partition of part_ee_ff for values from (1) to (10);
-create table part_ee_ff2 partition of part_ee_ff for values from (10) to (20);
--- test default partition
-create table part_default partition of list_parted default;
--- Negative test: a row, which would fit in other partition, does not fit
--- default partition, even when inserted directly
-insert into part_default values ('aa', 2);
-ERROR:  new row for relation "part_default" violates partition constraint
-DETAIL:  Failing row contains (aa, 2).
-insert into part_default values (null, 2);
-ERROR:  new row for relation "part_default" violates partition constraint
-DETAIL:  Failing row contains (null, 2).
--- ok
-insert into part_default values ('Zz', 2);
--- test if default partition works as expected for multi-level partitioned
--- table as well as when default partition itself is further partitioned
-drop table part_default;
-create table part_xx_yy partition of list_parted for values in ('xx', 'yy') partition by list (a);
-create table part_xx_yy_p1 partition of part_xx_yy for values in ('xx');
-create table part_xx_yy_defpart partition of part_xx_yy default;
-create table part_default partition of list_parted default partition by range(b);
-create table part_default_p1 partition of part_default for values from (20) to (30);
-create table part_default_p2 partition of part_default for values from (30) to (40);
--- fail
-insert into part_ee_ff1 values ('EE', 11);
-ERROR:  new row for relation "part_ee_ff1" violates partition constraint
-DETAIL:  Failing row contains (EE, 11).
-insert into part_default_p2 values ('gg', 43);
-ERROR:  new row for relation "part_default_p2" violates partition constraint
-DETAIL:  Failing row contains (gg, 43).
--- fail (even the parent's, ie, part_ee_ff's partition constraint applies)
-insert into part_ee_ff1 values ('cc', 1);
-ERROR:  new row for relation "part_ee_ff1" violates partition constraint
-DETAIL:  Failing row contains (cc, 1).
-insert into part_default values ('gg', 43);
-ERROR:  no partition of relation "part_default" found for row
-DETAIL:  Partition key of the failing row contains (b) = (43).
--- ok
-insert into part_ee_ff1 values ('ff', 1);
-insert into part_ee_ff2 values ('ff', 11);
-insert into part_default_p1 values ('cd', 25);
-insert into part_default_p2 values ('de', 35);
-insert into list_parted values ('ab', 21);
-insert into list_parted values ('xx', 1);
-insert into list_parted values ('yy', 2);
-select tableoid::regclass, * from list_parted;
-      tableoid      | a  | b  
---------------------+----+----
- part_cc_dd         | cC |  1
- part_ee_ff1        | ff |  1
- part_ee_ff2        | ff | 11
- part_xx_yy_p1      | xx |  1
- part_xx_yy_defpart | yy |  2
- part_null          |    |  0
- part_default_p1    | cd | 25
- part_default_p1    | ab | 21
- part_default_p2    | de | 35
-(9 rows)
-
--- Check tuple routing for partitioned tables
--- fail
-insert into range_parted values ('a', 0);
-ERROR:  no partition of relation "range_parted" found for row
-DETAIL:  Partition key of the failing row contains (a, (b + 0)) = (a, 0).
--- ok
-insert into range_parted values ('a', 1);
-insert into range_parted values ('a', 10);
--- fail
-insert into range_parted values ('a', 20);
-ERROR:  no partition of relation "range_parted" found for row
-DETAIL:  Partition key of the failing row contains (a, (b + 0)) = (a, 20).
--- ok
-insert into range_parted values ('b', 1);
-insert into range_parted values ('b', 10);
--- fail (partition key (b+0) is null)
-insert into range_parted values ('a');
-ERROR:  no partition of relation "range_parted" found for row
-DETAIL:  Partition key of the failing row contains (a, (b + 0)) = (a, null).
--- Check default partition
-create table part_def partition of range_parted default;
--- fail
-insert into part_def values ('b', 10);
-ERROR:  new row for relation "part_def" violates partition constraint
-DETAIL:  Failing row contains (b, 10).
--- ok
-insert into part_def values ('c', 10);
-insert into range_parted values (null, null);
-insert into range_parted values ('a', null);
-insert into range_parted values (null, 19);
-insert into range_parted values ('b', 20);
-select tableoid::regclass, * from range_parted;
- tableoid | a | b  
-----------+---+----
- part1    | a |  1
- part1    | a |  1
- part2    | a | 10
- part3    | b |  1
- part4    | b | 10
- part4    | b | 10
- part_def | c | 10
- part_def |   |   
- part_def | a |   
- part_def |   | 19
- part_def | b | 20
-(11 rows)
-
--- ok
-insert into list_parted values (null, 1);
-insert into list_parted (a) values ('aA');
--- fail (partition of part_ee_ff not found in both cases)
-insert into list_parted values ('EE', 0);
-ERROR:  no partition of relation "part_ee_ff" found for row
-DETAIL:  Partition key of the failing row contains (b) = (0).
-insert into part_ee_ff values ('EE', 0);
-ERROR:  no partition of relation "part_ee_ff" found for row
-DETAIL:  Partition key of the failing row contains (b) = (0).
--- ok
-insert into list_parted values ('EE', 1);
-insert into part_ee_ff values ('EE', 10);
-select tableoid::regclass, * from list_parted;
-      tableoid      | a  | b  
---------------------+----+----
- part_aa_bb         | aA |   
- part_cc_dd         | cC |  1
- part_ee_ff1        | ff |  1
- part_ee_ff1        | EE |  1
- part_ee_ff2        | ff | 11
- part_ee_ff2        | EE | 10
- part_xx_yy_p1      | xx |  1
- part_xx_yy_defpart | yy |  2
- part_null          |    |  0
- part_null          |    |  1
- part_default_p1    | cd | 25
- part_default_p1    | ab | 21
- part_default_p2    | de | 35
-(13 rows)
-
--- some more tests to exercise tuple-routing with multi-level partitioning
-create table part_gg partition of list_parted for values in ('gg') partition by range (b);
-create table part_gg1 partition of part_gg for values from (minvalue) to (1);
-create table part_gg2 partition of part_gg for values from (1) to (10) partition by range (b);
-create table part_gg2_1 partition of part_gg2 for values from (1) to (5);
-create table part_gg2_2 partition of part_gg2 for values from (5) to (10);
-create table part_ee_ff3 partition of part_ee_ff for values from (20) to (30) partition by range (b);
-create table part_ee_ff3_1 partition of part_ee_ff3 for values from (20) to (25);
-create table part_ee_ff3_2 partition of part_ee_ff3 for values from (25) to (30);
-truncate list_parted;
-insert into list_parted values ('aa'), ('cc');
-insert into list_parted select 'Ff', s.a from generate_series(1, 29) s(a);
-insert into list_parted select 'gg', s.a from generate_series(1, 9) s(a);
-insert into list_parted (b) values (1);
-select tableoid::regclass::text, a, min(b) as min_b, max(b) as max_b from list_parted group by 1, 2 order by 1;
-   tableoid    | a  | min_b | max_b 
----------------+----+-------+-------
- part_aa_bb    | aa |       |      
- part_cc_dd    | cc |       |      
- part_ee_ff1   | Ff |     1 |     9
- part_ee_ff2   | Ff |    10 |    19
- part_ee_ff3_1 | Ff |    20 |    24
- part_ee_ff3_2 | Ff |    25 |    29
- part_gg2_1    | gg |     1 |     4
- part_gg2_2    | gg |     5 |     9
- part_null     |    |     1 |     1
-(9 rows)
-
--- direct partition inserts should check hash partition bound constraint
--- Use hand-rolled hash functions and operator classes to get predictable
--- result on different machines.  The hash function for int4 simply returns
--- the sum of the values passed to it and the one for text returns the length
--- of the non-empty string value passed to it or 0.
-create or replace function part_hashint4_noop(value int4, seed int8)
-returns int8 as $$
-select value + seed;
-$$ language sql immutable;
-create operator class part_test_int4_ops
-for type int4
-using hash as
-operator 1 =,
-function 2 part_hashint4_noop(int4, int8);
-create or replace function part_hashtext_length(value text, seed int8)
-RETURNS int8 AS $$
-select length(coalesce(value, ''))::int8
-$$ language sql immutable;
-create operator class part_test_text_ops
-for type text
-using hash as
-operator 1 =,
-function 2 part_hashtext_length(text, int8);
-create table hash_parted (
-	a int
-) partition by hash (a part_test_int4_ops);
-create table hpart0 partition of hash_parted for values with (modulus 4, remainder 0);
-create table hpart1 partition of hash_parted for values with (modulus 4, remainder 1);
-create table hpart2 partition of hash_parted for values with (modulus 4, remainder 2);
-create table hpart3 partition of hash_parted for values with (modulus 4, remainder 3);
-insert into hash_parted values(generate_series(1,10));
--- direct insert of values divisible by 4 - ok;
-insert into hpart0 values(12),(16);
--- fail;
-insert into hpart0 values(11);
-ERROR:  new row for relation "hpart0" violates partition constraint
-DETAIL:  Failing row contains (11).
--- 11 % 4 -> 3 remainder i.e. valid data for hpart3 partition
-insert into hpart3 values(11);
--- view data
-select tableoid::regclass as part, a, a%4 as "remainder = a % 4"
-from hash_parted order by part;
-  part  | a  | remainder = a % 4 
---------+----+-------------------
- hpart0 |  4 |                 0
- hpart0 |  8 |                 0
- hpart0 | 12 |                 0
- hpart0 | 16 |                 0
- hpart1 |  1 |                 1
- hpart1 |  5 |                 1
- hpart1 |  9 |                 1
- hpart2 |  2 |                 2
- hpart2 |  6 |                 2
- hpart2 | 10 |                 2
- hpart3 |  3 |                 3
- hpart3 |  7 |                 3
- hpart3 | 11 |                 3
-(13 rows)
-
--- test \d+ output on a table which has both partitioned and unpartitioned
--- partitions
-\d+ list_parted
-                          Partitioned table "public.list_parted"
- Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
---------+---------+-----------+----------+---------+----------+--------------+-------------
- a      | text    |           |          |         | extended |              | 
- b      | integer |           |          |         | plain    |              | 
-Partition key: LIST (lower(a))
-Partitions: part_aa_bb FOR VALUES IN ('aa', 'bb'),
-            part_cc_dd FOR VALUES IN ('cc', 'dd'),
-            part_ee_ff FOR VALUES IN ('ee', 'ff'), PARTITIONED,
-            part_gg FOR VALUES IN ('gg'), PARTITIONED,
-            part_null FOR VALUES IN (NULL),
-            part_xx_yy FOR VALUES IN ('xx', 'yy'), PARTITIONED,
-            part_default DEFAULT, PARTITIONED
-
--- cleanup
-drop table range_parted, list_parted;
-drop table hash_parted;
--- test that a default partition added as the first partition accepts any value
--- including null
-create table list_parted (a int) partition by list (a);
-create table part_default partition of list_parted default;
-\d+ part_default
-                               Table "public.part_default"
- Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
---------+---------+-----------+----------+---------+---------+--------------+-------------
- a      | integer |           |          |         | plain   |              | 
-Partition of: list_parted DEFAULT
-No partition constraint
-
-insert into part_default values (null);
-insert into part_default values (1);
-insert into part_default values (-1);
-select tableoid::regclass, a from list_parted;
-   tableoid   | a  
---------------+----
- part_default |   
- part_default |  1
- part_default | -1
-(3 rows)
-
--- cleanup
-drop table list_parted;
--- more tests for certain multi-level partitioning scenarios
-create table mlparted (a int, b int) partition by range (a, b);
-create table mlparted1 (b int not null, a int not null) partition by range ((b+0));
-create table mlparted11 (like mlparted1);
-alter table mlparted11 drop a;
-alter table mlparted11 add a int;
-alter table mlparted11 drop a;
-alter table mlparted11 add a int not null;
--- attnum for key attribute 'a' is different in mlparted, mlparted1, and mlparted11
-select attrelid::regclass, attname, attnum
-from pg_attribute
-where attname = 'a'
- and (attrelid = 'mlparted'::regclass
-   or attrelid = 'mlparted1'::regclass
-   or attrelid = 'mlparted11'::regclass)
-order by attrelid::regclass::text;
-  attrelid  | attname | attnum 
-------------+---------+--------
- mlparted   | a       |      1
- mlparted1  | a       |      2
- mlparted11 | a       |      4
-(3 rows)
-
-alter table mlparted1 attach partition mlparted11 for values from (2) to (5);
-alter table mlparted attach partition mlparted1 for values from (1, 2) to (1, 10);
--- check that "(1, 2)" is correctly routed to mlparted11.
-insert into mlparted values (1, 2);
-select tableoid::regclass, * from mlparted;
-  tableoid  | a | b 
-------------+---+---
- mlparted11 | 1 | 2
-(1 row)
-
--- check that proper message is shown after failure to route through mlparted1
-insert into mlparted (a, b) values (1, 5);
-ERROR:  no partition of relation "mlparted1" found for row
-DETAIL:  Partition key of the failing row contains ((b + 0)) = (5).
-truncate mlparted;
-alter table mlparted add constraint check_b check (b = 3);
--- have a BR trigger modify the row such that the check_b is violated
-create function mlparted11_trig_fn()
-returns trigger AS
-$$
-begin
-  NEW.b := 4;
-  return NEW;
-end;
-$$
-language plpgsql;
-create trigger mlparted11_trig before insert ON mlparted11
-  for each row execute procedure mlparted11_trig_fn();
--- check that the correct row is shown when constraint check_b fails after
--- "(1, 2)" is routed to mlparted11 (actually "(1, 4)" would be shown due
--- to the BR trigger mlparted11_trig_fn)
-insert into mlparted values (1, 2);
-ERROR:  new row for relation "mlparted11" violates check constraint "check_b"
-DETAIL:  Failing row contains (1, 4).
-drop trigger mlparted11_trig on mlparted11;
-drop function mlparted11_trig_fn();
--- check that inserting into an internal partition successfully results in
--- checking its partition constraint before inserting into the leaf partition
--- selected by tuple-routing
-insert into mlparted1 (a, b) values (2, 3);
-ERROR:  new row for relation "mlparted1" violates partition constraint
-DETAIL:  Failing row contains (3, 2).
--- check routing error through a list partitioned table when the key is null
-create table lparted_nonullpart (a int, b char) partition by list (b);
-create table lparted_nonullpart_a partition of lparted_nonullpart for values in ('a');
-insert into lparted_nonullpart values (1);
-ERROR:  no partition of relation "lparted_nonullpart" found for row
-DETAIL:  Partition key of the failing row contains (b) = (null).
-drop table lparted_nonullpart;
--- check that RETURNING works correctly with tuple-routing
-alter table mlparted drop constraint check_b;
-create table mlparted12 partition of mlparted1 for values from (5) to (10);
-create table mlparted2 (b int not null, a int not null);
-alter table mlparted attach partition mlparted2 for values from (1, 10) to (1, 20);
-create table mlparted3 partition of mlparted for values from (1, 20) to (1, 30);
-create table mlparted4 (like mlparted);
-alter table mlparted4 drop a;
-alter table mlparted4 add a int not null;
-alter table mlparted attach partition mlparted4 for values from (1, 30) to (1, 40);
-with ins (a, b, c) as
-  (insert into mlparted (b, a) select s.a, 1 from generate_series(2, 39) s(a) returning tableoid::regclass, *)
-  select a, b, min(c), max(c) from ins group by a, b order by 1;
-     a      | b | min | max 
-------------+---+-----+-----
- mlparted11 | 1 |   2 |   4
- mlparted12 | 1 |   5 |   9
- mlparted2  | 1 |  10 |  19
- mlparted3  | 1 |  20 |  29
- mlparted4  | 1 |  30 |  39
-(5 rows)
-
-alter table mlparted add c text;
-create table mlparted5 (c text, a int not null, b int not null) partition by list (c);
-create table mlparted5a (a int not null, c text, b int not null);
-alter table mlparted5 attach partition mlparted5a for values in ('a');
-alter table mlparted attach partition mlparted5 for values from (1, 40) to (1, 50);
-alter table mlparted add constraint check_b check (a = 1 and b < 45);
-insert into mlparted values (1, 45, 'a');
-ERROR:  new row for relation "mlparted5a" violates check constraint "check_b"
-DETAIL:  Failing row contains (1, 45, a).
-create function mlparted5abrtrig_func() returns trigger as $$ begin new.c = 'b'; return new; end; $$ language plpgsql;
-create trigger mlparted5abrtrig before insert on mlparted5a for each row execute procedure mlparted5abrtrig_func();
-insert into mlparted5 (a, b, c) values (1, 40, 'a');
-ERROR:  new row for relation "mlparted5a" violates partition constraint
-DETAIL:  Failing row contains (b, 1, 40).
-drop table mlparted5;
-alter table mlparted drop constraint check_b;
--- Check multi-level default partition
-create table mlparted_def partition of mlparted default partition by range(a);
-create table mlparted_def1 partition of mlparted_def for values from (40) to (50);
-create table mlparted_def2 partition of mlparted_def for values from (50) to (60);
-insert into mlparted values (40, 100);
-insert into mlparted_def1 values (42, 100);
-insert into mlparted_def2 values (54, 50);
--- fail
-insert into mlparted values (70, 100);
-ERROR:  no partition of relation "mlparted_def" found for row
-DETAIL:  Partition key of the failing row contains (a) = (70).
-insert into mlparted_def1 values (52, 50);
-ERROR:  new row for relation "mlparted_def1" violates partition constraint
-DETAIL:  Failing row contains (52, 50, null).
-insert into mlparted_def2 values (34, 50);
-ERROR:  new row for relation "mlparted_def2" violates partition constraint
-DETAIL:  Failing row contains (34, 50, null).
--- ok
-create table mlparted_defd partition of mlparted_def default;
-insert into mlparted values (70, 100);
-select tableoid::regclass, * from mlparted_def;
-   tableoid    | a  |  b  | c 
----------------+----+-----+---
- mlparted_def1 | 40 | 100 | 
- mlparted_def1 | 42 | 100 | 
- mlparted_def2 | 54 |  50 | 
- mlparted_defd | 70 | 100 | 
-(4 rows)
-
--- Check multi-level tuple routing with attributes dropped from the
--- top-most parent.  First remove the last attribute.
-alter table mlparted add d int, add e int;
-alter table mlparted drop e;
-create table mlparted5 partition of mlparted
-  for values from (1, 40) to (1, 50) partition by range (c);
-create table mlparted5_ab partition of mlparted5
-  for values from ('a') to ('c') partition by list (c);
--- This partitioned table should remain with no partitions.
-create table mlparted5_cd partition of mlparted5
-  for values from ('c') to ('e') partition by list (c);
-create table mlparted5_a partition of mlparted5_ab for values in ('a');
-create table mlparted5_b (d int, b int, c text, a int);
-alter table mlparted5_ab attach partition mlparted5_b for values in ('b');
-truncate mlparted;
-insert into mlparted values (1, 2, 'a', 1);
-insert into mlparted values (1, 40, 'a', 1);  -- goes to mlparted5_a
-insert into mlparted values (1, 45, 'b', 1);  -- goes to mlparted5_b
-insert into mlparted values (1, 45, 'c', 1);  -- goes to mlparted5_cd, fails
-ERROR:  no partition of relation "mlparted5_cd" found for row
-DETAIL:  Partition key of the failing row contains (c) = (c).
-insert into mlparted values (1, 45, 'f', 1);  -- goes to mlparted5, fails
-ERROR:  no partition of relation "mlparted5" found for row
-DETAIL:  Partition key of the failing row contains (c) = (f).
-select tableoid::regclass, * from mlparted order by a, b, c, d;
-  tableoid   | a | b  | c | d 
--------------+---+----+---+---
- mlparted11  | 1 |  2 | a | 1
- mlparted5_a | 1 | 40 | a | 1
- mlparted5_b | 1 | 45 | b | 1
-(3 rows)
-
-alter table mlparted drop d;
-truncate mlparted;
--- Remove the before last attribute.
-alter table mlparted add e int, add d int;
-alter table mlparted drop e;
-insert into mlparted values (1, 2, 'a', 1);
-insert into mlparted values (1, 40, 'a', 1);  -- goes to mlparted5_a
-insert into mlparted values (1, 45, 'b', 1);  -- goes to mlparted5_b
-insert into mlparted values (1, 45, 'c', 1);  -- goes to mlparted5_cd, fails
-ERROR:  no partition of relation "mlparted5_cd" found for row
-DETAIL:  Partition key of the failing row contains (c) = (c).
-insert into mlparted values (1, 45, 'f', 1);  -- goes to mlparted5, fails
-ERROR:  no partition of relation "mlparted5" found for row
-DETAIL:  Partition key of the failing row contains (c) = (f).
-select tableoid::regclass, * from mlparted order by a, b, c, d;
-  tableoid   | a | b  | c | d 
--------------+---+----+---+---
- mlparted11  | 1 |  2 | a | 1
- mlparted5_a | 1 | 40 | a | 1
- mlparted5_b | 1 | 45 | b | 1
-(3 rows)
-
-alter table mlparted drop d;
-drop table mlparted5;
--- check that message shown after failure to find a partition shows the
--- appropriate key description (or none) in various situations
-create table key_desc (a int, b int) partition by list ((a+0));
-create table key_desc_1 partition of key_desc for values in (1) partition by range (b);
-create user regress_insert_other_user;
-grant select (a) on key_desc_1 to regress_insert_other_user;
-grant insert on key_desc to regress_insert_other_user;
-set role regress_insert_other_user;
--- no key description is shown
-insert into key_desc values (1, 1);
-ERROR:  no partition of relation "key_desc_1" found for row
-reset role;
-grant select (b) on key_desc_1 to regress_insert_other_user;
-set role regress_insert_other_user;
--- key description (b)=(1) is now shown
-insert into key_desc values (1, 1);
-ERROR:  no partition of relation "key_desc_1" found for row
-DETAIL:  Partition key of the failing row contains (b) = (1).
--- key description is not shown if key contains expression
-insert into key_desc values (2, 1);
-ERROR:  no partition of relation "key_desc" found for row
-reset role;
-revoke all on key_desc from regress_insert_other_user;
-revoke all on key_desc_1 from regress_insert_other_user;
-drop role regress_insert_other_user;
-drop table key_desc, key_desc_1;
--- test minvalue/maxvalue restrictions
-create table mcrparted (a int, b int, c int) partition by range (a, abs(b), c);
-create table mcrparted0 partition of mcrparted for values from (minvalue, 0, 0) to (1, maxvalue, maxvalue);
-ERROR:  every bound following MINVALUE must also be MINVALUE
-LINE 1: ...partition of mcrparted for values from (minvalue, 0, 0) to (...
-                                                             ^
-create table mcrparted2 partition of mcrparted for values from (10, 6, minvalue) to (10, maxvalue, minvalue);
-ERROR:  every bound following MAXVALUE must also be MAXVALUE
-LINE 1: ...r values from (10, 6, minvalue) to (10, maxvalue, minvalue);
-                                                             ^
-create table mcrparted4 partition of mcrparted for values from (21, minvalue, 0) to (30, 20, minvalue);
-ERROR:  every bound following MINVALUE must also be MINVALUE
-LINE 1: ...ition of mcrparted for values from (21, minvalue, 0) to (30,...
-                                                             ^
--- check multi-column range partitioning expression enforces the same
--- constraint as what tuple-routing would determine it to be
-create table mcrparted0 partition of mcrparted for values from (minvalue, minvalue, minvalue) to (1, maxvalue, maxvalue);
-create table mcrparted1 partition of mcrparted for values from (2, 1, minvalue) to (10, 5, 10);
-create table mcrparted2 partition of mcrparted for values from (10, 6, minvalue) to (10, maxvalue, maxvalue);
-create table mcrparted3 partition of mcrparted for values from (11, 1, 1) to (20, 10, 10);
-create table mcrparted4 partition of mcrparted for values from (21, minvalue, minvalue) to (30, 20, maxvalue);
-create table mcrparted5 partition of mcrparted for values from (30, 21, 20) to (maxvalue, maxvalue, maxvalue);
--- null not allowed in range partition
-insert into mcrparted values (null, null, null);
-ERROR:  no partition of relation "mcrparted" found for row
-DETAIL:  Partition key of the failing row contains (a, abs(b), c) = (null, null, null).
--- routed to mcrparted0
-insert into mcrparted values (0, 1, 1);
-insert into mcrparted0 values (0, 1, 1);
--- routed to mcparted1
-insert into mcrparted values (9, 1000, 1);
-insert into mcrparted1 values (9, 1000, 1);
-insert into mcrparted values (10, 5, -1);
-insert into mcrparted1 values (10, 5, -1);
-insert into mcrparted values (2, 1, 0);
-insert into mcrparted1 values (2, 1, 0);
--- routed to mcparted2
-insert into mcrparted values (10, 6, 1000);
-insert into mcrparted2 values (10, 6, 1000);
-insert into mcrparted values (10, 1000, 1000);
-insert into mcrparted2 values (10, 1000, 1000);
--- no partition exists, nor does mcrparted3 accept it
-insert into mcrparted values (11, 1, -1);
-ERROR:  no partition of relation "mcrparted" found for row
-DETAIL:  Partition key of the failing row contains (a, abs(b), c) = (11, 1, -1).
-insert into mcrparted3 values (11, 1, -1);
-ERROR:  new row for relation "mcrparted3" violates partition constraint
-DETAIL:  Failing row contains (11, 1, -1).
--- routed to mcrparted5
-insert into mcrparted values (30, 21, 20);
-insert into mcrparted5 values (30, 21, 20);
-insert into mcrparted4 values (30, 21, 20);	-- error
-ERROR:  new row for relation "mcrparted4" violates partition constraint
-DETAIL:  Failing row contains (30, 21, 20).
--- check rows
-select tableoid::regclass::text, * from mcrparted order by 1;
-  tableoid  | a  |  b   |  c   
-------------+----+------+------
- mcrparted0 |  0 |    1 |    1
- mcrparted0 |  0 |    1 |    1
- mcrparted1 |  9 | 1000 |    1
- mcrparted1 |  9 | 1000 |    1
- mcrparted1 | 10 |    5 |   -1
- mcrparted1 | 10 |    5 |   -1
- mcrparted1 |  2 |    1 |    0
- mcrparted1 |  2 |    1 |    0
- mcrparted2 | 10 |    6 | 1000
- mcrparted2 | 10 |    6 | 1000
- mcrparted2 | 10 | 1000 | 1000
- mcrparted2 | 10 | 1000 | 1000
- mcrparted5 | 30 |   21 |   20
- mcrparted5 | 30 |   21 |   20
-(14 rows)
-
--- cleanup
-drop table mcrparted;
--- check that a BR constraint can't make partition contain violating rows
-create table brtrigpartcon (a int, b text) partition by list (a);
-create table brtrigpartcon1 partition of brtrigpartcon for values in (1);
-create or replace function brtrigpartcon1trigf() returns trigger as $$begin new.a := 2; return new; end$$ language plpgsql;
-create trigger brtrigpartcon1trig before insert on brtrigpartcon1 for each row execute procedure brtrigpartcon1trigf();
-insert into brtrigpartcon values (1, 'hi there');
-ERROR:  new row for relation "brtrigpartcon1" violates partition constraint
-DETAIL:  Failing row contains (2, hi there).
-insert into brtrigpartcon1 values (1, 'hi there');
-ERROR:  new row for relation "brtrigpartcon1" violates partition constraint
-DETAIL:  Failing row contains (2, hi there).
--- check that the message shows the appropriate column description in a
--- situation where the partitioned table is not the primary ModifyTable node
-create table inserttest3 (f1 text default 'foo', f2 text default 'bar', f3 int);
-create role regress_coldesc_role;
-grant insert on inserttest3 to regress_coldesc_role;
-grant insert on brtrigpartcon to regress_coldesc_role;
-revoke select on brtrigpartcon from regress_coldesc_role;
-set role regress_coldesc_role;
-with result as (insert into brtrigpartcon values (1, 'hi there') returning 1)
-  insert into inserttest3 (f3) select * from result;
-ERROR:  new row for relation "brtrigpartcon1" violates partition constraint
-DETAIL:  Failing row contains (a, b) = (2, hi there).
-reset role;
--- cleanup
-revoke all on inserttest3 from regress_coldesc_role;
-revoke all on brtrigpartcon from regress_coldesc_role;
-drop role regress_coldesc_role;
-drop table inserttest3;
-drop table brtrigpartcon;
-drop function brtrigpartcon1trigf();
--- check that "do nothing" BR triggers work with tuple-routing
-create table donothingbrtrig_test (a int, b text) partition by list (a);
-create table donothingbrtrig_test1 (b text, a int);
-create table donothingbrtrig_test2 (c text, b text, a int);
-alter table donothingbrtrig_test2 drop column c;
-create or replace function donothingbrtrig_func() returns trigger as $$begin raise notice 'b: %', new.b; return NULL; end$$ language plpgsql;
-create trigger donothingbrtrig1 before insert on donothingbrtrig_test1 for each row execute procedure donothingbrtrig_func();
-create trigger donothingbrtrig2 before insert on donothingbrtrig_test2 for each row execute procedure donothingbrtrig_func();
-alter table donothingbrtrig_test attach partition donothingbrtrig_test1 for values in (1);
-alter table donothingbrtrig_test attach partition donothingbrtrig_test2 for values in (2);
-insert into donothingbrtrig_test values (1, 'foo'), (2, 'bar');
-NOTICE:  b: foo
-NOTICE:  b: bar
-copy donothingbrtrig_test from stdout;
-NOTICE:  b: baz
-NOTICE:  b: qux
-select tableoid::regclass, * from donothingbrtrig_test;
- tableoid | a | b 
-----------+---+---
-(0 rows)
-
--- cleanup
-drop table donothingbrtrig_test;
-drop function donothingbrtrig_func();
--- check multi-column range partitioning with minvalue/maxvalue constraints
-create table mcrparted (a text, b int) partition by range(a, b);
-create table mcrparted1_lt_b partition of mcrparted for values from (minvalue, minvalue) to ('b', minvalue);
-create table mcrparted2_b partition of mcrparted for values from ('b', minvalue) to ('c', minvalue);
-create table mcrparted3_c_to_common partition of mcrparted for values from ('c', minvalue) to ('common', minvalue);
-create table mcrparted4_common_lt_0 partition of mcrparted for values from ('common', minvalue) to ('common', 0);
-create table mcrparted5_common_0_to_10 partition of mcrparted for values from ('common', 0) to ('common', 10);
-create table mcrparted6_common_ge_10 partition of mcrparted for values from ('common', 10) to ('common', maxvalue);
-create table mcrparted7_gt_common_lt_d partition of mcrparted for values from ('common', maxvalue) to ('d', minvalue);
-create table mcrparted8_ge_d partition of mcrparted for values from ('d', minvalue) to (maxvalue, maxvalue);
-\d+ mcrparted
-                           Partitioned table "public.mcrparted"
- Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
---------+---------+-----------+----------+---------+----------+--------------+-------------
- a      | text    |           |          |         | extended |              | 
- b      | integer |           |          |         | plain    |              | 
-Partition key: RANGE (a, b)
-Partitions: mcrparted1_lt_b FOR VALUES FROM (MINVALUE, MINVALUE) TO ('b', MINVALUE),
-            mcrparted2_b FOR VALUES FROM ('b', MINVALUE) TO ('c', MINVALUE),
-            mcrparted3_c_to_common FOR VALUES FROM ('c', MINVALUE) TO ('common', MINVALUE),
-            mcrparted4_common_lt_0 FOR VALUES FROM ('common', MINVALUE) TO ('common', 0),
-            mcrparted5_common_0_to_10 FOR VALUES FROM ('common', 0) TO ('common', 10),
-            mcrparted6_common_ge_10 FOR VALUES FROM ('common', 10) TO ('common', MAXVALUE),
-            mcrparted7_gt_common_lt_d FOR VALUES FROM ('common', MAXVALUE) TO ('d', MINVALUE),
-            mcrparted8_ge_d FOR VALUES FROM ('d', MINVALUE) TO (MAXVALUE, MAXVALUE)
-
-\d+ mcrparted1_lt_b
-                              Table "public.mcrparted1_lt_b"
- Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
---------+---------+-----------+----------+---------+----------+--------------+-------------
- a      | text    |           |          |         | extended |              | 
- b      | integer |           |          |         | plain    |              | 
-Partition of: mcrparted FOR VALUES FROM (MINVALUE, MINVALUE) TO ('b', MINVALUE)
-Partition constraint: ((a IS NOT NULL) AND (b IS NOT NULL) AND (a < 'b'::text))
-
-\d+ mcrparted2_b
-                                Table "public.mcrparted2_b"
- Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
---------+---------+-----------+----------+---------+----------+--------------+-------------
- a      | text    |           |          |         | extended |              | 
- b      | integer |           |          |         | plain    |              | 
-Partition of: mcrparted FOR VALUES FROM ('b', MINVALUE) TO ('c', MINVALUE)
-Partition constraint: ((a IS NOT NULL) AND (b IS NOT NULL) AND (a >= 'b'::text) AND (a < 'c'::text))
-
-\d+ mcrparted3_c_to_common
-                           Table "public.mcrparted3_c_to_common"
- Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
---------+---------+-----------+----------+---------+----------+--------------+-------------
- a      | text    |           |          |         | extended |              | 
- b      | integer |           |          |         | plain    |              | 
-Partition of: mcrparted FOR VALUES FROM ('c', MINVALUE) TO ('common', MINVALUE)
-Partition constraint: ((a IS NOT NULL) AND (b IS NOT NULL) AND (a >= 'c'::text) AND (a < 'common'::text))
-
-\d+ mcrparted4_common_lt_0
-                           Table "public.mcrparted4_common_lt_0"
- Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
---------+---------+-----------+----------+---------+----------+--------------+-------------
- a      | text    |           |          |         | extended |              | 
- b      | integer |           |          |         | plain    |              | 
-Partition of: mcrparted FOR VALUES FROM ('common', MINVALUE) TO ('common', 0)
-Partition constraint: ((a IS NOT NULL) AND (b IS NOT NULL) AND (a = 'common'::text) AND (b < 0))
-
-\d+ mcrparted5_common_0_to_10
-                         Table "public.mcrparted5_common_0_to_10"
- Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
---------+---------+-----------+----------+---------+----------+--------------+-------------
- a      | text    |           |          |         | extended |              | 
- b      | integer |           |          |         | plain    |              | 
-Partition of: mcrparted FOR VALUES FROM ('common', 0) TO ('common', 10)
-Partition constraint: ((a IS NOT NULL) AND (b IS NOT NULL) AND (a = 'common'::text) AND (b >= 0) AND (b < 10))
-
-\d+ mcrparted6_common_ge_10
-                          Table "public.mcrparted6_common_ge_10"
- Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
---------+---------+-----------+----------+---------+----------+--------------+-------------
- a      | text    |           |          |         | extended |              | 
- b      | integer |           |          |         | plain    |              | 
-Partition of: mcrparted FOR VALUES FROM ('common', 10) TO ('common', MAXVALUE)
-Partition constraint: ((a IS NOT NULL) AND (b IS NOT NULL) AND (a = 'common'::text) AND (b >= 10))
-
-\d+ mcrparted7_gt_common_lt_d
-                         Table "public.mcrparted7_gt_common_lt_d"
- Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
---------+---------+-----------+----------+---------+----------+--------------+-------------
- a      | text    |           |          |         | extended |              | 
- b      | integer |           |          |         | plain    |              | 
-Partition of: mcrparted FOR VALUES FROM ('common', MAXVALUE) TO ('d', MINVALUE)
-Partition constraint: ((a IS NOT NULL) AND (b IS NOT NULL) AND (a > 'common'::text) AND (a < 'd'::text))
-
-\d+ mcrparted8_ge_d
-                              Table "public.mcrparted8_ge_d"
- Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
---------+---------+-----------+----------+---------+----------+--------------+-------------
- a      | text    |           |          |         | extended |              | 
- b      | integer |           |          |         | plain    |              | 
-Partition of: mcrparted FOR VALUES FROM ('d', MINVALUE) TO (MAXVALUE, MAXVALUE)
-Partition constraint: ((a IS NOT NULL) AND (b IS NOT NULL) AND (a >= 'd'::text))
-
-insert into mcrparted values ('aaa', 0), ('b', 0), ('bz', 10), ('c', -10),
-    ('comm', -10), ('common', -10), ('common', 0), ('common', 10),
-    ('commons', 0), ('d', -10), ('e', 0);
-select tableoid::regclass, * from mcrparted order by a, b;
-         tableoid          |    a    |  b  
----------------------------+---------+-----
- mcrparted1_lt_b           | aaa     |   0
- mcrparted2_b              | b       |   0
- mcrparted2_b              | bz      |  10
- mcrparted3_c_to_common    | c       | -10
- mcrparted3_c_to_common    | comm    | -10
- mcrparted4_common_lt_0    | common  | -10
- mcrparted5_common_0_to_10 | common  |   0
- mcrparted6_common_ge_10   | common  |  10
- mcrparted7_gt_common_lt_d | commons |   0
- mcrparted8_ge_d           | d       | -10
- mcrparted8_ge_d           | e       |   0
-(11 rows)
-
-drop table mcrparted;
--- check that wholerow vars in the RETURNING list work with partitioned tables
-create table returningwrtest (a int) partition by list (a);
-create table returningwrtest1 partition of returningwrtest for values in (1);
-insert into returningwrtest values (1) returning returningwrtest;
- returningwrtest 
------------------
- (1)
-(1 row)
-
--- check also that the wholerow vars in RETURNING list are converted as needed
-alter table returningwrtest add b text;
-create table returningwrtest2 (b text, c int, a int);
-alter table returningwrtest2 drop c;
-alter table returningwrtest attach partition returningwrtest2 for values in (2);
-insert into returningwrtest values (2, 'foo') returning returningwrtest;
- returningwrtest 
------------------
- (2,foo)
-(1 row)
-
-drop table returningwrtest;
diff -U3 /Users/kenaniah/workspace/postgres/src/test/regress/expected/create_operator.out /Users/kenaniah/workspace/postgres/src/test/regress/results/create_operator.out
--- /Users/kenaniah/workspace/postgres/src/test/regress/expected/create_operator.out	2021-10-03 17:41:49.000000000 -0700
+++ /Users/kenaniah/workspace/postgres/src/test/regress/results/create_operator.out	2021-10-03 20:08:13.000000000 -0700
@@ -212,7 +212,7 @@
    rightarg = int8,
    procedure = fn_op3
 );
-ERROR:  permission denied for type type_op3
+ERROR:  permission denied for schema public
 ROLLBACK;
 -- Should fail. CREATE OPERATOR requires USAGE on TYPE (need to check separately for rightarg)
 BEGIN TRANSACTION;
@@ -230,7 +230,7 @@
    rightarg = type_op4,
    procedure = fn_op4
 );
-ERROR:  permission denied for type type_op4
+ERROR:  permission denied for schema public
 ROLLBACK;
 -- Should fail. CREATE OPERATOR requires EXECUTE on function
 BEGIN TRANSACTION;
@@ -248,7 +248,7 @@
    rightarg = int8,
    procedure = fn_op5
 );
-ERROR:  permission denied for function fn_op5
+ERROR:  permission denied for schema public
 ROLLBACK;
 -- Should fail. CREATE OPERATOR requires USAGE on return TYPE
 BEGIN TRANSACTION;
@@ -266,7 +266,7 @@
    rightarg = int8,
    procedure = fn_op6
 );
-ERROR:  permission denied for type type_op6
+ERROR:  permission denied for schema public
 ROLLBACK;
 -- invalid: non-lowercase quoted identifiers
 CREATE OPERATOR ===
diff -U3 /Users/kenaniah/workspace/postgres/src/test/regress/expected/create_procedure.out /Users/kenaniah/workspace/postgres/src/test/regress/results/create_procedure.out
--- /Users/kenaniah/workspace/postgres/src/test/regress/expected/create_procedure.out	2021-10-03 17:41:49.000000000 -0700
+++ /Users/kenaniah/workspace/postgres/src/test/regress/results/create_procedure.out	2021-10-03 20:08:13.000000000 -0700
@@ -16,368 +16,11 @@
 INSERT INTO cp_test VALUES (1, x);
 $$;
 \df ptest1
-                        List of functions
- Schema |  Name  | Result data type | Argument data types | Type 
---------+--------+------------------+---------------------+------
- public | ptest1 |                  | IN x text           | proc
-(1 row)
+dyld: lazy symbol binding failed: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
+
+dyld: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
 
-SELECT pg_get_functiondef('ptest1'::regproc);
-                  pg_get_functiondef                  
-------------------------------------------------------
- CREATE OR REPLACE PROCEDURE public.ptest1(IN x text)+
-  LANGUAGE sql                                       +
- AS $procedure$                                      +
- INSERT INTO cp_test VALUES (1, x);                  +
- $procedure$                                         +
- 
-(1 row)
-
--- show only normal functions
-\dfn public.*test*1
-                           List of functions
- Schema |     Name     | Result data type | Argument data types | Type 
---------+--------------+------------------+---------------------+------
- public | cp_testfunc1 | integer          | a integer           | func
-(1 row)
-
--- show only procedures
-\dfp public.*test*1
-                        List of functions
- Schema |  Name  | Result data type | Argument data types | Type 
---------+--------+------------------+---------------------+------
- public | ptest1 |                  | IN x text           | proc
-(1 row)
-
-SELECT ptest1('x');  -- error
-ERROR:  ptest1(unknown) is a procedure
-LINE 1: SELECT ptest1('x');
-               ^
-HINT:  To call a procedure, use CALL.
-CALL ptest1('a');  -- ok
-CALL ptest1('xy' || 'zzy');  -- ok, constant-folded arg
-CALL ptest1(substring(random()::numeric(20,15)::text, 1, 1));  -- ok, volatile arg
-SELECT * FROM cp_test ORDER BY b COLLATE "C";
- a |   b   
----+-------
- 1 | 0
- 1 | a
- 1 | xyzzy
-(3 rows)
-
--- SQL-standard body
-CREATE PROCEDURE ptest1s(x text)
-LANGUAGE SQL
-BEGIN ATOMIC
-  INSERT INTO cp_test VALUES (1, x);
-END;
-\df ptest1s
-                        List of functions
- Schema |  Name   | Result data type | Argument data types | Type 
---------+---------+------------------+---------------------+------
- public | ptest1s |                  | IN x text           | proc
-(1 row)
-
-SELECT pg_get_functiondef('ptest1s'::regproc);
-                  pg_get_functiondef                   
--------------------------------------------------------
- CREATE OR REPLACE PROCEDURE public.ptest1s(IN x text)+
-  LANGUAGE sql                                        +
- BEGIN ATOMIC                                         +
-  INSERT INTO cp_test (a, b)                          +
-    VALUES (1, ptest1s.x);                            +
- END                                                  +
- 
-(1 row)
-
-CALL ptest1s('b');
-SELECT * FROM cp_test ORDER BY b COLLATE "C";
- a |   b   
----+-------
- 1 | 0
- 1 | a
- 1 | b
- 1 | xyzzy
-(4 rows)
-
--- utitlity functions currently not supported here
-CREATE PROCEDURE ptestx()
-LANGUAGE SQL
-BEGIN ATOMIC
-  CREATE TABLE x (a int);
-END;
-ERROR:  CREATE TABLE is not yet supported in unquoted SQL function body
-CREATE PROCEDURE ptest2()
-LANGUAGE SQL
-AS $$
-SELECT 5;
-$$;
-CALL ptest2();
--- nested CALL
-TRUNCATE cp_test;
-CREATE PROCEDURE ptest3(y text)
-LANGUAGE SQL
-AS $$
-CALL ptest1(y);
-CALL ptest1($1);
-$$;
-CALL ptest3('b');
-SELECT * FROM cp_test;
- a | b 
----+---
- 1 | b
- 1 | b
-(2 rows)
-
--- output arguments
-CREATE PROCEDURE ptest4a(INOUT a int, INOUT b int)
-LANGUAGE SQL
-AS $$
-SELECT 1, 2;
-$$;
-CALL ptest4a(NULL, NULL);
- a | b 
----+---
- 1 | 2
-(1 row)
-
-CREATE PROCEDURE ptest4b(INOUT b int, INOUT a int)
-LANGUAGE SQL
-AS $$
-CALL ptest4a(a, b);  -- error, not supported
-$$;
-ERROR:  calling procedures with output arguments is not supported in SQL functions
-CONTEXT:  SQL function "ptest4b"
-DROP PROCEDURE ptest4a;
--- named and default parameters
-CREATE OR REPLACE PROCEDURE ptest5(a int, b text, c int default 100)
-LANGUAGE SQL
-AS $$
-INSERT INTO cp_test VALUES(a, b);
-INSERT INTO cp_test VALUES(c, b);
-$$;
-TRUNCATE cp_test;
-CALL ptest5(10, 'Hello', 20);
-CALL ptest5(10, 'Hello');
-CALL ptest5(10, b => 'Hello');
-CALL ptest5(b => 'Hello', a => 10);
-SELECT * FROM cp_test;
-  a  |   b   
------+-------
-  10 | Hello
-  20 | Hello
-  10 | Hello
- 100 | Hello
-  10 | Hello
- 100 | Hello
-  10 | Hello
- 100 | Hello
-(8 rows)
-
--- polymorphic types
-CREATE PROCEDURE ptest6(a int, b anyelement)
-LANGUAGE SQL
-AS $$
-SELECT NULL::int;
-$$;
-CALL ptest6(1, 2);
--- collation assignment
-CREATE PROCEDURE ptest7(a text, b text)
-LANGUAGE SQL
-AS $$
-SELECT a = b;
-$$;
-CALL ptest7(least('a', 'b'), 'a');
--- empty body
-CREATE PROCEDURE ptest8(x text)
-BEGIN ATOMIC
-END;
-\df ptest8
-                        List of functions
- Schema |  Name  | Result data type | Argument data types | Type 
---------+--------+------------------+---------------------+------
- public | ptest8 |                  | IN x text           | proc
-(1 row)
-
-SELECT pg_get_functiondef('ptest8'::regproc);
-                  pg_get_functiondef                  
-------------------------------------------------------
- CREATE OR REPLACE PROCEDURE public.ptest8(IN x text)+
-  LANGUAGE sql                                       +
- BEGIN ATOMIC                                        +
- END                                                 +
- 
-(1 row)
-
-CALL ptest8('');
--- OUT parameters
-CREATE PROCEDURE ptest9(OUT a int)
-LANGUAGE SQL
-AS $$
-INSERT INTO cp_test VALUES (1, 'a');
-SELECT 1;
-$$;
--- standard way to do a call:
-CALL ptest9(NULL);
- a 
----
- 1
-(1 row)
-
--- you can write an expression, but it's not evaluated
-CALL ptest9(1/0);  -- no error
- a 
----
- 1
-(1 row)
-
--- ... and it had better match the type of the parameter
-CALL ptest9(1./0.);  -- error
-ERROR:  procedure ptest9(numeric) does not exist
-LINE 1: CALL ptest9(1./0.);
-             ^
-HINT:  No procedure matches the given name and argument types. You might need to add explicit type casts.
--- check named-parameter matching
-CREATE PROCEDURE ptest10(OUT a int, IN b int, IN c int)
-LANGUAGE SQL AS $$ SELECT b - c $$;
-CALL ptest10(null, 7, 4);
- a 
----
- 3
-(1 row)
-
-CALL ptest10(a => null, b => 8, c => 2);
- a 
----
- 6
-(1 row)
-
-CALL ptest10(null, 7, c => 2);
- a 
----
- 5
-(1 row)
-
-CALL ptest10(null, c => 4, b => 11);
- a 
----
- 7
-(1 row)
-
-CALL ptest10(b => 8, c => 2, a => 0);
- a 
----
- 6
-(1 row)
-
-CREATE PROCEDURE ptest11(a OUT int, VARIADIC b int[]) LANGUAGE SQL
-  AS $$ SELECT b[1] + b[2] $$;
-CALL ptest11(null, 11, 12, 13);
- a  
-----
- 23
-(1 row)
-
--- check resolution of ambiguous DROP commands
-CREATE PROCEDURE ptest10(IN a int, IN b int, IN c int)
-LANGUAGE SQL AS $$ SELECT a + b - c $$;
-\df ptest10
-                                   List of functions
- Schema |  Name   | Result data type |            Argument data types            | Type 
---------+---------+------------------+-------------------------------------------+------
- public | ptest10 |                  | IN a integer, IN b integer, IN c integer  | proc
- public | ptest10 |                  | OUT a integer, IN b integer, IN c integer | proc
-(2 rows)
-
-drop procedure ptest10;  -- fail
-ERROR:  procedure name "ptest10" is not unique
-HINT:  Specify the argument list to select the procedure unambiguously.
-drop procedure ptest10(int, int, int);  -- fail
-ERROR:  procedure name "ptest10" is not unique
-begin;
-drop procedure ptest10(out int, int, int);
-\df ptest10
-                                   List of functions
- Schema |  Name   | Result data type |           Argument data types            | Type 
---------+---------+------------------+------------------------------------------+------
- public | ptest10 |                  | IN a integer, IN b integer, IN c integer | proc
-(1 row)
-
-drop procedure ptest10(int, int, int);  -- now this would work
-rollback;
-begin;
-drop procedure ptest10(in int, int, int);
-\df ptest10
-                                   List of functions
- Schema |  Name   | Result data type |            Argument data types            | Type 
---------+---------+------------------+-------------------------------------------+------
- public | ptest10 |                  | OUT a integer, IN b integer, IN c integer | proc
-(1 row)
-
-drop procedure ptest10(int, int, int);  -- now this would work
-rollback;
--- various error cases
-CALL version();  -- error: not a procedure
-ERROR:  version() is not a procedure
-LINE 1: CALL version();
-             ^
-HINT:  To call a function, use SELECT.
-CALL sum(1);  -- error: not a procedure
-ERROR:  sum(integer) is not a procedure
-LINE 1: CALL sum(1);
-             ^
-HINT:  To call a function, use SELECT.
-CREATE PROCEDURE ptestx() LANGUAGE SQL WINDOW AS $$ INSERT INTO cp_test VALUES (1, 'a') $$;
-ERROR:  invalid attribute in procedure definition
-LINE 1: CREATE PROCEDURE ptestx() LANGUAGE SQL WINDOW AS $$ INSERT I...
-                                               ^
-CREATE PROCEDURE ptestx() LANGUAGE SQL STRICT AS $$ INSERT INTO cp_test VALUES (1, 'a') $$;
-ERROR:  invalid attribute in procedure definition
-LINE 1: CREATE PROCEDURE ptestx() LANGUAGE SQL STRICT AS $$ INSERT I...
-                                               ^
-CREATE PROCEDURE ptestx(a VARIADIC int[], b OUT int) LANGUAGE SQL
-  AS $$ SELECT a[1] $$;
-ERROR:  VARIADIC parameter must be the last parameter
-CREATE PROCEDURE ptestx(a int DEFAULT 42, b OUT int) LANGUAGE SQL
-  AS $$ SELECT a $$;
-ERROR:  procedure OUT parameters cannot appear after one with a default value
-ALTER PROCEDURE ptest1(text) STRICT;
-ERROR:  invalid attribute in procedure definition
-LINE 1: ALTER PROCEDURE ptest1(text) STRICT;
-                                     ^
-ALTER FUNCTION ptest1(text) VOLATILE;  -- error: not a function
-ERROR:  ptest1(text) is not a function
-ALTER PROCEDURE cp_testfunc1(int) VOLATILE;  -- error: not a procedure
-ERROR:  cp_testfunc1(integer) is not a procedure
-ALTER PROCEDURE nonexistent() VOLATILE;
-ERROR:  procedure nonexistent() does not exist
-DROP FUNCTION ptest1(text);  -- error: not a function
-ERROR:  ptest1(text) is not a function
-DROP PROCEDURE cp_testfunc1(int);  -- error: not a procedure
-ERROR:  cp_testfunc1(integer) is not a procedure
-DROP PROCEDURE nonexistent();
-ERROR:  procedure nonexistent() does not exist
--- privileges
-CREATE USER regress_cp_user1;
-GRANT INSERT ON cp_test TO regress_cp_user1;
-REVOKE EXECUTE ON PROCEDURE ptest1(text) FROM PUBLIC;
-SET ROLE regress_cp_user1;
-CALL ptest1('a');  -- error
-ERROR:  permission denied for procedure ptest1
-RESET ROLE;
-GRANT EXECUTE ON PROCEDURE ptest1(text) TO regress_cp_user1;
-SET ROLE regress_cp_user1;
-CALL ptest1('a');  -- ok
-RESET ROLE;
--- ROUTINE syntax
-ALTER ROUTINE cp_testfunc1(int) RENAME TO cp_testfunc1a;
-ALTER ROUTINE cp_testfunc1a RENAME TO cp_testfunc1;
-ALTER ROUTINE ptest1(text) RENAME TO ptest1a;
-ALTER ROUTINE ptest1a RENAME TO ptest1;
-DROP ROUTINE cp_testfunc1(int);
--- cleanup
-DROP PROCEDURE ptest1;
-DROP PROCEDURE ptest1s;
-DROP PROCEDURE ptest2;
-DROP TABLE cp_test;
-DROP USER regress_cp_user1;
diff -U3 /Users/kenaniah/workspace/postgres/src/test/regress/expected/create_index.out /Users/kenaniah/workspace/postgres/src/test/regress/results/create_index.out
--- /Users/kenaniah/workspace/postgres/src/test/regress/expected/create_index.out	2021-10-03 17:41:49.000000000 -0700
+++ /Users/kenaniah/workspace/postgres/src/test/regress/results/create_index.out	2021-10-03 20:08:14.000000000 -0700
@@ -1230,1570 +1230,11 @@
 CREATE INDEX gin_relopts_test ON array_index_op_test USING gin (i)
   WITH (FASTUPDATE=on, GIN_PENDING_LIST_LIMIT=128);
 \d+ gin_relopts_test
-                Index "public.gin_relopts_test"
- Column |  Type   | Key? | Definition | Storage | Stats target 
---------+---------+------+------------+---------+--------------
- i      | integer | yes  | i          | plain   | 
-gin, for table "public.array_index_op_test"
-Options: fastupdate=on, gin_pending_list_limit=128
+dyld: lazy symbol binding failed: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
+
+dyld: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
 
---
--- HASH
---
-CREATE INDEX hash_i4_index ON hash_i4_heap USING hash (random int4_ops);
-CREATE INDEX hash_name_index ON hash_name_heap USING hash (random name_ops);
-CREATE INDEX hash_txt_index ON hash_txt_heap USING hash (random text_ops);
-CREATE INDEX hash_f8_index ON hash_f8_heap USING hash (random float8_ops) WITH (fillfactor=60);
-CREATE UNLOGGED TABLE unlogged_hash_table (id int4);
-CREATE INDEX unlogged_hash_index ON unlogged_hash_table USING hash (id int4_ops);
-DROP TABLE unlogged_hash_table;
--- CREATE INDEX hash_ovfl_index ON hash_ovfl_heap USING hash (x int4_ops);
--- Test hash index build tuplesorting.  Force hash tuplesort using low
--- maintenance_work_mem setting and fillfactor:
-SET maintenance_work_mem = '1MB';
-CREATE INDEX hash_tuplesort_idx ON tenk1 USING hash (stringu1 name_ops) WITH (fillfactor = 10);
-EXPLAIN (COSTS OFF)
-SELECT count(*) FROM tenk1 WHERE stringu1 = 'TVAAAA';
-                      QUERY PLAN                       
--------------------------------------------------------
- Aggregate
-   ->  Bitmap Heap Scan on tenk1
-         Recheck Cond: (stringu1 = 'TVAAAA'::name)
-         ->  Bitmap Index Scan on hash_tuplesort_idx
-               Index Cond: (stringu1 = 'TVAAAA'::name)
-(5 rows)
-
-SELECT count(*) FROM tenk1 WHERE stringu1 = 'TVAAAA';
- count 
--------
-    14
-(1 row)
-
-DROP INDEX hash_tuplesort_idx;
-RESET maintenance_work_mem;
---
--- Test functional index
---
-CREATE TABLE func_index_heap (f1 text, f2 text);
-CREATE UNIQUE INDEX func_index_index on func_index_heap (textcat(f1,f2));
-INSERT INTO func_index_heap VALUES('ABC','DEF');
-INSERT INTO func_index_heap VALUES('AB','CDEFG');
-INSERT INTO func_index_heap VALUES('QWE','RTY');
--- this should fail because of unique index:
-INSERT INTO func_index_heap VALUES('ABCD', 'EF');
-ERROR:  duplicate key value violates unique constraint "func_index_index"
-DETAIL:  Key (textcat(f1, f2))=(ABCDEF) already exists.
--- but this shouldn't:
-INSERT INTO func_index_heap VALUES('QWERTY');
--- while we're here, see that the metadata looks sane
-\d func_index_heap
-         Table "public.func_index_heap"
- Column | Type | Collation | Nullable | Default 
---------+------+-----------+----------+---------
- f1     | text |           |          | 
- f2     | text |           |          | 
-Indexes:
-    "func_index_index" UNIQUE, btree (textcat(f1, f2))
-
-\d func_index_index
-     Index "public.func_index_index"
- Column  | Type | Key? |   Definition    
----------+------+------+-----------------
- textcat | text | yes  | textcat(f1, f2)
-unique, btree, for table "public.func_index_heap"
-
---
--- Same test, expressional index
---
-DROP TABLE func_index_heap;
-CREATE TABLE func_index_heap (f1 text, f2 text);
-CREATE UNIQUE INDEX func_index_index on func_index_heap ((f1 || f2) text_ops);
-INSERT INTO func_index_heap VALUES('ABC','DEF');
-INSERT INTO func_index_heap VALUES('AB','CDEFG');
-INSERT INTO func_index_heap VALUES('QWE','RTY');
--- this should fail because of unique index:
-INSERT INTO func_index_heap VALUES('ABCD', 'EF');
-ERROR:  duplicate key value violates unique constraint "func_index_index"
-DETAIL:  Key ((f1 || f2))=(ABCDEF) already exists.
--- but this shouldn't:
-INSERT INTO func_index_heap VALUES('QWERTY');
--- while we're here, see that the metadata looks sane
-\d func_index_heap
-         Table "public.func_index_heap"
- Column | Type | Collation | Nullable | Default 
---------+------+-----------+----------+---------
- f1     | text |           |          | 
- f2     | text |           |          | 
-Indexes:
-    "func_index_index" UNIQUE, btree ((f1 || f2))
-
-\d func_index_index
-  Index "public.func_index_index"
- Column | Type | Key? | Definition 
---------+------+------+------------
- expr   | text | yes  | (f1 || f2)
-unique, btree, for table "public.func_index_heap"
-
--- this should fail because of unsafe column type (anonymous record)
-create index on func_index_heap ((f1 || f2), (row(f1, f2)));
-ERROR:  column "row" has pseudo-type record
---
--- Test unique index with included columns
---
-CREATE TABLE covering_index_heap (f1 int, f2 int, f3 text);
-CREATE UNIQUE INDEX covering_index_index on covering_index_heap (f1,f2) INCLUDE(f3);
-INSERT INTO covering_index_heap VALUES(1,1,'AAA');
-INSERT INTO covering_index_heap VALUES(1,2,'AAA');
--- this should fail because of unique index on f1,f2:
-INSERT INTO covering_index_heap VALUES(1,2,'BBB');
-ERROR:  duplicate key value violates unique constraint "covering_index_index"
-DETAIL:  Key (f1, f2)=(1, 2) already exists.
--- and this shouldn't:
-INSERT INTO covering_index_heap VALUES(1,4,'AAA');
--- Try to build index on table that already contains data
-CREATE UNIQUE INDEX covering_pkey on covering_index_heap (f1,f2) INCLUDE(f3);
--- Try to use existing covering index as primary key
-ALTER TABLE covering_index_heap ADD CONSTRAINT covering_pkey PRIMARY KEY USING INDEX
-covering_pkey;
-DROP TABLE covering_index_heap;
---
--- Also try building functional, expressional, and partial indexes on
--- tables that already contain data.
---
-create unique index hash_f8_index_1 on hash_f8_heap(abs(random));
-create unique index hash_f8_index_2 on hash_f8_heap((seqno + 1), random);
-create unique index hash_f8_index_3 on hash_f8_heap(random) where seqno > 1000;
---
--- Try some concurrent index builds
---
--- Unfortunately this only tests about half the code paths because there are
--- no concurrent updates happening to the table at the same time.
-CREATE TABLE concur_heap (f1 text, f2 text);
--- empty table
-CREATE INDEX CONCURRENTLY concur_index1 ON concur_heap(f2,f1);
-CREATE INDEX CONCURRENTLY IF NOT EXISTS concur_index1 ON concur_heap(f2,f1);
-NOTICE:  relation "concur_index1" already exists, skipping
-INSERT INTO concur_heap VALUES  ('a','b');
-INSERT INTO concur_heap VALUES  ('b','b');
--- unique index
-CREATE UNIQUE INDEX CONCURRENTLY concur_index2 ON concur_heap(f1);
-CREATE UNIQUE INDEX CONCURRENTLY IF NOT EXISTS concur_index2 ON concur_heap(f1);
-NOTICE:  relation "concur_index2" already exists, skipping
--- check if constraint is set up properly to be enforced
-INSERT INTO concur_heap VALUES ('b','x');
-ERROR:  duplicate key value violates unique constraint "concur_index2"
-DETAIL:  Key (f1)=(b) already exists.
--- check if constraint is enforced properly at build time
-CREATE UNIQUE INDEX CONCURRENTLY concur_index3 ON concur_heap(f2);
-ERROR:  could not create unique index "concur_index3"
-DETAIL:  Key (f2)=(b) is duplicated.
--- test that expression indexes and partial indexes work concurrently
-CREATE INDEX CONCURRENTLY concur_index4 on concur_heap(f2) WHERE f1='a';
-CREATE INDEX CONCURRENTLY concur_index5 on concur_heap(f2) WHERE f1='x';
--- here we also check that you can default the index name
-CREATE INDEX CONCURRENTLY on concur_heap((f2||f1));
--- You can't do a concurrent index build in a transaction
-BEGIN;
-CREATE INDEX CONCURRENTLY concur_index7 ON concur_heap(f1);
-ERROR:  CREATE INDEX CONCURRENTLY cannot run inside a transaction block
-COMMIT;
--- test where predicate is able to do a transactional update during
--- a concurrent build before switching pg_index state flags.
-CREATE FUNCTION predicate_stable() RETURNS bool IMMUTABLE
-LANGUAGE plpgsql AS $$
-BEGIN
-  EXECUTE 'SELECT txid_current()';
-  RETURN true;
-END; $$;
-CREATE INDEX CONCURRENTLY concur_index8 ON concur_heap (f1)
-  WHERE predicate_stable();
-DROP INDEX concur_index8;
-DROP FUNCTION predicate_stable();
--- But you can do a regular index build in a transaction
-BEGIN;
-CREATE INDEX std_index on concur_heap(f2);
-COMMIT;
--- Failed builds are left invalid by VACUUM FULL, fixed by REINDEX
-VACUUM FULL concur_heap;
-REINDEX TABLE concur_heap;
-ERROR:  could not create unique index "concur_index3"
-DETAIL:  Key (f2)=(b) is duplicated.
-DELETE FROM concur_heap WHERE f1 = 'b';
-VACUUM FULL concur_heap;
-\d concur_heap
-           Table "public.concur_heap"
- Column | Type | Collation | Nullable | Default 
---------+------+-----------+----------+---------
- f1     | text |           |          | 
- f2     | text |           |          | 
-Indexes:
-    "concur_heap_expr_idx" btree ((f2 || f1))
-    "concur_index1" btree (f2, f1)
-    "concur_index2" UNIQUE, btree (f1)
-    "concur_index3" UNIQUE, btree (f2) INVALID
-    "concur_index4" btree (f2) WHERE f1 = 'a'::text
-    "concur_index5" btree (f2) WHERE f1 = 'x'::text
-    "std_index" btree (f2)
-
-REINDEX TABLE concur_heap;
-\d concur_heap
-           Table "public.concur_heap"
- Column | Type | Collation | Nullable | Default 
---------+------+-----------+----------+---------
- f1     | text |           |          | 
- f2     | text |           |          | 
-Indexes:
-    "concur_heap_expr_idx" btree ((f2 || f1))
-    "concur_index1" btree (f2, f1)
-    "concur_index2" UNIQUE, btree (f1)
-    "concur_index3" UNIQUE, btree (f2)
-    "concur_index4" btree (f2) WHERE f1 = 'a'::text
-    "concur_index5" btree (f2) WHERE f1 = 'x'::text
-    "std_index" btree (f2)
-
--- Temporary tables with concurrent builds and on-commit actions
--- CONCURRENTLY used with CREATE INDEX and DROP INDEX is ignored.
--- PRESERVE ROWS, the default.
-CREATE TEMP TABLE concur_temp (f1 int, f2 text)
-  ON COMMIT PRESERVE ROWS;
-INSERT INTO concur_temp VALUES (1, 'foo'), (2, 'bar');
-CREATE INDEX CONCURRENTLY concur_temp_ind ON concur_temp(f1);
-DROP INDEX CONCURRENTLY concur_temp_ind;
-DROP TABLE concur_temp;
--- ON COMMIT DROP
-BEGIN;
-CREATE TEMP TABLE concur_temp (f1 int, f2 text)
-  ON COMMIT DROP;
-INSERT INTO concur_temp VALUES (1, 'foo'), (2, 'bar');
--- Fails when running in a transaction.
-CREATE INDEX CONCURRENTLY concur_temp_ind ON concur_temp(f1);
-ERROR:  CREATE INDEX CONCURRENTLY cannot run inside a transaction block
-COMMIT;
--- ON COMMIT DELETE ROWS
-CREATE TEMP TABLE concur_temp (f1 int, f2 text)
-  ON COMMIT DELETE ROWS;
-INSERT INTO concur_temp VALUES (1, 'foo'), (2, 'bar');
-CREATE INDEX CONCURRENTLY concur_temp_ind ON concur_temp(f1);
-DROP INDEX CONCURRENTLY concur_temp_ind;
-DROP TABLE concur_temp;
---
--- Try some concurrent index drops
---
-DROP INDEX CONCURRENTLY "concur_index2";				-- works
-DROP INDEX CONCURRENTLY IF EXISTS "concur_index2";		-- notice
-NOTICE:  index "concur_index2" does not exist, skipping
--- failures
-DROP INDEX CONCURRENTLY "concur_index2", "concur_index3";
-ERROR:  DROP INDEX CONCURRENTLY does not support dropping multiple objects
-BEGIN;
-DROP INDEX CONCURRENTLY "concur_index5";
-ERROR:  DROP INDEX CONCURRENTLY cannot run inside a transaction block
-ROLLBACK;
--- successes
-DROP INDEX CONCURRENTLY IF EXISTS "concur_index3";
-DROP INDEX CONCURRENTLY "concur_index4";
-DROP INDEX CONCURRENTLY "concur_index5";
-DROP INDEX CONCURRENTLY "concur_index1";
-DROP INDEX CONCURRENTLY "concur_heap_expr_idx";
-\d concur_heap
-           Table "public.concur_heap"
- Column | Type | Collation | Nullable | Default 
---------+------+-----------+----------+---------
- f1     | text |           |          | 
- f2     | text |           |          | 
-Indexes:
-    "std_index" btree (f2)
-
-DROP TABLE concur_heap;
---
--- Test ADD CONSTRAINT USING INDEX
---
-CREATE TABLE cwi_test( a int , b varchar(10), c char);
--- add some data so that all tests have something to work with.
-INSERT INTO cwi_test VALUES(1, 2), (3, 4), (5, 6);
-CREATE UNIQUE INDEX cwi_uniq_idx ON cwi_test(a , b);
-ALTER TABLE cwi_test ADD primary key USING INDEX cwi_uniq_idx;
-\d cwi_test
-                     Table "public.cwi_test"
- Column |         Type          | Collation | Nullable | Default 
---------+-----------------------+-----------+----------+---------
- a      | integer               |           | not null | 
- b      | character varying(10) |           | not null | 
- c      | character(1)          |           |          | 
-Indexes:
-    "cwi_uniq_idx" PRIMARY KEY, btree (a, b)
-
-\d cwi_uniq_idx
-            Index "public.cwi_uniq_idx"
- Column |         Type          | Key? | Definition 
---------+-----------------------+------+------------
- a      | integer               | yes  | a
- b      | character varying(10) | yes  | b
-primary key, btree, for table "public.cwi_test"
-
-CREATE UNIQUE INDEX cwi_uniq2_idx ON cwi_test(b , a);
-ALTER TABLE cwi_test DROP CONSTRAINT cwi_uniq_idx,
-	ADD CONSTRAINT cwi_replaced_pkey PRIMARY KEY
-		USING INDEX cwi_uniq2_idx;
-NOTICE:  ALTER TABLE / ADD CONSTRAINT USING INDEX will rename index "cwi_uniq2_idx" to "cwi_replaced_pkey"
-\d cwi_test
-                     Table "public.cwi_test"
- Column |         Type          | Collation | Nullable | Default 
---------+-----------------------+-----------+----------+---------
- a      | integer               |           | not null | 
- b      | character varying(10) |           | not null | 
- c      | character(1)          |           |          | 
-Indexes:
-    "cwi_replaced_pkey" PRIMARY KEY, btree (b, a)
-
-\d cwi_replaced_pkey
-          Index "public.cwi_replaced_pkey"
- Column |         Type          | Key? | Definition 
---------+-----------------------+------+------------
- b      | character varying(10) | yes  | b
- a      | integer               | yes  | a
-primary key, btree, for table "public.cwi_test"
-
-DROP INDEX cwi_replaced_pkey;	-- Should fail; a constraint depends on it
-ERROR:  cannot drop index cwi_replaced_pkey because constraint cwi_replaced_pkey on table cwi_test requires it
-HINT:  You can drop constraint cwi_replaced_pkey on table cwi_test instead.
--- Check that non-default index options are rejected
-CREATE UNIQUE INDEX cwi_uniq3_idx ON cwi_test(a desc);
-ALTER TABLE cwi_test ADD UNIQUE USING INDEX cwi_uniq3_idx;  -- fail
-ERROR:  index "cwi_uniq3_idx" column number 1 does not have default sorting behavior
-LINE 1: ALTER TABLE cwi_test ADD UNIQUE USING INDEX cwi_uniq3_idx;
-                                 ^
-DETAIL:  Cannot create a primary key or unique constraint using such an index.
-CREATE UNIQUE INDEX cwi_uniq4_idx ON cwi_test(b collate "POSIX");
-ALTER TABLE cwi_test ADD UNIQUE USING INDEX cwi_uniq4_idx;  -- fail
-ERROR:  index "cwi_uniq4_idx" column number 1 does not have default sorting behavior
-LINE 1: ALTER TABLE cwi_test ADD UNIQUE USING INDEX cwi_uniq4_idx;
-                                 ^
-DETAIL:  Cannot create a primary key or unique constraint using such an index.
-DROP TABLE cwi_test;
--- ADD CONSTRAINT USING INDEX is forbidden on partitioned tables
-CREATE TABLE cwi_test(a int) PARTITION BY hash (a);
-create unique index on cwi_test (a);
-alter table cwi_test add primary key using index cwi_test_a_idx ;
-ERROR:  ALTER TABLE / ADD CONSTRAINT USING INDEX is not supported on partitioned tables
-DROP TABLE cwi_test;
---
--- Check handling of indexes on system columns
---
-CREATE TABLE syscol_table (a INT);
--- System columns cannot be indexed
-CREATE INDEX ON syscolcol_table (ctid);
-ERROR:  relation "syscolcol_table" does not exist
--- nor used in expressions
-CREATE INDEX ON syscol_table ((ctid >= '(1000,0)'));
-ERROR:  index creation on system columns is not supported
--- nor used in predicates
-CREATE INDEX ON syscol_table (a) WHERE ctid >= '(1000,0)';
-ERROR:  index creation on system columns is not supported
-DROP TABLE syscol_table;
---
--- Tests for IS NULL/IS NOT NULL with b-tree indexes
---
-CREATE TABLE onek_with_null AS SELECT unique1, unique2 FROM onek;
-INSERT INTO onek_with_null (unique1,unique2) VALUES (NULL, -1), (NULL, NULL);
-CREATE UNIQUE INDEX onek_nulltest ON onek_with_null (unique2,unique1);
-SET enable_seqscan = OFF;
-SET enable_indexscan = ON;
-SET enable_bitmapscan = ON;
-SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL;
- count 
--------
-     2
-(1 row)
-
-SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NULL;
- count 
--------
-     1
-(1 row)
-
-SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL;
- count 
--------
-  1000
-(1 row)
-
-SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NOT NULL;
- count 
--------
-     1
-(1 row)
-
-SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL AND unique1 > 500;
- count 
--------
-   499
-(1 row)
-
-SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique1 > 500;
- count 
--------
-     0
-(1 row)
-
-DROP INDEX onek_nulltest;
-CREATE UNIQUE INDEX onek_nulltest ON onek_with_null (unique2 desc,unique1);
-SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL;
- count 
--------
-     2
-(1 row)
-
-SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NULL;
- count 
--------
-     1
-(1 row)
-
-SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL;
- count 
--------
-  1000
-(1 row)
-
-SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NOT NULL;
- count 
--------
-     1
-(1 row)
-
-SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL AND unique1 > 500;
- count 
--------
-   499
-(1 row)
-
-SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique1 > 500;
- count 
--------
-     0
-(1 row)
-
-DROP INDEX onek_nulltest;
-CREATE UNIQUE INDEX onek_nulltest ON onek_with_null (unique2 desc nulls last,unique1);
-SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL;
- count 
--------
-     2
-(1 row)
-
-SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NULL;
- count 
--------
-     1
-(1 row)
-
-SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL;
- count 
--------
-  1000
-(1 row)
-
-SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NOT NULL;
- count 
--------
-     1
-(1 row)
-
-SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL AND unique1 > 500;
- count 
--------
-   499
-(1 row)
-
-SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique1 > 500;
- count 
--------
-     0
-(1 row)
-
-DROP INDEX onek_nulltest;
-CREATE UNIQUE INDEX onek_nulltest ON onek_with_null (unique2  nulls first,unique1);
-SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL;
- count 
--------
-     2
-(1 row)
-
-SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NULL;
- count 
--------
-     1
-(1 row)
-
-SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL;
- count 
--------
-  1000
-(1 row)
-
-SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NOT NULL;
- count 
--------
-     1
-(1 row)
-
-SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL AND unique1 > 500;
- count 
--------
-   499
-(1 row)
-
-SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique1 > 500;
- count 
--------
-     0
-(1 row)
-
-DROP INDEX onek_nulltest;
--- Check initial-positioning logic too
-CREATE UNIQUE INDEX onek_nulltest ON onek_with_null (unique2);
-SET enable_seqscan = OFF;
-SET enable_indexscan = ON;
-SET enable_bitmapscan = OFF;
-SELECT unique1, unique2 FROM onek_with_null
-  ORDER BY unique2 LIMIT 2;
- unique1 | unique2 
----------+---------
-         |      -1
-     147 |       0
-(2 rows)
-
-SELECT unique1, unique2 FROM onek_with_null WHERE unique2 >= -1
-  ORDER BY unique2 LIMIT 2;
- unique1 | unique2 
----------+---------
-         |      -1
-     147 |       0
-(2 rows)
-
-SELECT unique1, unique2 FROM onek_with_null WHERE unique2 >= 0
-  ORDER BY unique2 LIMIT 2;
- unique1 | unique2 
----------+---------
-     147 |       0
-     931 |       1
-(2 rows)
-
-SELECT unique1, unique2 FROM onek_with_null
-  ORDER BY unique2 DESC LIMIT 2;
- unique1 | unique2 
----------+---------
-         |        
-     278 |     999
-(2 rows)
-
-SELECT unique1, unique2 FROM onek_with_null WHERE unique2 >= -1
-  ORDER BY unique2 DESC LIMIT 2;
- unique1 | unique2 
----------+---------
-     278 |     999
-       0 |     998
-(2 rows)
-
-SELECT unique1, unique2 FROM onek_with_null WHERE unique2 < 999
-  ORDER BY unique2 DESC LIMIT 2;
- unique1 | unique2 
----------+---------
-       0 |     998
-     744 |     997
-(2 rows)
-
-RESET enable_seqscan;
-RESET enable_indexscan;
-RESET enable_bitmapscan;
-DROP TABLE onek_with_null;
---
--- Check bitmap index path planning
---
-EXPLAIN (COSTS OFF)
-SELECT * FROM tenk1
-  WHERE thousand = 42 AND (tenthous = 1 OR tenthous = 3 OR tenthous = 42);
-                                                               QUERY PLAN                                                                
------------------------------------------------------------------------------------------------------------------------------------------
- Bitmap Heap Scan on tenk1
-   Recheck Cond: (((thousand = 42) AND (tenthous = 1)) OR ((thousand = 42) AND (tenthous = 3)) OR ((thousand = 42) AND (tenthous = 42)))
-   ->  BitmapOr
-         ->  Bitmap Index Scan on tenk1_thous_tenthous
-               Index Cond: ((thousand = 42) AND (tenthous = 1))
-         ->  Bitmap Index Scan on tenk1_thous_tenthous
-               Index Cond: ((thousand = 42) AND (tenthous = 3))
-         ->  Bitmap Index Scan on tenk1_thous_tenthous
-               Index Cond: ((thousand = 42) AND (tenthous = 42))
-(9 rows)
-
-SELECT * FROM tenk1
-  WHERE thousand = 42 AND (tenthous = 1 OR tenthous = 3 OR tenthous = 42);
- unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
----------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
-      42 |    5530 |   0 |    2 |   2 |      2 |      42 |       42 |          42 |        42 |       42 |  84 |   85 | QBAAAA   | SEIAAA   | OOOOxx
-(1 row)
-
-EXPLAIN (COSTS OFF)
-SELECT count(*) FROM tenk1
-  WHERE hundred = 42 AND (thousand = 42 OR thousand = 99);
-                                   QUERY PLAN                                    
----------------------------------------------------------------------------------
- Aggregate
-   ->  Bitmap Heap Scan on tenk1
-         Recheck Cond: ((hundred = 42) AND ((thousand = 42) OR (thousand = 99)))
-         ->  BitmapAnd
-               ->  Bitmap Index Scan on tenk1_hundred
-                     Index Cond: (hundred = 42)
-               ->  BitmapOr
-                     ->  Bitmap Index Scan on tenk1_thous_tenthous
-                           Index Cond: (thousand = 42)
-                     ->  Bitmap Index Scan on tenk1_thous_tenthous
-                           Index Cond: (thousand = 99)
-(11 rows)
-
-SELECT count(*) FROM tenk1
-  WHERE hundred = 42 AND (thousand = 42 OR thousand = 99);
- count 
--------
-    10
-(1 row)
-
---
--- Check behavior with duplicate index column contents
---
-CREATE TABLE dupindexcols AS
-  SELECT unique1 as id, stringu2::text as f1 FROM tenk1;
-CREATE INDEX dupindexcols_i ON dupindexcols (f1, id, f1 text_pattern_ops);
-ANALYZE dupindexcols;
-EXPLAIN (COSTS OFF)
-  SELECT count(*) FROM dupindexcols
-    WHERE f1 BETWEEN 'WA' AND 'ZZZ' and id < 1000 and f1 ~<~ 'YX';
-                                                   QUERY PLAN                                                   
-----------------------------------------------------------------------------------------------------------------
- Aggregate
-   ->  Bitmap Heap Scan on dupindexcols
-         Recheck Cond: ((f1 >= 'WA'::text) AND (f1 <= 'ZZZ'::text) AND (id < 1000) AND (f1 ~<~ 'YX'::text))
-         ->  Bitmap Index Scan on dupindexcols_i
-               Index Cond: ((f1 >= 'WA'::text) AND (f1 <= 'ZZZ'::text) AND (id < 1000) AND (f1 ~<~ 'YX'::text))
-(5 rows)
-
-SELECT count(*) FROM dupindexcols
-  WHERE f1 BETWEEN 'WA' AND 'ZZZ' and id < 1000 and f1 ~<~ 'YX';
- count 
--------
-    97
-(1 row)
-
---
--- Check ordering of =ANY indexqual results (bug in 9.2.0)
---
-vacuum tenk1;		-- ensure we get consistent plans here
-explain (costs off)
-SELECT unique1 FROM tenk1
-WHERE unique1 IN (1,42,7)
-ORDER BY unique1;
-                      QUERY PLAN                       
--------------------------------------------------------
- Index Only Scan using tenk1_unique1 on tenk1
-   Index Cond: (unique1 = ANY ('{1,42,7}'::integer[]))
-(2 rows)
-
-SELECT unique1 FROM tenk1
-WHERE unique1 IN (1,42,7)
-ORDER BY unique1;
- unique1 
----------
-       1
-       7
-      42
-(3 rows)
-
-explain (costs off)
-SELECT thousand, tenthous FROM tenk1
-WHERE thousand < 2 AND tenthous IN (1001,3000)
-ORDER BY thousand;
-                      QUERY PLAN                       
--------------------------------------------------------
- Index Only Scan using tenk1_thous_tenthous on tenk1
-   Index Cond: (thousand < 2)
-   Filter: (tenthous = ANY ('{1001,3000}'::integer[]))
-(3 rows)
-
-SELECT thousand, tenthous FROM tenk1
-WHERE thousand < 2 AND tenthous IN (1001,3000)
-ORDER BY thousand;
- thousand | tenthous 
-----------+----------
-        0 |     3000
-        1 |     1001
-(2 rows)
-
-SET enable_indexonlyscan = OFF;
-explain (costs off)
-SELECT thousand, tenthous FROM tenk1
-WHERE thousand < 2 AND tenthous IN (1001,3000)
-ORDER BY thousand;
-                                      QUERY PLAN                                      
---------------------------------------------------------------------------------------
- Sort
-   Sort Key: thousand
-   ->  Index Scan using tenk1_thous_tenthous on tenk1
-         Index Cond: ((thousand < 2) AND (tenthous = ANY ('{1001,3000}'::integer[])))
-(4 rows)
-
-SELECT thousand, tenthous FROM tenk1
-WHERE thousand < 2 AND tenthous IN (1001,3000)
-ORDER BY thousand;
- thousand | tenthous 
-----------+----------
-        0 |     3000
-        1 |     1001
-(2 rows)
-
-RESET enable_indexonlyscan;
---
--- Check elimination of constant-NULL subexpressions
---
-explain (costs off)
-  select * from tenk1 where (thousand, tenthous) in ((1,1001), (null,null));
-                      QUERY PLAN                      
-------------------------------------------------------
- Index Scan using tenk1_thous_tenthous on tenk1
-   Index Cond: ((thousand = 1) AND (tenthous = 1001))
-(2 rows)
-
---
--- Check matching of boolean index columns to WHERE conditions and sort keys
---
-create temp table boolindex (b bool, i int, unique(b, i), junk float);
-explain (costs off)
-  select * from boolindex order by b, i limit 10;
-                      QUERY PLAN                       
--------------------------------------------------------
- Limit
-   ->  Index Scan using boolindex_b_i_key on boolindex
-(2 rows)
-
-explain (costs off)
-  select * from boolindex where b order by i limit 10;
-                      QUERY PLAN                       
--------------------------------------------------------
- Limit
-   ->  Index Scan using boolindex_b_i_key on boolindex
-         Index Cond: (b = true)
-(3 rows)
-
-explain (costs off)
-  select * from boolindex where b = true order by i desc limit 10;
-                           QUERY PLAN                           
-----------------------------------------------------------------
- Limit
-   ->  Index Scan Backward using boolindex_b_i_key on boolindex
-         Index Cond: (b = true)
-(3 rows)
-
-explain (costs off)
-  select * from boolindex where not b order by i limit 10;
-                      QUERY PLAN                       
--------------------------------------------------------
- Limit
-   ->  Index Scan using boolindex_b_i_key on boolindex
-         Index Cond: (b = false)
-(3 rows)
-
-explain (costs off)
-  select * from boolindex where b is true order by i desc limit 10;
-                           QUERY PLAN                           
-----------------------------------------------------------------
- Limit
-   ->  Index Scan Backward using boolindex_b_i_key on boolindex
-         Index Cond: (b = true)
-(3 rows)
-
-explain (costs off)
-  select * from boolindex where b is false order by i desc limit 10;
-                           QUERY PLAN                           
-----------------------------------------------------------------
- Limit
-   ->  Index Scan Backward using boolindex_b_i_key on boolindex
-         Index Cond: (b = false)
-(3 rows)
-
---
--- REINDEX (VERBOSE)
---
-CREATE TABLE reindex_verbose(id integer primary key);
-\set VERBOSITY terse \\ -- suppress machine-dependent details
-REINDEX (VERBOSE) TABLE reindex_verbose;
-INFO:  index "reindex_verbose_pkey" was reindexed
-\set VERBOSITY default
-DROP TABLE reindex_verbose;
---
--- REINDEX CONCURRENTLY
---
-CREATE TABLE concur_reindex_tab (c1 int);
--- REINDEX
-REINDEX TABLE concur_reindex_tab; -- notice
-NOTICE:  table "concur_reindex_tab" has no indexes to reindex
-REINDEX (CONCURRENTLY) TABLE concur_reindex_tab; -- notice
-NOTICE:  table "concur_reindex_tab" has no indexes that can be reindexed concurrently
-ALTER TABLE concur_reindex_tab ADD COLUMN c2 text; -- add toast index
--- Normal index with integer column
-CREATE UNIQUE INDEX concur_reindex_ind1 ON concur_reindex_tab(c1);
--- Normal index with text column
-CREATE INDEX concur_reindex_ind2 ON concur_reindex_tab(c2);
--- UNIQUE index with expression
-CREATE UNIQUE INDEX concur_reindex_ind3 ON concur_reindex_tab(abs(c1));
--- Duplicate column names
-CREATE INDEX concur_reindex_ind4 ON concur_reindex_tab(c1, c1, c2);
--- Create table for check on foreign key dependence switch with indexes swapped
-ALTER TABLE concur_reindex_tab ADD PRIMARY KEY USING INDEX concur_reindex_ind1;
-CREATE TABLE concur_reindex_tab2 (c1 int REFERENCES concur_reindex_tab);
-INSERT INTO concur_reindex_tab VALUES  (1, 'a');
-INSERT INTO concur_reindex_tab VALUES  (2, 'a');
--- Reindex concurrently of exclusion constraint currently not supported
-CREATE TABLE concur_reindex_tab3 (c1 int, c2 int4range, EXCLUDE USING gist (c2 WITH &&));
-INSERT INTO concur_reindex_tab3 VALUES  (3, '[1,2]');
-REINDEX INDEX CONCURRENTLY  concur_reindex_tab3_c2_excl;  -- error
-ERROR:  concurrent index creation for exclusion constraints is not supported
-REINDEX TABLE CONCURRENTLY concur_reindex_tab3;  -- succeeds with warning
-WARNING:  cannot reindex exclusion constraint index "public.concur_reindex_tab3_c2_excl" concurrently, skipping
-INSERT INTO concur_reindex_tab3 VALUES  (4, '[2,4]');
-ERROR:  conflicting key value violates exclusion constraint "concur_reindex_tab3_c2_excl"
-DETAIL:  Key (c2)=([2,5)) conflicts with existing key (c2)=([1,3)).
--- Check materialized views
-CREATE MATERIALIZED VIEW concur_reindex_matview AS SELECT * FROM concur_reindex_tab;
--- Dependency lookup before and after the follow-up REINDEX commands.
--- These should remain consistent.
-SELECT pg_describe_object(classid, objid, objsubid) as obj,
-       pg_describe_object(refclassid,refobjid,refobjsubid) as objref,
-       deptype
-FROM pg_depend
-WHERE classid = 'pg_class'::regclass AND
-  objid in ('concur_reindex_tab'::regclass,
-            'concur_reindex_ind1'::regclass,
-	    'concur_reindex_ind2'::regclass,
-	    'concur_reindex_ind3'::regclass,
-	    'concur_reindex_ind4'::regclass,
-	    'concur_reindex_matview'::regclass)
-  ORDER BY 1, 2;
-                   obj                    |                           objref                           | deptype 
-------------------------------------------+------------------------------------------------------------+---------
- index concur_reindex_ind1                | constraint concur_reindex_ind1 on table concur_reindex_tab | i
- index concur_reindex_ind2                | column c2 of table concur_reindex_tab                      | a
- index concur_reindex_ind3                | column c1 of table concur_reindex_tab                      | a
- index concur_reindex_ind3                | table concur_reindex_tab                                   | a
- index concur_reindex_ind4                | column c1 of table concur_reindex_tab                      | a
- index concur_reindex_ind4                | column c2 of table concur_reindex_tab                      | a
- materialized view concur_reindex_matview | schema public                                              | n
- table concur_reindex_tab                 | schema public                                              | n
-(8 rows)
-
-REINDEX INDEX CONCURRENTLY concur_reindex_ind1;
-REINDEX TABLE CONCURRENTLY concur_reindex_tab;
-REINDEX TABLE CONCURRENTLY concur_reindex_matview;
-SELECT pg_describe_object(classid, objid, objsubid) as obj,
-       pg_describe_object(refclassid,refobjid,refobjsubid) as objref,
-       deptype
-FROM pg_depend
-WHERE classid = 'pg_class'::regclass AND
-  objid in ('concur_reindex_tab'::regclass,
-            'concur_reindex_ind1'::regclass,
-	    'concur_reindex_ind2'::regclass,
-	    'concur_reindex_ind3'::regclass,
-	    'concur_reindex_ind4'::regclass,
-	    'concur_reindex_matview'::regclass)
-  ORDER BY 1, 2;
-                   obj                    |                           objref                           | deptype 
-------------------------------------------+------------------------------------------------------------+---------
- index concur_reindex_ind1                | constraint concur_reindex_ind1 on table concur_reindex_tab | i
- index concur_reindex_ind2                | column c2 of table concur_reindex_tab                      | a
- index concur_reindex_ind3                | column c1 of table concur_reindex_tab                      | a
- index concur_reindex_ind3                | table concur_reindex_tab                                   | a
- index concur_reindex_ind4                | column c1 of table concur_reindex_tab                      | a
- index concur_reindex_ind4                | column c2 of table concur_reindex_tab                      | a
- materialized view concur_reindex_matview | schema public                                              | n
- table concur_reindex_tab                 | schema public                                              | n
-(8 rows)
-
--- Check that comments are preserved
-CREATE TABLE testcomment (i int);
-CREATE INDEX testcomment_idx1 ON testcomment (i);
-COMMENT ON INDEX testcomment_idx1 IS 'test comment';
-SELECT obj_description('testcomment_idx1'::regclass, 'pg_class');
- obj_description 
------------------
- test comment
-(1 row)
-
-REINDEX TABLE testcomment;
-SELECT obj_description('testcomment_idx1'::regclass, 'pg_class');
- obj_description 
------------------
- test comment
-(1 row)
-
-REINDEX TABLE CONCURRENTLY testcomment ;
-SELECT obj_description('testcomment_idx1'::regclass, 'pg_class');
- obj_description 
------------------
- test comment
-(1 row)
-
-DROP TABLE testcomment;
--- Check that indisclustered updates are preserved
-CREATE TABLE concur_clustered(i int);
-CREATE INDEX concur_clustered_i_idx ON concur_clustered(i);
-ALTER TABLE concur_clustered CLUSTER ON concur_clustered_i_idx;
-REINDEX TABLE CONCURRENTLY concur_clustered;
-SELECT indexrelid::regclass, indisclustered FROM pg_index
-  WHERE indrelid = 'concur_clustered'::regclass;
-       indexrelid       | indisclustered 
-------------------------+----------------
- concur_clustered_i_idx | t
-(1 row)
-
-DROP TABLE concur_clustered;
--- Check that indisreplident updates are preserved.
-CREATE TABLE concur_replident(i int NOT NULL);
-CREATE UNIQUE INDEX concur_replident_i_idx ON concur_replident(i);
-ALTER TABLE concur_replident REPLICA IDENTITY
-  USING INDEX concur_replident_i_idx;
-SELECT indexrelid::regclass, indisreplident FROM pg_index
-  WHERE indrelid = 'concur_replident'::regclass;
-       indexrelid       | indisreplident 
-------------------------+----------------
- concur_replident_i_idx | t
-(1 row)
-
-REINDEX TABLE CONCURRENTLY concur_replident;
-SELECT indexrelid::regclass, indisreplident FROM pg_index
-  WHERE indrelid = 'concur_replident'::regclass;
-       indexrelid       | indisreplident 
-------------------------+----------------
- concur_replident_i_idx | t
-(1 row)
-
-DROP TABLE concur_replident;
--- Partitions
--- Create some partitioned tables
-CREATE TABLE concur_reindex_part (c1 int, c2 int) PARTITION BY RANGE (c1);
-CREATE TABLE concur_reindex_part_0 PARTITION OF concur_reindex_part
-  FOR VALUES FROM (0) TO (10) PARTITION BY list (c2);
-CREATE TABLE concur_reindex_part_0_1 PARTITION OF concur_reindex_part_0
-  FOR VALUES IN (1);
-CREATE TABLE concur_reindex_part_0_2 PARTITION OF concur_reindex_part_0
-  FOR VALUES IN (2);
--- This partitioned table will have no partitions.
-CREATE TABLE concur_reindex_part_10 PARTITION OF concur_reindex_part
-  FOR VALUES FROM (10) TO (20) PARTITION BY list (c2);
--- Create some partitioned indexes
-CREATE INDEX concur_reindex_part_index ON ONLY concur_reindex_part (c1);
-CREATE INDEX concur_reindex_part_index_0 ON ONLY concur_reindex_part_0 (c1);
-ALTER INDEX concur_reindex_part_index ATTACH PARTITION concur_reindex_part_index_0;
--- This partitioned index will have no partitions.
-CREATE INDEX concur_reindex_part_index_10 ON ONLY concur_reindex_part_10 (c1);
-ALTER INDEX concur_reindex_part_index ATTACH PARTITION concur_reindex_part_index_10;
-CREATE INDEX concur_reindex_part_index_0_1 ON ONLY concur_reindex_part_0_1 (c1);
-ALTER INDEX concur_reindex_part_index_0 ATTACH PARTITION concur_reindex_part_index_0_1;
-CREATE INDEX concur_reindex_part_index_0_2 ON ONLY concur_reindex_part_0_2 (c1);
-ALTER INDEX concur_reindex_part_index_0 ATTACH PARTITION concur_reindex_part_index_0_2;
-SELECT relid, parentrelid, level FROM pg_partition_tree('concur_reindex_part_index')
-  ORDER BY relid, level;
-             relid             |         parentrelid         | level 
--------------------------------+-----------------------------+-------
- concur_reindex_part_index     |                             |     0
- concur_reindex_part_index_0   | concur_reindex_part_index   |     1
- concur_reindex_part_index_10  | concur_reindex_part_index   |     1
- concur_reindex_part_index_0_1 | concur_reindex_part_index_0 |     2
- concur_reindex_part_index_0_2 | concur_reindex_part_index_0 |     2
-(5 rows)
-
-SELECT relid, parentrelid, level FROM pg_partition_tree('concur_reindex_part_index')
-  ORDER BY relid, level;
-             relid             |         parentrelid         | level 
--------------------------------+-----------------------------+-------
- concur_reindex_part_index     |                             |     0
- concur_reindex_part_index_0   | concur_reindex_part_index   |     1
- concur_reindex_part_index_10  | concur_reindex_part_index   |     1
- concur_reindex_part_index_0_1 | concur_reindex_part_index_0 |     2
- concur_reindex_part_index_0_2 | concur_reindex_part_index_0 |     2
-(5 rows)
-
--- REINDEX should preserve dependencies of partition tree.
-SELECT pg_describe_object(classid, objid, objsubid) as obj,
-       pg_describe_object(refclassid,refobjid,refobjsubid) as objref,
-       deptype
-FROM pg_depend
-WHERE classid = 'pg_class'::regclass AND
-  objid in ('concur_reindex_part'::regclass,
-            'concur_reindex_part_0'::regclass,
-            'concur_reindex_part_0_1'::regclass,
-            'concur_reindex_part_0_2'::regclass,
-            'concur_reindex_part_index'::regclass,
-            'concur_reindex_part_index_0'::regclass,
-            'concur_reindex_part_index_0_1'::regclass,
-            'concur_reindex_part_index_0_2'::regclass)
-  ORDER BY 1, 2;
-                   obj                    |                   objref                   | deptype 
-------------------------------------------+--------------------------------------------+---------
- column c1 of table concur_reindex_part   | table concur_reindex_part                  | i
- column c2 of table concur_reindex_part_0 | table concur_reindex_part_0                | i
- index concur_reindex_part_index          | column c1 of table concur_reindex_part     | a
- index concur_reindex_part_index_0        | column c1 of table concur_reindex_part_0   | a
- index concur_reindex_part_index_0        | index concur_reindex_part_index            | P
- index concur_reindex_part_index_0        | table concur_reindex_part_0                | S
- index concur_reindex_part_index_0_1      | column c1 of table concur_reindex_part_0_1 | a
- index concur_reindex_part_index_0_1      | index concur_reindex_part_index_0          | P
- index concur_reindex_part_index_0_1      | table concur_reindex_part_0_1              | S
- index concur_reindex_part_index_0_2      | column c1 of table concur_reindex_part_0_2 | a
- index concur_reindex_part_index_0_2      | index concur_reindex_part_index_0          | P
- index concur_reindex_part_index_0_2      | table concur_reindex_part_0_2              | S
- table concur_reindex_part                | schema public                              | n
- table concur_reindex_part_0              | schema public                              | n
- table concur_reindex_part_0              | table concur_reindex_part                  | a
- table concur_reindex_part_0_1            | schema public                              | n
- table concur_reindex_part_0_1            | table concur_reindex_part_0                | a
- table concur_reindex_part_0_2            | schema public                              | n
- table concur_reindex_part_0_2            | table concur_reindex_part_0                | a
-(19 rows)
-
-REINDEX INDEX CONCURRENTLY concur_reindex_part_index_0_1;
-REINDEX INDEX CONCURRENTLY concur_reindex_part_index_0_2;
-SELECT relid, parentrelid, level FROM pg_partition_tree('concur_reindex_part_index')
-  ORDER BY relid, level;
-             relid             |         parentrelid         | level 
--------------------------------+-----------------------------+-------
- concur_reindex_part_index     |                             |     0
- concur_reindex_part_index_0   | concur_reindex_part_index   |     1
- concur_reindex_part_index_10  | concur_reindex_part_index   |     1
- concur_reindex_part_index_0_1 | concur_reindex_part_index_0 |     2
- concur_reindex_part_index_0_2 | concur_reindex_part_index_0 |     2
-(5 rows)
-
-REINDEX TABLE CONCURRENTLY concur_reindex_part_0_1;
-REINDEX TABLE CONCURRENTLY concur_reindex_part_0_2;
-SELECT pg_describe_object(classid, objid, objsubid) as obj,
-       pg_describe_object(refclassid,refobjid,refobjsubid) as objref,
-       deptype
-FROM pg_depend
-WHERE classid = 'pg_class'::regclass AND
-  objid in ('concur_reindex_part'::regclass,
-            'concur_reindex_part_0'::regclass,
-            'concur_reindex_part_0_1'::regclass,
-            'concur_reindex_part_0_2'::regclass,
-            'concur_reindex_part_index'::regclass,
-            'concur_reindex_part_index_0'::regclass,
-            'concur_reindex_part_index_0_1'::regclass,
-            'concur_reindex_part_index_0_2'::regclass)
-  ORDER BY 1, 2;
-                   obj                    |                   objref                   | deptype 
-------------------------------------------+--------------------------------------------+---------
- column c1 of table concur_reindex_part   | table concur_reindex_part                  | i
- column c2 of table concur_reindex_part_0 | table concur_reindex_part_0                | i
- index concur_reindex_part_index          | column c1 of table concur_reindex_part     | a
- index concur_reindex_part_index_0        | column c1 of table concur_reindex_part_0   | a
- index concur_reindex_part_index_0        | index concur_reindex_part_index            | P
- index concur_reindex_part_index_0        | table concur_reindex_part_0                | S
- index concur_reindex_part_index_0_1      | column c1 of table concur_reindex_part_0_1 | a
- index concur_reindex_part_index_0_1      | index concur_reindex_part_index_0          | P
- index concur_reindex_part_index_0_1      | table concur_reindex_part_0_1              | S
- index concur_reindex_part_index_0_2      | column c1 of table concur_reindex_part_0_2 | a
- index concur_reindex_part_index_0_2      | index concur_reindex_part_index_0          | P
- index concur_reindex_part_index_0_2      | table concur_reindex_part_0_2              | S
- table concur_reindex_part                | schema public                              | n
- table concur_reindex_part_0              | schema public                              | n
- table concur_reindex_part_0              | table concur_reindex_part                  | a
- table concur_reindex_part_0_1            | schema public                              | n
- table concur_reindex_part_0_1            | table concur_reindex_part_0                | a
- table concur_reindex_part_0_2            | schema public                              | n
- table concur_reindex_part_0_2            | table concur_reindex_part_0                | a
-(19 rows)
-
-SELECT relid, parentrelid, level FROM pg_partition_tree('concur_reindex_part_index')
-  ORDER BY relid, level;
-             relid             |         parentrelid         | level 
--------------------------------+-----------------------------+-------
- concur_reindex_part_index     |                             |     0
- concur_reindex_part_index_0   | concur_reindex_part_index   |     1
- concur_reindex_part_index_10  | concur_reindex_part_index   |     1
- concur_reindex_part_index_0_1 | concur_reindex_part_index_0 |     2
- concur_reindex_part_index_0_2 | concur_reindex_part_index_0 |     2
-(5 rows)
-
--- REINDEX for partitioned indexes
--- REINDEX TABLE fails for partitioned indexes
--- Top-most parent index
-REINDEX TABLE concur_reindex_part_index; -- error
-ERROR:  "concur_reindex_part_index" is not a table or materialized view
-REINDEX TABLE CONCURRENTLY concur_reindex_part_index; -- error
-ERROR:  "concur_reindex_part_index" is not a table or materialized view
--- Partitioned index with no leaves
-REINDEX TABLE concur_reindex_part_index_10; -- error
-ERROR:  "concur_reindex_part_index_10" is not a table or materialized view
-REINDEX TABLE CONCURRENTLY concur_reindex_part_index_10; -- error
-ERROR:  "concur_reindex_part_index_10" is not a table or materialized view
--- Cannot run in a transaction block
-BEGIN;
-REINDEX INDEX concur_reindex_part_index;
-ERROR:  REINDEX INDEX cannot run inside a transaction block
-CONTEXT:  while reindexing partitioned index "public.concur_reindex_part_index"
-ROLLBACK;
--- Helper functions to track changes of relfilenodes in a partition tree.
--- Create a table tracking the relfilenode state.
-CREATE OR REPLACE FUNCTION create_relfilenode_part(relname text, indname text)
-  RETURNS VOID AS
-  $func$
-  BEGIN
-  EXECUTE format('
-    CREATE TABLE %I AS
-      SELECT oid, relname, relfilenode, relkind, reltoastrelid
-      FROM pg_class
-      WHERE oid IN
-         (SELECT relid FROM pg_partition_tree(''%I''));',
-	 relname, indname);
-  END
-  $func$ LANGUAGE plpgsql;
-CREATE OR REPLACE FUNCTION compare_relfilenode_part(tabname text)
-  RETURNS TABLE (relname name, relkind "char", state text) AS
-  $func$
-  BEGIN
-    RETURN QUERY EXECUTE
-      format(
-        'SELECT  b.relname,
-                 b.relkind,
-                 CASE WHEN a.relfilenode = b.relfilenode THEN ''relfilenode is unchanged''
-                 ELSE ''relfilenode has changed'' END
-           -- Do not join with OID here as CONCURRENTLY changes it.
-           FROM %I b JOIN pg_class a ON b.relname = a.relname
-           ORDER BY 1;', tabname);
-  END
-  $func$ LANGUAGE plpgsql;
---  Check that expected relfilenodes are changed, non-concurrent case.
-SELECT create_relfilenode_part('reindex_index_status', 'concur_reindex_part_index');
- create_relfilenode_part 
--------------------------
- 
-(1 row)
-
-REINDEX INDEX concur_reindex_part_index;
-SELECT * FROM compare_relfilenode_part('reindex_index_status');
-            relname            | relkind |          state           
--------------------------------+---------+--------------------------
- concur_reindex_part_index     | I       | relfilenode is unchanged
- concur_reindex_part_index_0   | I       | relfilenode is unchanged
- concur_reindex_part_index_0_1 | i       | relfilenode has changed
- concur_reindex_part_index_0_2 | i       | relfilenode has changed
- concur_reindex_part_index_10  | I       | relfilenode is unchanged
-(5 rows)
-
-DROP TABLE reindex_index_status;
--- concurrent case.
-SELECT create_relfilenode_part('reindex_index_status', 'concur_reindex_part_index');
- create_relfilenode_part 
--------------------------
- 
-(1 row)
-
-REINDEX INDEX CONCURRENTLY concur_reindex_part_index;
-SELECT * FROM compare_relfilenode_part('reindex_index_status');
-            relname            | relkind |          state           
--------------------------------+---------+--------------------------
- concur_reindex_part_index     | I       | relfilenode is unchanged
- concur_reindex_part_index_0   | I       | relfilenode is unchanged
- concur_reindex_part_index_0_1 | i       | relfilenode has changed
- concur_reindex_part_index_0_2 | i       | relfilenode has changed
- concur_reindex_part_index_10  | I       | relfilenode is unchanged
-(5 rows)
-
-DROP TABLE reindex_index_status;
--- REINDEX for partitioned tables
--- REINDEX INDEX fails for partitioned tables
--- Top-most parent
-REINDEX INDEX concur_reindex_part; -- error
-ERROR:  "concur_reindex_part" is not an index
-REINDEX INDEX CONCURRENTLY concur_reindex_part; -- error
-ERROR:  "concur_reindex_part" is not an index
--- Partitioned with no leaves
-REINDEX INDEX concur_reindex_part_10; -- error
-ERROR:  "concur_reindex_part_10" is not an index
-REINDEX INDEX CONCURRENTLY concur_reindex_part_10; -- error
-ERROR:  "concur_reindex_part_10" is not an index
--- Cannot run in a transaction block
-BEGIN;
-REINDEX TABLE concur_reindex_part;
-ERROR:  REINDEX TABLE cannot run inside a transaction block
-CONTEXT:  while reindexing partitioned table "public.concur_reindex_part"
-ROLLBACK;
--- Check that expected relfilenodes are changed, non-concurrent case.
--- Note that the partition tree changes of the *indexes* need to be checked.
-SELECT create_relfilenode_part('reindex_index_status', 'concur_reindex_part_index');
- create_relfilenode_part 
--------------------------
- 
-(1 row)
-
-REINDEX TABLE concur_reindex_part;
-SELECT * FROM compare_relfilenode_part('reindex_index_status');
-            relname            | relkind |          state           
--------------------------------+---------+--------------------------
- concur_reindex_part_index     | I       | relfilenode is unchanged
- concur_reindex_part_index_0   | I       | relfilenode is unchanged
- concur_reindex_part_index_0_1 | i       | relfilenode has changed
- concur_reindex_part_index_0_2 | i       | relfilenode has changed
- concur_reindex_part_index_10  | I       | relfilenode is unchanged
-(5 rows)
-
-DROP TABLE reindex_index_status;
--- concurrent case.
-SELECT create_relfilenode_part('reindex_index_status', 'concur_reindex_part_index');
- create_relfilenode_part 
--------------------------
- 
-(1 row)
-
-REINDEX TABLE CONCURRENTLY concur_reindex_part;
-SELECT * FROM compare_relfilenode_part('reindex_index_status');
-            relname            | relkind |          state           
--------------------------------+---------+--------------------------
- concur_reindex_part_index     | I       | relfilenode is unchanged
- concur_reindex_part_index_0   | I       | relfilenode is unchanged
- concur_reindex_part_index_0_1 | i       | relfilenode has changed
- concur_reindex_part_index_0_2 | i       | relfilenode has changed
- concur_reindex_part_index_10  | I       | relfilenode is unchanged
-(5 rows)
-
-DROP TABLE reindex_index_status;
-DROP FUNCTION create_relfilenode_part;
-DROP FUNCTION compare_relfilenode_part;
--- Cleanup of partition tree used for REINDEX test.
-DROP TABLE concur_reindex_part;
--- Check errors
--- Cannot run inside a transaction block
-BEGIN;
-REINDEX TABLE CONCURRENTLY concur_reindex_tab;
-ERROR:  REINDEX CONCURRENTLY cannot run inside a transaction block
-COMMIT;
-REINDEX TABLE CONCURRENTLY pg_class; -- no catalog relation
-ERROR:  cannot reindex system catalogs concurrently
-REINDEX INDEX CONCURRENTLY pg_class_oid_index; -- no catalog index
-ERROR:  cannot reindex system catalogs concurrently
--- These are the toast table and index of pg_authid.
-REINDEX TABLE CONCURRENTLY pg_toast.pg_toast_1260; -- no catalog toast table
-ERROR:  cannot reindex system catalogs concurrently
-REINDEX INDEX CONCURRENTLY pg_toast.pg_toast_1260_index; -- no catalog toast index
-ERROR:  cannot reindex system catalogs concurrently
-REINDEX SYSTEM CONCURRENTLY postgres; -- not allowed for SYSTEM
-ERROR:  cannot reindex system catalogs concurrently
--- Warns about catalog relations
-REINDEX SCHEMA CONCURRENTLY pg_catalog;
-WARNING:  cannot reindex system catalogs concurrently, skipping all
--- Check the relation status, there should not be invalid indexes
-\d concur_reindex_tab
-         Table "public.concur_reindex_tab"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- c1     | integer |           | not null | 
- c2     | text    |           |          | 
-Indexes:
-    "concur_reindex_ind1" PRIMARY KEY, btree (c1)
-    "concur_reindex_ind2" btree (c2)
-    "concur_reindex_ind3" UNIQUE, btree (abs(c1))
-    "concur_reindex_ind4" btree (c1, c1, c2)
-Referenced by:
-    TABLE "concur_reindex_tab2" CONSTRAINT "concur_reindex_tab2_c1_fkey" FOREIGN KEY (c1) REFERENCES concur_reindex_tab(c1)
-
-DROP MATERIALIZED VIEW concur_reindex_matview;
-DROP TABLE concur_reindex_tab, concur_reindex_tab2, concur_reindex_tab3;
--- Check handling of invalid indexes
-CREATE TABLE concur_reindex_tab4 (c1 int);
-INSERT INTO concur_reindex_tab4 VALUES (1), (1), (2);
--- This trick creates an invalid index.
-CREATE UNIQUE INDEX CONCURRENTLY concur_reindex_ind5 ON concur_reindex_tab4 (c1);
-ERROR:  could not create unique index "concur_reindex_ind5"
-DETAIL:  Key (c1)=(1) is duplicated.
--- Reindexing concurrently this index fails with the same failure.
--- The extra index created is itself invalid, and can be dropped.
-REINDEX INDEX CONCURRENTLY concur_reindex_ind5;
-ERROR:  could not create unique index "concur_reindex_ind5_ccnew"
-DETAIL:  Key (c1)=(1) is duplicated.
-\d concur_reindex_tab4
-        Table "public.concur_reindex_tab4"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- c1     | integer |           |          | 
-Indexes:
-    "concur_reindex_ind5" UNIQUE, btree (c1) INVALID
-    "concur_reindex_ind5_ccnew" UNIQUE, btree (c1) INVALID
-
-DROP INDEX concur_reindex_ind5_ccnew;
--- This makes the previous failure go away, so the index can become valid.
-DELETE FROM concur_reindex_tab4 WHERE c1 = 1;
--- The invalid index is not processed when running REINDEX TABLE.
-REINDEX TABLE CONCURRENTLY concur_reindex_tab4;
-WARNING:  cannot reindex invalid index "public.concur_reindex_ind5" concurrently, skipping
-NOTICE:  table "concur_reindex_tab4" has no indexes that can be reindexed concurrently
-\d concur_reindex_tab4
-        Table "public.concur_reindex_tab4"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- c1     | integer |           |          | 
-Indexes:
-    "concur_reindex_ind5" UNIQUE, btree (c1) INVALID
-
--- But it is fixed with REINDEX INDEX.
-REINDEX INDEX CONCURRENTLY concur_reindex_ind5;
-\d concur_reindex_tab4
-        Table "public.concur_reindex_tab4"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- c1     | integer |           |          | 
-Indexes:
-    "concur_reindex_ind5" UNIQUE, btree (c1)
-
-DROP TABLE concur_reindex_tab4;
--- Check handling of indexes with expressions and predicates.  The
--- definitions of the rebuilt indexes should match the original
--- definitions.
-CREATE TABLE concur_exprs_tab (c1 int , c2 boolean);
-INSERT INTO concur_exprs_tab (c1, c2) VALUES (1369652450, FALSE),
-  (414515746, TRUE),
-  (897778963, FALSE);
-CREATE UNIQUE INDEX concur_exprs_index_expr
-  ON concur_exprs_tab ((c1::text COLLATE "C"));
-CREATE UNIQUE INDEX concur_exprs_index_pred ON concur_exprs_tab (c1)
-  WHERE (c1::text > 500000000::text COLLATE "C");
-CREATE UNIQUE INDEX concur_exprs_index_pred_2
-  ON concur_exprs_tab ((1 / c1))
-  WHERE ('-H') >= (c2::TEXT) COLLATE "C";
-ALTER INDEX concur_exprs_index_expr ALTER COLUMN 1 SET STATISTICS 100;
-ANALYZE concur_exprs_tab;
-SELECT starelid::regclass, count(*) FROM pg_statistic WHERE starelid IN (
-  'concur_exprs_index_expr'::regclass,
-  'concur_exprs_index_pred'::regclass,
-  'concur_exprs_index_pred_2'::regclass)
-  GROUP BY starelid ORDER BY starelid::regclass::text;
-        starelid         | count 
--------------------------+-------
- concur_exprs_index_expr |     1
-(1 row)
-
-SELECT pg_get_indexdef('concur_exprs_index_expr'::regclass);
-                                                pg_get_indexdef                                                
----------------------------------------------------------------------------------------------------------------
- CREATE UNIQUE INDEX concur_exprs_index_expr ON public.concur_exprs_tab USING btree (((c1)::text) COLLATE "C")
-(1 row)
-
-SELECT pg_get_indexdef('concur_exprs_index_pred'::regclass);
-                                                               pg_get_indexdef                                                                
-----------------------------------------------------------------------------------------------------------------------------------------------
- CREATE UNIQUE INDEX concur_exprs_index_pred ON public.concur_exprs_tab USING btree (c1) WHERE ((c1)::text > ((500000000)::text COLLATE "C"))
-(1 row)
-
-SELECT pg_get_indexdef('concur_exprs_index_pred_2'::regclass);
-                                                                 pg_get_indexdef                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------------
- CREATE UNIQUE INDEX concur_exprs_index_pred_2 ON public.concur_exprs_tab USING btree (((1 / c1))) WHERE ('-H'::text >= ((c2)::text COLLATE "C"))
-(1 row)
-
-REINDEX TABLE CONCURRENTLY concur_exprs_tab;
-SELECT pg_get_indexdef('concur_exprs_index_expr'::regclass);
-                                                pg_get_indexdef                                                
----------------------------------------------------------------------------------------------------------------
- CREATE UNIQUE INDEX concur_exprs_index_expr ON public.concur_exprs_tab USING btree (((c1)::text) COLLATE "C")
-(1 row)
-
-SELECT pg_get_indexdef('concur_exprs_index_pred'::regclass);
-                                                               pg_get_indexdef                                                                
-----------------------------------------------------------------------------------------------------------------------------------------------
- CREATE UNIQUE INDEX concur_exprs_index_pred ON public.concur_exprs_tab USING btree (c1) WHERE ((c1)::text > ((500000000)::text COLLATE "C"))
-(1 row)
-
-SELECT pg_get_indexdef('concur_exprs_index_pred_2'::regclass);
-                                                                 pg_get_indexdef                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------------
- CREATE UNIQUE INDEX concur_exprs_index_pred_2 ON public.concur_exprs_tab USING btree (((1 / c1))) WHERE ('-H'::text >= ((c2)::text COLLATE "C"))
-(1 row)
-
--- ALTER TABLE recreates the indexes, which should keep their collations.
-ALTER TABLE concur_exprs_tab ALTER c2 TYPE TEXT;
-SELECT pg_get_indexdef('concur_exprs_index_expr'::regclass);
-                                                pg_get_indexdef                                                
----------------------------------------------------------------------------------------------------------------
- CREATE UNIQUE INDEX concur_exprs_index_expr ON public.concur_exprs_tab USING btree (((c1)::text) COLLATE "C")
-(1 row)
-
-SELECT pg_get_indexdef('concur_exprs_index_pred'::regclass);
-                                                               pg_get_indexdef                                                                
-----------------------------------------------------------------------------------------------------------------------------------------------
- CREATE UNIQUE INDEX concur_exprs_index_pred ON public.concur_exprs_tab USING btree (c1) WHERE ((c1)::text > ((500000000)::text COLLATE "C"))
-(1 row)
-
-SELECT pg_get_indexdef('concur_exprs_index_pred_2'::regclass);
-                                                             pg_get_indexdef                                                              
-------------------------------------------------------------------------------------------------------------------------------------------
- CREATE UNIQUE INDEX concur_exprs_index_pred_2 ON public.concur_exprs_tab USING btree (((1 / c1))) WHERE ('-H'::text >= (c2 COLLATE "C"))
-(1 row)
-
--- Statistics should remain intact.
-SELECT starelid::regclass, count(*) FROM pg_statistic WHERE starelid IN (
-  'concur_exprs_index_expr'::regclass,
-  'concur_exprs_index_pred'::regclass,
-  'concur_exprs_index_pred_2'::regclass)
-  GROUP BY starelid ORDER BY starelid::regclass::text;
-        starelid         | count 
--------------------------+-------
- concur_exprs_index_expr |     1
-(1 row)
-
--- attstattarget should remain intact
-SELECT attrelid::regclass, attnum, attstattarget
-  FROM pg_attribute WHERE attrelid IN (
-    'concur_exprs_index_expr'::regclass,
-    'concur_exprs_index_pred'::regclass,
-    'concur_exprs_index_pred_2'::regclass)
-  ORDER BY attrelid::regclass::text, attnum;
-         attrelid          | attnum | attstattarget 
----------------------------+--------+---------------
- concur_exprs_index_expr   |      1 |           100
- concur_exprs_index_pred   |      1 |            -1
- concur_exprs_index_pred_2 |      1 |            -1
-(3 rows)
-
-DROP TABLE concur_exprs_tab;
--- Temporary tables and on-commit actions, where CONCURRENTLY is ignored.
--- ON COMMIT PRESERVE ROWS, the default.
-CREATE TEMP TABLE concur_temp_tab_1 (c1 int, c2 text)
-  ON COMMIT PRESERVE ROWS;
-INSERT INTO concur_temp_tab_1 VALUES (1, 'foo'), (2, 'bar');
-CREATE INDEX concur_temp_ind_1 ON concur_temp_tab_1(c2);
-REINDEX TABLE CONCURRENTLY concur_temp_tab_1;
-REINDEX INDEX CONCURRENTLY concur_temp_ind_1;
--- Still fails in transaction blocks
-BEGIN;
-REINDEX INDEX CONCURRENTLY concur_temp_ind_1;
-ERROR:  REINDEX CONCURRENTLY cannot run inside a transaction block
-COMMIT;
--- ON COMMIT DELETE ROWS
-CREATE TEMP TABLE concur_temp_tab_2 (c1 int, c2 text)
-  ON COMMIT DELETE ROWS;
-CREATE INDEX concur_temp_ind_2 ON concur_temp_tab_2(c2);
-REINDEX TABLE CONCURRENTLY concur_temp_tab_2;
-REINDEX INDEX CONCURRENTLY concur_temp_ind_2;
--- ON COMMIT DROP
-BEGIN;
-CREATE TEMP TABLE concur_temp_tab_3 (c1 int, c2 text)
-  ON COMMIT PRESERVE ROWS;
-INSERT INTO concur_temp_tab_3 VALUES (1, 'foo'), (2, 'bar');
-CREATE INDEX concur_temp_ind_3 ON concur_temp_tab_3(c2);
--- Fails when running in a transaction
-REINDEX INDEX CONCURRENTLY concur_temp_ind_3;
-ERROR:  REINDEX CONCURRENTLY cannot run inside a transaction block
-COMMIT;
--- REINDEX SCHEMA processes all temporary relations
-CREATE TABLE reindex_temp_before AS
-SELECT oid, relname, relfilenode, relkind, reltoastrelid
-  FROM pg_class
-  WHERE relname IN ('concur_temp_ind_1', 'concur_temp_ind_2');
-SELECT pg_my_temp_schema()::regnamespace as temp_schema_name \gset
-REINDEX SCHEMA CONCURRENTLY :temp_schema_name;
-SELECT  b.relname,
-        b.relkind,
-        CASE WHEN a.relfilenode = b.relfilenode THEN 'relfilenode is unchanged'
-        ELSE 'relfilenode has changed' END
-  FROM reindex_temp_before b JOIN pg_class a ON b.oid = a.oid
-  ORDER BY 1;
-      relname      | relkind |          case           
--------------------+---------+-------------------------
- concur_temp_ind_1 | i       | relfilenode has changed
- concur_temp_ind_2 | i       | relfilenode has changed
-(2 rows)
-
-DROP TABLE concur_temp_tab_1, concur_temp_tab_2, reindex_temp_before;
---
--- REINDEX SCHEMA
---
-REINDEX SCHEMA schema_to_reindex; -- failure, schema does not exist
-ERROR:  schema "schema_to_reindex" does not exist
-CREATE SCHEMA schema_to_reindex;
-SET search_path = 'schema_to_reindex';
-CREATE TABLE table1(col1 SERIAL PRIMARY KEY);
-INSERT INTO table1 SELECT generate_series(1,400);
-CREATE TABLE table2(col1 SERIAL PRIMARY KEY, col2 TEXT NOT NULL);
-INSERT INTO table2 SELECT generate_series(1,400), 'abc';
-CREATE INDEX ON table2(col2);
-CREATE MATERIALIZED VIEW matview AS SELECT col1 FROM table2;
-CREATE INDEX ON matview(col1);
-CREATE VIEW view AS SELECT col2 FROM table2;
-CREATE TABLE reindex_before AS
-SELECT oid, relname, relfilenode, relkind, reltoastrelid
-	FROM pg_class
-	where relnamespace = (SELECT oid FROM pg_namespace WHERE nspname = 'schema_to_reindex');
-INSERT INTO reindex_before
-SELECT oid, 'pg_toast_TABLE', relfilenode, relkind, reltoastrelid
-FROM pg_class WHERE oid IN
-	(SELECT reltoastrelid FROM reindex_before WHERE reltoastrelid > 0);
-INSERT INTO reindex_before
-SELECT oid, 'pg_toast_TABLE_index', relfilenode, relkind, reltoastrelid
-FROM pg_class where oid in
-	(select indexrelid from pg_index where indrelid in
-		(select reltoastrelid from reindex_before where reltoastrelid > 0));
-REINDEX SCHEMA schema_to_reindex;
-CREATE TABLE reindex_after AS SELECT oid, relname, relfilenode, relkind
-	FROM pg_class
-	where relnamespace = (SELECT oid FROM pg_namespace WHERE nspname = 'schema_to_reindex');
-SELECT  b.relname,
-        b.relkind,
-        CASE WHEN a.relfilenode = b.relfilenode THEN 'relfilenode is unchanged'
-        ELSE 'relfilenode has changed' END
-  FROM reindex_before b JOIN pg_class a ON b.oid = a.oid
-  ORDER BY 1;
-       relname        | relkind |           case           
-----------------------+---------+--------------------------
- matview              | m       | relfilenode is unchanged
- matview_col1_idx     | i       | relfilenode has changed
- pg_toast_TABLE       | t       | relfilenode is unchanged
- pg_toast_TABLE_index | i       | relfilenode has changed
- table1               | r       | relfilenode is unchanged
- table1_col1_seq      | S       | relfilenode is unchanged
- table1_pkey          | i       | relfilenode has changed
- table2               | r       | relfilenode is unchanged
- table2_col1_seq      | S       | relfilenode is unchanged
- table2_col2_idx      | i       | relfilenode has changed
- table2_pkey          | i       | relfilenode has changed
- view                 | v       | relfilenode is unchanged
-(12 rows)
-
-REINDEX SCHEMA schema_to_reindex;
-BEGIN;
-REINDEX SCHEMA schema_to_reindex; -- failure, cannot run in a transaction
-ERROR:  REINDEX SCHEMA cannot run inside a transaction block
-END;
--- concurrently
-REINDEX SCHEMA CONCURRENTLY schema_to_reindex;
--- Failure for unauthorized user
-CREATE ROLE regress_reindexuser NOLOGIN;
-SET SESSION ROLE regress_reindexuser;
-REINDEX SCHEMA schema_to_reindex;
-ERROR:  must be owner of schema schema_to_reindex
--- Permission failures with toast tables and indexes (pg_authid here)
-RESET ROLE;
-GRANT USAGE ON SCHEMA pg_toast TO regress_reindexuser;
-SET SESSION ROLE regress_reindexuser;
-REINDEX TABLE pg_toast.pg_toast_1260;
-ERROR:  must be owner of table pg_toast_1260
-REINDEX INDEX pg_toast.pg_toast_1260_index;
-ERROR:  must be owner of index pg_toast_1260_index
--- Clean up
-RESET ROLE;
-REVOKE USAGE ON SCHEMA pg_toast FROM regress_reindexuser;
-DROP ROLE regress_reindexuser;
-DROP SCHEMA schema_to_reindex CASCADE;
-NOTICE:  drop cascades to 6 other objects
-DETAIL:  drop cascades to table table1
-drop cascades to table table2
-drop cascades to materialized view matview
-drop cascades to view view
-drop cascades to table reindex_before
-drop cascades to table reindex_after
diff -U3 /Users/kenaniah/workspace/postgres/src/test/regress/expected/create_view.out /Users/kenaniah/workspace/postgres/src/test/regress/results/create_view.out
--- /Users/kenaniah/workspace/postgres/src/test/regress/expected/create_view.out	2021-10-03 17:41:49.000000000 -0700
+++ /Users/kenaniah/workspace/postgres/src/test/regress/results/create_view.out	2021-10-03 20:08:13.000000000 -0700
@@ -304,1767 +304,11 @@
 CREATE VIEW unspecified_types AS
   SELECT 42 as i, 42.5 as num, 'foo' as u, 'foo'::unknown as u2, null as n;
 \d+ unspecified_types
-                   View "testviewschm2.unspecified_types"
- Column |  Type   | Collation | Nullable | Default | Storage  | Description 
---------+---------+-----------+----------+---------+----------+-------------
- i      | integer |           |          |         | plain    | 
- num    | numeric |           |          |         | main     | 
- u      | text    |           |          |         | extended | 
- u2     | text    |           |          |         | extended | 
- n      | text    |           |          |         | extended | 
-View definition:
- SELECT 42 AS i,
-    42.5 AS num,
-    'foo'::text AS u,
-    'foo'::text AS u2,
-    NULL::text AS n;
+dyld: lazy symbol binding failed: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
+
+dyld: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
 
-SELECT * FROM unspecified_types;
- i  | num  |  u  | u2  | n 
-----+------+-----+-----+---
- 42 | 42.5 | foo | foo | 
-(1 row)
-
--- This test checks that proper typmods are assigned in a multi-row VALUES
-CREATE VIEW tt1 AS
-  SELECT * FROM (
-    VALUES
-       ('abc'::varchar(3), '0123456789', 42, 'abcd'::varchar(4)),
-       ('0123456789', 'abc'::varchar(3), 42.12, 'abc'::varchar(4))
-  ) vv(a,b,c,d);
-\d+ tt1
-                                View "testviewschm2.tt1"
- Column |         Type         | Collation | Nullable | Default | Storage  | Description 
---------+----------------------+-----------+----------+---------+----------+-------------
- a      | character varying    |           |          |         | extended | 
- b      | character varying    |           |          |         | extended | 
- c      | numeric              |           |          |         | main     | 
- d      | character varying(4) |           |          |         | extended | 
-View definition:
- SELECT vv.a,
-    vv.b,
-    vv.c,
-    vv.d
-   FROM ( VALUES ('abc'::character varying(3),'0123456789'::character varying,42,'abcd'::character varying(4)), ('0123456789'::character varying,'abc'::character varying(3),42.12,'abc'::character varying(4))) vv(a, b, c, d);
-
-SELECT * FROM tt1;
-     a      |     b      |   c   |  d   
-------------+------------+-------+------
- abc        | 0123456789 |    42 | abcd
- 0123456789 | abc        | 42.12 | abc
-(2 rows)
-
-SELECT a::varchar(3) FROM tt1;
-  a  
------
- abc
- 012
-(2 rows)
-
-DROP VIEW tt1;
--- Test view decompilation in the face of relation renaming conflicts
-CREATE TABLE tt1 (f1 int, f2 int, f3 text);
-CREATE TABLE tx1 (x1 int, x2 int, x3 text);
-CREATE TABLE temp_view_test.tt1 (y1 int, f2 int, f3 text);
-CREATE VIEW aliased_view_1 AS
-  select * from tt1
-    where exists (select 1 from tx1 where tt1.f1 = tx1.x1);
-CREATE VIEW aliased_view_2 AS
-  select * from tt1 a1
-    where exists (select 1 from tx1 where a1.f1 = tx1.x1);
-CREATE VIEW aliased_view_3 AS
-  select * from tt1
-    where exists (select 1 from tx1 a2 where tt1.f1 = a2.x1);
-CREATE VIEW aliased_view_4 AS
-  select * from temp_view_test.tt1
-    where exists (select 1 from tt1 where temp_view_test.tt1.y1 = tt1.f1);
-\d+ aliased_view_1
-                    View "testviewschm2.aliased_view_1"
- Column |  Type   | Collation | Nullable | Default | Storage  | Description 
---------+---------+-----------+----------+---------+----------+-------------
- f1     | integer |           |          |         | plain    | 
- f2     | integer |           |          |         | plain    | 
- f3     | text    |           |          |         | extended | 
-View definition:
- SELECT tt1.f1,
-    tt1.f2,
-    tt1.f3
-   FROM tt1
-  WHERE (EXISTS ( SELECT 1
-           FROM tx1
-          WHERE tt1.f1 = tx1.x1));
-
-\d+ aliased_view_2
-                    View "testviewschm2.aliased_view_2"
- Column |  Type   | Collation | Nullable | Default | Storage  | Description 
---------+---------+-----------+----------+---------+----------+-------------
- f1     | integer |           |          |         | plain    | 
- f2     | integer |           |          |         | plain    | 
- f3     | text    |           |          |         | extended | 
-View definition:
- SELECT a1.f1,
-    a1.f2,
-    a1.f3
-   FROM tt1 a1
-  WHERE (EXISTS ( SELECT 1
-           FROM tx1
-          WHERE a1.f1 = tx1.x1));
-
-\d+ aliased_view_3
-                    View "testviewschm2.aliased_view_3"
- Column |  Type   | Collation | Nullable | Default | Storage  | Description 
---------+---------+-----------+----------+---------+----------+-------------
- f1     | integer |           |          |         | plain    | 
- f2     | integer |           |          |         | plain    | 
- f3     | text    |           |          |         | extended | 
-View definition:
- SELECT tt1.f1,
-    tt1.f2,
-    tt1.f3
-   FROM tt1
-  WHERE (EXISTS ( SELECT 1
-           FROM tx1 a2
-          WHERE tt1.f1 = a2.x1));
-
-\d+ aliased_view_4
-                    View "testviewschm2.aliased_view_4"
- Column |  Type   | Collation | Nullable | Default | Storage  | Description 
---------+---------+-----------+----------+---------+----------+-------------
- y1     | integer |           |          |         | plain    | 
- f2     | integer |           |          |         | plain    | 
- f3     | text    |           |          |         | extended | 
-View definition:
- SELECT tt1.y1,
-    tt1.f2,
-    tt1.f3
-   FROM temp_view_test.tt1
-  WHERE (EXISTS ( SELECT 1
-           FROM tt1 tt1_1
-          WHERE tt1.y1 = tt1_1.f1));
-
-ALTER TABLE tx1 RENAME TO a1;
-\d+ aliased_view_1
-                    View "testviewschm2.aliased_view_1"
- Column |  Type   | Collation | Nullable | Default | Storage  | Description 
---------+---------+-----------+----------+---------+----------+-------------
- f1     | integer |           |          |         | plain    | 
- f2     | integer |           |          |         | plain    | 
- f3     | text    |           |          |         | extended | 
-View definition:
- SELECT tt1.f1,
-    tt1.f2,
-    tt1.f3
-   FROM tt1
-  WHERE (EXISTS ( SELECT 1
-           FROM a1
-          WHERE tt1.f1 = a1.x1));
-
-\d+ aliased_view_2
-                    View "testviewschm2.aliased_view_2"
- Column |  Type   | Collation | Nullable | Default | Storage  | Description 
---------+---------+-----------+----------+---------+----------+-------------
- f1     | integer |           |          |         | plain    | 
- f2     | integer |           |          |         | plain    | 
- f3     | text    |           |          |         | extended | 
-View definition:
- SELECT a1.f1,
-    a1.f2,
-    a1.f3
-   FROM tt1 a1
-  WHERE (EXISTS ( SELECT 1
-           FROM a1 a1_1
-          WHERE a1.f1 = a1_1.x1));
-
-\d+ aliased_view_3
-                    View "testviewschm2.aliased_view_3"
- Column |  Type   | Collation | Nullable | Default | Storage  | Description 
---------+---------+-----------+----------+---------+----------+-------------
- f1     | integer |           |          |         | plain    | 
- f2     | integer |           |          |         | plain    | 
- f3     | text    |           |          |         | extended | 
-View definition:
- SELECT tt1.f1,
-    tt1.f2,
-    tt1.f3
-   FROM tt1
-  WHERE (EXISTS ( SELECT 1
-           FROM a1 a2
-          WHERE tt1.f1 = a2.x1));
-
-\d+ aliased_view_4
-                    View "testviewschm2.aliased_view_4"
- Column |  Type   | Collation | Nullable | Default | Storage  | Description 
---------+---------+-----------+----------+---------+----------+-------------
- y1     | integer |           |          |         | plain    | 
- f2     | integer |           |          |         | plain    | 
- f3     | text    |           |          |         | extended | 
-View definition:
- SELECT tt1.y1,
-    tt1.f2,
-    tt1.f3
-   FROM temp_view_test.tt1
-  WHERE (EXISTS ( SELECT 1
-           FROM tt1 tt1_1
-          WHERE tt1.y1 = tt1_1.f1));
-
-ALTER TABLE tt1 RENAME TO a2;
-\d+ aliased_view_1
-                    View "testviewschm2.aliased_view_1"
- Column |  Type   | Collation | Nullable | Default | Storage  | Description 
---------+---------+-----------+----------+---------+----------+-------------
- f1     | integer |           |          |         | plain    | 
- f2     | integer |           |          |         | plain    | 
- f3     | text    |           |          |         | extended | 
-View definition:
- SELECT a2.f1,
-    a2.f2,
-    a2.f3
-   FROM a2
-  WHERE (EXISTS ( SELECT 1
-           FROM a1
-          WHERE a2.f1 = a1.x1));
-
-\d+ aliased_view_2
-                    View "testviewschm2.aliased_view_2"
- Column |  Type   | Collation | Nullable | Default | Storage  | Description 
---------+---------+-----------+----------+---------+----------+-------------
- f1     | integer |           |          |         | plain    | 
- f2     | integer |           |          |         | plain    | 
- f3     | text    |           |          |         | extended | 
-View definition:
- SELECT a1.f1,
-    a1.f2,
-    a1.f3
-   FROM a2 a1
-  WHERE (EXISTS ( SELECT 1
-           FROM a1 a1_1
-          WHERE a1.f1 = a1_1.x1));
-
-\d+ aliased_view_3
-                    View "testviewschm2.aliased_view_3"
- Column |  Type   | Collation | Nullable | Default | Storage  | Description 
---------+---------+-----------+----------+---------+----------+-------------
- f1     | integer |           |          |         | plain    | 
- f2     | integer |           |          |         | plain    | 
- f3     | text    |           |          |         | extended | 
-View definition:
- SELECT a2.f1,
-    a2.f2,
-    a2.f3
-   FROM a2
-  WHERE (EXISTS ( SELECT 1
-           FROM a1 a2_1
-          WHERE a2.f1 = a2_1.x1));
-
-\d+ aliased_view_4
-                    View "testviewschm2.aliased_view_4"
- Column |  Type   | Collation | Nullable | Default | Storage  | Description 
---------+---------+-----------+----------+---------+----------+-------------
- y1     | integer |           |          |         | plain    | 
- f2     | integer |           |          |         | plain    | 
- f3     | text    |           |          |         | extended | 
-View definition:
- SELECT tt1.y1,
-    tt1.f2,
-    tt1.f3
-   FROM temp_view_test.tt1
-  WHERE (EXISTS ( SELECT 1
-           FROM a2
-          WHERE tt1.y1 = a2.f1));
-
-ALTER TABLE a1 RENAME TO tt1;
-\d+ aliased_view_1
-                    View "testviewschm2.aliased_view_1"
- Column |  Type   | Collation | Nullable | Default | Storage  | Description 
---------+---------+-----------+----------+---------+----------+-------------
- f1     | integer |           |          |         | plain    | 
- f2     | integer |           |          |         | plain    | 
- f3     | text    |           |          |         | extended | 
-View definition:
- SELECT a2.f1,
-    a2.f2,
-    a2.f3
-   FROM a2
-  WHERE (EXISTS ( SELECT 1
-           FROM tt1
-          WHERE a2.f1 = tt1.x1));
-
-\d+ aliased_view_2
-                    View "testviewschm2.aliased_view_2"
- Column |  Type   | Collation | Nullable | Default | Storage  | Description 
---------+---------+-----------+----------+---------+----------+-------------
- f1     | integer |           |          |         | plain    | 
- f2     | integer |           |          |         | plain    | 
- f3     | text    |           |          |         | extended | 
-View definition:
- SELECT a1.f1,
-    a1.f2,
-    a1.f3
-   FROM a2 a1
-  WHERE (EXISTS ( SELECT 1
-           FROM tt1
-          WHERE a1.f1 = tt1.x1));
-
-\d+ aliased_view_3
-                    View "testviewschm2.aliased_view_3"
- Column |  Type   | Collation | Nullable | Default | Storage  | Description 
---------+---------+-----------+----------+---------+----------+-------------
- f1     | integer |           |          |         | plain    | 
- f2     | integer |           |          |         | plain    | 
- f3     | text    |           |          |         | extended | 
-View definition:
- SELECT a2.f1,
-    a2.f2,
-    a2.f3
-   FROM a2
-  WHERE (EXISTS ( SELECT 1
-           FROM tt1 a2_1
-          WHERE a2.f1 = a2_1.x1));
-
-\d+ aliased_view_4
-                    View "testviewschm2.aliased_view_4"
- Column |  Type   | Collation | Nullable | Default | Storage  | Description 
---------+---------+-----------+----------+---------+----------+-------------
- y1     | integer |           |          |         | plain    | 
- f2     | integer |           |          |         | plain    | 
- f3     | text    |           |          |         | extended | 
-View definition:
- SELECT tt1.y1,
-    tt1.f2,
-    tt1.f3
-   FROM temp_view_test.tt1
-  WHERE (EXISTS ( SELECT 1
-           FROM a2
-          WHERE tt1.y1 = a2.f1));
-
-ALTER TABLE a2 RENAME TO tx1;
-ALTER TABLE tx1 SET SCHEMA temp_view_test;
-\d+ aliased_view_1
-                    View "testviewschm2.aliased_view_1"
- Column |  Type   | Collation | Nullable | Default | Storage  | Description 
---------+---------+-----------+----------+---------+----------+-------------
- f1     | integer |           |          |         | plain    | 
- f2     | integer |           |          |         | plain    | 
- f3     | text    |           |          |         | extended | 
-View definition:
- SELECT tx1.f1,
-    tx1.f2,
-    tx1.f3
-   FROM temp_view_test.tx1
-  WHERE (EXISTS ( SELECT 1
-           FROM tt1
-          WHERE tx1.f1 = tt1.x1));
-
-\d+ aliased_view_2
-                    View "testviewschm2.aliased_view_2"
- Column |  Type   | Collation | Nullable | Default | Storage  | Description 
---------+---------+-----------+----------+---------+----------+-------------
- f1     | integer |           |          |         | plain    | 
- f2     | integer |           |          |         | plain    | 
- f3     | text    |           |          |         | extended | 
-View definition:
- SELECT a1.f1,
-    a1.f2,
-    a1.f3
-   FROM temp_view_test.tx1 a1
-  WHERE (EXISTS ( SELECT 1
-           FROM tt1
-          WHERE a1.f1 = tt1.x1));
-
-\d+ aliased_view_3
-                    View "testviewschm2.aliased_view_3"
- Column |  Type   | Collation | Nullable | Default | Storage  | Description 
---------+---------+-----------+----------+---------+----------+-------------
- f1     | integer |           |          |         | plain    | 
- f2     | integer |           |          |         | plain    | 
- f3     | text    |           |          |         | extended | 
-View definition:
- SELECT tx1.f1,
-    tx1.f2,
-    tx1.f3
-   FROM temp_view_test.tx1
-  WHERE (EXISTS ( SELECT 1
-           FROM tt1 a2
-          WHERE tx1.f1 = a2.x1));
-
-\d+ aliased_view_4
-                    View "testviewschm2.aliased_view_4"
- Column |  Type   | Collation | Nullable | Default | Storage  | Description 
---------+---------+-----------+----------+---------+----------+-------------
- y1     | integer |           |          |         | plain    | 
- f2     | integer |           |          |         | plain    | 
- f3     | text    |           |          |         | extended | 
-View definition:
- SELECT tt1.y1,
-    tt1.f2,
-    tt1.f3
-   FROM temp_view_test.tt1
-  WHERE (EXISTS ( SELECT 1
-           FROM temp_view_test.tx1
-          WHERE tt1.y1 = tx1.f1));
-
-ALTER TABLE temp_view_test.tt1 RENAME TO tmp1;
-ALTER TABLE temp_view_test.tmp1 SET SCHEMA testviewschm2;
-ALTER TABLE tmp1 RENAME TO tx1;
-\d+ aliased_view_1
-                    View "testviewschm2.aliased_view_1"
- Column |  Type   | Collation | Nullable | Default | Storage  | Description 
---------+---------+-----------+----------+---------+----------+-------------
- f1     | integer |           |          |         | plain    | 
- f2     | integer |           |          |         | plain    | 
- f3     | text    |           |          |         | extended | 
-View definition:
- SELECT tx1.f1,
-    tx1.f2,
-    tx1.f3
-   FROM temp_view_test.tx1
-  WHERE (EXISTS ( SELECT 1
-           FROM tt1
-          WHERE tx1.f1 = tt1.x1));
-
-\d+ aliased_view_2
-                    View "testviewschm2.aliased_view_2"
- Column |  Type   | Collation | Nullable | Default | Storage  | Description 
---------+---------+-----------+----------+---------+----------+-------------
- f1     | integer |           |          |         | plain    | 
- f2     | integer |           |          |         | plain    | 
- f3     | text    |           |          |         | extended | 
-View definition:
- SELECT a1.f1,
-    a1.f2,
-    a1.f3
-   FROM temp_view_test.tx1 a1
-  WHERE (EXISTS ( SELECT 1
-           FROM tt1
-          WHERE a1.f1 = tt1.x1));
-
-\d+ aliased_view_3
-                    View "testviewschm2.aliased_view_3"
- Column |  Type   | Collation | Nullable | Default | Storage  | Description 
---------+---------+-----------+----------+---------+----------+-------------
- f1     | integer |           |          |         | plain    | 
- f2     | integer |           |          |         | plain    | 
- f3     | text    |           |          |         | extended | 
-View definition:
- SELECT tx1.f1,
-    tx1.f2,
-    tx1.f3
-   FROM temp_view_test.tx1
-  WHERE (EXISTS ( SELECT 1
-           FROM tt1 a2
-          WHERE tx1.f1 = a2.x1));
-
-\d+ aliased_view_4
-                    View "testviewschm2.aliased_view_4"
- Column |  Type   | Collation | Nullable | Default | Storage  | Description 
---------+---------+-----------+----------+---------+----------+-------------
- y1     | integer |           |          |         | plain    | 
- f2     | integer |           |          |         | plain    | 
- f3     | text    |           |          |         | extended | 
-View definition:
- SELECT tx1.y1,
-    tx1.f2,
-    tx1.f3
-   FROM tx1
-  WHERE (EXISTS ( SELECT 1
-           FROM temp_view_test.tx1 tx1_1
-          WHERE tx1.y1 = tx1_1.f1));
-
--- Test aliasing of joins
-create view view_of_joins as
-select * from
-  (select * from (tbl1 cross join tbl2) same) ss,
-  (tbl3 cross join tbl4) same;
-\d+ view_of_joins
-                    View "testviewschm2.view_of_joins"
- Column |  Type   | Collation | Nullable | Default | Storage | Description 
---------+---------+-----------+----------+---------+---------+-------------
- a      | integer |           |          |         | plain   | 
- b      | integer |           |          |         | plain   | 
- c      | integer |           |          |         | plain   | 
- d      | integer |           |          |         | plain   | 
- e      | integer |           |          |         | plain   | 
- f      | integer |           |          |         | plain   | 
- g      | integer |           |          |         | plain   | 
- h      | integer |           |          |         | plain   | 
-View definition:
- SELECT ss.a,
-    ss.b,
-    ss.c,
-    ss.d,
-    same.e,
-    same.f,
-    same.g,
-    same.h
-   FROM ( SELECT same_1.a,
-            same_1.b,
-            same_1.c,
-            same_1.d
-           FROM (tbl1
-             CROSS JOIN tbl2) same_1) ss,
-    (tbl3
-     CROSS JOIN tbl4) same;
-
-create table tbl1a (a int, c int);
-create view view_of_joins_2a as select * from tbl1 join tbl1a using (a);
-create view view_of_joins_2b as select * from tbl1 join tbl1a using (a) as x;
-create view view_of_joins_2c as select * from (tbl1 join tbl1a using (a)) as y;
-create view view_of_joins_2d as select * from (tbl1 join tbl1a using (a) as x) as y;
-select pg_get_viewdef('view_of_joins_2a', true);
-       pg_get_viewdef       
-----------------------------
-  SELECT tbl1.a,           +
-     tbl1.b,               +
-     tbl1a.c               +
-    FROM tbl1              +
-      JOIN tbl1a USING (a);
-(1 row)
-
-select pg_get_viewdef('view_of_joins_2b', true);
-         pg_get_viewdef          
----------------------------------
-  SELECT tbl1.a,                +
-     tbl1.b,                    +
-     tbl1a.c                    +
-    FROM tbl1                   +
-      JOIN tbl1a USING (a) AS x;
-(1 row)
-
-select pg_get_viewdef('view_of_joins_2c', true);
-        pg_get_viewdef         
--------------------------------
-  SELECT y.a,                 +
-     y.b,                     +
-     y.c                      +
-    FROM (tbl1                +
-      JOIN tbl1a USING (a)) y;
-(1 row)
-
-select pg_get_viewdef('view_of_joins_2d', true);
-           pg_get_viewdef           
-------------------------------------
-  SELECT y.a,                      +
-     y.b,                          +
-     y.c                           +
-    FROM (tbl1                     +
-      JOIN tbl1a USING (a) AS x) y;
-(1 row)
-
--- Test view decompilation in the face of column addition/deletion/renaming
-create table tt2 (a int, b int, c int);
-create table tt3 (ax int8, b int2, c numeric);
-create table tt4 (ay int, b int, q int);
-create view v1 as select * from tt2 natural join tt3;
-create view v1a as select * from (tt2 natural join tt3) j;
-create view v2 as select * from tt2 join tt3 using (b,c) join tt4 using (b);
-create view v2a as select * from (tt2 join tt3 using (b,c) join tt4 using (b)) j;
-create view v3 as select * from tt2 join tt3 using (b,c) full join tt4 using (b);
-select pg_get_viewdef('v1', true);
-       pg_get_viewdef        
------------------------------
-  SELECT tt2.b,             +
-     tt3.c,                 +
-     tt2.a,                 +
-     tt3.ax                 +
-    FROM tt2                +
-      JOIN tt3 USING (b, c);
-(1 row)
-
-select pg_get_viewdef('v1a', true);
-         pg_get_viewdef         
---------------------------------
-  SELECT j.b,                  +
-     j.c,                      +
-     j.a,                      +
-     j.ax                      +
-    FROM (tt2                  +
-      JOIN tt3 USING (b, c)) j;
-(1 row)
-
-select pg_get_viewdef('v2', true);
-       pg_get_viewdef       
-----------------------------
-  SELECT tt2.b,            +
-     tt3.c,                +
-     tt2.a,                +
-     tt3.ax,               +
-     tt4.ay,               +
-     tt4.q                 +
-    FROM tt2               +
-      JOIN tt3 USING (b, c)+
-      JOIN tt4 USING (b);
-(1 row)
-
-select pg_get_viewdef('v2a', true);
-       pg_get_viewdef        
------------------------------
-  SELECT j.b,               +
-     j.c,                   +
-     j.a,                   +
-     j.ax,                  +
-     j.ay,                  +
-     j.q                    +
-    FROM (tt2               +
-      JOIN tt3 USING (b, c) +
-      JOIN tt4 USING (b)) j;
-(1 row)
-
-select pg_get_viewdef('v3', true);
-        pg_get_viewdef         
--------------------------------
-  SELECT b,                   +
-     tt3.c,                   +
-     tt2.a,                   +
-     tt3.ax,                  +
-     tt4.ay,                  +
-     tt4.q                    +
-    FROM tt2                  +
-      JOIN tt3 USING (b, c)   +
-      FULL JOIN tt4 USING (b);
-(1 row)
-
-alter table tt2 add column d int;
-alter table tt2 add column e int;
-select pg_get_viewdef('v1', true);
-       pg_get_viewdef        
------------------------------
-  SELECT tt2.b,             +
-     tt3.c,                 +
-     tt2.a,                 +
-     tt3.ax                 +
-    FROM tt2                +
-      JOIN tt3 USING (b, c);
-(1 row)
-
-select pg_get_viewdef('v1a', true);
-         pg_get_viewdef         
---------------------------------
-  SELECT j.b,                  +
-     j.c,                      +
-     j.a,                      +
-     j.ax                      +
-    FROM (tt2                  +
-      JOIN tt3 USING (b, c)) j;
-(1 row)
-
-select pg_get_viewdef('v2', true);
-       pg_get_viewdef       
-----------------------------
-  SELECT tt2.b,            +
-     tt3.c,                +
-     tt2.a,                +
-     tt3.ax,               +
-     tt4.ay,               +
-     tt4.q                 +
-    FROM tt2               +
-      JOIN tt3 USING (b, c)+
-      JOIN tt4 USING (b);
-(1 row)
-
-select pg_get_viewdef('v2a', true);
-       pg_get_viewdef        
------------------------------
-  SELECT j.b,               +
-     j.c,                   +
-     j.a,                   +
-     j.ax,                  +
-     j.ay,                  +
-     j.q                    +
-    FROM (tt2               +
-      JOIN tt3 USING (b, c) +
-      JOIN tt4 USING (b)) j;
-(1 row)
-
-select pg_get_viewdef('v3', true);
-        pg_get_viewdef         
--------------------------------
-  SELECT b,                   +
-     tt3.c,                   +
-     tt2.a,                   +
-     tt3.ax,                  +
-     tt4.ay,                  +
-     tt4.q                    +
-    FROM tt2                  +
-      JOIN tt3 USING (b, c)   +
-      FULL JOIN tt4 USING (b);
-(1 row)
-
-alter table tt3 rename c to d;
-select pg_get_viewdef('v1', true);
-              pg_get_viewdef               
--------------------------------------------
-  SELECT tt2.b,                           +
-     tt3.c,                               +
-     tt2.a,                               +
-     tt3.ax                               +
-    FROM tt2                              +
-      JOIN tt3 tt3(ax, b, c) USING (b, c);
-(1 row)
-
-select pg_get_viewdef('v1a', true);
-                pg_get_viewdef                
-----------------------------------------------
-  SELECT j.b,                                +
-     j.c,                                    +
-     j.a,                                    +
-     j.ax                                    +
-    FROM (tt2                                +
-      JOIN tt3 tt3(ax, b, c) USING (b, c)) j;
-(1 row)
-
-select pg_get_viewdef('v2', true);
-              pg_get_viewdef              
-------------------------------------------
-  SELECT tt2.b,                          +
-     tt3.c,                              +
-     tt2.a,                              +
-     tt3.ax,                             +
-     tt4.ay,                             +
-     tt4.q                               +
-    FROM tt2                             +
-      JOIN tt3 tt3(ax, b, c) USING (b, c)+
-      JOIN tt4 USING (b);
-(1 row)
-
-select pg_get_viewdef('v2a', true);
-              pg_get_viewdef              
-------------------------------------------
-  SELECT j.b,                            +
-     j.c,                                +
-     j.a,                                +
-     j.ax,                               +
-     j.ay,                               +
-     j.q                                 +
-    FROM (tt2                            +
-      JOIN tt3 tt3(ax, b, c) USING (b, c)+
-      JOIN tt4 USING (b)) j;
-(1 row)
-
-select pg_get_viewdef('v3', true);
-              pg_get_viewdef              
-------------------------------------------
-  SELECT b,                              +
-     tt3.c,                              +
-     tt2.a,                              +
-     tt3.ax,                             +
-     tt4.ay,                             +
-     tt4.q                               +
-    FROM tt2                             +
-      JOIN tt3 tt3(ax, b, c) USING (b, c)+
-      FULL JOIN tt4 USING (b);
-(1 row)
-
-alter table tt3 add column c int;
-alter table tt3 add column e int;
-select pg_get_viewdef('v1', true);
-                  pg_get_viewdef                   
----------------------------------------------------
-  SELECT tt2.b,                                   +
-     tt3.c,                                       +
-     tt2.a,                                       +
-     tt3.ax                                       +
-    FROM tt2                                      +
-      JOIN tt3 tt3(ax, b, c, c_1, e) USING (b, c);
-(1 row)
-
-select pg_get_viewdef('v1a', true);
-                                  pg_get_viewdef                                   
------------------------------------------------------------------------------------
-  SELECT j.b,                                                                     +
-     j.c,                                                                         +
-     j.a,                                                                         +
-     j.ax                                                                         +
-    FROM (tt2                                                                     +
-      JOIN tt3 tt3(ax, b, c, c_1, e) USING (b, c)) j(b, c, a, d, e, ax, c_1, e_1);
-(1 row)
-
-select pg_get_viewdef('v2', true);
-                  pg_get_viewdef                  
---------------------------------------------------
-  SELECT tt2.b,                                  +
-     tt3.c,                                      +
-     tt2.a,                                      +
-     tt3.ax,                                     +
-     tt4.ay,                                     +
-     tt4.q                                       +
-    FROM tt2                                     +
-      JOIN tt3 tt3(ax, b, c, c_1, e) USING (b, c)+
-      JOIN tt4 USING (b);
-(1 row)
-
-select pg_get_viewdef('v2a', true);
-                         pg_get_viewdef                          
------------------------------------------------------------------
-  SELECT j.b,                                                   +
-     j.c,                                                       +
-     j.a,                                                       +
-     j.ax,                                                      +
-     j.ay,                                                      +
-     j.q                                                        +
-    FROM (tt2                                                   +
-      JOIN tt3 tt3(ax, b, c, c_1, e) USING (b, c)               +
-      JOIN tt4 USING (b)) j(b, c, a, d, e, ax, c_1, e_1, ay, q);
-(1 row)
-
-select pg_get_viewdef('v3', true);
-                  pg_get_viewdef                  
---------------------------------------------------
-  SELECT b,                                      +
-     tt3.c,                                      +
-     tt2.a,                                      +
-     tt3.ax,                                     +
-     tt4.ay,                                     +
-     tt4.q                                       +
-    FROM tt2                                     +
-      JOIN tt3 tt3(ax, b, c, c_1, e) USING (b, c)+
-      FULL JOIN tt4 USING (b);
-(1 row)
-
-alter table tt2 drop column d;
-select pg_get_viewdef('v1', true);
-                  pg_get_viewdef                   
----------------------------------------------------
-  SELECT tt2.b,                                   +
-     tt3.c,                                       +
-     tt2.a,                                       +
-     tt3.ax                                       +
-    FROM tt2                                      +
-      JOIN tt3 tt3(ax, b, c, c_1, e) USING (b, c);
-(1 row)
-
-select pg_get_viewdef('v1a', true);
-                                 pg_get_viewdef                                 
---------------------------------------------------------------------------------
-  SELECT j.b,                                                                  +
-     j.c,                                                                      +
-     j.a,                                                                      +
-     j.ax                                                                      +
-    FROM (tt2                                                                  +
-      JOIN tt3 tt3(ax, b, c, c_1, e) USING (b, c)) j(b, c, a, e, ax, c_1, e_1);
-(1 row)
-
-select pg_get_viewdef('v2', true);
-                  pg_get_viewdef                  
---------------------------------------------------
-  SELECT tt2.b,                                  +
-     tt3.c,                                      +
-     tt2.a,                                      +
-     tt3.ax,                                     +
-     tt4.ay,                                     +
-     tt4.q                                       +
-    FROM tt2                                     +
-      JOIN tt3 tt3(ax, b, c, c_1, e) USING (b, c)+
-      JOIN tt4 USING (b);
-(1 row)
-
-select pg_get_viewdef('v2a', true);
-                        pg_get_viewdef                        
---------------------------------------------------------------
-  SELECT j.b,                                                +
-     j.c,                                                    +
-     j.a,                                                    +
-     j.ax,                                                   +
-     j.ay,                                                   +
-     j.q                                                     +
-    FROM (tt2                                                +
-      JOIN tt3 tt3(ax, b, c, c_1, e) USING (b, c)            +
-      JOIN tt4 USING (b)) j(b, c, a, e, ax, c_1, e_1, ay, q);
-(1 row)
-
-select pg_get_viewdef('v3', true);
-                  pg_get_viewdef                  
---------------------------------------------------
-  SELECT b,                                      +
-     tt3.c,                                      +
-     tt2.a,                                      +
-     tt3.ax,                                     +
-     tt4.ay,                                     +
-     tt4.q                                       +
-    FROM tt2                                     +
-      JOIN tt3 tt3(ax, b, c, c_1, e) USING (b, c)+
-      FULL JOIN tt4 USING (b);
-(1 row)
-
-create table tt5 (a int, b int);
-create table tt6 (c int, d int);
-create view vv1 as select * from (tt5 cross join tt6) j(aa,bb,cc,dd);
-select pg_get_viewdef('vv1', true);
-             pg_get_viewdef              
------------------------------------------
-  SELECT j.aa,                          +
-     j.bb,                              +
-     j.cc,                              +
-     j.dd                               +
-    FROM (tt5                           +
-      CROSS JOIN tt6) j(aa, bb, cc, dd);
-(1 row)
-
-alter table tt5 add column c int;
-select pg_get_viewdef('vv1', true);
-               pg_get_viewdef               
---------------------------------------------
-  SELECT j.aa,                             +
-     j.bb,                                 +
-     j.cc,                                 +
-     j.dd                                  +
-    FROM (tt5                              +
-      CROSS JOIN tt6) j(aa, bb, c, cc, dd);
-(1 row)
-
-alter table tt5 add column cc int;
-select pg_get_viewdef('vv1', true);
-                  pg_get_viewdef                  
---------------------------------------------------
-  SELECT j.aa,                                   +
-     j.bb,                                       +
-     j.cc,                                       +
-     j.dd                                        +
-    FROM (tt5                                    +
-      CROSS JOIN tt6) j(aa, bb, c, cc_1, cc, dd);
-(1 row)
-
-alter table tt5 drop column c;
-select pg_get_viewdef('vv1', true);
-                pg_get_viewdef                 
------------------------------------------------
-  SELECT j.aa,                                +
-     j.bb,                                    +
-     j.cc,                                    +
-     j.dd                                     +
-    FROM (tt5                                 +
-      CROSS JOIN tt6) j(aa, bb, cc_1, cc, dd);
-(1 row)
-
-create view v4 as select * from v1;
-alter view v1 rename column a to x;
-select pg_get_viewdef('v1', true);
-                  pg_get_viewdef                   
----------------------------------------------------
-  SELECT tt2.b,                                   +
-     tt3.c,                                       +
-     tt2.a AS x,                                  +
-     tt3.ax                                       +
-    FROM tt2                                      +
-      JOIN tt3 tt3(ax, b, c, c_1, e) USING (b, c);
-(1 row)
-
-select pg_get_viewdef('v4', true);
- pg_get_viewdef 
-----------------
-  SELECT v1.b, +
-     v1.c,     +
-     v1.x AS a,+
-     v1.ax     +
-    FROM v1;
-(1 row)
-
--- Unnamed FULL JOIN USING is lots of fun too
-create table tt7 (x int, xx int, y int);
-alter table tt7 drop column xx;
-create table tt8 (x int, z int);
-create view vv2 as
-select * from (values(1,2,3,4,5)) v(a,b,c,d,e)
-union all
-select * from tt7 full join tt8 using (x), tt8 tt8x;
-select pg_get_viewdef('vv2', true);
-                 pg_get_viewdef                 
-------------------------------------------------
-  SELECT v.a,                                  +
-     v.b,                                      +
-     v.c,                                      +
-     v.d,                                      +
-     v.e                                       +
-    FROM ( VALUES (1,2,3,4,5)) v(a, b, c, d, e)+
- UNION ALL                                     +
-  SELECT x AS a,                               +
-     tt7.y AS b,                               +
-     tt8.z AS c,                               +
-     tt8x.x_1 AS d,                            +
-     tt8x.z AS e                               +
-    FROM tt7                                   +
-      FULL JOIN tt8 USING (x),                 +
-     tt8 tt8x(x_1, z);
-(1 row)
-
-create view vv3 as
-select * from (values(1,2,3,4,5,6)) v(a,b,c,x,e,f)
-union all
-select * from
-  tt7 full join tt8 using (x),
-  tt7 tt7x full join tt8 tt8x using (x);
-select pg_get_viewdef('vv3', true);
-                   pg_get_viewdef                    
------------------------------------------------------
-  SELECT v.a,                                       +
-     v.b,                                           +
-     v.c,                                           +
-     v.x,                                           +
-     v.e,                                           +
-     v.f                                            +
-    FROM ( VALUES (1,2,3,4,5,6)) v(a, b, c, x, e, f)+
- UNION ALL                                          +
-  SELECT x AS a,                                    +
-     tt7.y AS b,                                    +
-     tt8.z AS c,                                    +
-     x_1 AS x,                                      +
-     tt7x.y AS e,                                   +
-     tt8x.z AS f                                    +
-    FROM tt7                                        +
-      FULL JOIN tt8 USING (x),                      +
-     tt7 tt7x(x_1, y)                               +
-      FULL JOIN tt8 tt8x(x_1, z) USING (x_1);
-(1 row)
-
-create view vv4 as
-select * from (values(1,2,3,4,5,6,7)) v(a,b,c,x,e,f,g)
-union all
-select * from
-  tt7 full join tt8 using (x),
-  tt7 tt7x full join tt8 tt8x using (x) full join tt8 tt8y using (x);
-select pg_get_viewdef('vv4', true);
-                      pg_get_viewdef                      
-----------------------------------------------------------
-  SELECT v.a,                                            +
-     v.b,                                                +
-     v.c,                                                +
-     v.x,                                                +
-     v.e,                                                +
-     v.f,                                                +
-     v.g                                                 +
-    FROM ( VALUES (1,2,3,4,5,6,7)) v(a, b, c, x, e, f, g)+
- UNION ALL                                               +
-  SELECT x AS a,                                         +
-     tt7.y AS b,                                         +
-     tt8.z AS c,                                         +
-     x_1 AS x,                                           +
-     tt7x.y AS e,                                        +
-     tt8x.z AS f,                                        +
-     tt8y.z AS g                                         +
-    FROM tt7                                             +
-      FULL JOIN tt8 USING (x),                           +
-     tt7 tt7x(x_1, y)                                    +
-      FULL JOIN tt8 tt8x(x_1, z) USING (x_1)             +
-      FULL JOIN tt8 tt8y(x_1, z) USING (x_1);
-(1 row)
-
-alter table tt7 add column zz int;
-alter table tt7 add column z int;
-alter table tt7 drop column zz;
-alter table tt8 add column z2 int;
-select pg_get_viewdef('vv2', true);
-                 pg_get_viewdef                 
-------------------------------------------------
-  SELECT v.a,                                  +
-     v.b,                                      +
-     v.c,                                      +
-     v.d,                                      +
-     v.e                                       +
-    FROM ( VALUES (1,2,3,4,5)) v(a, b, c, d, e)+
- UNION ALL                                     +
-  SELECT x AS a,                               +
-     tt7.y AS b,                               +
-     tt8.z AS c,                               +
-     tt8x.x_1 AS d,                            +
-     tt8x.z AS e                               +
-    FROM tt7                                   +
-      FULL JOIN tt8 USING (x),                 +
-     tt8 tt8x(x_1, z, z2);
-(1 row)
-
-select pg_get_viewdef('vv3', true);
-                   pg_get_viewdef                    
------------------------------------------------------
-  SELECT v.a,                                       +
-     v.b,                                           +
-     v.c,                                           +
-     v.x,                                           +
-     v.e,                                           +
-     v.f                                            +
-    FROM ( VALUES (1,2,3,4,5,6)) v(a, b, c, x, e, f)+
- UNION ALL                                          +
-  SELECT x AS a,                                    +
-     tt7.y AS b,                                    +
-     tt8.z AS c,                                    +
-     x_1 AS x,                                      +
-     tt7x.y AS e,                                   +
-     tt8x.z AS f                                    +
-    FROM tt7                                        +
-      FULL JOIN tt8 USING (x),                      +
-     tt7 tt7x(x_1, y, z)                            +
-      FULL JOIN tt8 tt8x(x_1, z, z2) USING (x_1);
-(1 row)
-
-select pg_get_viewdef('vv4', true);
-                      pg_get_viewdef                      
-----------------------------------------------------------
-  SELECT v.a,                                            +
-     v.b,                                                +
-     v.c,                                                +
-     v.x,                                                +
-     v.e,                                                +
-     v.f,                                                +
-     v.g                                                 +
-    FROM ( VALUES (1,2,3,4,5,6,7)) v(a, b, c, x, e, f, g)+
- UNION ALL                                               +
-  SELECT x AS a,                                         +
-     tt7.y AS b,                                         +
-     tt8.z AS c,                                         +
-     x_1 AS x,                                           +
-     tt7x.y AS e,                                        +
-     tt8x.z AS f,                                        +
-     tt8y.z AS g                                         +
-    FROM tt7                                             +
-      FULL JOIN tt8 USING (x),                           +
-     tt7 tt7x(x_1, y, z)                                 +
-      FULL JOIN tt8 tt8x(x_1, z, z2) USING (x_1)         +
-      FULL JOIN tt8 tt8y(x_1, z, z2) USING (x_1);
-(1 row)
-
--- Implicit coercions in a JOIN USING create issues similar to FULL JOIN
-create table tt7a (x date, xx int, y int);
-alter table tt7a drop column xx;
-create table tt8a (x timestamptz, z int);
-create view vv2a as
-select * from (values(now(),2,3,now(),5)) v(a,b,c,d,e)
-union all
-select * from tt7a left join tt8a using (x), tt8a tt8ax;
-select pg_get_viewdef('vv2a', true);
-                     pg_get_viewdef                     
---------------------------------------------------------
-  SELECT v.a,                                          +
-     v.b,                                              +
-     v.c,                                              +
-     v.d,                                              +
-     v.e                                               +
-    FROM ( VALUES (now(),2,3,now(),5)) v(a, b, c, d, e)+
- UNION ALL                                             +
-  SELECT x AS a,                                       +
-     tt7a.y AS b,                                      +
-     tt8a.z AS c,                                      +
-     tt8ax.x_1 AS d,                                   +
-     tt8ax.z AS e                                      +
-    FROM tt7a                                          +
-      LEFT JOIN tt8a USING (x),                        +
-     tt8a tt8ax(x_1, z);
-(1 row)
-
---
--- Also check dropping a column that existed when the view was made
---
-create table tt9 (x int, xx int, y int);
-create table tt10 (x int, z int);
-create view vv5 as select x,y,z from tt9 join tt10 using(x);
-select pg_get_viewdef('vv5', true);
-      pg_get_viewdef       
----------------------------
-  SELECT tt9.x,           +
-     tt9.y,               +
-     tt10.z               +
-    FROM tt9              +
-      JOIN tt10 USING (x);
-(1 row)
-
-alter table tt9 drop column xx;
-select pg_get_viewdef('vv5', true);
-      pg_get_viewdef       
----------------------------
-  SELECT tt9.x,           +
-     tt9.y,               +
-     tt10.z               +
-    FROM tt9              +
-      JOIN tt10 USING (x);
-(1 row)
-
---
--- Another corner case is that we might add a column to a table below a
--- JOIN USING, and thereby make the USING column name ambiguous
---
-create table tt11 (x int, y int);
-create table tt12 (x int, z int);
-create table tt13 (z int, q int);
-create view vv6 as select x,y,z,q from
-  (tt11 join tt12 using(x)) join tt13 using(z);
-select pg_get_viewdef('vv6', true);
-      pg_get_viewdef       
----------------------------
-  SELECT tt11.x,          +
-     tt11.y,              +
-     tt12.z,              +
-     tt13.q               +
-    FROM tt11             +
-      JOIN tt12 USING (x) +
-      JOIN tt13 USING (z);
-(1 row)
-
-alter table tt11 add column z int;
-select pg_get_viewdef('vv6', true);
-        pg_get_viewdef        
-------------------------------
-  SELECT tt11.x,             +
-     tt11.y,                 +
-     tt12.z,                 +
-     tt13.q                  +
-    FROM tt11 tt11(x, y, z_1)+
-      JOIN tt12 USING (x)    +
-      JOIN tt13 USING (z);
-(1 row)
-
---
--- Check cases involving dropped/altered columns in a function's rowtype result
---
-create table tt14t (f1 text, f2 text, f3 text, f4 text);
-insert into tt14t values('foo', 'bar', 'baz', '42');
-alter table tt14t drop column f2;
-create function tt14f() returns setof tt14t as
-$$
-declare
-    rec1 record;
-begin
-    for rec1 in select * from tt14t
-    loop
-        return next rec1;
-    end loop;
-end;
-$$
-language plpgsql;
-create view tt14v as select t.* from tt14f() t;
-select pg_get_viewdef('tt14v', true);
-         pg_get_viewdef         
---------------------------------
-  SELECT t.f1,                 +
-     t.f3,                     +
-     t.f4                      +
-    FROM tt14f() t(f1, f3, f4);
-(1 row)
-
-select * from tt14v;
- f1  | f3  | f4 
------+-----+----
- foo | baz | 42
-(1 row)
-
-begin;
--- this perhaps should be rejected, but it isn't:
-alter table tt14t drop column f3;
--- f3 is still in the view ...
-select pg_get_viewdef('tt14v', true);
-         pg_get_viewdef         
---------------------------------
-  SELECT t.f1,                 +
-     t.f3,                     +
-     t.f4                      +
-    FROM tt14f() t(f1, f3, f4);
-(1 row)
-
--- but will fail at execution
-select f1, f4 from tt14v;
- f1  | f4 
------+----
- foo | 42
-(1 row)
-
-select * from tt14v;
-ERROR:  attribute 3 of type record has been dropped
-rollback;
-begin;
--- this perhaps should be rejected, but it isn't:
-alter table tt14t alter column f4 type integer using f4::integer;
--- f4 is still in the view ...
-select pg_get_viewdef('tt14v', true);
-         pg_get_viewdef         
---------------------------------
-  SELECT t.f1,                 +
-     t.f3,                     +
-     t.f4                      +
-    FROM tt14f() t(f1, f3, f4);
-(1 row)
-
--- but will fail at execution
-select f1, f3 from tt14v;
- f1  | f3  
------+-----
- foo | baz
-(1 row)
-
-select * from tt14v;
-ERROR:  attribute 4 of type record has wrong type
-DETAIL:  Table has type integer, but query expects text.
-rollback;
--- check display of whole-row variables in some corner cases
-create type nestedcomposite as (x int8_tbl);
-create view tt15v as select row(i)::nestedcomposite from int8_tbl i;
-select * from tt15v;
-                   row                    
-------------------------------------------
- ("(123,456)")
- ("(123,4567890123456789)")
- ("(4567890123456789,123)")
- ("(4567890123456789,4567890123456789)")
- ("(4567890123456789,-4567890123456789)")
-(5 rows)
-
-select pg_get_viewdef('tt15v', true);
-                    pg_get_viewdef                    
-------------------------------------------------------
-  SELECT ROW(i.*::int8_tbl)::nestedcomposite AS "row"+
-    FROM int8_tbl i;
-(1 row)
-
-select row(i.*::int8_tbl)::nestedcomposite from int8_tbl i;
-                   row                    
-------------------------------------------
- ("(123,456)")
- ("(123,4567890123456789)")
- ("(4567890123456789,123)")
- ("(4567890123456789,4567890123456789)")
- ("(4567890123456789,-4567890123456789)")
-(5 rows)
-
-create view tt16v as select * from int8_tbl i, lateral(values(i)) ss;
-select * from tt16v;
-        q1        |        q2         |               column1                
-------------------+-------------------+--------------------------------------
-              123 |               456 | (123,456)
-              123 |  4567890123456789 | (123,4567890123456789)
- 4567890123456789 |               123 | (4567890123456789,123)
- 4567890123456789 |  4567890123456789 | (4567890123456789,4567890123456789)
- 4567890123456789 | -4567890123456789 | (4567890123456789,-4567890123456789)
-(5 rows)
-
-select pg_get_viewdef('tt16v', true);
-              pg_get_viewdef               
--------------------------------------------
-  SELECT i.q1,                            +
-     i.q2,                                +
-     ss.column1                           +
-    FROM int8_tbl i,                      +
-     LATERAL ( VALUES (i.*::int8_tbl)) ss;
-(1 row)
-
-select * from int8_tbl i, lateral(values(i.*::int8_tbl)) ss;
-        q1        |        q2         |               column1                
-------------------+-------------------+--------------------------------------
-              123 |               456 | (123,456)
-              123 |  4567890123456789 | (123,4567890123456789)
- 4567890123456789 |               123 | (4567890123456789,123)
- 4567890123456789 |  4567890123456789 | (4567890123456789,4567890123456789)
- 4567890123456789 | -4567890123456789 | (4567890123456789,-4567890123456789)
-(5 rows)
-
-create view tt17v as select * from int8_tbl i where i in (values(i));
-select * from tt17v;
-        q1        |        q2         
-------------------+-------------------
-              123 |               456
-              123 |  4567890123456789
- 4567890123456789 |               123
- 4567890123456789 |  4567890123456789
- 4567890123456789 | -4567890123456789
-(5 rows)
-
-select pg_get_viewdef('tt17v', true);
-               pg_get_viewdef                
----------------------------------------------
-  SELECT i.q1,                              +
-     i.q2                                   +
-    FROM int8_tbl i                         +
-   WHERE (i.* IN ( VALUES (i.*::int8_tbl)));
-(1 row)
-
-select * from int8_tbl i where i.* in (values(i.*::int8_tbl));
-        q1        |        q2         
-------------------+-------------------
-              123 |               456
-              123 |  4567890123456789
- 4567890123456789 |               123
- 4567890123456789 |  4567890123456789
- 4567890123456789 | -4567890123456789
-(5 rows)
-
--- check unique-ification of overlength names
-create view tt18v as
-  select * from int8_tbl xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxy
-  union all
-  select * from int8_tbl xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxz;
-NOTICE:  identifier "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxy" will be truncated to "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
-NOTICE:  identifier "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxz" will be truncated to "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
-select pg_get_viewdef('tt18v', true);
-                                  pg_get_viewdef                                   
------------------------------------------------------------------------------------
-  SELECT xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.q1,      +
-     xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.q2           +
-    FROM int8_tbl xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx +
- UNION ALL                                                                        +
-  SELECT xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.q1,      +
-     xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.q2           +
-    FROM int8_tbl xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx;
-(1 row)
-
-explain (costs off) select * from tt18v;
-                                         QUERY PLAN                                         
---------------------------------------------------------------------------------------------
- Append
-   ->  Seq Scan on int8_tbl xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
-   ->  Seq Scan on int8_tbl xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx_1
-(3 rows)
-
--- check display of ScalarArrayOp with a sub-select
-select 'foo'::text = any(array['abc','def','foo']::text[]);
- ?column? 
-----------
- t
-(1 row)
-
-select 'foo'::text = any((select array['abc','def','foo']::text[]));  -- fail
-ERROR:  operator does not exist: text = text[]
-LINE 1: select 'foo'::text = any((select array['abc','def','foo']::t...
-                           ^
-HINT:  No operator matches the given name and argument types. You might need to add explicit type casts.
-select 'foo'::text = any((select array['abc','def','foo']::text[])::text[]);
- ?column? 
-----------
- t
-(1 row)
-
-create view tt19v as
-select 'foo'::text = any(array['abc','def','foo']::text[]) c1,
-       'foo'::text = any((select array['abc','def','foo']::text[])::text[]) c2;
-select pg_get_viewdef('tt19v', true);
-                                               pg_get_viewdef                                               
-------------------------------------------------------------------------------------------------------------
-  SELECT 'foo'::text = ANY (ARRAY['abc'::text, 'def'::text, 'foo'::text]) AS c1,                           +
-     'foo'::text = ANY ((( SELECT ARRAY['abc'::text, 'def'::text, 'foo'::text] AS "array"))::text[]) AS c2;
-(1 row)
-
--- check display of assorted RTE_FUNCTION expressions
-create view tt20v as
-select * from
-  coalesce(1,2) as c,
-  collation for ('x'::text) col,
-  current_date as d,
-  localtimestamp(3) as t,
-  cast(1+2 as int4) as i4,
-  cast(1+2 as int8) as i8;
-select pg_get_viewdef('tt20v', true);
-               pg_get_viewdef                
----------------------------------------------
-  SELECT c.c,                               +
-     col.col,                               +
-     d.d,                                   +
-     t.t,                                   +
-     i4.i4,                                 +
-     i8.i8                                  +
-    FROM COALESCE(1, 2) c(c),               +
-     COLLATION FOR ('x'::text) col(col),    +
-     CURRENT_DATE d(d),                     +
-     LOCALTIMESTAMP(3) t(t),                +
-     CAST(1 + 2 AS integer) i4(i4),         +
-     CAST((1 + 2)::bigint AS bigint) i8(i8);
-(1 row)
-
--- reverse-listing of various special function syntaxes required by SQL
-create view tt201v as
-select
-  extract(day from now()) as extr,
-  (now(), '1 day'::interval) overlaps
-    (current_timestamp(2), '1 day'::interval) as o,
-  'foo' is normalized isn,
-  'foo' is nfkc normalized isnn,
-  normalize('foo') as n,
-  normalize('foo', nfkd) as nfkd,
-  overlay('foo' placing 'bar' from 2) as ovl,
-  overlay('foo' placing 'bar' from 2 for 3) as ovl2,
-  position('foo' in 'foobar') as p,
-  substring('foo' from 2 for 3) as s,
-  substring('foo' similar 'f' escape '#') as ss,
-  substring('foo' from 'oo') as ssf,  -- historically-permitted abuse
-  trim(' ' from ' foo ') as bt,
-  trim(leading ' ' from ' foo ') as lt,
-  trim(trailing ' foo ') as rt,
-  trim(E'\\000'::bytea from E'\\000Tom\\000'::bytea) as btb,
-  trim(leading E'\\000'::bytea from E'\\000Tom\\000'::bytea) as ltb,
-  trim(trailing E'\\000'::bytea from E'\\000Tom\\000'::bytea) as rtb;
-select pg_get_viewdef('tt201v', true);
-                                        pg_get_viewdef                                         
------------------------------------------------------------------------------------------------
-  SELECT EXTRACT(day FROM now()) AS extr,                                                     +
-     ((now(), '@ 1 day'::interval) OVERLAPS (CURRENT_TIMESTAMP(2), '@ 1 day'::interval)) AS o,+
-     (('foo'::text) IS NORMALIZED) AS isn,                                                    +
-     (('foo'::text) IS NFKC NORMALIZED) AS isnn,                                              +
-     NORMALIZE('foo'::text) AS n,                                                             +
-     NORMALIZE('foo'::text, NFKD) AS nfkd,                                                    +
-     OVERLAY('foo'::text PLACING 'bar'::text FROM 2) AS ovl,                                  +
-     OVERLAY('foo'::text PLACING 'bar'::text FROM 2 FOR 3) AS ovl2,                           +
-     POSITION(('foo'::text) IN ('foobar'::text)) AS p,                                        +
-     SUBSTRING('foo'::text FROM 2 FOR 3) AS s,                                                +
-     SUBSTRING('foo'::text SIMILAR 'f'::text ESCAPE '#'::text) AS ss,                         +
-     "substring"('foo'::text, 'oo'::text) AS ssf,                                             +
-     TRIM(BOTH ' '::text FROM ' foo '::text) AS bt,                                           +
-     TRIM(LEADING ' '::text FROM ' foo '::text) AS lt,                                        +
-     TRIM(TRAILING FROM ' foo '::text) AS rt,                                                 +
-     TRIM(BOTH '\x00'::bytea FROM '\x00546f6d00'::bytea) AS btb,                              +
-     TRIM(LEADING '\x00'::bytea FROM '\x00546f6d00'::bytea) AS ltb,                           +
-     TRIM(TRAILING '\x00'::bytea FROM '\x00546f6d00'::bytea) AS rtb;
-(1 row)
-
--- corner cases with empty join conditions
-create view tt21v as
-select * from tt5 natural inner join tt6;
-select pg_get_viewdef('tt21v', true);
-    pg_get_viewdef    
-----------------------
-  SELECT tt5.a,      +
-     tt5.b,          +
-     tt5.cc,         +
-     tt6.c,          +
-     tt6.d           +
-    FROM tt5         +
-      CROSS JOIN tt6;
-(1 row)
-
-create view tt22v as
-select * from tt5 natural left join tt6;
-select pg_get_viewdef('tt22v', true);
-       pg_get_viewdef        
------------------------------
-  SELECT tt5.a,             +
-     tt5.b,                 +
-     tt5.cc,                +
-     tt6.c,                 +
-     tt6.d                  +
-    FROM tt5                +
-      LEFT JOIN tt6 ON TRUE;
-(1 row)
-
--- check handling of views with immediately-renamed columns
-create view tt23v (col_a, col_b) as
-select q1 as other_name1, q2 as other_name2 from int8_tbl
-union
-select 42, 43;
-select pg_get_viewdef('tt23v', true);
-        pg_get_viewdef         
--------------------------------
-  SELECT int8_tbl.q1 AS col_a,+
-     int8_tbl.q2 AS col_b     +
-    FROM int8_tbl             +
- UNION                        +
-  SELECT 42 AS col_a,         +
-     43 AS col_b;
-(1 row)
-
-select pg_get_ruledef(oid, true) from pg_rewrite
-  where ev_class = 'tt23v'::regclass and ev_type = '1';
-                         pg_get_ruledef                          
------------------------------------------------------------------
- CREATE RULE "_RETURN" AS                                       +
-     ON SELECT TO tt23v DO INSTEAD  SELECT int8_tbl.q1 AS col_a,+
-     int8_tbl.q2 AS col_b                                       +
-    FROM int8_tbl                                               +
- UNION                                                          +
-  SELECT 42 AS col_a,                                           +
-     43 AS col_b;
-(1 row)
-
--- test extraction of FieldSelect field names (get_name_for_var_field)
-create view tt24v as
-with cte as materialized (select r from (values(1,2),(3,4)) r)
-select (r).column2 as col_a, (rr).column2 as col_b from
-  cte join (select rr from (values(1,7),(3,8)) rr limit 2) ss
-  on (r).column1 = (rr).column1;
-select pg_get_viewdef('tt24v', true);
-                       pg_get_viewdef                       
-------------------------------------------------------------
-  WITH cte AS MATERIALIZED (                               +
-          SELECT r.*::record AS r                          +
-            FROM ( VALUES (1,2), (3,4)) r                  +
-         )                                                 +
-  SELECT (cte.r).column2 AS col_a,                         +
-     (ss.rr).column2 AS col_b                              +
-    FROM cte                                               +
-      JOIN ( SELECT rr.*::record AS rr                     +
-            FROM ( VALUES (1,7), (3,8)) rr                 +
-          LIMIT 2) ss ON (cte.r).column1 = (ss.rr).column1;
-(1 row)
-
-create view tt25v as
-with cte as materialized (select pg_get_keywords() k)
-select (k).word from cte;
-select pg_get_viewdef('tt25v', true);
-             pg_get_viewdef             
-----------------------------------------
-  WITH cte AS MATERIALIZED (           +
-          SELECT pg_get_keywords() AS k+
-         )                             +
-  SELECT (cte.k).word AS word          +
-    FROM cte;
-(1 row)
-
--- also check cases seen only in EXPLAIN
-explain (verbose, costs off)
-select * from tt24v;
-                                        QUERY PLAN                                        
-------------------------------------------------------------------------------------------
- Hash Join
-   Output: (cte.r).column2, ((ROW("*VALUES*".column1, "*VALUES*".column2))).column2
-   Hash Cond: (((ROW("*VALUES*".column1, "*VALUES*".column2))).column1 = (cte.r).column1)
-   CTE cte
-     ->  Values Scan on "*VALUES*_1"
-           Output: ROW("*VALUES*_1".column1, "*VALUES*_1".column2)
-   ->  Limit
-         Output: (ROW("*VALUES*".column1, "*VALUES*".column2))
-         ->  Values Scan on "*VALUES*"
-               Output: ROW("*VALUES*".column1, "*VALUES*".column2)
-   ->  Hash
-         Output: cte.r
-         ->  CTE Scan on cte
-               Output: cte.r
-(14 rows)
-
-explain (verbose, costs off)
-select (r).column2 from (select r from (values(1,2),(3,4)) r limit 1) ss;
-                            QUERY PLAN                             
--------------------------------------------------------------------
- Subquery Scan on ss
-   Output: (ss.r).column2
-   ->  Limit
-         Output: (ROW("*VALUES*".column1, "*VALUES*".column2))
-         ->  Values Scan on "*VALUES*"
-               Output: ROW("*VALUES*".column1, "*VALUES*".column2)
-(6 rows)
-
--- test pretty-print parenthesization rules, and SubLink deparsing
-create view tt26v as
-select x + y + z as c1,
-       (x * y) + z as c2,
-       x + (y * z) as c3,
-       (x + y) * z as c4,
-       x * (y + z) as c5,
-       x + (y + z) as c6,
-       x + (y # z) as c7,
-       (x > y) AND (y > z OR x > z) as c8,
-       (x > y) OR (y > z AND NOT (x > z)) as c9,
-       (x,y) <> ALL (values(1,2),(3,4)) as c10,
-       (x,y) <= ANY (values(1,2),(3,4)) as c11
-from (values(1,2,3)) v(x,y,z);
-select pg_get_viewdef('tt26v', true);
-                     pg_get_viewdef                     
---------------------------------------------------------
-  SELECT v.x + v.y + v.z AS c1,                        +
-     v.x * v.y + v.z AS c2,                            +
-     v.x + v.y * v.z AS c3,                            +
-     (v.x + v.y) * v.z AS c4,                          +
-     v.x * (v.y + v.z) AS c5,                          +
-     v.x + (v.y + v.z) AS c6,                          +
-     v.x + (v.y # v.z) AS c7,                          +
-     v.x > v.y AND (v.y > v.z OR v.x > v.z) AS c8,     +
-     v.x > v.y OR v.y > v.z AND NOT v.x > v.z AS c9,   +
-     ((v.x, v.y) <> ALL ( VALUES (1,2), (3,4))) AS c10,+
-     ((v.x, v.y) <= ANY ( VALUES (1,2), (3,4))) AS c11 +
-    FROM ( VALUES (1,2,3)) v(x, y, z);
-(1 row)
-
--- clean up all the random objects we made above
-DROP SCHEMA temp_view_test CASCADE;
-NOTICE:  drop cascades to 27 other objects
-DETAIL:  drop cascades to table temp_view_test.base_table
-drop cascades to view v2_temp
-drop cascades to view v4_temp
-drop cascades to view v6_temp
-drop cascades to view v7_temp
-drop cascades to view v10_temp
-drop cascades to view v8_temp
-drop cascades to view v9_temp
-drop cascades to view v11_temp
-drop cascades to view v12_temp
-drop cascades to table temp_view_test.base_table2
-drop cascades to view v5_temp
-drop cascades to view temp_view_test.v1
-drop cascades to view temp_view_test.v2
-drop cascades to view temp_view_test.v3
-drop cascades to view temp_view_test.v4
-drop cascades to view temp_view_test.v5
-drop cascades to view temp_view_test.v6
-drop cascades to view temp_view_test.v7
-drop cascades to view temp_view_test.v8
-drop cascades to sequence temp_view_test.seq1
-drop cascades to view temp_view_test.v9
-drop cascades to table temp_view_test.tx1
-drop cascades to view aliased_view_1
-drop cascades to view aliased_view_2
-drop cascades to view aliased_view_3
-drop cascades to view aliased_view_4
-DROP SCHEMA testviewschm2 CASCADE;
-NOTICE:  drop cascades to 73 other objects
-DETAIL:  drop cascades to table t1
-drop cascades to view temporal1
-drop cascades to view temporal2
-drop cascades to view temporal3
-drop cascades to view temporal4
-drop cascades to table t2
-drop cascades to view nontemp1
-drop cascades to view nontemp2
-drop cascades to view nontemp3
-drop cascades to view nontemp4
-drop cascades to table tbl1
-drop cascades to table tbl2
-drop cascades to table tbl3
-drop cascades to table tbl4
-drop cascades to view mytempview
-drop cascades to view pubview
-drop cascades to view mysecview1
-drop cascades to view mysecview2
-drop cascades to view mysecview3
-drop cascades to view mysecview4
-drop cascades to view unspecified_types
-drop cascades to table tt1
-drop cascades to table tx1
-drop cascades to view view_of_joins
-drop cascades to table tbl1a
-drop cascades to view view_of_joins_2a
-drop cascades to view view_of_joins_2b
-drop cascades to view view_of_joins_2c
-drop cascades to view view_of_joins_2d
-drop cascades to table tt2
-drop cascades to table tt3
-drop cascades to table tt4
-drop cascades to view v1
-drop cascades to view v1a
-drop cascades to view v2
-drop cascades to view v2a
-drop cascades to view v3
-drop cascades to table tt5
-drop cascades to table tt6
-drop cascades to view vv1
-drop cascades to view v4
-drop cascades to table tt7
-drop cascades to table tt8
-drop cascades to view vv2
-drop cascades to view vv3
-drop cascades to view vv4
-drop cascades to table tt7a
-drop cascades to table tt8a
-drop cascades to view vv2a
-drop cascades to table tt9
-drop cascades to table tt10
-drop cascades to view vv5
-drop cascades to table tt11
-drop cascades to table tt12
-drop cascades to table tt13
-drop cascades to view vv6
-drop cascades to table tt14t
-drop cascades to function tt14f()
-drop cascades to view tt14v
-drop cascades to type nestedcomposite
-drop cascades to view tt15v
-drop cascades to view tt16v
-drop cascades to view tt17v
-drop cascades to view tt18v
-drop cascades to view tt19v
-drop cascades to view tt20v
-drop cascades to view tt201v
-drop cascades to view tt21v
-drop cascades to view tt22v
-drop cascades to view tt23v
-drop cascades to view tt24v
-drop cascades to view tt25v
-drop cascades to view tt26v
diff -U3 /Users/kenaniah/workspace/postgres/src/test/regress/expected/index_including.out /Users/kenaniah/workspace/postgres/src/test/regress/results/index_including.out
--- /Users/kenaniah/workspace/postgres/src/test/regress/expected/index_including.out	2021-10-03 17:41:49.000000000 -0700
+++ /Users/kenaniah/workspace/postgres/src/test/regress/results/index_including.out	2021-10-03 20:08:13.000000000 -0700
@@ -20,381 +20,11 @@
 (2 rows)
 
 \d tbl_include_reg_idx
-  Index "public.tbl_include_reg_idx"
- Column |  Type   | Key? | Definition 
---------+---------+------+------------
- c1     | integer | yes  | c1
- c2     | integer | yes  | c2
- c3     | integer | no   | c3
- c4     | box     | no   | c4
-btree, for table "public.tbl_include_reg"
+dyld: lazy symbol binding failed: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
+
+dyld: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
 
--- Unique index and unique constraint
-CREATE TABLE tbl_include_unique1 (c1 int, c2 int, c3 int, c4 box);
-INSERT INTO tbl_include_unique1 SELECT x, 2*x, 3*x, box('4,4,4,4') FROM generate_series(1,10) AS x;
-CREATE UNIQUE INDEX tbl_include_unique1_idx_unique ON tbl_include_unique1 using btree (c1, c2) INCLUDE (c3, c4);
-ALTER TABLE tbl_include_unique1 add UNIQUE USING INDEX tbl_include_unique1_idx_unique;
-ALTER TABLE tbl_include_unique1 add UNIQUE (c1, c2) INCLUDE (c3, c4);
-SELECT pg_get_indexdef(i.indexrelid)
-FROM pg_index i JOIN pg_class c ON i.indexrelid = c.oid
-WHERE i.indrelid = 'tbl_include_unique1'::regclass ORDER BY c.relname;
-                                                       pg_get_indexdef                                                       
------------------------------------------------------------------------------------------------------------------------------
- CREATE UNIQUE INDEX tbl_include_unique1_c1_c2_c3_c4_key ON public.tbl_include_unique1 USING btree (c1, c2) INCLUDE (c3, c4)
- CREATE UNIQUE INDEX tbl_include_unique1_idx_unique ON public.tbl_include_unique1 USING btree (c1, c2) INCLUDE (c3, c4)
-(2 rows)
-
--- Unique index and unique constraint. Both must fail.
-CREATE TABLE tbl_include_unique2 (c1 int, c2 int, c3 int, c4 box);
-INSERT INTO tbl_include_unique2 SELECT 1, 2, 3*x, box('4,4,4,4') FROM generate_series(1,10) AS x;
-CREATE UNIQUE INDEX tbl_include_unique2_idx_unique ON tbl_include_unique2 using btree (c1, c2) INCLUDE (c3, c4);
-ERROR:  could not create unique index "tbl_include_unique2_idx_unique"
-DETAIL:  Key (c1, c2)=(1, 2) is duplicated.
-ALTER TABLE tbl_include_unique2 add UNIQUE (c1, c2) INCLUDE (c3, c4);
-ERROR:  could not create unique index "tbl_include_unique2_c1_c2_c3_c4_key"
-DETAIL:  Key (c1, c2)=(1, 2) is duplicated.
--- PK constraint
-CREATE TABLE tbl_include_pk (c1 int, c2 int, c3 int, c4 box);
-INSERT INTO tbl_include_pk SELECT 1, 2*x, 3*x, box('4,4,4,4') FROM generate_series(1,10) AS x;
-ALTER TABLE tbl_include_pk add PRIMARY KEY (c1, c2) INCLUDE (c3, c4);
-SELECT pg_get_indexdef(i.indexrelid)
-FROM pg_index i JOIN pg_class c ON i.indexrelid = c.oid
-WHERE i.indrelid = 'tbl_include_pk'::regclass ORDER BY c.relname;
-                                            pg_get_indexdef                                             
---------------------------------------------------------------------------------------------------------
- CREATE UNIQUE INDEX tbl_include_pk_pkey ON public.tbl_include_pk USING btree (c1, c2) INCLUDE (c3, c4)
-(1 row)
-
-CREATE TABLE tbl_include_box (c1 int, c2 int, c3 int, c4 box);
-INSERT INTO tbl_include_box SELECT 1, 2*x, 3*x, box('4,4,4,4') FROM generate_series(1,10) AS x;
-CREATE UNIQUE INDEX tbl_include_box_idx_unique ON tbl_include_box using btree (c1, c2) INCLUDE (c3, c4);
-ALTER TABLE tbl_include_box add PRIMARY KEY USING INDEX tbl_include_box_idx_unique;
-SELECT pg_get_indexdef(i.indexrelid)
-FROM pg_index i JOIN pg_class c ON i.indexrelid = c.oid
-WHERE i.indrelid = 'tbl_include_box'::regclass ORDER BY c.relname;
-                                                pg_get_indexdef                                                 
-----------------------------------------------------------------------------------------------------------------
- CREATE UNIQUE INDEX tbl_include_box_idx_unique ON public.tbl_include_box USING btree (c1, c2) INCLUDE (c3, c4)
-(1 row)
-
--- PK constraint. Must fail.
-CREATE TABLE tbl_include_box_pk (c1 int, c2 int, c3 int, c4 box);
-INSERT INTO tbl_include_box_pk SELECT 1, 2, 3*x, box('4,4,4,4') FROM generate_series(1,10) AS x;
-ALTER TABLE tbl_include_box_pk add PRIMARY KEY (c1, c2) INCLUDE (c3, c4);
-ERROR:  could not create unique index "tbl_include_box_pk_pkey"
-DETAIL:  Key (c1, c2)=(1, 2) is duplicated.
-/*
- * 2. Test CREATE TABLE with constraint
- */
-CREATE TABLE tbl (c1 int,c2 int, c3 int, c4 box,
-				CONSTRAINT covering UNIQUE(c1,c2) INCLUDE(c3,c4));
-SELECT indexrelid::regclass, indnatts, indnkeyatts, indisunique, indisprimary, indkey, indclass FROM pg_index WHERE indrelid = 'tbl'::regclass::oid;
- indexrelid | indnatts | indnkeyatts | indisunique | indisprimary | indkey  | indclass  
-------------+----------+-------------+-------------+--------------+---------+-----------
- covering   |        4 |           2 | t           | f            | 1 2 3 4 | 1978 1978
-(1 row)
-
-SELECT pg_get_constraintdef(oid), conname, conkey FROM pg_constraint WHERE conrelid = 'tbl'::regclass::oid;
-       pg_get_constraintdef       | conname  | conkey 
-----------------------------------+----------+--------
- UNIQUE (c1, c2) INCLUDE (c3, c4) | covering | {1,2}
-(1 row)
-
--- ensure that constraint works
-INSERT INTO tbl SELECT 1, 2, 3*x, box('4,4,4,4') FROM generate_series(1,10) AS x;
-ERROR:  duplicate key value violates unique constraint "covering"
-DETAIL:  Key (c1, c2)=(1, 2) already exists.
-DROP TABLE tbl;
-CREATE TABLE tbl (c1 int,c2 int, c3 int, c4 box,
-				CONSTRAINT covering PRIMARY KEY(c1,c2) INCLUDE(c3,c4));
-SELECT indexrelid::regclass, indnatts, indnkeyatts, indisunique, indisprimary, indkey, indclass FROM pg_index WHERE indrelid = 'tbl'::regclass::oid;
- indexrelid | indnatts | indnkeyatts | indisunique | indisprimary | indkey  | indclass  
-------------+----------+-------------+-------------+--------------+---------+-----------
- covering   |        4 |           2 | t           | t            | 1 2 3 4 | 1978 1978
-(1 row)
-
-SELECT pg_get_constraintdef(oid), conname, conkey FROM pg_constraint WHERE conrelid = 'tbl'::regclass::oid;
-         pg_get_constraintdef          | conname  | conkey 
----------------------------------------+----------+--------
- PRIMARY KEY (c1, c2) INCLUDE (c3, c4) | covering | {1,2}
-(1 row)
-
--- ensure that constraint works
-INSERT INTO tbl SELECT 1, 2, 3*x, box('4,4,4,4') FROM generate_series(1,10) AS x;
-ERROR:  duplicate key value violates unique constraint "covering"
-DETAIL:  Key (c1, c2)=(1, 2) already exists.
-INSERT INTO tbl SELECT 1, NULL, 3*x, box('4,4,4,4') FROM generate_series(1,10) AS x;
-ERROR:  null value in column "c2" of relation "tbl" violates not-null constraint
-DETAIL:  Failing row contains (1, null, 3, (4,4),(4,4)).
-INSERT INTO tbl SELECT x, 2*x, NULL, NULL FROM generate_series(1,300) AS x;
-explain (costs off)
-select * from tbl where (c1,c2,c3) < (2,5,1);
-                   QUERY PLAN                   
-------------------------------------------------
- Bitmap Heap Scan on tbl
-   Filter: (ROW(c1, c2, c3) < ROW(2, 5, 1))
-   ->  Bitmap Index Scan on covering
-         Index Cond: (ROW(c1, c2) <= ROW(2, 5))
-(4 rows)
-
-select * from tbl where (c1,c2,c3) < (2,5,1);
- c1 | c2 | c3 | c4 
-----+----+----+----
-  1 |  2 |    | 
-  2 |  4 |    | 
-(2 rows)
-
--- row comparison that compares high key at page boundary
-SET enable_seqscan = off;
-explain (costs off)
-select * from tbl where (c1,c2,c3) < (262,1,1) limit 1;
-                     QUERY PLAN                     
-----------------------------------------------------
- Limit
-   ->  Index Only Scan using covering on tbl
-         Index Cond: (ROW(c1, c2) <= ROW(262, 1))
-         Filter: (ROW(c1, c2, c3) < ROW(262, 1, 1))
-(4 rows)
-
-select * from tbl where (c1,c2,c3) < (262,1,1) limit 1;
- c1 | c2 | c3 | c4 
-----+----+----+----
-  1 |  2 |    | 
-(1 row)
-
-DROP TABLE tbl;
-RESET enable_seqscan;
-CREATE TABLE tbl (c1 int,c2 int, c3 int, c4 box,
-				UNIQUE(c1,c2) INCLUDE(c3,c4));
-SELECT indexrelid::regclass, indnatts, indnkeyatts, indisunique, indisprimary, indkey, indclass FROM pg_index WHERE indrelid = 'tbl'::regclass::oid;
-     indexrelid      | indnatts | indnkeyatts | indisunique | indisprimary | indkey  | indclass  
----------------------+----------+-------------+-------------+--------------+---------+-----------
- tbl_c1_c2_c3_c4_key |        4 |           2 | t           | f            | 1 2 3 4 | 1978 1978
-(1 row)
-
-SELECT pg_get_constraintdef(oid), conname, conkey FROM pg_constraint WHERE conrelid = 'tbl'::regclass::oid;
-       pg_get_constraintdef       |       conname       | conkey 
-----------------------------------+---------------------+--------
- UNIQUE (c1, c2) INCLUDE (c3, c4) | tbl_c1_c2_c3_c4_key | {1,2}
-(1 row)
-
--- ensure that constraint works
-INSERT INTO tbl SELECT 1, 2, 3*x, box('4,4,4,4') FROM generate_series(1,10) AS x;
-ERROR:  duplicate key value violates unique constraint "tbl_c1_c2_c3_c4_key"
-DETAIL:  Key (c1, c2)=(1, 2) already exists.
-DROP TABLE tbl;
-CREATE TABLE tbl (c1 int,c2 int, c3 int, c4 box,
-				PRIMARY KEY(c1,c2) INCLUDE(c3,c4));
-SELECT indexrelid::regclass, indnatts, indnkeyatts, indisunique, indisprimary, indkey, indclass FROM pg_index WHERE indrelid = 'tbl'::regclass::oid;
- indexrelid | indnatts | indnkeyatts | indisunique | indisprimary | indkey  | indclass  
-------------+----------+-------------+-------------+--------------+---------+-----------
- tbl_pkey   |        4 |           2 | t           | t            | 1 2 3 4 | 1978 1978
-(1 row)
-
-SELECT pg_get_constraintdef(oid), conname, conkey FROM pg_constraint WHERE conrelid = 'tbl'::regclass::oid;
-         pg_get_constraintdef          | conname  | conkey 
----------------------------------------+----------+--------
- PRIMARY KEY (c1, c2) INCLUDE (c3, c4) | tbl_pkey | {1,2}
-(1 row)
-
--- ensure that constraint works
-INSERT INTO tbl SELECT 1, 2, 3*x, box('4,4,4,4') FROM generate_series(1,10) AS x;
-ERROR:  duplicate key value violates unique constraint "tbl_pkey"
-DETAIL:  Key (c1, c2)=(1, 2) already exists.
-INSERT INTO tbl SELECT 1, NULL, 3*x, box('4,4,4,4') FROM generate_series(1,10) AS x;
-ERROR:  null value in column "c2" of relation "tbl" violates not-null constraint
-DETAIL:  Failing row contains (1, null, 3, (4,4),(4,4)).
-INSERT INTO tbl SELECT x, 2*x, NULL, NULL FROM generate_series(1,10) AS x;
-DROP TABLE tbl;
-CREATE TABLE tbl (c1 int,c2 int, c3 int, c4 box,
-				EXCLUDE USING btree (c1 WITH =) INCLUDE(c3,c4));
-SELECT indexrelid::regclass, indnatts, indnkeyatts, indisunique, indisprimary, indkey, indclass FROM pg_index WHERE indrelid = 'tbl'::regclass::oid;
-    indexrelid     | indnatts | indnkeyatts | indisunique | indisprimary | indkey | indclass 
--------------------+----------+-------------+-------------+--------------+--------+----------
- tbl_c1_c3_c4_excl |        3 |           1 | f           | f            | 1 3 4  | 1978
-(1 row)
-
-SELECT pg_get_constraintdef(oid), conname, conkey FROM pg_constraint WHERE conrelid = 'tbl'::regclass::oid;
-               pg_get_constraintdef               |      conname      | conkey 
---------------------------------------------------+-------------------+--------
- EXCLUDE USING btree (c1 WITH =) INCLUDE (c3, c4) | tbl_c1_c3_c4_excl | {1}
-(1 row)
-
--- ensure that constraint works
-INSERT INTO tbl SELECT 1, 2, 3*x, box('4,4,4,4') FROM generate_series(1,10) AS x;
-ERROR:  conflicting key value violates exclusion constraint "tbl_c1_c3_c4_excl"
-DETAIL:  Key (c1)=(1) conflicts with existing key (c1)=(1).
-INSERT INTO tbl SELECT x, 2*x, NULL, NULL FROM generate_series(1,10) AS x;
-DROP TABLE tbl;
-/*
- * 3.0 Test ALTER TABLE DROP COLUMN.
- * Any column deletion leads to index deletion.
- */
-CREATE TABLE tbl (c1 int,c2 int, c3 int, c4 int);
-CREATE UNIQUE INDEX tbl_idx ON tbl using btree(c1, c2, c3, c4);
-SELECT indexdef FROM pg_indexes WHERE tablename = 'tbl' ORDER BY indexname;
-                                indexdef                                
-------------------------------------------------------------------------
- CREATE UNIQUE INDEX tbl_idx ON public.tbl USING btree (c1, c2, c3, c4)
-(1 row)
-
-ALTER TABLE tbl DROP COLUMN c3;
-SELECT indexdef FROM pg_indexes WHERE tablename = 'tbl' ORDER BY indexname;
- indexdef 
-----------
-(0 rows)
-
-DROP TABLE tbl;
-/*
- * 3.1 Test ALTER TABLE DROP COLUMN.
- * Included column deletion leads to the index deletion,
- * AS well AS key columns deletion. It's explained in documentation.
- */
-CREATE TABLE tbl (c1 int,c2 int, c3 int, c4 box);
-CREATE UNIQUE INDEX tbl_idx ON tbl using btree(c1, c2) INCLUDE(c3,c4);
-SELECT indexdef FROM pg_indexes WHERE tablename = 'tbl' ORDER BY indexname;
-                                    indexdef                                     
----------------------------------------------------------------------------------
- CREATE UNIQUE INDEX tbl_idx ON public.tbl USING btree (c1, c2) INCLUDE (c3, c4)
-(1 row)
-
-ALTER TABLE tbl DROP COLUMN c3;
-SELECT indexdef FROM pg_indexes WHERE tablename = 'tbl' ORDER BY indexname;
- indexdef 
-----------
-(0 rows)
-
-DROP TABLE tbl;
-/*
- * 3.2 Test ALTER TABLE DROP COLUMN.
- * Included column deletion leads to the index deletion.
- * AS well AS key columns deletion. It's explained in documentation.
- */
-CREATE TABLE tbl (c1 int,c2 int, c3 int, c4 box, UNIQUE(c1, c2) INCLUDE(c3,c4));
-SELECT indexdef FROM pg_indexes WHERE tablename = 'tbl' ORDER BY indexname;
-                                          indexdef                                           
----------------------------------------------------------------------------------------------
- CREATE UNIQUE INDEX tbl_c1_c2_c3_c4_key ON public.tbl USING btree (c1, c2) INCLUDE (c3, c4)
-(1 row)
-
-ALTER TABLE tbl DROP COLUMN c3;
-SELECT indexdef FROM pg_indexes WHERE tablename = 'tbl' ORDER BY indexname;
- indexdef 
-----------
-(0 rows)
-
-ALTER TABLE tbl DROP COLUMN c1;
-SELECT indexdef FROM pg_indexes WHERE tablename = 'tbl' ORDER BY indexname;
- indexdef 
-----------
-(0 rows)
-
-DROP TABLE tbl;
-/*
- * 3.3 Test ALTER TABLE SET STATISTICS
- */
-CREATE TABLE tbl (c1 int, c2 int);
-CREATE INDEX tbl_idx ON tbl (c1, (c1+0)) INCLUDE (c2);
-ALTER INDEX tbl_idx ALTER COLUMN 1 SET STATISTICS 1000;
-ERROR:  cannot alter statistics on non-expression column "c1" of index "tbl_idx"
-HINT:  Alter statistics on table column instead.
-ALTER INDEX tbl_idx ALTER COLUMN 2 SET STATISTICS 1000;
-ALTER INDEX tbl_idx ALTER COLUMN 3 SET STATISTICS 1000;
-ERROR:  cannot alter statistics on included column "c2" of index "tbl_idx"
-ALTER INDEX tbl_idx ALTER COLUMN 4 SET STATISTICS 1000;
-ERROR:  column number 4 of relation "tbl_idx" does not exist
-DROP TABLE tbl;
-/*
- * 4. CREATE INDEX CONCURRENTLY
- */
-CREATE TABLE tbl (c1 int,c2 int, c3 int, c4 box, UNIQUE(c1, c2) INCLUDE(c3,c4));
-INSERT INTO tbl SELECT x, 2*x, 3*x, box('4,4,4,4') FROM generate_series(1,1000) AS x;
-CREATE UNIQUE INDEX CONCURRENTLY on tbl (c1, c2) INCLUDE (c3, c4);
-SELECT indexdef FROM pg_indexes WHERE tablename = 'tbl' ORDER BY indexname;
-                                          indexdef                                           
----------------------------------------------------------------------------------------------
- CREATE UNIQUE INDEX tbl_c1_c2_c3_c4_idx ON public.tbl USING btree (c1, c2) INCLUDE (c3, c4)
- CREATE UNIQUE INDEX tbl_c1_c2_c3_c4_key ON public.tbl USING btree (c1, c2) INCLUDE (c3, c4)
-(2 rows)
-
-DROP TABLE tbl;
-/*
- * 5. REINDEX
- */
-CREATE TABLE tbl (c1 int,c2 int, c3 int, c4 box, UNIQUE(c1, c2) INCLUDE(c3,c4));
-SELECT indexdef FROM pg_indexes WHERE tablename = 'tbl' ORDER BY indexname;
-                                          indexdef                                           
----------------------------------------------------------------------------------------------
- CREATE UNIQUE INDEX tbl_c1_c2_c3_c4_key ON public.tbl USING btree (c1, c2) INCLUDE (c3, c4)
-(1 row)
-
-ALTER TABLE tbl DROP COLUMN c3;
-SELECT indexdef FROM pg_indexes WHERE tablename = 'tbl' ORDER BY indexname;
- indexdef 
-----------
-(0 rows)
-
-REINDEX INDEX tbl_c1_c2_c3_c4_key;
-ERROR:  relation "tbl_c1_c2_c3_c4_key" does not exist
-SELECT indexdef FROM pg_indexes WHERE tablename = 'tbl' ORDER BY indexname;
- indexdef 
-----------
-(0 rows)
-
-ALTER TABLE tbl DROP COLUMN c1;
-SELECT indexdef FROM pg_indexes WHERE tablename = 'tbl' ORDER BY indexname;
- indexdef 
-----------
-(0 rows)
-
-DROP TABLE tbl;
-/*
- * 7. Check various AMs. All but btree, gist and spgist must fail.
- */
-CREATE TABLE tbl (c1 int,c2 int, c3 box, c4 box);
-CREATE INDEX on tbl USING brin(c1, c2) INCLUDE (c3, c4);
-ERROR:  access method "brin" does not support included columns
-CREATE INDEX on tbl USING gist(c3) INCLUDE (c1, c4);
-CREATE INDEX on tbl USING spgist(c3) INCLUDE (c4);
-CREATE INDEX on tbl USING gin(c1, c2) INCLUDE (c3, c4);
-ERROR:  access method "gin" does not support included columns
-CREATE INDEX on tbl USING hash(c1, c2) INCLUDE (c3, c4);
-ERROR:  access method "hash" does not support included columns
-CREATE INDEX on tbl USING rtree(c3) INCLUDE (c1, c4);
-NOTICE:  substituting access method "gist" for obsolete method "rtree"
-CREATE INDEX on tbl USING btree(c1, c2) INCLUDE (c3, c4);
-DROP TABLE tbl;
-/*
- * 8. Update, delete values in indexed table.
- */
-CREATE TABLE tbl (c1 int, c2 int, c3 int, c4 box);
-INSERT INTO tbl SELECT x, 2*x, 3*x, box('4,4,4,4') FROM generate_series(1,10) AS x;
-CREATE UNIQUE INDEX tbl_idx_unique ON tbl using btree(c1, c2) INCLUDE (c3,c4);
-UPDATE tbl SET c1 = 100 WHERE c1 = 2;
-UPDATE tbl SET c1 = 1 WHERE c1 = 3;
--- should fail
-UPDATE tbl SET c2 = 2 WHERE c1 = 1;
-ERROR:  duplicate key value violates unique constraint "tbl_idx_unique"
-DETAIL:  Key (c1, c2)=(1, 2) already exists.
-UPDATE tbl SET c3 = 1;
-DELETE FROM tbl WHERE c1 = 5 OR c3 = 12;
-DROP TABLE tbl;
-/*
- * 9. Alter column type.
- */
-CREATE TABLE tbl (c1 int,c2 int, c3 int, c4 box, UNIQUE(c1, c2) INCLUDE(c3,c4));
-INSERT INTO tbl SELECT x, 2*x, 3*x, box('4,4,4,4') FROM generate_series(1,10) AS x;
-ALTER TABLE tbl ALTER c1 TYPE bigint;
-ALTER TABLE tbl ALTER c3 TYPE bigint;
-\d tbl
-                Table "public.tbl"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- c1     | bigint  |           |          | 
- c2     | integer |           |          | 
- c3     | bigint  |           |          | 
- c4     | box     |           |          | 
-Indexes:
-    "tbl_c1_c2_c3_c4_key" UNIQUE CONSTRAINT, btree (c1, c2) INCLUDE (c3, c4)
-
-DROP TABLE tbl;
diff -U3 /Users/kenaniah/workspace/postgres/src/test/regress/expected/index_including_gist.out /Users/kenaniah/workspace/postgres/src/test/regress/results/index_including_gist.out
--- /Users/kenaniah/workspace/postgres/src/test/regress/expected/index_including_gist.out	2021-10-03 17:41:49.000000000 -0700
+++ /Users/kenaniah/workspace/postgres/src/test/regress/results/index_including_gist.out	2021-10-03 20:08:14.000000000 -0700
@@ -126,41 +126,11 @@
 ALTER TABLE tbl_gist ALTER c1 TYPE bigint;
 ALTER TABLE tbl_gist ALTER c3 TYPE bigint;
 \d tbl_gist
-              Table "public.tbl_gist"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- c1     | bigint  |           |          | 
- c2     | integer |           |          | 
- c3     | bigint  |           |          | 
- c4     | box     |           |          | 
-Indexes:
-    "tbl_gist_idx" gist (c4) INCLUDE (c1, c3)
+dyld: lazy symbol binding failed: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
 
-DROP TABLE tbl_gist;
-/*
- * 6. EXCLUDE constraint.
- */
-CREATE TABLE tbl_gist (c1 int, c2 int, c3 int, c4 box, EXCLUDE USING gist (c4 WITH &&) INCLUDE (c1, c2, c3));
-INSERT INTO tbl_gist SELECT x, 2*x, 3*x, box(point(x,x+1),point(2*x,2*x+1)) FROM generate_series(1,10) AS x;
-ERROR:  conflicting key value violates exclusion constraint "tbl_gist_c4_c1_c2_c3_excl"
-DETAIL:  Key (c4)=((4,5),(2,3)) conflicts with existing key (c4)=((2,3),(1,2)).
-INSERT INTO tbl_gist SELECT x, 2*x, 3*x, box(point(3*x,2*x),point(3*x+1,2*x+1)) FROM generate_series(1,10) AS x;
-EXPLAIN  (costs off) SELECT * FROM tbl_gist where c4 <@ box(point(1,1),point(10,10));
-                         QUERY PLAN                          
--------------------------------------------------------------
- Index Only Scan using tbl_gist_c4_c1_c2_c3_excl on tbl_gist
-   Index Cond: (c4 <@ '(10,10),(1,1)'::box)
-(2 rows)
+dyld: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
 
-\d tbl_gist
-              Table "public.tbl_gist"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- c1     | integer |           |          | 
- c2     | integer |           |          | 
- c3     | integer |           |          | 
- c4     | box     |           |          | 
-Indexes:
-    "tbl_gist_c4_c1_c2_c3_excl" EXCLUDE USING gist (c4 WITH &&) INCLUDE (c1, c2, c3)
-
-DROP TABLE tbl_gist;
diff -U3 /Users/kenaniah/workspace/postgres/src/test/regress/expected/create_aggregate.out /Users/kenaniah/workspace/postgres/src/test/regress/results/create_aggregate.out
--- /Users/kenaniah/workspace/postgres/src/test/regress/expected/create_aggregate.out	2021-10-03 17:41:49.000000000 -0700
+++ /Users/kenaniah/workspace/postgres/src/test/regress/results/create_aggregate.out	2021-10-03 20:08:14.000000000 -0700
@@ -112,213 +112,11 @@
 alter aggregate my_rank(VARIADIC "any" ORDER BY VARIADIC "any")
   rename to test_rank;
 \da test_*
-                                       List of aggregate functions
- Schema |         Name         | Result data type |          Argument data types           | Description 
---------+----------------------+------------------+----------------------------------------+-------------
- public | test_percentile_disc | anyelement       | double precision ORDER BY anyelement   | 
- public | test_rank            | bigint           | VARIADIC "any" ORDER BY VARIADIC "any" | 
-(2 rows)
+dyld: lazy symbol binding failed: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
 
--- moving-aggregate options
-CREATE AGGREGATE sumdouble (float8)
-(
-    stype = float8,
-    sfunc = float8pl,
-    mstype = float8,
-    msfunc = float8pl,
-    minvfunc = float8mi
-);
--- aggregate combine and serialization functions
--- can't specify just one of serialfunc and deserialfunc
-CREATE AGGREGATE myavg (numeric)
-(
-	stype = internal,
-	sfunc = numeric_avg_accum,
-	serialfunc = numeric_avg_serialize
-);
-ERROR:  must specify both or neither of serialization and deserialization functions
--- serialfunc must have correct parameters
-CREATE AGGREGATE myavg (numeric)
-(
-	stype = internal,
-	sfunc = numeric_avg_accum,
-	serialfunc = numeric_avg_deserialize,
-	deserialfunc = numeric_avg_deserialize
-);
-ERROR:  function numeric_avg_deserialize(internal) does not exist
--- deserialfunc must have correct parameters
-CREATE AGGREGATE myavg (numeric)
-(
-	stype = internal,
-	sfunc = numeric_avg_accum,
-	serialfunc = numeric_avg_serialize,
-	deserialfunc = numeric_avg_serialize
-);
-ERROR:  function numeric_avg_serialize(bytea, internal) does not exist
--- ensure combine function parameters are checked
-CREATE AGGREGATE myavg (numeric)
-(
-	stype = internal,
-	sfunc = numeric_avg_accum,
-	serialfunc = numeric_avg_serialize,
-	deserialfunc = numeric_avg_deserialize,
-	combinefunc = int4larger
-);
-ERROR:  function int4larger(internal, internal) does not exist
--- ensure create aggregate works.
-CREATE AGGREGATE myavg (numeric)
-(
-	stype = internal,
-	sfunc = numeric_avg_accum,
-	finalfunc = numeric_avg,
-	serialfunc = numeric_avg_serialize,
-	deserialfunc = numeric_avg_deserialize,
-	combinefunc = numeric_avg_combine,
-	finalfunc_modify = shareable  -- just to test a non-default setting
-);
--- Ensure all these functions made it into the catalog
-SELECT aggfnoid, aggtransfn, aggcombinefn, aggtranstype::regtype,
-       aggserialfn, aggdeserialfn, aggfinalmodify
-FROM pg_aggregate
-WHERE aggfnoid = 'myavg'::REGPROC;
- aggfnoid |    aggtransfn     |    aggcombinefn     | aggtranstype |      aggserialfn      |      aggdeserialfn      | aggfinalmodify 
-----------+-------------------+---------------------+--------------+-----------------------+-------------------------+----------------
- myavg    | numeric_avg_accum | numeric_avg_combine | internal     | numeric_avg_serialize | numeric_avg_deserialize | s
-(1 row)
+dyld: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
 
-DROP AGGREGATE myavg (numeric);
--- create or replace aggregate
-CREATE AGGREGATE myavg (numeric)
-(
-	stype = internal,
-	sfunc = numeric_avg_accum,
-	finalfunc = numeric_avg
-);
-CREATE OR REPLACE AGGREGATE myavg (numeric)
-(
-	stype = internal,
-	sfunc = numeric_avg_accum,
-	finalfunc = numeric_avg,
-	serialfunc = numeric_avg_serialize,
-	deserialfunc = numeric_avg_deserialize,
-	combinefunc = numeric_avg_combine,
-	finalfunc_modify = shareable  -- just to test a non-default setting
-);
--- Ensure all these functions made it into the catalog again
-SELECT aggfnoid, aggtransfn, aggcombinefn, aggtranstype::regtype,
-       aggserialfn, aggdeserialfn, aggfinalmodify
-FROM pg_aggregate
-WHERE aggfnoid = 'myavg'::REGPROC;
- aggfnoid |    aggtransfn     |    aggcombinefn     | aggtranstype |      aggserialfn      |      aggdeserialfn      | aggfinalmodify 
-----------+-------------------+---------------------+--------------+-----------------------+-------------------------+----------------
- myavg    | numeric_avg_accum | numeric_avg_combine | internal     | numeric_avg_serialize | numeric_avg_deserialize | s
-(1 row)
-
--- can change stype:
-CREATE OR REPLACE AGGREGATE myavg (numeric)
-(
-	stype = numeric,
-	sfunc = numeric_add
-);
-SELECT aggfnoid, aggtransfn, aggcombinefn, aggtranstype::regtype,
-       aggserialfn, aggdeserialfn, aggfinalmodify
-FROM pg_aggregate
-WHERE aggfnoid = 'myavg'::REGPROC;
- aggfnoid | aggtransfn  | aggcombinefn | aggtranstype | aggserialfn | aggdeserialfn | aggfinalmodify 
-----------+-------------+--------------+--------------+-------------+---------------+----------------
- myavg    | numeric_add | -            | numeric      | -           | -             | r
-(1 row)
-
--- can't change return type:
-CREATE OR REPLACE AGGREGATE myavg (numeric)
-(
-	stype = numeric,
-	sfunc = numeric_add,
-	finalfunc = numeric_out
-);
-ERROR:  cannot change return type of existing function
-HINT:  Use DROP AGGREGATE myavg(numeric) first.
--- can't change to a different kind:
-CREATE OR REPLACE AGGREGATE myavg (order by numeric)
-(
-	stype = numeric,
-	sfunc = numeric_add
-);
-ERROR:  cannot change routine kind
-DETAIL:  "myavg" is an ordinary aggregate function.
--- can't change plain function to aggregate:
-create function sum4(int8,int8,int8,int8) returns int8 as
-'select $1 + $2 + $3 + $4' language sql strict immutable;
-CREATE OR REPLACE AGGREGATE sum3 (int8,int8,int8)
-(
-	stype = int8,
-	sfunc = sum4
-);
-ERROR:  cannot change routine kind
-DETAIL:  "sum3" is a function.
-drop function sum4(int8,int8,int8,int8);
-DROP AGGREGATE myavg (numeric);
--- invalid: bad parallel-safety marking
-CREATE AGGREGATE mysum (int)
-(
-	stype = int,
-	sfunc = int4pl,
-	parallel = pear
-);
-ERROR:  parameter "parallel" must be SAFE, RESTRICTED, or UNSAFE
--- invalid: nonstrict inverse with strict forward function
-CREATE FUNCTION float8mi_n(float8, float8) RETURNS float8 AS
-$$ SELECT $1 - $2; $$
-LANGUAGE SQL;
-CREATE AGGREGATE invalidsumdouble (float8)
-(
-    stype = float8,
-    sfunc = float8pl,
-    mstype = float8,
-    msfunc = float8pl,
-    minvfunc = float8mi_n
-);
-ERROR:  strictness of aggregate's forward and inverse transition functions must match
--- invalid: non-matching result types
-CREATE FUNCTION float8mi_int(float8, float8) RETURNS int AS
-$$ SELECT CAST($1 - $2 AS INT); $$
-LANGUAGE SQL;
-CREATE AGGREGATE wrongreturntype (float8)
-(
-    stype = float8,
-    sfunc = float8pl,
-    mstype = float8,
-    msfunc = float8pl,
-    minvfunc = float8mi_int
-);
-ERROR:  return type of inverse transition function float8mi_int is not double precision
--- invalid: non-lowercase quoted identifiers
-CREATE AGGREGATE case_agg ( -- old syntax
-	"Sfunc1" = int4pl,
-	"Basetype" = int4,
-	"Stype1" = int4,
-	"Initcond1" = '0',
-	"Parallel" = safe
-);
-WARNING:  aggregate attribute "Sfunc1" not recognized
-WARNING:  aggregate attribute "Basetype" not recognized
-WARNING:  aggregate attribute "Stype1" not recognized
-WARNING:  aggregate attribute "Initcond1" not recognized
-WARNING:  aggregate attribute "Parallel" not recognized
-ERROR:  aggregate stype must be specified
-CREATE AGGREGATE case_agg(float8)
-(
-	"Stype" = internal,
-	"Sfunc" = ordered_set_transition,
-	"Finalfunc" = percentile_disc_final,
-	"Finalfunc_extra" = true,
-	"Finalfunc_modify" = read_write,
-	"Parallel" = safe
-);
-WARNING:  aggregate attribute "Stype" not recognized
-WARNING:  aggregate attribute "Sfunc" not recognized
-WARNING:  aggregate attribute "Finalfunc" not recognized
-WARNING:  aggregate attribute "Finalfunc_extra" not recognized
-WARNING:  aggregate attribute "Finalfunc_modify" not recognized
-WARNING:  aggregate attribute "Parallel" not recognized
-ERROR:  aggregate stype must be specified
diff -U3 /Users/kenaniah/workspace/postgres/src/test/regress/expected/constraints.out /Users/kenaniah/workspace/postgres/src/test/regress/results/constraints.out
--- /Users/kenaniah/workspace/postgres/src/test/regress/expected/constraints.out	2021-10-03 20:08:03.000000000 -0700
+++ /Users/kenaniah/workspace/postgres/src/test/regress/results/constraints.out	2021-10-03 20:08:14.000000000 -0700
@@ -708,31 +708,41 @@
 CREATE ROLE regress_constraint_comments;
 SET SESSION AUTHORIZATION regress_constraint_comments;
 CREATE TABLE constraint_comments_tbl (a int CONSTRAINT the_constraint CHECK (a > 0));
+ERROR:  permission denied for schema public
+LINE 1: CREATE TABLE constraint_comments_tbl (a int CONSTRAINT the_c...
+                     ^
 CREATE DOMAIN constraint_comments_dom AS int CONSTRAINT the_constraint CHECK (value > 0);
+ERROR:  permission denied for schema public
 COMMENT ON CONSTRAINT the_constraint ON constraint_comments_tbl IS 'yes, the comment';
+ERROR:  relation "constraint_comments_tbl" does not exist
 COMMENT ON CONSTRAINT the_constraint ON DOMAIN constraint_comments_dom IS 'yes, another comment';
+ERROR:  type "constraint_comments_dom" does not exist
 -- no such constraint
 COMMENT ON CONSTRAINT no_constraint ON constraint_comments_tbl IS 'yes, the comment';
-ERROR:  constraint "no_constraint" for table "constraint_comments_tbl" does not exist
+ERROR:  relation "constraint_comments_tbl" does not exist
 COMMENT ON CONSTRAINT no_constraint ON DOMAIN constraint_comments_dom IS 'yes, another comment';
-ERROR:  constraint "no_constraint" for domain constraint_comments_dom does not exist
+ERROR:  type "constraint_comments_dom" does not exist
 -- no such table/domain
 COMMENT ON CONSTRAINT the_constraint ON no_comments_tbl IS 'bad comment';
 ERROR:  relation "no_comments_tbl" does not exist
 COMMENT ON CONSTRAINT the_constraint ON DOMAIN no_comments_dom IS 'another bad comment';
 ERROR:  type "no_comments_dom" does not exist
 COMMENT ON CONSTRAINT the_constraint ON constraint_comments_tbl IS NULL;
+ERROR:  relation "constraint_comments_tbl" does not exist
 COMMENT ON CONSTRAINT the_constraint ON DOMAIN constraint_comments_dom IS NULL;
+ERROR:  type "constraint_comments_dom" does not exist
 -- unauthorized user
 RESET SESSION AUTHORIZATION;
 CREATE ROLE regress_constraint_comments_noaccess;
 SET SESSION AUTHORIZATION regress_constraint_comments_noaccess;
 COMMENT ON CONSTRAINT the_constraint ON constraint_comments_tbl IS 'no, the comment';
-ERROR:  must be owner of relation constraint_comments_tbl
+ERROR:  relation "constraint_comments_tbl" does not exist
 COMMENT ON CONSTRAINT the_constraint ON DOMAIN constraint_comments_dom IS 'no, another comment';
-ERROR:  must be owner of type constraint_comments_dom
+ERROR:  type "constraint_comments_dom" does not exist
 RESET SESSION AUTHORIZATION;
 DROP TABLE constraint_comments_tbl;
+ERROR:  table "constraint_comments_tbl" does not exist
 DROP DOMAIN constraint_comments_dom;
+ERROR:  type "constraint_comments_dom" does not exist
 DROP ROLE regress_constraint_comments;
 DROP ROLE regress_constraint_comments_noaccess;
diff -U3 /Users/kenaniah/workspace/postgres/src/test/regress/expected/triggers.out /Users/kenaniah/workspace/postgres/src/test/regress/results/triggers.out
--- /Users/kenaniah/workspace/postgres/src/test/regress/expected/triggers.out	2021-10-03 18:09:17.000000000 -0700
+++ /Users/kenaniah/workspace/postgres/src/test/regress/results/triggers.out	2021-10-03 20:08:14.000000000 -0700
@@ -1225,2264 +1225,11 @@
 \set QUIET true
 -- Describe view should list triggers
 \d main_view
-              View "public.main_view"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
- b      | integer |           |          | 
-Triggers:
-    after_del_stmt_trig AFTER DELETE ON main_view FOR EACH STATEMENT EXECUTE FUNCTION view_trigger('after_view_del_stmt')
-    after_ins_stmt_trig AFTER INSERT ON main_view FOR EACH STATEMENT EXECUTE FUNCTION view_trigger('after_view_ins_stmt')
-    after_upd_stmt_trig AFTER UPDATE ON main_view FOR EACH STATEMENT EXECUTE FUNCTION view_trigger('after_view_upd_stmt')
-    before_del_stmt_trig BEFORE DELETE ON main_view FOR EACH STATEMENT EXECUTE FUNCTION view_trigger('before_view_del_stmt')
-    before_ins_stmt_trig BEFORE INSERT ON main_view FOR EACH STATEMENT EXECUTE FUNCTION view_trigger('before_view_ins_stmt')
-    before_upd_stmt_trig BEFORE UPDATE ON main_view FOR EACH STATEMENT EXECUTE FUNCTION view_trigger('before_view_upd_stmt')
-    instead_of_delete_trig INSTEAD OF DELETE ON main_view FOR EACH ROW EXECUTE FUNCTION view_trigger('instead_of_del')
-    instead_of_insert_trig INSTEAD OF INSERT ON main_view FOR EACH ROW EXECUTE FUNCTION view_trigger('instead_of_ins')
-    instead_of_update_trig INSTEAD OF UPDATE ON main_view FOR EACH ROW EXECUTE FUNCTION view_trigger('instead_of_upd')
+dyld: lazy symbol binding failed: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
+
+dyld: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
 
--- Test dropping view triggers
-DROP TRIGGER instead_of_insert_trig ON main_view;
-DROP TRIGGER instead_of_delete_trig ON main_view;
-\d+ main_view
-                          View "public.main_view"
- Column |  Type   | Collation | Nullable | Default | Storage | Description 
---------+---------+-----------+----------+---------+---------+-------------
- a      | integer |           |          |         | plain   | 
- b      | integer |           |          |         | plain   | 
-View definition:
- SELECT main_table.a,
-    main_table.b
-   FROM main_table;
-Triggers:
-    after_del_stmt_trig AFTER DELETE ON main_view FOR EACH STATEMENT EXECUTE FUNCTION view_trigger('after_view_del_stmt')
-    after_ins_stmt_trig AFTER INSERT ON main_view FOR EACH STATEMENT EXECUTE FUNCTION view_trigger('after_view_ins_stmt')
-    after_upd_stmt_trig AFTER UPDATE ON main_view FOR EACH STATEMENT EXECUTE FUNCTION view_trigger('after_view_upd_stmt')
-    before_del_stmt_trig BEFORE DELETE ON main_view FOR EACH STATEMENT EXECUTE FUNCTION view_trigger('before_view_del_stmt')
-    before_ins_stmt_trig BEFORE INSERT ON main_view FOR EACH STATEMENT EXECUTE FUNCTION view_trigger('before_view_ins_stmt')
-    before_upd_stmt_trig BEFORE UPDATE ON main_view FOR EACH STATEMENT EXECUTE FUNCTION view_trigger('before_view_upd_stmt')
-    instead_of_update_trig INSTEAD OF UPDATE ON main_view FOR EACH ROW EXECUTE FUNCTION view_trigger('instead_of_upd')
-
-DROP VIEW main_view;
---
--- Test triggers on a join view
---
-CREATE TABLE country_table (
-    country_id        serial primary key,
-    country_name    text unique not null,
-    continent        text not null
-);
-INSERT INTO country_table (country_name, continent)
-    VALUES ('Japan', 'Asia'),
-           ('UK', 'Europe'),
-           ('USA', 'North America')
-    RETURNING *;
- country_id | country_name |   continent   
-------------+--------------+---------------
-          1 | Japan        | Asia
-          2 | UK           | Europe
-          3 | USA          | North America
-(3 rows)
-
-CREATE TABLE city_table (
-    city_id        serial primary key,
-    city_name    text not null,
-    population    bigint,
-    country_id    int references country_table
-);
-CREATE VIEW city_view AS
-    SELECT city_id, city_name, population, country_name, continent
-    FROM city_table ci
-    LEFT JOIN country_table co ON co.country_id = ci.country_id;
-CREATE FUNCTION city_insert() RETURNS trigger LANGUAGE plpgsql AS $$
-declare
-    ctry_id int;
-begin
-    if NEW.country_name IS NOT NULL then
-        SELECT country_id, continent INTO ctry_id, NEW.continent
-            FROM country_table WHERE country_name = NEW.country_name;
-        if NOT FOUND then
-            raise exception 'No such country: "%"', NEW.country_name;
-        end if;
-    else
-        NEW.continent := NULL;
-    end if;
-
-    if NEW.city_id IS NOT NULL then
-        INSERT INTO city_table
-            VALUES(NEW.city_id, NEW.city_name, NEW.population, ctry_id);
-    else
-        INSERT INTO city_table(city_name, population, country_id)
-            VALUES(NEW.city_name, NEW.population, ctry_id)
-            RETURNING city_id INTO NEW.city_id;
-    end if;
-
-    RETURN NEW;
-end;
-$$;
-CREATE TRIGGER city_insert_trig INSTEAD OF INSERT ON city_view
-FOR EACH ROW EXECUTE PROCEDURE city_insert();
-CREATE FUNCTION city_delete() RETURNS trigger LANGUAGE plpgsql AS $$
-begin
-    DELETE FROM city_table WHERE city_id = OLD.city_id;
-    if NOT FOUND then RETURN NULL; end if;
-    RETURN OLD;
-end;
-$$;
-CREATE TRIGGER city_delete_trig INSTEAD OF DELETE ON city_view
-FOR EACH ROW EXECUTE PROCEDURE city_delete();
-CREATE FUNCTION city_update() RETURNS trigger LANGUAGE plpgsql AS $$
-declare
-    ctry_id int;
-begin
-    if NEW.country_name IS DISTINCT FROM OLD.country_name then
-        SELECT country_id, continent INTO ctry_id, NEW.continent
-            FROM country_table WHERE country_name = NEW.country_name;
-        if NOT FOUND then
-            raise exception 'No such country: "%"', NEW.country_name;
-        end if;
-
-        UPDATE city_table SET city_name = NEW.city_name,
-                              population = NEW.population,
-                              country_id = ctry_id
-            WHERE city_id = OLD.city_id;
-    else
-        UPDATE city_table SET city_name = NEW.city_name,
-                              population = NEW.population
-            WHERE city_id = OLD.city_id;
-        NEW.continent := OLD.continent;
-    end if;
-
-    if NOT FOUND then RETURN NULL; end if;
-    RETURN NEW;
-end;
-$$;
-CREATE TRIGGER city_update_trig INSTEAD OF UPDATE ON city_view
-FOR EACH ROW EXECUTE PROCEDURE city_update();
-\set QUIET false
--- INSERT .. RETURNING
-INSERT INTO city_view(city_name) VALUES('Tokyo') RETURNING *;
- city_id | city_name | population | country_name | continent 
----------+-----------+------------+--------------+-----------
-       1 | Tokyo     |            |              | 
-(1 row)
-
-INSERT 0 1
-INSERT INTO city_view(city_name, population) VALUES('London', 7556900) RETURNING *;
- city_id | city_name | population | country_name | continent 
----------+-----------+------------+--------------+-----------
-       2 | London    |    7556900 |              | 
-(1 row)
-
-INSERT 0 1
-INSERT INTO city_view(city_name, country_name) VALUES('Washington DC', 'USA') RETURNING *;
- city_id |   city_name   | population | country_name |   continent   
----------+---------------+------------+--------------+---------------
-       3 | Washington DC |            | USA          | North America
-(1 row)
-
-INSERT 0 1
-INSERT INTO city_view(city_id, city_name) VALUES(123456, 'New York') RETURNING *;
- city_id | city_name | population | country_name | continent 
----------+-----------+------------+--------------+-----------
-  123456 | New York  |            |              | 
-(1 row)
-
-INSERT 0 1
-INSERT INTO city_view VALUES(234567, 'Birmingham', 1016800, 'UK', 'EU') RETURNING *;
- city_id | city_name  | population | country_name | continent 
----------+------------+------------+--------------+-----------
-  234567 | Birmingham |    1016800 | UK           | Europe
-(1 row)
-
-INSERT 0 1
--- UPDATE .. RETURNING
-UPDATE city_view SET country_name = 'Japon' WHERE city_name = 'Tokyo'; -- error
-ERROR:  No such country: "Japon"
-CONTEXT:  PL/pgSQL function city_update() line 9 at RAISE
-UPDATE city_view SET country_name = 'Japan' WHERE city_name = 'Takyo'; -- no match
-UPDATE 0
-UPDATE city_view SET country_name = 'Japan' WHERE city_name = 'Tokyo' RETURNING *; -- OK
- city_id | city_name | population | country_name | continent 
----------+-----------+------------+--------------+-----------
-       1 | Tokyo     |            | Japan        | Asia
-(1 row)
-
-UPDATE 1
-UPDATE city_view SET population = 13010279 WHERE city_name = 'Tokyo' RETURNING *;
- city_id | city_name | population | country_name | continent 
----------+-----------+------------+--------------+-----------
-       1 | Tokyo     |   13010279 | Japan        | Asia
-(1 row)
-
-UPDATE 1
-UPDATE city_view SET country_name = 'UK' WHERE city_name = 'New York' RETURNING *;
- city_id | city_name | population | country_name | continent 
----------+-----------+------------+--------------+-----------
-  123456 | New York  |            | UK           | Europe
-(1 row)
-
-UPDATE 1
-UPDATE city_view SET country_name = 'USA', population = 8391881 WHERE city_name = 'New York' RETURNING *;
- city_id | city_name | population | country_name |   continent   
----------+-----------+------------+--------------+---------------
-  123456 | New York  |    8391881 | USA          | North America
-(1 row)
-
-UPDATE 1
-UPDATE city_view SET continent = 'EU' WHERE continent = 'Europe' RETURNING *;
- city_id | city_name  | population | country_name | continent 
----------+------------+------------+--------------+-----------
-  234567 | Birmingham |    1016800 | UK           | Europe
-(1 row)
-
-UPDATE 1
-UPDATE city_view v1 SET country_name = v2.country_name FROM city_view v2
-    WHERE v2.city_name = 'Birmingham' AND v1.city_name = 'London' RETURNING *;
- city_id | city_name | population | country_name | continent | city_id | city_name  | population | country_name | continent 
----------+-----------+------------+--------------+-----------+---------+------------+------------+--------------+-----------
-       2 | London    |    7556900 | UK           | Europe    |  234567 | Birmingham |    1016800 | UK           | Europe
-(1 row)
-
-UPDATE 1
--- DELETE .. RETURNING
-DELETE FROM city_view WHERE city_name = 'Birmingham' RETURNING *;
- city_id | city_name  | population | country_name | continent 
----------+------------+------------+--------------+-----------
-  234567 | Birmingham |    1016800 | UK           | Europe
-(1 row)
-
-DELETE 1
-\set QUIET true
--- read-only view with WHERE clause
-CREATE VIEW european_city_view AS
-    SELECT * FROM city_view WHERE continent = 'Europe';
-SELECT count(*) FROM european_city_view;
- count 
--------
-     1
-(1 row)
-
-CREATE FUNCTION no_op_trig_fn() RETURNS trigger LANGUAGE plpgsql
-AS 'begin RETURN NULL; end';
-CREATE TRIGGER no_op_trig INSTEAD OF INSERT OR UPDATE OR DELETE
-ON european_city_view FOR EACH ROW EXECUTE PROCEDURE no_op_trig_fn();
-\set QUIET false
-INSERT INTO european_city_view VALUES (0, 'x', 10000, 'y', 'z');
-INSERT 0 0
-UPDATE european_city_view SET population = 10000;
-UPDATE 0
-DELETE FROM european_city_view;
-DELETE 0
-\set QUIET true
--- rules bypassing no-op triggers
-CREATE RULE european_city_insert_rule AS ON INSERT TO european_city_view
-DO INSTEAD INSERT INTO city_view
-VALUES (NEW.city_id, NEW.city_name, NEW.population, NEW.country_name, NEW.continent)
-RETURNING *;
-CREATE RULE european_city_update_rule AS ON UPDATE TO european_city_view
-DO INSTEAD UPDATE city_view SET
-    city_name = NEW.city_name,
-    population = NEW.population,
-    country_name = NEW.country_name
-WHERE city_id = OLD.city_id
-RETURNING NEW.*;
-CREATE RULE european_city_delete_rule AS ON DELETE TO european_city_view
-DO INSTEAD DELETE FROM city_view WHERE city_id = OLD.city_id RETURNING *;
-\set QUIET false
--- INSERT not limited by view's WHERE clause, but UPDATE AND DELETE are
-INSERT INTO european_city_view(city_name, country_name)
-    VALUES ('Cambridge', 'USA') RETURNING *;
- city_id | city_name | population | country_name |   continent   
----------+-----------+------------+--------------+---------------
-       4 | Cambridge |            | USA          | North America
-(1 row)
-
-INSERT 0 1
-UPDATE european_city_view SET country_name = 'UK'
-    WHERE city_name = 'Cambridge';
-UPDATE 0
-DELETE FROM european_city_view WHERE city_name = 'Cambridge';
-DELETE 0
--- UPDATE and DELETE via rule and trigger
-UPDATE city_view SET country_name = 'UK'
-    WHERE city_name = 'Cambridge' RETURNING *;
- city_id | city_name | population | country_name | continent 
----------+-----------+------------+--------------+-----------
-       4 | Cambridge |            | UK           | Europe
-(1 row)
-
-UPDATE 1
-UPDATE european_city_view SET population = 122800
-    WHERE city_name = 'Cambridge' RETURNING *;
- city_id | city_name | population | country_name | continent 
----------+-----------+------------+--------------+-----------
-       4 | Cambridge |     122800 | UK           | Europe
-(1 row)
-
-UPDATE 1
-DELETE FROM european_city_view WHERE city_name = 'Cambridge' RETURNING *;
- city_id | city_name | population | country_name | continent 
----------+-----------+------------+--------------+-----------
-       4 | Cambridge |     122800 | UK           | Europe
-(1 row)
-
-DELETE 1
--- join UPDATE test
-UPDATE city_view v SET population = 599657
-    FROM city_table ci, country_table co
-    WHERE ci.city_name = 'Washington DC' and co.country_name = 'USA'
-    AND v.city_id = ci.city_id AND v.country_name = co.country_name
-    RETURNING co.country_id, v.country_name,
-              v.city_id, v.city_name, v.population;
- country_id | country_name | city_id |   city_name   | population 
-------------+--------------+---------+---------------+------------
-          3 | USA          |       3 | Washington DC |     599657
-(1 row)
-
-UPDATE 1
-\set QUIET true
-SELECT * FROM city_view;
- city_id |   city_name   | population | country_name |   continent   
----------+---------------+------------+--------------+---------------
-       1 | Tokyo         |   13010279 | Japan        | Asia
-  123456 | New York      |    8391881 | USA          | North America
-       2 | London        |    7556900 | UK           | Europe
-       3 | Washington DC |     599657 | USA          | North America
-(4 rows)
-
-DROP TABLE city_table CASCADE;
-NOTICE:  drop cascades to 2 other objects
-DETAIL:  drop cascades to view city_view
-drop cascades to view european_city_view
-DROP TABLE country_table;
--- Test pg_trigger_depth()
-create table depth_a (id int not null primary key);
-create table depth_b (id int not null primary key);
-create table depth_c (id int not null primary key);
-create function depth_a_tf() returns trigger
-  language plpgsql as $$
-begin
-  raise notice '%: depth = %', tg_name, pg_trigger_depth();
-  insert into depth_b values (new.id);
-  raise notice '%: depth = %', tg_name, pg_trigger_depth();
-  return new;
-end;
-$$;
-create trigger depth_a_tr before insert on depth_a
-  for each row execute procedure depth_a_tf();
-create function depth_b_tf() returns trigger
-  language plpgsql as $$
-begin
-  raise notice '%: depth = %', tg_name, pg_trigger_depth();
-  begin
-    execute 'insert into depth_c values (' || new.id::text || ')';
-  exception
-    when sqlstate 'U9999' then
-      raise notice 'SQLSTATE = U9999: depth = %', pg_trigger_depth();
-  end;
-  raise notice '%: depth = %', tg_name, pg_trigger_depth();
-  if new.id = 1 then
-    execute 'insert into depth_c values (' || new.id::text || ')';
-  end if;
-  return new;
-end;
-$$;
-create trigger depth_b_tr before insert on depth_b
-  for each row execute procedure depth_b_tf();
-create function depth_c_tf() returns trigger
-  language plpgsql as $$
-begin
-  raise notice '%: depth = %', tg_name, pg_trigger_depth();
-  if new.id = 1 then
-    raise exception sqlstate 'U9999';
-  end if;
-  raise notice '%: depth = %', tg_name, pg_trigger_depth();
-  return new;
-end;
-$$;
-create trigger depth_c_tr before insert on depth_c
-  for each row execute procedure depth_c_tf();
-select pg_trigger_depth();
- pg_trigger_depth 
-------------------
-                0
-(1 row)
-
-insert into depth_a values (1);
-NOTICE:  depth_a_tr: depth = 1
-NOTICE:  depth_b_tr: depth = 2
-NOTICE:  depth_c_tr: depth = 3
-NOTICE:  SQLSTATE = U9999: depth = 2
-NOTICE:  depth_b_tr: depth = 2
-NOTICE:  depth_c_tr: depth = 3
-ERROR:  U9999
-CONTEXT:  PL/pgSQL function depth_c_tf() line 5 at RAISE
-SQL statement "insert into depth_c values (1)"
-PL/pgSQL function depth_b_tf() line 12 at EXECUTE
-SQL statement "insert into depth_b values (new.id)"
-PL/pgSQL function depth_a_tf() line 4 at SQL statement
-select pg_trigger_depth();
- pg_trigger_depth 
-------------------
-                0
-(1 row)
-
-insert into depth_a values (2);
-NOTICE:  depth_a_tr: depth = 1
-NOTICE:  depth_b_tr: depth = 2
-NOTICE:  depth_c_tr: depth = 3
-NOTICE:  depth_c_tr: depth = 3
-NOTICE:  depth_b_tr: depth = 2
-NOTICE:  depth_a_tr: depth = 1
-select pg_trigger_depth();
- pg_trigger_depth 
-------------------
-                0
-(1 row)
-
-drop table depth_a, depth_b, depth_c;
-drop function depth_a_tf();
-drop function depth_b_tf();
-drop function depth_c_tf();
---
--- Test updates to rows during firing of BEFORE ROW triggers.
--- As of 9.2, such cases should be rejected (see bug #6123).
---
-create temp table parent (
-    aid int not null primary key,
-    val1 text,
-    val2 text,
-    val3 text,
-    val4 text,
-    bcnt int not null default 0);
-create temp table child (
-    bid int not null primary key,
-    aid int not null,
-    val1 text);
-create function parent_upd_func()
-  returns trigger language plpgsql as
-$$
-begin
-  if old.val1 <> new.val1 then
-    new.val2 = new.val1;
-    delete from child where child.aid = new.aid and child.val1 = new.val1;
-  end if;
-  return new;
-end;
-$$;
-create trigger parent_upd_trig before update on parent
-  for each row execute procedure parent_upd_func();
-create function parent_del_func()
-  returns trigger language plpgsql as
-$$
-begin
-  delete from child where aid = old.aid;
-  return old;
-end;
-$$;
-create trigger parent_del_trig before delete on parent
-  for each row execute procedure parent_del_func();
-create function child_ins_func()
-  returns trigger language plpgsql as
-$$
-begin
-  update parent set bcnt = bcnt + 1 where aid = new.aid;
-  return new;
-end;
-$$;
-create trigger child_ins_trig after insert on child
-  for each row execute procedure child_ins_func();
-create function child_del_func()
-  returns trigger language plpgsql as
-$$
-begin
-  update parent set bcnt = bcnt - 1 where aid = old.aid;
-  return old;
-end;
-$$;
-create trigger child_del_trig after delete on child
-  for each row execute procedure child_del_func();
-insert into parent values (1, 'a', 'a', 'a', 'a', 0);
-insert into child values (10, 1, 'b');
-select * from parent; select * from child;
- aid | val1 | val2 | val3 | val4 | bcnt 
------+------+------+------+------+------
-   1 | a    | a    | a    | a    |    1
-(1 row)
-
- bid | aid | val1 
------+-----+------
-  10 |   1 | b
-(1 row)
-
-update parent set val1 = 'b' where aid = 1; -- should fail
-ERROR:  tuple to be updated was already modified by an operation triggered by the current command
-HINT:  Consider using an AFTER trigger instead of a BEFORE trigger to propagate changes to other rows.
-select * from parent; select * from child;
- aid | val1 | val2 | val3 | val4 | bcnt 
------+------+------+------+------+------
-   1 | a    | a    | a    | a    |    1
-(1 row)
-
- bid | aid | val1 
------+-----+------
-  10 |   1 | b
-(1 row)
-
-delete from parent where aid = 1; -- should fail
-ERROR:  tuple to be deleted was already modified by an operation triggered by the current command
-HINT:  Consider using an AFTER trigger instead of a BEFORE trigger to propagate changes to other rows.
-select * from parent; select * from child;
- aid | val1 | val2 | val3 | val4 | bcnt 
------+------+------+------+------+------
-   1 | a    | a    | a    | a    |    1
-(1 row)
-
- bid | aid | val1 
------+-----+------
-  10 |   1 | b
-(1 row)
-
--- replace the trigger function with one that restarts the deletion after
--- having modified a child
-create or replace function parent_del_func()
-  returns trigger language plpgsql as
-$$
-begin
-  delete from child where aid = old.aid;
-  if found then
-    delete from parent where aid = old.aid;
-    return null; -- cancel outer deletion
-  end if;
-  return old;
-end;
-$$;
-delete from parent where aid = 1;
-select * from parent; select * from child;
- aid | val1 | val2 | val3 | val4 | bcnt 
------+------+------+------+------+------
-(0 rows)
-
- bid | aid | val1 
------+-----+------
-(0 rows)
-
-drop table parent, child;
-drop function parent_upd_func();
-drop function parent_del_func();
-drop function child_ins_func();
-drop function child_del_func();
--- similar case, but with a self-referencing FK so that parent and child
--- rows can be affected by a single operation
-create temp table self_ref_trigger (
-    id int primary key,
-    parent int references self_ref_trigger,
-    data text,
-    nchildren int not null default 0
-);
-create function self_ref_trigger_ins_func()
-  returns trigger language plpgsql as
-$$
-begin
-  if new.parent is not null then
-    update self_ref_trigger set nchildren = nchildren + 1
-      where id = new.parent;
-  end if;
-  return new;
-end;
-$$;
-create trigger self_ref_trigger_ins_trig before insert on self_ref_trigger
-  for each row execute procedure self_ref_trigger_ins_func();
-create function self_ref_trigger_del_func()
-  returns trigger language plpgsql as
-$$
-begin
-  if old.parent is not null then
-    update self_ref_trigger set nchildren = nchildren - 1
-      where id = old.parent;
-  end if;
-  return old;
-end;
-$$;
-create trigger self_ref_trigger_del_trig before delete on self_ref_trigger
-  for each row execute procedure self_ref_trigger_del_func();
-insert into self_ref_trigger values (1, null, 'root');
-insert into self_ref_trigger values (2, 1, 'root child A');
-insert into self_ref_trigger values (3, 1, 'root child B');
-insert into self_ref_trigger values (4, 2, 'grandchild 1');
-insert into self_ref_trigger values (5, 3, 'grandchild 2');
-update self_ref_trigger set data = 'root!' where id = 1;
-select * from self_ref_trigger;
- id | parent |     data     | nchildren 
-----+--------+--------------+-----------
-  2 |      1 | root child A |         1
-  4 |      2 | grandchild 1 |         0
-  3 |      1 | root child B |         1
-  5 |      3 | grandchild 2 |         0
-  1 |        | root!        |         2
-(5 rows)
-
-delete from self_ref_trigger;
-ERROR:  tuple to be updated was already modified by an operation triggered by the current command
-HINT:  Consider using an AFTER trigger instead of a BEFORE trigger to propagate changes to other rows.
-select * from self_ref_trigger;
- id | parent |     data     | nchildren 
-----+--------+--------------+-----------
-  2 |      1 | root child A |         1
-  4 |      2 | grandchild 1 |         0
-  3 |      1 | root child B |         1
-  5 |      3 | grandchild 2 |         0
-  1 |        | root!        |         2
-(5 rows)
-
-drop table self_ref_trigger;
-drop function self_ref_trigger_ins_func();
-drop function self_ref_trigger_del_func();
---
--- Check that statement triggers work correctly even with all children excluded
---
-create table stmt_trig_on_empty_upd (a int);
-create table stmt_trig_on_empty_upd1 () inherits (stmt_trig_on_empty_upd);
-create function update_stmt_notice() returns trigger as $$
-begin
-	raise notice 'updating %', TG_TABLE_NAME;
-	return null;
-end;
-$$ language plpgsql;
-create trigger before_stmt_trigger
-	before update on stmt_trig_on_empty_upd
-	execute procedure update_stmt_notice();
-create trigger before_stmt_trigger
-	before update on stmt_trig_on_empty_upd1
-	execute procedure update_stmt_notice();
--- inherited no-op update
-update stmt_trig_on_empty_upd set a = a where false returning a+1 as aa;
-NOTICE:  updating stmt_trig_on_empty_upd
- aa 
-----
-(0 rows)
-
--- simple no-op update
-update stmt_trig_on_empty_upd1 set a = a where false returning a+1 as aa;
-NOTICE:  updating stmt_trig_on_empty_upd1
- aa 
-----
-(0 rows)
-
-drop table stmt_trig_on_empty_upd cascade;
-NOTICE:  drop cascades to table stmt_trig_on_empty_upd1
-drop function update_stmt_notice();
---
--- Check that index creation (or DDL in general) is prohibited in a trigger
---
-create table trigger_ddl_table (
-   col1 integer,
-   col2 integer
-);
-create function trigger_ddl_func() returns trigger as $$
-begin
-  alter table trigger_ddl_table add primary key (col1);
-  return new;
-end$$ language plpgsql;
-create trigger trigger_ddl_func before insert on trigger_ddl_table for each row
-  execute procedure trigger_ddl_func();
-insert into trigger_ddl_table values (1, 42);  -- fail
-ERROR:  cannot ALTER TABLE "trigger_ddl_table" because it is being used by active queries in this session
-CONTEXT:  SQL statement "alter table trigger_ddl_table add primary key (col1)"
-PL/pgSQL function trigger_ddl_func() line 3 at SQL statement
-create or replace function trigger_ddl_func() returns trigger as $$
-begin
-  create index on trigger_ddl_table (col2);
-  return new;
-end$$ language plpgsql;
-insert into trigger_ddl_table values (1, 42);  -- fail
-ERROR:  cannot CREATE INDEX "trigger_ddl_table" because it is being used by active queries in this session
-CONTEXT:  SQL statement "create index on trigger_ddl_table (col2)"
-PL/pgSQL function trigger_ddl_func() line 3 at SQL statement
-drop table trigger_ddl_table;
-drop function trigger_ddl_func();
---
--- Verify behavior of before and after triggers with INSERT...ON CONFLICT
--- DO UPDATE
---
-create table upsert (key int4 primary key, color text);
-create function upsert_before_func()
-  returns trigger language plpgsql as
-$$
-begin
-  if (TG_OP = 'UPDATE') then
-    raise warning 'before update (old): %', old.*::text;
-    raise warning 'before update (new): %', new.*::text;
-  elsif (TG_OP = 'INSERT') then
-    raise warning 'before insert (new): %', new.*::text;
-    if new.key % 2 = 0 then
-      new.key := new.key + 1;
-      new.color := new.color || ' trig modified';
-      raise warning 'before insert (new, modified): %', new.*::text;
-    end if;
-  end if;
-  return new;
-end;
-$$;
-create trigger upsert_before_trig before insert or update on upsert
-  for each row execute procedure upsert_before_func();
-create function upsert_after_func()
-  returns trigger language plpgsql as
-$$
-begin
-  if (TG_OP = 'UPDATE') then
-    raise warning 'after update (old): %', old.*::text;
-    raise warning 'after update (new): %', new.*::text;
-  elsif (TG_OP = 'INSERT') then
-    raise warning 'after insert (new): %', new.*::text;
-  end if;
-  return null;
-end;
-$$;
-create trigger upsert_after_trig after insert or update on upsert
-  for each row execute procedure upsert_after_func();
-insert into upsert values(1, 'black') on conflict (key) do update set color = 'updated ' || upsert.color;
-WARNING:  before insert (new): (1,black)
-WARNING:  after insert (new): (1,black)
-insert into upsert values(2, 'red') on conflict (key) do update set color = 'updated ' || upsert.color;
-WARNING:  before insert (new): (2,red)
-WARNING:  before insert (new, modified): (3,"red trig modified")
-WARNING:  after insert (new): (3,"red trig modified")
-insert into upsert values(3, 'orange') on conflict (key) do update set color = 'updated ' || upsert.color;
-WARNING:  before insert (new): (3,orange)
-WARNING:  before update (old): (3,"red trig modified")
-WARNING:  before update (new): (3,"updated red trig modified")
-WARNING:  after update (old): (3,"red trig modified")
-WARNING:  after update (new): (3,"updated red trig modified")
-insert into upsert values(4, 'green') on conflict (key) do update set color = 'updated ' || upsert.color;
-WARNING:  before insert (new): (4,green)
-WARNING:  before insert (new, modified): (5,"green trig modified")
-WARNING:  after insert (new): (5,"green trig modified")
-insert into upsert values(5, 'purple') on conflict (key) do update set color = 'updated ' || upsert.color;
-WARNING:  before insert (new): (5,purple)
-WARNING:  before update (old): (5,"green trig modified")
-WARNING:  before update (new): (5,"updated green trig modified")
-WARNING:  after update (old): (5,"green trig modified")
-WARNING:  after update (new): (5,"updated green trig modified")
-insert into upsert values(6, 'white') on conflict (key) do update set color = 'updated ' || upsert.color;
-WARNING:  before insert (new): (6,white)
-WARNING:  before insert (new, modified): (7,"white trig modified")
-WARNING:  after insert (new): (7,"white trig modified")
-insert into upsert values(7, 'pink') on conflict (key) do update set color = 'updated ' || upsert.color;
-WARNING:  before insert (new): (7,pink)
-WARNING:  before update (old): (7,"white trig modified")
-WARNING:  before update (new): (7,"updated white trig modified")
-WARNING:  after update (old): (7,"white trig modified")
-WARNING:  after update (new): (7,"updated white trig modified")
-insert into upsert values(8, 'yellow') on conflict (key) do update set color = 'updated ' || upsert.color;
-WARNING:  before insert (new): (8,yellow)
-WARNING:  before insert (new, modified): (9,"yellow trig modified")
-WARNING:  after insert (new): (9,"yellow trig modified")
-select * from upsert;
- key |            color            
------+-----------------------------
-   1 | black
-   3 | updated red trig modified
-   5 | updated green trig modified
-   7 | updated white trig modified
-   9 | yellow trig modified
-(5 rows)
-
-drop table upsert;
-drop function upsert_before_func();
-drop function upsert_after_func();
---
--- Verify that triggers with transition tables are not allowed on
--- views
---
-create table my_table (i int);
-create view my_view as select * from my_table;
-create function my_trigger_function() returns trigger as $$ begin end; $$ language plpgsql;
-create trigger my_trigger after update on my_view referencing old table as old_table
-   for each statement execute procedure my_trigger_function();
-ERROR:  "my_view" is a view
-DETAIL:  Triggers on views cannot have transition tables.
-drop function my_trigger_function();
-drop view my_view;
-drop table my_table;
---
--- Verify cases that are unsupported with partitioned tables
---
-create table parted_trig (a int) partition by list (a);
-create function trigger_nothing() returns trigger
-  language plpgsql as $$ begin end; $$;
-create trigger failed instead of update on parted_trig
-  for each row execute procedure trigger_nothing();
-ERROR:  "parted_trig" is a table
-DETAIL:  Tables cannot have INSTEAD OF triggers.
-create trigger failed after update on parted_trig
-  referencing old table as old_table
-  for each row execute procedure trigger_nothing();
-ERROR:  "parted_trig" is a partitioned table
-DETAIL:  Triggers on partitioned tables cannot have transition tables.
-drop table parted_trig;
---
--- Verify trigger creation for partitioned tables, and drop behavior
---
-create table trigpart (a int, b int) partition by range (a);
-create table trigpart1 partition of trigpart for values from (0) to (1000);
-create trigger trg1 after insert on trigpart for each row execute procedure trigger_nothing();
-create table trigpart2 partition of trigpart for values from (1000) to (2000);
-create table trigpart3 (like trigpart);
-alter table trigpart attach partition trigpart3 for values from (2000) to (3000);
-create table trigpart4 partition of trigpart for values from (3000) to (4000) partition by range (a);
-create table trigpart41 partition of trigpart4 for values from (3000) to (3500);
-create table trigpart42 (like trigpart);
-alter table trigpart4 attach partition trigpart42 for values from (3500) to (4000);
-select tgrelid::regclass, tgname, tgfoid::regproc from pg_trigger
-  where tgrelid::regclass::text like 'trigpart%' order by tgrelid::regclass::text;
-  tgrelid   | tgname |     tgfoid      
-------------+--------+-----------------
- trigpart   | trg1   | trigger_nothing
- trigpart1  | trg1   | trigger_nothing
- trigpart2  | trg1   | trigger_nothing
- trigpart3  | trg1   | trigger_nothing
- trigpart4  | trg1   | trigger_nothing
- trigpart41 | trg1   | trigger_nothing
- trigpart42 | trg1   | trigger_nothing
-(7 rows)
-
-drop trigger trg1 on trigpart1;	-- fail
-ERROR:  cannot drop trigger trg1 on table trigpart1 because trigger trg1 on table trigpart requires it
-HINT:  You can drop trigger trg1 on table trigpart instead.
-drop trigger trg1 on trigpart2;	-- fail
-ERROR:  cannot drop trigger trg1 on table trigpart2 because trigger trg1 on table trigpart requires it
-HINT:  You can drop trigger trg1 on table trigpart instead.
-drop trigger trg1 on trigpart3;	-- fail
-ERROR:  cannot drop trigger trg1 on table trigpart3 because trigger trg1 on table trigpart requires it
-HINT:  You can drop trigger trg1 on table trigpart instead.
-drop table trigpart2;			-- ok, trigger should be gone in that partition
-select tgrelid::regclass, tgname, tgfoid::regproc from pg_trigger
-  where tgrelid::regclass::text like 'trigpart%' order by tgrelid::regclass::text;
-  tgrelid   | tgname |     tgfoid      
-------------+--------+-----------------
- trigpart   | trg1   | trigger_nothing
- trigpart1  | trg1   | trigger_nothing
- trigpart3  | trg1   | trigger_nothing
- trigpart4  | trg1   | trigger_nothing
- trigpart41 | trg1   | trigger_nothing
- trigpart42 | trg1   | trigger_nothing
-(6 rows)
-
-drop trigger trg1 on trigpart;		-- ok, all gone
-select tgrelid::regclass, tgname, tgfoid::regproc from pg_trigger
-  where tgrelid::regclass::text like 'trigpart%' order by tgrelid::regclass::text;
- tgrelid | tgname | tgfoid 
----------+--------+--------
-(0 rows)
-
--- check detach behavior
-create trigger trg1 after insert on trigpart for each row execute procedure trigger_nothing();
-\d trigpart3
-             Table "public.trigpart3"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
- b      | integer |           |          | 
-Partition of: trigpart FOR VALUES FROM (2000) TO (3000)
-Triggers:
-    trg1 AFTER INSERT ON trigpart3 FOR EACH ROW EXECUTE FUNCTION trigger_nothing(), ON TABLE trigpart
-
-alter table trigpart detach partition trigpart3;
-drop trigger trg1 on trigpart3; -- fail due to "does not exist"
-ERROR:  trigger "trg1" for table "trigpart3" does not exist
-alter table trigpart detach partition trigpart4;
-drop trigger trg1 on trigpart41; -- fail due to "does not exist"
-ERROR:  trigger "trg1" for table "trigpart41" does not exist
-drop table trigpart4;
-alter table trigpart attach partition trigpart3 for values from (2000) to (3000);
-alter table trigpart detach partition trigpart3;
-alter table trigpart attach partition trigpart3 for values from (2000) to (3000);
-drop table trigpart3;
-select tgrelid::regclass::text, tgname, tgfoid::regproc, tgenabled, tgisinternal from pg_trigger
-  where tgname ~ '^trg1' order by 1;
-  tgrelid  | tgname |     tgfoid      | tgenabled | tgisinternal 
------------+--------+-----------------+-----------+--------------
- trigpart  | trg1   | trigger_nothing | O         | f
- trigpart1 | trg1   | trigger_nothing | O         | t
-(2 rows)
-
-create table trigpart3 (like trigpart);
-create trigger trg1 after insert on trigpart3 for each row execute procedure trigger_nothing();
-\d trigpart3
-             Table "public.trigpart3"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
- b      | integer |           |          | 
-Triggers:
-    trg1 AFTER INSERT ON trigpart3 FOR EACH ROW EXECUTE FUNCTION trigger_nothing()
-
-alter table trigpart attach partition trigpart3 FOR VALUES FROM (2000) to (3000); -- fail
-ERROR:  trigger "trg1" for relation "trigpart3" already exists
-drop table trigpart3;
-drop table trigpart;
-drop function trigger_nothing();
---
--- Verify that triggers are fired for partitioned tables
---
-create table parted_stmt_trig (a int) partition by list (a);
-create table parted_stmt_trig1 partition of parted_stmt_trig for values in (1);
-create table parted_stmt_trig2 partition of parted_stmt_trig for values in (2);
-create table parted2_stmt_trig (a int) partition by list (a);
-create table parted2_stmt_trig1 partition of parted2_stmt_trig for values in (1);
-create table parted2_stmt_trig2 partition of parted2_stmt_trig for values in (2);
-create or replace function trigger_notice() returns trigger as $$
-  begin
-    raise notice 'trigger % on % % % for %', TG_NAME, TG_TABLE_NAME, TG_WHEN, TG_OP, TG_LEVEL;
-    if TG_LEVEL = 'ROW' then
-       return NEW;
-    end if;
-    return null;
-  end;
-  $$ language plpgsql;
--- insert/update/delete statement-level triggers on the parent
-create trigger trig_ins_before before insert on parted_stmt_trig
-  for each statement execute procedure trigger_notice();
-create trigger trig_ins_after after insert on parted_stmt_trig
-  for each statement execute procedure trigger_notice();
-create trigger trig_upd_before before update on parted_stmt_trig
-  for each statement execute procedure trigger_notice();
-create trigger trig_upd_after after update on parted_stmt_trig
-  for each statement execute procedure trigger_notice();
-create trigger trig_del_before before delete on parted_stmt_trig
-  for each statement execute procedure trigger_notice();
-create trigger trig_del_after after delete on parted_stmt_trig
-  for each statement execute procedure trigger_notice();
--- insert/update/delete row-level triggers on the parent
-create trigger trig_ins_after_parent after insert on parted_stmt_trig
-  for each row execute procedure trigger_notice();
-create trigger trig_upd_after_parent after update on parted_stmt_trig
-  for each row execute procedure trigger_notice();
-create trigger trig_del_after_parent after delete on parted_stmt_trig
-  for each row execute procedure trigger_notice();
--- insert/update/delete row-level triggers on the first partition
-create trigger trig_ins_before_child before insert on parted_stmt_trig1
-  for each row execute procedure trigger_notice();
-create trigger trig_ins_after_child after insert on parted_stmt_trig1
-  for each row execute procedure trigger_notice();
-create trigger trig_upd_before_child before update on parted_stmt_trig1
-  for each row execute procedure trigger_notice();
-create trigger trig_upd_after_child after update on parted_stmt_trig1
-  for each row execute procedure trigger_notice();
-create trigger trig_del_before_child before delete on parted_stmt_trig1
-  for each row execute procedure trigger_notice();
-create trigger trig_del_after_child after delete on parted_stmt_trig1
-  for each row execute procedure trigger_notice();
--- insert/update/delete statement-level triggers on the parent
-create trigger trig_ins_before_3 before insert on parted2_stmt_trig
-  for each statement execute procedure trigger_notice();
-create trigger trig_ins_after_3 after insert on parted2_stmt_trig
-  for each statement execute procedure trigger_notice();
-create trigger trig_upd_before_3 before update on parted2_stmt_trig
-  for each statement execute procedure trigger_notice();
-create trigger trig_upd_after_3 after update on parted2_stmt_trig
-  for each statement execute procedure trigger_notice();
-create trigger trig_del_before_3 before delete on parted2_stmt_trig
-  for each statement execute procedure trigger_notice();
-create trigger trig_del_after_3 after delete on parted2_stmt_trig
-  for each statement execute procedure trigger_notice();
-with ins (a) as (
-  insert into parted2_stmt_trig values (1), (2) returning a
-) insert into parted_stmt_trig select a from ins returning tableoid::regclass, a;
-NOTICE:  trigger trig_ins_before on parted_stmt_trig BEFORE INSERT for STATEMENT
-NOTICE:  trigger trig_ins_before_3 on parted2_stmt_trig BEFORE INSERT for STATEMENT
-NOTICE:  trigger trig_ins_before_child on parted_stmt_trig1 BEFORE INSERT for ROW
-NOTICE:  trigger trig_ins_after_child on parted_stmt_trig1 AFTER INSERT for ROW
-NOTICE:  trigger trig_ins_after_parent on parted_stmt_trig1 AFTER INSERT for ROW
-NOTICE:  trigger trig_ins_after_parent on parted_stmt_trig2 AFTER INSERT for ROW
-NOTICE:  trigger trig_ins_after_3 on parted2_stmt_trig AFTER INSERT for STATEMENT
-NOTICE:  trigger trig_ins_after on parted_stmt_trig AFTER INSERT for STATEMENT
-     tableoid      | a 
--------------------+---
- parted_stmt_trig1 | 1
- parted_stmt_trig2 | 2
-(2 rows)
-
-with upd as (
-  update parted2_stmt_trig set a = a
-) update parted_stmt_trig  set a = a;
-NOTICE:  trigger trig_upd_before on parted_stmt_trig BEFORE UPDATE for STATEMENT
-NOTICE:  trigger trig_upd_before_child on parted_stmt_trig1 BEFORE UPDATE for ROW
-NOTICE:  trigger trig_upd_before_3 on parted2_stmt_trig BEFORE UPDATE for STATEMENT
-NOTICE:  trigger trig_upd_after_child on parted_stmt_trig1 AFTER UPDATE for ROW
-NOTICE:  trigger trig_upd_after_parent on parted_stmt_trig1 AFTER UPDATE for ROW
-NOTICE:  trigger trig_upd_after_parent on parted_stmt_trig2 AFTER UPDATE for ROW
-NOTICE:  trigger trig_upd_after on parted_stmt_trig AFTER UPDATE for STATEMENT
-NOTICE:  trigger trig_upd_after_3 on parted2_stmt_trig AFTER UPDATE for STATEMENT
-delete from parted_stmt_trig;
-NOTICE:  trigger trig_del_before on parted_stmt_trig BEFORE DELETE for STATEMENT
-NOTICE:  trigger trig_del_before_child on parted_stmt_trig1 BEFORE DELETE for ROW
-NOTICE:  trigger trig_del_after_parent on parted_stmt_trig2 AFTER DELETE for ROW
-NOTICE:  trigger trig_del_after on parted_stmt_trig AFTER DELETE for STATEMENT
--- insert via copy on the parent
-copy parted_stmt_trig(a) from stdin;
-NOTICE:  trigger trig_ins_before on parted_stmt_trig BEFORE INSERT for STATEMENT
-NOTICE:  trigger trig_ins_before_child on parted_stmt_trig1 BEFORE INSERT for ROW
-NOTICE:  trigger trig_ins_after_child on parted_stmt_trig1 AFTER INSERT for ROW
-NOTICE:  trigger trig_ins_after_parent on parted_stmt_trig1 AFTER INSERT for ROW
-NOTICE:  trigger trig_ins_after_parent on parted_stmt_trig2 AFTER INSERT for ROW
-NOTICE:  trigger trig_ins_after on parted_stmt_trig AFTER INSERT for STATEMENT
--- insert via copy on the first partition
-copy parted_stmt_trig1(a) from stdin;
-NOTICE:  trigger trig_ins_before_child on parted_stmt_trig1 BEFORE INSERT for ROW
-NOTICE:  trigger trig_ins_after_child on parted_stmt_trig1 AFTER INSERT for ROW
-NOTICE:  trigger trig_ins_after_parent on parted_stmt_trig1 AFTER INSERT for ROW
--- Disabling a trigger in the parent table should disable children triggers too
-alter table parted_stmt_trig disable trigger trig_ins_after_parent;
-insert into parted_stmt_trig values (1);
-NOTICE:  trigger trig_ins_before on parted_stmt_trig BEFORE INSERT for STATEMENT
-NOTICE:  trigger trig_ins_before_child on parted_stmt_trig1 BEFORE INSERT for ROW
-NOTICE:  trigger trig_ins_after_child on parted_stmt_trig1 AFTER INSERT for ROW
-NOTICE:  trigger trig_ins_after on parted_stmt_trig AFTER INSERT for STATEMENT
-alter table parted_stmt_trig enable trigger trig_ins_after_parent;
-insert into parted_stmt_trig values (1);
-NOTICE:  trigger trig_ins_before on parted_stmt_trig BEFORE INSERT for STATEMENT
-NOTICE:  trigger trig_ins_before_child on parted_stmt_trig1 BEFORE INSERT for ROW
-NOTICE:  trigger trig_ins_after_child on parted_stmt_trig1 AFTER INSERT for ROW
-NOTICE:  trigger trig_ins_after_parent on parted_stmt_trig1 AFTER INSERT for ROW
-NOTICE:  trigger trig_ins_after on parted_stmt_trig AFTER INSERT for STATEMENT
-drop table parted_stmt_trig, parted2_stmt_trig;
--- Verify that triggers fire in alphabetical order
-create table parted_trig (a int) partition by range (a);
-create table parted_trig_1 partition of parted_trig for values from (0) to (1000)
-   partition by range (a);
-create table parted_trig_1_1 partition of parted_trig_1 for values from (0) to (100);
-create table parted_trig_2 partition of parted_trig for values from (1000) to (2000);
-create trigger zzz after insert on parted_trig for each row execute procedure trigger_notice();
-create trigger mmm after insert on parted_trig_1_1 for each row execute procedure trigger_notice();
-create trigger aaa after insert on parted_trig_1 for each row execute procedure trigger_notice();
-create trigger bbb after insert on parted_trig for each row execute procedure trigger_notice();
-create trigger qqq after insert on parted_trig_1_1 for each row execute procedure trigger_notice();
-insert into parted_trig values (50), (1500);
-NOTICE:  trigger aaa on parted_trig_1_1 AFTER INSERT for ROW
-NOTICE:  trigger bbb on parted_trig_1_1 AFTER INSERT for ROW
-NOTICE:  trigger mmm on parted_trig_1_1 AFTER INSERT for ROW
-NOTICE:  trigger qqq on parted_trig_1_1 AFTER INSERT for ROW
-NOTICE:  trigger zzz on parted_trig_1_1 AFTER INSERT for ROW
-NOTICE:  trigger bbb on parted_trig_2 AFTER INSERT for ROW
-NOTICE:  trigger zzz on parted_trig_2 AFTER INSERT for ROW
-drop table parted_trig;
--- Verify propagation of trigger arguments to partitions
-create table parted_trig (a int) partition by list (a);
-create table parted_trig1 partition of parted_trig for values in (1);
-create or replace function trigger_notice() returns trigger as $$
-  declare
-    arg1 text = TG_ARGV[0];
-    arg2 integer = TG_ARGV[1];
-  begin
-    raise notice 'trigger % on % % % for % args % %',
-		TG_NAME, TG_TABLE_NAME, TG_WHEN, TG_OP, TG_LEVEL, arg1, arg2;
-    return null;
-  end;
-  $$ language plpgsql;
-create trigger aaa after insert on parted_trig
-   for each row execute procedure trigger_notice('quirky', 1);
--- Verify propagation of trigger arguments to partitions attached after creating trigger
-create table parted_trig2 partition of parted_trig for values in (2);
-create table parted_trig3 (like parted_trig);
-alter table parted_trig attach partition parted_trig3 for values in (3);
-insert into parted_trig values (1), (2), (3);
-NOTICE:  trigger aaa on parted_trig1 AFTER INSERT for ROW args quirky 1
-NOTICE:  trigger aaa on parted_trig2 AFTER INSERT for ROW args quirky 1
-NOTICE:  trigger aaa on parted_trig3 AFTER INSERT for ROW args quirky 1
-drop table parted_trig;
--- test irregular partitions (i.e., different column definitions),
--- including that the WHEN clause works
-create function bark(text) returns bool language plpgsql immutable
-  as $$ begin raise notice '% <- woof!', $1; return true; end; $$;
-create or replace function trigger_notice_ab() returns trigger as $$
-  begin
-    raise notice 'trigger % on % % % for %: (a,b)=(%,%)',
-		TG_NAME, TG_TABLE_NAME, TG_WHEN, TG_OP, TG_LEVEL,
-		NEW.a, NEW.b;
-    if TG_LEVEL = 'ROW' then
-       return NEW;
-    end if;
-    return null;
-  end;
-  $$ language plpgsql;
-create table parted_irreg_ancestor (fd text, b text, fd2 int, fd3 int, a int)
-  partition by range (b);
-alter table parted_irreg_ancestor drop column fd,
-  drop column fd2, drop column fd3;
-create table parted_irreg (fd int, a int, fd2 int, b text)
-  partition by range (b);
-alter table parted_irreg drop column fd, drop column fd2;
-alter table parted_irreg_ancestor attach partition parted_irreg
-  for values from ('aaaa') to ('zzzz');
-create table parted1_irreg (b text, fd int, a int);
-alter table parted1_irreg drop column fd;
-alter table parted_irreg attach partition parted1_irreg
-  for values from ('aaaa') to ('bbbb');
-create trigger parted_trig after insert on parted_irreg
-  for each row execute procedure trigger_notice_ab();
-create trigger parted_trig_odd after insert on parted_irreg for each row
-  when (bark(new.b) AND new.a % 2 = 1) execute procedure trigger_notice_ab();
--- we should hear barking for every insert, but parted_trig_odd only emits
--- noise for odd values of a. parted_trig does it for all inserts.
-insert into parted_irreg values (1, 'aardvark'), (2, 'aanimals');
-NOTICE:  aardvark <- woof!
-NOTICE:  aanimals <- woof!
-NOTICE:  trigger parted_trig on parted1_irreg AFTER INSERT for ROW: (a,b)=(1,aardvark)
-NOTICE:  trigger parted_trig_odd on parted1_irreg AFTER INSERT for ROW: (a,b)=(1,aardvark)
-NOTICE:  trigger parted_trig on parted1_irreg AFTER INSERT for ROW: (a,b)=(2,aanimals)
-insert into parted1_irreg values ('aardwolf', 2);
-NOTICE:  aardwolf <- woof!
-NOTICE:  trigger parted_trig on parted1_irreg AFTER INSERT for ROW: (a,b)=(2,aardwolf)
-insert into parted_irreg_ancestor values ('aasvogel', 3);
-NOTICE:  aasvogel <- woof!
-NOTICE:  trigger parted_trig on parted1_irreg AFTER INSERT for ROW: (a,b)=(3,aasvogel)
-NOTICE:  trigger parted_trig_odd on parted1_irreg AFTER INSERT for ROW: (a,b)=(3,aasvogel)
-drop table parted_irreg_ancestor;
--- Before triggers and partitions
-create table parted (a int, b int, c text) partition by list (a);
-create table parted_1 partition of parted for values in (1)
-  partition by list (b);
-create table parted_1_1 partition of parted_1 for values in (1);
-create function parted_trigfunc() returns trigger language plpgsql as $$
-begin
-  new.a = new.a + 1;
-  return new;
-end;
-$$;
-insert into parted values (1, 1, 'uno uno v1');    -- works
-create trigger t before insert or update or delete on parted
-  for each row execute function parted_trigfunc();
-insert into parted values (1, 1, 'uno uno v2');    -- fail
-ERROR:  moving row to another partition during a BEFORE FOR EACH ROW trigger is not supported
-DETAIL:  Before executing trigger "t", the row was to be in partition "public.parted_1_1".
-update parted set c = c || 'v3';                   -- fail
-ERROR:  no partition of relation "parted" found for row
-DETAIL:  Partition key of the failing row contains (a) = (2).
-create or replace function parted_trigfunc() returns trigger language plpgsql as $$
-begin
-  new.b = new.b + 1;
-  return new;
-end;
-$$;
-insert into parted values (1, 1, 'uno uno v4');    -- fail
-ERROR:  moving row to another partition during a BEFORE FOR EACH ROW trigger is not supported
-DETAIL:  Before executing trigger "t", the row was to be in partition "public.parted_1_1".
-update parted set c = c || 'v5';                   -- fail
-ERROR:  no partition of relation "parted_1" found for row
-DETAIL:  Partition key of the failing row contains (b) = (2).
-create or replace function parted_trigfunc() returns trigger language plpgsql as $$
-begin
-  new.c = new.c || ' did '|| TG_OP;
-  return new;
-end;
-$$;
-insert into parted values (1, 1, 'uno uno');       -- works
-update parted set c = c || ' v6';                   -- works
-select tableoid::regclass, * from parted;
-  tableoid  | a | b |                c                 
-------------+---+---+----------------------------------
- parted_1_1 | 1 | 1 | uno uno v1 v6 did UPDATE
- parted_1_1 | 1 | 1 | uno uno did INSERT v6 did UPDATE
-(2 rows)
-
--- update itself moves tuple to new partition; trigger still works
-truncate table parted;
-create table parted_2 partition of parted for values in (2);
-insert into parted values (1, 1, 'uno uno v5');
-update parted set a = 2;
-select tableoid::regclass, * from parted;
- tableoid | a | b |                      c                      
-----------+---+---+---------------------------------------------
- parted_2 | 2 | 1 | uno uno v5 did INSERT did UPDATE did INSERT
-(1 row)
-
--- both trigger and update change the partition
-create or replace function parted_trigfunc2() returns trigger language plpgsql as $$
-begin
-  new.a = new.a + 1;
-  return new;
-end;
-$$;
-create trigger t2 before update on parted
-  for each row execute function parted_trigfunc2();
-truncate table parted;
-insert into parted values (1, 1, 'uno uno v6');
-create table parted_3 partition of parted for values in (3);
-update parted set a = a + 1;
-select tableoid::regclass, * from parted;
- tableoid | a | b |                      c                      
-----------+---+---+---------------------------------------------
- parted_3 | 3 | 1 | uno uno v6 did INSERT did UPDATE did INSERT
-(1 row)
-
--- there's no partition for a=0, but this update works anyway because
--- the trigger causes the tuple to be routed to another partition
-update parted set a = 0;
-select tableoid::regclass, * from parted;
-  tableoid  | a | b |                                 c                                 
-------------+---+---+-------------------------------------------------------------------
- parted_1_1 | 1 | 1 | uno uno v6 did INSERT did UPDATE did INSERT did UPDATE did INSERT
-(1 row)
-
-drop table parted;
-create table parted (a int, b int, c text) partition by list ((a + b));
-create or replace function parted_trigfunc() returns trigger language plpgsql as $$
-begin
-  new.a = new.a + new.b;
-  return new;
-end;
-$$;
-create table parted_1 partition of parted for values in (1, 2);
-create table parted_2 partition of parted for values in (3, 4);
-create trigger t before insert or update on parted
-  for each row execute function parted_trigfunc();
-insert into parted values (0, 1, 'zero win');
-insert into parted values (1, 1, 'one fail');
-ERROR:  moving row to another partition during a BEFORE FOR EACH ROW trigger is not supported
-DETAIL:  Before executing trigger "t", the row was to be in partition "public.parted_1".
-insert into parted values (1, 2, 'two fail');
-ERROR:  moving row to another partition during a BEFORE FOR EACH ROW trigger is not supported
-DETAIL:  Before executing trigger "t", the row was to be in partition "public.parted_2".
-select * from parted;
- a | b |    c     
----+---+----------
- 1 | 1 | zero win
-(1 row)
-
-drop table parted;
-drop function parted_trigfunc();
---
--- Constraint triggers and partitioned tables
-create table parted_constr_ancestor (a int, b text)
-  partition by range (b);
-create table parted_constr (a int, b text)
-  partition by range (b);
-alter table parted_constr_ancestor attach partition parted_constr
-  for values from ('aaaa') to ('zzzz');
-create table parted1_constr (a int, b text);
-alter table parted_constr attach partition parted1_constr
-  for values from ('aaaa') to ('bbbb');
-create constraint trigger parted_trig after insert on parted_constr_ancestor
-  deferrable
-  for each row execute procedure trigger_notice_ab();
-create constraint trigger parted_trig_two after insert on parted_constr
-  deferrable initially deferred
-  for each row when (bark(new.b) AND new.a % 2 = 1)
-  execute procedure trigger_notice_ab();
--- The immediate constraint is fired immediately; the WHEN clause of the
--- deferred constraint is also called immediately.  The deferred constraint
--- is fired at commit time.
-begin;
-insert into parted_constr values (1, 'aardvark');
-NOTICE:  aardvark <- woof!
-NOTICE:  trigger parted_trig on parted1_constr AFTER INSERT for ROW: (a,b)=(1,aardvark)
-insert into parted1_constr values (2, 'aardwolf');
-NOTICE:  aardwolf <- woof!
-NOTICE:  trigger parted_trig on parted1_constr AFTER INSERT for ROW: (a,b)=(2,aardwolf)
-insert into parted_constr_ancestor values (3, 'aasvogel');
-NOTICE:  aasvogel <- woof!
-NOTICE:  trigger parted_trig on parted1_constr AFTER INSERT for ROW: (a,b)=(3,aasvogel)
-commit;
-NOTICE:  trigger parted_trig_two on parted1_constr AFTER INSERT for ROW: (a,b)=(1,aardvark)
-NOTICE:  trigger parted_trig_two on parted1_constr AFTER INSERT for ROW: (a,b)=(3,aasvogel)
--- The WHEN clause is immediate, and both constraint triggers are fired at
--- commit time.
-begin;
-set constraints parted_trig deferred;
-insert into parted_constr values (1, 'aardvark');
-NOTICE:  aardvark <- woof!
-insert into parted1_constr values (2, 'aardwolf'), (3, 'aasvogel');
-NOTICE:  aardwolf <- woof!
-NOTICE:  aasvogel <- woof!
-commit;
-NOTICE:  trigger parted_trig on parted1_constr AFTER INSERT for ROW: (a,b)=(1,aardvark)
-NOTICE:  trigger parted_trig_two on parted1_constr AFTER INSERT for ROW: (a,b)=(1,aardvark)
-NOTICE:  trigger parted_trig on parted1_constr AFTER INSERT for ROW: (a,b)=(2,aardwolf)
-NOTICE:  trigger parted_trig on parted1_constr AFTER INSERT for ROW: (a,b)=(3,aasvogel)
-NOTICE:  trigger parted_trig_two on parted1_constr AFTER INSERT for ROW: (a,b)=(3,aasvogel)
-drop table parted_constr_ancestor;
-drop function bark(text);
--- Test that the WHEN clause is set properly to partitions
-create table parted_trigger (a int, b text) partition by range (a);
-create table parted_trigger_1 partition of parted_trigger for values from (0) to (1000);
-create table parted_trigger_2 (drp int, a int, b text);
-alter table parted_trigger_2 drop column drp;
-alter table parted_trigger attach partition parted_trigger_2 for values from (1000) to (2000);
-create trigger parted_trigger after update on parted_trigger
-  for each row when (new.a % 2 = 1 and length(old.b) >= 2) execute procedure trigger_notice_ab();
-create table parted_trigger_3 (b text, a int) partition by range (length(b));
-create table parted_trigger_3_1 partition of parted_trigger_3 for values from (1) to (3);
-create table parted_trigger_3_2 partition of parted_trigger_3 for values from (3) to (5);
-alter table parted_trigger attach partition parted_trigger_3 for values from (2000) to (3000);
-insert into parted_trigger values
-    (0, 'a'), (1, 'bbb'), (2, 'bcd'), (3, 'c'),
-	(1000, 'c'), (1001, 'ddd'), (1002, 'efg'), (1003, 'f'),
-	(2000, 'e'), (2001, 'fff'), (2002, 'ghi'), (2003, 'h');
-update parted_trigger set a = a + 2; -- notice for odd 'a' values, long 'b' values
-NOTICE:  trigger parted_trigger on parted_trigger_1 AFTER UPDATE for ROW: (a,b)=(3,bbb)
-NOTICE:  trigger parted_trigger on parted_trigger_2 AFTER UPDATE for ROW: (a,b)=(1003,ddd)
-NOTICE:  trigger parted_trigger on parted_trigger_3_2 AFTER UPDATE for ROW: (a,b)=(2003,fff)
-drop table parted_trigger;
--- try a constraint trigger, also
-create table parted_referenced (a int);
-create table unparted_trigger (a int, b text);	-- for comparison purposes
-create table parted_trigger (a int, b text) partition by range (a);
-create table parted_trigger_1 partition of parted_trigger for values from (0) to (1000);
-create table parted_trigger_2 (drp int, a int, b text);
-alter table parted_trigger_2 drop column drp;
-alter table parted_trigger attach partition parted_trigger_2 for values from (1000) to (2000);
-create constraint trigger parted_trigger after update on parted_trigger
-  from parted_referenced
-  for each row execute procedure trigger_notice_ab();
-create constraint trigger parted_trigger after update on unparted_trigger
-  from parted_referenced
-  for each row execute procedure trigger_notice_ab();
-create table parted_trigger_3 (b text, a int) partition by range (length(b));
-create table parted_trigger_3_1 partition of parted_trigger_3 for values from (1) to (3);
-create table parted_trigger_3_2 partition of parted_trigger_3 for values from (3) to (5);
-alter table parted_trigger attach partition parted_trigger_3 for values from (2000) to (3000);
-select tgname, conname, t.tgrelid::regclass, t.tgconstrrelid::regclass,
-  c.conrelid::regclass, c.confrelid::regclass
-  from pg_trigger t join pg_constraint c on (t.tgconstraint = c.oid)
-  where tgname = 'parted_trigger'
-  order by t.tgrelid::regclass::text;
-     tgname     |    conname     |      tgrelid       |   tgconstrrelid   |      conrelid      | confrelid 
-----------------+----------------+--------------------+-------------------+--------------------+-----------
- parted_trigger | parted_trigger | parted_trigger     | parted_referenced | parted_trigger     | -
- parted_trigger | parted_trigger | parted_trigger_1   | parted_referenced | parted_trigger_1   | -
- parted_trigger | parted_trigger | parted_trigger_2   | parted_referenced | parted_trigger_2   | -
- parted_trigger | parted_trigger | parted_trigger_3   | parted_referenced | parted_trigger_3   | -
- parted_trigger | parted_trigger | parted_trigger_3_1 | parted_referenced | parted_trigger_3_1 | -
- parted_trigger | parted_trigger | parted_trigger_3_2 | parted_referenced | parted_trigger_3_2 | -
- parted_trigger | parted_trigger | unparted_trigger   | parted_referenced | unparted_trigger   | -
-(7 rows)
-
-drop table parted_referenced, parted_trigger, unparted_trigger;
--- verify that the "AFTER UPDATE OF columns" event is propagated correctly
-create table parted_trigger (a int, b text) partition by range (a);
-create table parted_trigger_1 partition of parted_trigger for values from (0) to (1000);
-create table parted_trigger_2 (drp int, a int, b text);
-alter table parted_trigger_2 drop column drp;
-alter table parted_trigger attach partition parted_trigger_2 for values from (1000) to (2000);
-create trigger parted_trigger after update of b on parted_trigger
-  for each row execute procedure trigger_notice_ab();
-create table parted_trigger_3 (b text, a int) partition by range (length(b));
-create table parted_trigger_3_1 partition of parted_trigger_3 for values from (1) to (4);
-create table parted_trigger_3_2 partition of parted_trigger_3 for values from (4) to (8);
-alter table parted_trigger attach partition parted_trigger_3 for values from (2000) to (3000);
-insert into parted_trigger values (0, 'a'), (1000, 'c'), (2000, 'e'), (2001, 'eeee');
-update parted_trigger set a = a + 2;	-- no notices here
-update parted_trigger set b = b || 'b';	-- all triggers should fire
-NOTICE:  trigger parted_trigger on parted_trigger_1 AFTER UPDATE for ROW: (a,b)=(2,ab)
-NOTICE:  trigger parted_trigger on parted_trigger_2 AFTER UPDATE for ROW: (a,b)=(1002,cb)
-NOTICE:  trigger parted_trigger on parted_trigger_3_1 AFTER UPDATE for ROW: (a,b)=(2002,eb)
-NOTICE:  trigger parted_trigger on parted_trigger_3_2 AFTER UPDATE for ROW: (a,b)=(2003,eeeeb)
-drop table parted_trigger;
-drop function trigger_notice_ab();
--- Make sure we don't end up with unnecessary copies of triggers, when
--- cloning them.
-create table trg_clone (a int) partition by range (a);
-create table trg_clone1 partition of trg_clone for values from (0) to (1000);
-alter table trg_clone add constraint uniq unique (a) deferrable;
-create table trg_clone2 partition of trg_clone for values from (1000) to (2000);
-create table trg_clone3 partition of trg_clone for values from (2000) to (3000)
-  partition by range (a);
-create table trg_clone_3_3 partition of trg_clone3 for values from (2000) to (2100);
-select tgrelid::regclass, count(*) from pg_trigger
-  where tgrelid::regclass in ('trg_clone', 'trg_clone1', 'trg_clone2',
-	'trg_clone3', 'trg_clone_3_3')
-  group by tgrelid::regclass order by tgrelid::regclass;
-    tgrelid    | count 
----------------+-------
- trg_clone     |     1
- trg_clone1    |     1
- trg_clone2    |     1
- trg_clone3    |     1
- trg_clone_3_3 |     1
-(5 rows)
-
-drop table trg_clone;
--- Test the interaction between ALTER TABLE .. DISABLE TRIGGER and
--- both kinds of inheritance.  Historically, legacy inheritance has
--- not recursed to children, so that behavior is preserved.
-create table parent (a int);
-create table child1 () inherits (parent);
-create function trig_nothing() returns trigger language plpgsql
-  as $$ begin return null; end $$;
-create trigger tg after insert on parent
-  for each row execute function trig_nothing();
-create trigger tg after insert on child1
-  for each row execute function trig_nothing();
-alter table parent disable trigger tg;
-select tgrelid::regclass, tgname, tgenabled from pg_trigger
-  where tgrelid in ('parent'::regclass, 'child1'::regclass)
-  order by tgrelid::regclass::text;
- tgrelid | tgname | tgenabled 
----------+--------+-----------
- child1  | tg     | O
- parent  | tg     | D
-(2 rows)
-
-alter table only parent enable always trigger tg;
-select tgrelid::regclass, tgname, tgenabled from pg_trigger
-  where tgrelid in ('parent'::regclass, 'child1'::regclass)
-  order by tgrelid::regclass::text;
- tgrelid | tgname | tgenabled 
----------+--------+-----------
- child1  | tg     | O
- parent  | tg     | A
-(2 rows)
-
-drop table parent, child1;
-create table parent (a int) partition by list (a);
-create table child1 partition of parent for values in (1);
-create trigger tg after insert on parent
-  for each row execute procedure trig_nothing();
-select tgrelid::regclass, tgname, tgenabled from pg_trigger
-  where tgrelid in ('parent'::regclass, 'child1'::regclass)
-  order by tgrelid::regclass::text;
- tgrelid | tgname | tgenabled 
----------+--------+-----------
- child1  | tg     | O
- parent  | tg     | O
-(2 rows)
-
-alter table only parent enable always trigger tg;
-select tgrelid::regclass, tgname, tgenabled from pg_trigger
-  where tgrelid in ('parent'::regclass, 'child1'::regclass)
-  order by tgrelid::regclass::text;
- tgrelid | tgname | tgenabled 
----------+--------+-----------
- child1  | tg     | O
- parent  | tg     | A
-(2 rows)
-
-drop table parent, child1;
--- Verify that firing state propagates correctly on creation, too
-CREATE TABLE trgfire (i int) PARTITION BY RANGE (i);
-CREATE TABLE trgfire1 PARTITION OF trgfire FOR VALUES FROM (1) TO (10);
-CREATE OR REPLACE FUNCTION tgf() RETURNS trigger LANGUAGE plpgsql
-  AS $$ begin raise exception 'except'; end $$;
-CREATE TRIGGER tg AFTER INSERT ON trgfire FOR EACH ROW EXECUTE FUNCTION tgf();
-INSERT INTO trgfire VALUES (1);
-ERROR:  except
-CONTEXT:  PL/pgSQL function tgf() line 1 at RAISE
-ALTER TABLE trgfire DISABLE TRIGGER tg;
-INSERT INTO trgfire VALUES (1);
-CREATE TABLE trgfire2 PARTITION OF trgfire FOR VALUES FROM (10) TO (20);
-INSERT INTO trgfire VALUES (11);
-CREATE TABLE trgfire3 (LIKE trgfire);
-ALTER TABLE trgfire ATTACH PARTITION trgfire3 FOR VALUES FROM (20) TO (30);
-INSERT INTO trgfire VALUES (21);
-CREATE TABLE trgfire4 PARTITION OF trgfire FOR VALUES FROM (30) TO (40) PARTITION BY LIST (i);
-CREATE TABLE trgfire4_30 PARTITION OF trgfire4 FOR VALUES IN (30);
-INSERT INTO trgfire VALUES (30);
-CREATE TABLE trgfire5 (LIKE trgfire) PARTITION BY LIST (i);
-CREATE TABLE trgfire5_40 PARTITION OF trgfire5 FOR VALUES IN (40);
-ALTER TABLE trgfire ATTACH PARTITION trgfire5 FOR VALUES FROM (40) TO (50);
-INSERT INTO trgfire VALUES (40);
-SELECT tgrelid::regclass, tgenabled FROM pg_trigger
-  WHERE tgrelid::regclass IN (SELECT oid from pg_class where relname LIKE 'trgfire%')
-  ORDER BY tgrelid::regclass::text;
-   tgrelid   | tgenabled 
--------------+-----------
- trgfire     | D
- trgfire1    | D
- trgfire2    | D
- trgfire3    | D
- trgfire4    | D
- trgfire4_30 | D
- trgfire5    | D
- trgfire5_40 | D
-(8 rows)
-
-ALTER TABLE trgfire ENABLE TRIGGER tg;
-INSERT INTO trgfire VALUES (1);
-ERROR:  except
-CONTEXT:  PL/pgSQL function tgf() line 1 at RAISE
-INSERT INTO trgfire VALUES (11);
-ERROR:  except
-CONTEXT:  PL/pgSQL function tgf() line 1 at RAISE
-INSERT INTO trgfire VALUES (21);
-ERROR:  except
-CONTEXT:  PL/pgSQL function tgf() line 1 at RAISE
-INSERT INTO trgfire VALUES (30);
-ERROR:  except
-CONTEXT:  PL/pgSQL function tgf() line 1 at RAISE
-INSERT INTO trgfire VALUES (40);
-ERROR:  except
-CONTEXT:  PL/pgSQL function tgf() line 1 at RAISE
-DROP TABLE trgfire;
-DROP FUNCTION tgf();
---
--- Test the interaction between transition tables and both kinds of
--- inheritance.  We'll dump the contents of the transition tables in a
--- format that shows the attribute order, so that we can distinguish
--- tuple formats (though not dropped attributes).
---
-create or replace function dump_insert() returns trigger language plpgsql as
-$$
-  begin
-    raise notice 'trigger = %, new table = %',
-                 TG_NAME,
-                 (select string_agg(new_table::text, ', ' order by a) from new_table);
-    return null;
-  end;
-$$;
-create or replace function dump_update() returns trigger language plpgsql as
-$$
-  begin
-    raise notice 'trigger = %, old table = %, new table = %',
-                 TG_NAME,
-                 (select string_agg(old_table::text, ', ' order by a) from old_table),
-                 (select string_agg(new_table::text, ', ' order by a) from new_table);
-    return null;
-  end;
-$$;
-create or replace function dump_delete() returns trigger language plpgsql as
-$$
-  begin
-    raise notice 'trigger = %, old table = %',
-                 TG_NAME,
-                 (select string_agg(old_table::text, ', ' order by a) from old_table);
-    return null;
-  end;
-$$;
---
--- Verify behavior of statement triggers on partition hierarchy with
--- transition tables.  Tuples should appear to each trigger in the
--- format of the relation the trigger is attached to.
---
--- set up a partition hierarchy with some different TupleDescriptors
-create table parent (a text, b int) partition by list (a);
--- a child matching parent
-create table child1 partition of parent for values in ('AAA');
--- a child with a dropped column
-create table child2 (x int, a text, b int);
-alter table child2 drop column x;
-alter table parent attach partition child2 for values in ('BBB');
--- a child with a different column order
-create table child3 (b int, a text);
-alter table parent attach partition child3 for values in ('CCC');
-create trigger parent_insert_trig
-  after insert on parent referencing new table as new_table
-  for each statement execute procedure dump_insert();
-create trigger parent_update_trig
-  after update on parent referencing old table as old_table new table as new_table
-  for each statement execute procedure dump_update();
-create trigger parent_delete_trig
-  after delete on parent referencing old table as old_table
-  for each statement execute procedure dump_delete();
-create trigger child1_insert_trig
-  after insert on child1 referencing new table as new_table
-  for each statement execute procedure dump_insert();
-create trigger child1_update_trig
-  after update on child1 referencing old table as old_table new table as new_table
-  for each statement execute procedure dump_update();
-create trigger child1_delete_trig
-  after delete on child1 referencing old table as old_table
-  for each statement execute procedure dump_delete();
-create trigger child2_insert_trig
-  after insert on child2 referencing new table as new_table
-  for each statement execute procedure dump_insert();
-create trigger child2_update_trig
-  after update on child2 referencing old table as old_table new table as new_table
-  for each statement execute procedure dump_update();
-create trigger child2_delete_trig
-  after delete on child2 referencing old table as old_table
-  for each statement execute procedure dump_delete();
-create trigger child3_insert_trig
-  after insert on child3 referencing new table as new_table
-  for each statement execute procedure dump_insert();
-create trigger child3_update_trig
-  after update on child3 referencing old table as old_table new table as new_table
-  for each statement execute procedure dump_update();
-create trigger child3_delete_trig
-  after delete on child3 referencing old table as old_table
-  for each statement execute procedure dump_delete();
-SELECT trigger_name, event_manipulation, event_object_schema, event_object_table,
-       action_order, action_condition, action_orientation, action_timing,
-       action_reference_old_table, action_reference_new_table
-  FROM information_schema.triggers
-  WHERE event_object_table IN ('parent', 'child1', 'child2', 'child3')
-  ORDER BY trigger_name COLLATE "C", 2;
-    trigger_name    | event_manipulation | event_object_schema | event_object_table | action_order | action_condition | action_orientation | action_timing | action_reference_old_table | action_reference_new_table 
---------------------+--------------------+---------------------+--------------------+--------------+------------------+--------------------+---------------+----------------------------+----------------------------
- child1_delete_trig | DELETE             | public              | child1             |            1 |                  | STATEMENT          | AFTER         | old_table                  | 
- child1_insert_trig | INSERT             | public              | child1             |            1 |                  | STATEMENT          | AFTER         |                            | new_table
- child1_update_trig | UPDATE             | public              | child1             |            1 |                  | STATEMENT          | AFTER         | old_table                  | new_table
- child2_delete_trig | DELETE             | public              | child2             |            1 |                  | STATEMENT          | AFTER         | old_table                  | 
- child2_insert_trig | INSERT             | public              | child2             |            1 |                  | STATEMENT          | AFTER         |                            | new_table
- child2_update_trig | UPDATE             | public              | child2             |            1 |                  | STATEMENT          | AFTER         | old_table                  | new_table
- child3_delete_trig | DELETE             | public              | child3             |            1 |                  | STATEMENT          | AFTER         | old_table                  | 
- child3_insert_trig | INSERT             | public              | child3             |            1 |                  | STATEMENT          | AFTER         |                            | new_table
- child3_update_trig | UPDATE             | public              | child3             |            1 |                  | STATEMENT          | AFTER         | old_table                  | new_table
- parent_delete_trig | DELETE             | public              | parent             |            1 |                  | STATEMENT          | AFTER         | old_table                  | 
- parent_insert_trig | INSERT             | public              | parent             |            1 |                  | STATEMENT          | AFTER         |                            | new_table
- parent_update_trig | UPDATE             | public              | parent             |            1 |                  | STATEMENT          | AFTER         | old_table                  | new_table
-(12 rows)
-
--- insert directly into children sees respective child-format tuples
-insert into child1 values ('AAA', 42);
-NOTICE:  trigger = child1_insert_trig, new table = (AAA,42)
-insert into child2 values ('BBB', 42);
-NOTICE:  trigger = child2_insert_trig, new table = (BBB,42)
-insert into child3 values (42, 'CCC');
-NOTICE:  trigger = child3_insert_trig, new table = (42,CCC)
--- update via parent sees parent-format tuples
-update parent set b = b + 1;
-NOTICE:  trigger = parent_update_trig, old table = (AAA,42), (BBB,42), (CCC,42), new table = (AAA,43), (BBB,43), (CCC,43)
--- delete via parent sees parent-format tuples
-delete from parent;
-NOTICE:  trigger = parent_delete_trig, old table = (AAA,43), (BBB,43), (CCC,43)
--- insert into parent sees parent-format tuples
-insert into parent values ('AAA', 42);
-NOTICE:  trigger = parent_insert_trig, new table = (AAA,42)
-insert into parent values ('BBB', 42);
-NOTICE:  trigger = parent_insert_trig, new table = (BBB,42)
-insert into parent values ('CCC', 42);
-NOTICE:  trigger = parent_insert_trig, new table = (CCC,42)
--- delete from children sees respective child-format tuples
-delete from child1;
-NOTICE:  trigger = child1_delete_trig, old table = (AAA,42)
-delete from child2;
-NOTICE:  trigger = child2_delete_trig, old table = (BBB,42)
-delete from child3;
-NOTICE:  trigger = child3_delete_trig, old table = (42,CCC)
--- copy into parent sees parent-format tuples
-copy parent (a, b) from stdin;
-NOTICE:  trigger = parent_insert_trig, new table = (AAA,42), (BBB,42), (CCC,42)
--- DML affecting parent sees tuples collected from children even if
--- there is no transition table trigger on the children
-drop trigger child1_insert_trig on child1;
-drop trigger child1_update_trig on child1;
-drop trigger child1_delete_trig on child1;
-drop trigger child2_insert_trig on child2;
-drop trigger child2_update_trig on child2;
-drop trigger child2_delete_trig on child2;
-drop trigger child3_insert_trig on child3;
-drop trigger child3_update_trig on child3;
-drop trigger child3_delete_trig on child3;
-delete from parent;
-NOTICE:  trigger = parent_delete_trig, old table = (AAA,42), (BBB,42), (CCC,42)
--- copy into parent sees tuples collected from children even if there
--- is no transition-table trigger on the children
-copy parent (a, b) from stdin;
-NOTICE:  trigger = parent_insert_trig, new table = (AAA,42), (BBB,42), (CCC,42)
--- insert into parent with a before trigger on a child tuple before
--- insertion, and we capture the newly modified row in parent format
-create or replace function intercept_insert() returns trigger language plpgsql as
-$$
-  begin
-    new.b = new.b + 1000;
-    return new;
-  end;
-$$;
-create trigger intercept_insert_child3
-  before insert on child3
-  for each row execute procedure intercept_insert();
--- insert, parent trigger sees post-modification parent-format tuple
-insert into parent values ('AAA', 42), ('BBB', 42), ('CCC', 66);
-NOTICE:  trigger = parent_insert_trig, new table = (AAA,42), (BBB,42), (CCC,1066)
--- copy, parent trigger sees post-modification parent-format tuple
-copy parent (a, b) from stdin;
-NOTICE:  trigger = parent_insert_trig, new table = (AAA,42), (BBB,42), (CCC,1234)
-drop table child1, child2, child3, parent;
-drop function intercept_insert();
---
--- Verify prohibition of row triggers with transition triggers on
--- partitions
---
-create table parent (a text, b int) partition by list (a);
-create table child partition of parent for values in ('AAA');
--- adding row trigger with transition table fails
-create trigger child_row_trig
-  after insert on child referencing new table as new_table
-  for each row execute procedure dump_insert();
-ERROR:  ROW triggers with transition tables are not supported on partitions
--- detaching it first works
-alter table parent detach partition child;
-create trigger child_row_trig
-  after insert on child referencing new table as new_table
-  for each row execute procedure dump_insert();
--- but now we're not allowed to reattach it
-alter table parent attach partition child for values in ('AAA');
-ERROR:  trigger "child_row_trig" prevents table "child" from becoming a partition
-DETAIL:  ROW triggers with transition tables are not supported on partitions
--- drop the trigger, and now we're allowed to attach it again
-drop trigger child_row_trig on child;
-alter table parent attach partition child for values in ('AAA');
-drop table child, parent;
---
--- Verify behavior of statement triggers on (non-partition)
--- inheritance hierarchy with transition tables; similar to the
--- partition case, except there is no rerouting on insertion and child
--- tables can have extra columns
---
--- set up inheritance hierarchy with different TupleDescriptors
-create table parent (a text, b int);
--- a child matching parent
-create table child1 () inherits (parent);
--- a child with a different column order
-create table child2 (b int, a text);
-alter table child2 inherit parent;
--- a child with an extra column
-create table child3 (c text) inherits (parent);
-create trigger parent_insert_trig
-  after insert on parent referencing new table as new_table
-  for each statement execute procedure dump_insert();
-create trigger parent_update_trig
-  after update on parent referencing old table as old_table new table as new_table
-  for each statement execute procedure dump_update();
-create trigger parent_delete_trig
-  after delete on parent referencing old table as old_table
-  for each statement execute procedure dump_delete();
-create trigger child1_insert_trig
-  after insert on child1 referencing new table as new_table
-  for each statement execute procedure dump_insert();
-create trigger child1_update_trig
-  after update on child1 referencing old table as old_table new table as new_table
-  for each statement execute procedure dump_update();
-create trigger child1_delete_trig
-  after delete on child1 referencing old table as old_table
-  for each statement execute procedure dump_delete();
-create trigger child2_insert_trig
-  after insert on child2 referencing new table as new_table
-  for each statement execute procedure dump_insert();
-create trigger child2_update_trig
-  after update on child2 referencing old table as old_table new table as new_table
-  for each statement execute procedure dump_update();
-create trigger child2_delete_trig
-  after delete on child2 referencing old table as old_table
-  for each statement execute procedure dump_delete();
-create trigger child3_insert_trig
-  after insert on child3 referencing new table as new_table
-  for each statement execute procedure dump_insert();
-create trigger child3_update_trig
-  after update on child3 referencing old table as old_table new table as new_table
-  for each statement execute procedure dump_update();
-create trigger child3_delete_trig
-  after delete on child3 referencing old table as old_table
-  for each statement execute procedure dump_delete();
--- insert directly into children sees respective child-format tuples
-insert into child1 values ('AAA', 42);
-NOTICE:  trigger = child1_insert_trig, new table = (AAA,42)
-insert into child2 values (42, 'BBB');
-NOTICE:  trigger = child2_insert_trig, new table = (42,BBB)
-insert into child3 values ('CCC', 42, 'foo');
-NOTICE:  trigger = child3_insert_trig, new table = (CCC,42,foo)
--- update via parent sees parent-format tuples
-update parent set b = b + 1;
-NOTICE:  trigger = parent_update_trig, old table = (AAA,42), (BBB,42), (CCC,42), new table = (AAA,43), (BBB,43), (CCC,43)
--- delete via parent sees parent-format tuples
-delete from parent;
-NOTICE:  trigger = parent_delete_trig, old table = (AAA,43), (BBB,43), (CCC,43)
--- reinsert values into children for next test...
-insert into child1 values ('AAA', 42);
-NOTICE:  trigger = child1_insert_trig, new table = (AAA,42)
-insert into child2 values (42, 'BBB');
-NOTICE:  trigger = child2_insert_trig, new table = (42,BBB)
-insert into child3 values ('CCC', 42, 'foo');
-NOTICE:  trigger = child3_insert_trig, new table = (CCC,42,foo)
--- delete from children sees respective child-format tuples
-delete from child1;
-NOTICE:  trigger = child1_delete_trig, old table = (AAA,42)
-delete from child2;
-NOTICE:  trigger = child2_delete_trig, old table = (42,BBB)
-delete from child3;
-NOTICE:  trigger = child3_delete_trig, old table = (CCC,42,foo)
--- copy into parent sees parent-format tuples (no rerouting, so these
--- are really inserted into the parent)
-copy parent (a, b) from stdin;
-NOTICE:  trigger = parent_insert_trig, new table = (AAA,42), (BBB,42), (CCC,42)
--- same behavior for copy if there is an index (interesting because rows are
--- captured by a different code path in copyfrom.c if there are indexes)
-create index on parent(b);
-copy parent (a, b) from stdin;
-NOTICE:  trigger = parent_insert_trig, new table = (DDD,42)
--- DML affecting parent sees tuples collected from children even if
--- there is no transition table trigger on the children
-drop trigger child1_insert_trig on child1;
-drop trigger child1_update_trig on child1;
-drop trigger child1_delete_trig on child1;
-drop trigger child2_insert_trig on child2;
-drop trigger child2_update_trig on child2;
-drop trigger child2_delete_trig on child2;
-drop trigger child3_insert_trig on child3;
-drop trigger child3_update_trig on child3;
-drop trigger child3_delete_trig on child3;
-delete from parent;
-NOTICE:  trigger = parent_delete_trig, old table = (AAA,42), (BBB,42), (CCC,42), (DDD,42)
-drop table child1, child2, child3, parent;
---
--- Verify prohibition of row triggers with transition triggers on
--- inheritance children
---
-create table parent (a text, b int);
-create table child () inherits (parent);
--- adding row trigger with transition table fails
-create trigger child_row_trig
-  after insert on child referencing new table as new_table
-  for each row execute procedure dump_insert();
-ERROR:  ROW triggers with transition tables are not supported on inheritance children
--- disinheriting it first works
-alter table child no inherit parent;
-create trigger child_row_trig
-  after insert on child referencing new table as new_table
-  for each row execute procedure dump_insert();
--- but now we're not allowed to make it inherit anymore
-alter table child inherit parent;
-ERROR:  trigger "child_row_trig" prevents table "child" from becoming an inheritance child
-DETAIL:  ROW triggers with transition tables are not supported in inheritance hierarchies.
--- drop the trigger, and now we're allowed to make it inherit again
-drop trigger child_row_trig on child;
-alter table child inherit parent;
-drop table child, parent;
---
--- Verify behavior of queries with wCTEs, where multiple transition
--- tuplestores can be active at the same time because there are
--- multiple DML statements that might fire triggers with transition
--- tables
---
-create table table1 (a int);
-create table table2 (a text);
-create trigger table1_trig
-  after insert on table1 referencing new table as new_table
-  for each statement execute procedure dump_insert();
-create trigger table2_trig
-  after insert on table2 referencing new table as new_table
-  for each statement execute procedure dump_insert();
-with wcte as (insert into table1 values (42))
-  insert into table2 values ('hello world');
-NOTICE:  trigger = table2_trig, new table = ("hello world")
-NOTICE:  trigger = table1_trig, new table = (42)
-with wcte as (insert into table1 values (43))
-  insert into table1 values (44);
-NOTICE:  trigger = table1_trig, new table = (43), (44)
-select * from table1;
- a  
-----
- 42
- 44
- 43
-(3 rows)
-
-select * from table2;
-      a      
--------------
- hello world
-(1 row)
-
-drop table table1;
-drop table table2;
---
--- Verify behavior of INSERT ... ON CONFLICT DO UPDATE ... with
--- transition tables.
---
-create table my_table (a int primary key, b text);
-create trigger my_table_insert_trig
-  after insert on my_table referencing new table as new_table
-  for each statement execute procedure dump_insert();
-create trigger my_table_update_trig
-  after update on my_table referencing old table as old_table new table as new_table
-  for each statement execute procedure dump_update();
--- inserts only
-insert into my_table values (1, 'AAA'), (2, 'BBB')
-  on conflict (a) do
-  update set b = my_table.b || ':' || excluded.b;
-NOTICE:  trigger = my_table_update_trig, old table = <NULL>, new table = <NULL>
-NOTICE:  trigger = my_table_insert_trig, new table = (1,AAA), (2,BBB)
--- mixture of inserts and updates
-insert into my_table values (1, 'AAA'), (2, 'BBB'), (3, 'CCC'), (4, 'DDD')
-  on conflict (a) do
-  update set b = my_table.b || ':' || excluded.b;
-NOTICE:  trigger = my_table_update_trig, old table = (1,AAA), (2,BBB), new table = (1,AAA:AAA), (2,BBB:BBB)
-NOTICE:  trigger = my_table_insert_trig, new table = (3,CCC), (4,DDD)
--- updates only
-insert into my_table values (3, 'CCC'), (4, 'DDD')
-  on conflict (a) do
-  update set b = my_table.b || ':' || excluded.b;
-NOTICE:  trigger = my_table_update_trig, old table = (3,CCC), (4,DDD), new table = (3,CCC:CCC), (4,DDD:DDD)
-NOTICE:  trigger = my_table_insert_trig, new table = <NULL>
---
--- now using a partitioned table
---
-create table iocdu_tt_parted (a int primary key, b text) partition by list (a);
-create table iocdu_tt_parted1 partition of iocdu_tt_parted for values in (1);
-create table iocdu_tt_parted2 partition of iocdu_tt_parted for values in (2);
-create table iocdu_tt_parted3 partition of iocdu_tt_parted for values in (3);
-create table iocdu_tt_parted4 partition of iocdu_tt_parted for values in (4);
-create trigger iocdu_tt_parted_insert_trig
-  after insert on iocdu_tt_parted referencing new table as new_table
-  for each statement execute procedure dump_insert();
-create trigger iocdu_tt_parted_update_trig
-  after update on iocdu_tt_parted referencing old table as old_table new table as new_table
-  for each statement execute procedure dump_update();
--- inserts only
-insert into iocdu_tt_parted values (1, 'AAA'), (2, 'BBB')
-  on conflict (a) do
-  update set b = iocdu_tt_parted.b || ':' || excluded.b;
-NOTICE:  trigger = iocdu_tt_parted_update_trig, old table = <NULL>, new table = <NULL>
-NOTICE:  trigger = iocdu_tt_parted_insert_trig, new table = (1,AAA), (2,BBB)
--- mixture of inserts and updates
-insert into iocdu_tt_parted values (1, 'AAA'), (2, 'BBB'), (3, 'CCC'), (4, 'DDD')
-  on conflict (a) do
-  update set b = iocdu_tt_parted.b || ':' || excluded.b;
-NOTICE:  trigger = iocdu_tt_parted_update_trig, old table = (1,AAA), (2,BBB), new table = (1,AAA:AAA), (2,BBB:BBB)
-NOTICE:  trigger = iocdu_tt_parted_insert_trig, new table = (3,CCC), (4,DDD)
--- updates only
-insert into iocdu_tt_parted values (3, 'CCC'), (4, 'DDD')
-  on conflict (a) do
-  update set b = iocdu_tt_parted.b || ':' || excluded.b;
-NOTICE:  trigger = iocdu_tt_parted_update_trig, old table = (3,CCC), (4,DDD), new table = (3,CCC:CCC), (4,DDD:DDD)
-NOTICE:  trigger = iocdu_tt_parted_insert_trig, new table = <NULL>
-drop table iocdu_tt_parted;
---
--- Verify that you can't create a trigger with transition tables for
--- more than one event.
---
-create trigger my_table_multievent_trig
-  after insert or update on my_table referencing new table as new_table
-  for each statement execute procedure dump_insert();
-ERROR:  transition tables cannot be specified for triggers with more than one event
---
--- Verify that you can't create a trigger with transition tables with
--- a column list.
---
-create trigger my_table_col_update_trig
-  after update of b on my_table referencing new table as new_table
-  for each statement execute procedure dump_insert();
-ERROR:  transition tables cannot be specified for triggers with column lists
-drop table my_table;
---
--- Test firing of triggers with transition tables by foreign key cascades
---
-create table refd_table (a int primary key, b text);
-create table trig_table (a int, b text,
-  foreign key (a) references refd_table on update cascade on delete cascade
-);
-create trigger trig_table_before_trig
-  before insert or update or delete on trig_table
-  for each statement execute procedure trigger_func('trig_table');
-create trigger trig_table_insert_trig
-  after insert on trig_table referencing new table as new_table
-  for each statement execute procedure dump_insert();
-create trigger trig_table_update_trig
-  after update on trig_table referencing old table as old_table new table as new_table
-  for each statement execute procedure dump_update();
-create trigger trig_table_delete_trig
-  after delete on trig_table referencing old table as old_table
-  for each statement execute procedure dump_delete();
-insert into refd_table values
-  (1, 'one'),
-  (2, 'two'),
-  (3, 'three');
-insert into trig_table values
-  (1, 'one a'),
-  (1, 'one b'),
-  (2, 'two a'),
-  (2, 'two b'),
-  (3, 'three a'),
-  (3, 'three b');
-NOTICE:  trigger_func(trig_table) called: action = INSERT, when = BEFORE, level = STATEMENT
-NOTICE:  trigger = trig_table_insert_trig, new table = (1,"one a"), (1,"one b"), (2,"two a"), (2,"two b"), (3,"three a"), (3,"three b")
-update refd_table set a = 11 where b = 'one';
-NOTICE:  trigger_func(trig_table) called: action = UPDATE, when = BEFORE, level = STATEMENT
-NOTICE:  trigger = trig_table_update_trig, old table = (1,"one a"), (1,"one b"), new table = (11,"one a"), (11,"one b")
-select * from trig_table;
- a  |    b    
-----+---------
-  2 | two a
-  2 | two b
-  3 | three a
-  3 | three b
- 11 | one a
- 11 | one b
-(6 rows)
-
-delete from refd_table where length(b) = 3;
-NOTICE:  trigger_func(trig_table) called: action = DELETE, when = BEFORE, level = STATEMENT
-NOTICE:  trigger = trig_table_delete_trig, old table = (2,"two a"), (2,"two b"), (11,"one a"), (11,"one b")
-select * from trig_table;
- a |    b    
----+---------
- 3 | three a
- 3 | three b
-(2 rows)
-
-drop table refd_table, trig_table;
---
--- self-referential FKs are even more fun
---
-create table self_ref (a int primary key,
-                       b int references self_ref(a) on delete cascade);
-create trigger self_ref_before_trig
-  before delete on self_ref
-  for each statement execute procedure trigger_func('self_ref');
-create trigger self_ref_r_trig
-  after delete on self_ref referencing old table as old_table
-  for each row execute procedure dump_delete();
-create trigger self_ref_s_trig
-  after delete on self_ref referencing old table as old_table
-  for each statement execute procedure dump_delete();
-insert into self_ref values (1, null), (2, 1), (3, 2);
-delete from self_ref where a = 1;
-NOTICE:  trigger_func(self_ref) called: action = DELETE, when = BEFORE, level = STATEMENT
-NOTICE:  trigger = self_ref_r_trig, old table = (1,), (2,1)
-NOTICE:  trigger_func(self_ref) called: action = DELETE, when = BEFORE, level = STATEMENT
-NOTICE:  trigger = self_ref_r_trig, old table = (1,), (2,1)
-NOTICE:  trigger = self_ref_s_trig, old table = (1,), (2,1)
-NOTICE:  trigger = self_ref_r_trig, old table = (3,2)
-NOTICE:  trigger = self_ref_s_trig, old table = (3,2)
--- without AR trigger, cascaded deletes all end up in one transition table
-drop trigger self_ref_r_trig on self_ref;
-insert into self_ref values (1, null), (2, 1), (3, 2), (4, 3);
-delete from self_ref where a = 1;
-NOTICE:  trigger_func(self_ref) called: action = DELETE, when = BEFORE, level = STATEMENT
-NOTICE:  trigger = self_ref_s_trig, old table = (1,), (2,1), (3,2), (4,3)
-drop table self_ref;
--- cleanup
-drop function dump_insert();
-drop function dump_update();
-drop function dump_delete();
---
--- Tests for CREATE OR REPLACE TRIGGER
---
-create table my_table (id integer);
-create function funcA() returns trigger as $$
-begin
-  raise notice 'hello from funcA';
-  return null;
-end; $$ language plpgsql;
-create function funcB() returns trigger as $$
-begin
-  raise notice 'hello from funcB';
-  return null;
-end; $$ language plpgsql;
-create trigger my_trig
-  after insert on my_table
-  for each row execute procedure funcA();
-create trigger my_trig
-  before insert on my_table
-  for each row execute procedure funcB();  -- should fail
-ERROR:  trigger "my_trig" for relation "my_table" already exists
-insert into my_table values (1);
-NOTICE:  hello from funcA
-create or replace trigger my_trig
-  before insert on my_table
-  for each row execute procedure funcB();  -- OK
-insert into my_table values (2);  -- this insert should become a no-op
-NOTICE:  hello from funcB
-table my_table;
- id 
-----
-  1
-(1 row)
-
-drop table my_table;
--- test CREATE OR REPLACE TRIGGER on partition table
-create table parted_trig (a int) partition by range (a);
-create table parted_trig_1 partition of parted_trig
-       for values from (0) to (1000) partition by range (a);
-create table parted_trig_1_1 partition of parted_trig_1 for values from (0) to (100);
-create table parted_trig_2 partition of parted_trig for values from (1000) to (2000);
-create table default_parted_trig partition of parted_trig default;
--- test that trigger can be replaced by another one
--- at the same level of partition table
-create or replace trigger my_trig
-  after insert on parted_trig
-  for each row execute procedure funcA();
-insert into parted_trig (a) values (50);
-NOTICE:  hello from funcA
-create or replace trigger my_trig
-  after insert on parted_trig
-  for each row execute procedure funcB();
-insert into parted_trig (a) values (50);
-NOTICE:  hello from funcB
--- test that child trigger cannot be replaced directly
-create or replace trigger my_trig
-  after insert on parted_trig
-  for each row execute procedure funcA();
-insert into parted_trig (a) values (50);
-NOTICE:  hello from funcA
-create or replace trigger my_trig
-  after insert on parted_trig_1
-  for each row execute procedure funcB();  -- should fail
-ERROR:  trigger "my_trig" for relation "parted_trig_1" is an internal trigger
-insert into parted_trig (a) values (50);
-NOTICE:  hello from funcA
-drop trigger my_trig on parted_trig;
-insert into parted_trig (a) values (50);
--- test that user trigger can be overwritten by one defined at upper level
-create trigger my_trig
-  after insert on parted_trig_1
-  for each row execute procedure funcA();
-insert into parted_trig (a) values (50);
-NOTICE:  hello from funcA
-create trigger my_trig
-  after insert on parted_trig
-  for each row execute procedure funcB();  -- should fail
-ERROR:  trigger "my_trig" for relation "parted_trig_1" already exists
-insert into parted_trig (a) values (50);
-NOTICE:  hello from funcA
-create or replace trigger my_trig
-  after insert on parted_trig
-  for each row execute procedure funcB();
-insert into parted_trig (a) values (50);
-NOTICE:  hello from funcB
--- cleanup
-drop table parted_trig;
-drop function funcA();
-drop function funcB();
--- Leave around some objects for other tests
-create table trigger_parted (a int primary key) partition by list (a);
-create function trigger_parted_trigfunc() returns trigger language plpgsql as
-  $$ begin end; $$;
-create trigger aft_row after insert or update on trigger_parted
-  for each row execute function trigger_parted_trigfunc();
-create table trigger_parted_p1 partition of trigger_parted for values in (1)
-  partition by list (a);
-create table trigger_parted_p1_1 partition of trigger_parted_p1 for values in (1);
-create table trigger_parted_p2 partition of trigger_parted for values in (2)
-  partition by list (a);
-create table trigger_parted_p2_2 partition of trigger_parted_p2 for values in (2);
-alter table only trigger_parted_p2 disable trigger aft_row;
-alter table trigger_parted_p2_2 enable always trigger aft_row;
--- verify transition table conversion slot's lifetime
--- https://postgr.es/m/39a71864-b120-5a5c-8cc5-c632b6f16761@amazon.com
-create table convslot_test_parent (col1 text primary key);
-create table convslot_test_child (col1 text primary key,
-	foreign key (col1) references convslot_test_parent(col1) on delete cascade on update cascade
-);
-alter table convslot_test_child add column col2 text not null default 'tutu';
-insert into convslot_test_parent(col1) values ('1');
-insert into convslot_test_child(col1) values ('1');
-insert into convslot_test_parent(col1) values ('3');
-insert into convslot_test_child(col1) values ('3');
-create or replace function trigger_function1()
-returns trigger
-language plpgsql
-AS $$
-begin
-raise notice 'trigger = %, old_table = %',
-          TG_NAME,
-          (select string_agg(old_table::text, ', ' order by col1) from old_table);
-return null;
-end; $$;
-create or replace function trigger_function2()
-returns trigger
-language plpgsql
-AS $$
-begin
-raise notice 'trigger = %, new table = %',
-          TG_NAME,
-          (select string_agg(new_table::text, ', ' order by col1) from new_table);
-return null;
-end; $$;
-create trigger but_trigger after update on convslot_test_child
-referencing new table as new_table
-for each statement execute function trigger_function2();
-update convslot_test_parent set col1 = col1 || '1';
-NOTICE:  trigger = but_trigger, new table = (11,tutu), (31,tutu)
-create or replace function trigger_function3()
-returns trigger
-language plpgsql
-AS $$
-begin
-raise notice 'trigger = %, old_table = %, new table = %',
-          TG_NAME,
-          (select string_agg(old_table::text, ', ' order by col1) from old_table),
-          (select string_agg(new_table::text, ', ' order by col1) from new_table);
-return null;
-end; $$;
-create trigger but_trigger2 after update on convslot_test_child
-referencing old table as old_table new table as new_table
-for each statement execute function trigger_function3();
-update convslot_test_parent set col1 = col1 || '1';
-NOTICE:  trigger = but_trigger, new table = (111,tutu), (311,tutu)
-NOTICE:  trigger = but_trigger2, old_table = (11,tutu), (31,tutu), new table = (111,tutu), (311,tutu)
-create trigger bdt_trigger after delete on convslot_test_child
-referencing old table as old_table
-for each statement execute function trigger_function1();
-delete from convslot_test_parent;
-NOTICE:  trigger = bdt_trigger, old_table = (111,tutu), (311,tutu)
-drop table convslot_test_child, convslot_test_parent;
--- Test trigger renaming on partitioned tables
-create table grandparent (id int, primary key (id)) partition by range (id);
-create table middle partition of grandparent for values from (1) to (10)
-partition by range (id);
-create table chi partition of middle for values from (1) to (5);
-create table cho partition of middle for values from (6) to (10);
-create function f () returns trigger as
-$$ begin return new; end; $$
-language plpgsql;
-create trigger a after insert on grandparent
-for each row execute procedure f();
-alter trigger a on grandparent rename to b;
-select tgrelid::regclass, tgname,
-(select tgname from pg_trigger tr where tr.oid = pg_trigger.tgparentid) parent_tgname
-from pg_trigger where tgrelid in (select relid from pg_partition_tree('grandparent'))
-order by tgname, tgrelid::regclass::text COLLATE "C";
-   tgrelid   | tgname | parent_tgname 
--------------+--------+---------------
- chi         | b      | b
- cho         | b      | b
- grandparent | b      | 
- middle      | b      | b
-(4 rows)
-
-alter trigger a on only grandparent rename to b;	-- ONLY not supported
-ERROR:  syntax error at or near "only"
-LINE 1: alter trigger a on only grandparent rename to b;
-                           ^
-alter trigger b on middle rename to c;	-- can't rename trigger on partition
-ERROR:  cannot rename trigger "b" on table "middle"
-HINT:  Rename trigger on partitioned table "grandparent" instead.
-create trigger c after insert on middle
-for each row execute procedure f();
-alter trigger b on grandparent rename to c;
-ERROR:  trigger "c" for relation "middle" already exists
--- Rename cascading does not affect statement triggers
-create trigger p after insert on grandparent for each statement execute function f();
-create trigger p after insert on middle for each statement execute function f();
-alter trigger p on grandparent rename to q;
-select tgrelid::regclass, tgname,
-(select tgname from pg_trigger tr where tr.oid = pg_trigger.tgparentid) parent_tgname
-from pg_trigger where tgrelid in (select relid from pg_partition_tree('grandparent'))
-order by tgname, tgrelid::regclass::text COLLATE "C";
-   tgrelid   | tgname | parent_tgname 
--------------+--------+---------------
- chi         | b      | b
- cho         | b      | b
- grandparent | b      | 
- middle      | b      | b
- chi         | c      | c
- cho         | c      | c
- middle      | c      | 
- middle      | p      | 
- grandparent | q      | 
-(9 rows)
-
-drop table grandparent;
--- Trigger renaming does not recurse on legacy inheritance
-create table parent (a int);
-create table child () inherits (parent);
-create trigger parenttrig after insert on parent
-for each row execute procedure f();
-create trigger parenttrig after insert on child
-for each row execute procedure f();
-alter trigger parenttrig on parent rename to anothertrig;
-\d+ child
-                                   Table "public.child"
- Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
---------+---------+-----------+----------+---------+---------+--------------+-------------
- a      | integer |           |          |         | plain   |              | 
-Triggers:
-    parenttrig AFTER INSERT ON child FOR EACH ROW EXECUTE FUNCTION f()
-Inherits: parent
-
-drop table parent, child;
-drop function f();
diff -U3 /Users/kenaniah/workspace/postgres/src/test/regress/expected/inherit.out /Users/kenaniah/workspace/postgres/src/test/regress/results/inherit.out
--- /Users/kenaniah/workspace/postgres/src/test/regress/expected/inherit.out	2021-10-03 18:09:17.000000000 -0700
+++ /Users/kenaniah/workspace/postgres/src/test/regress/results/inherit.out	2021-10-03 20:08:14.000000000 -0700
@@ -746,1895 +746,11 @@
 -- Test that child does not inherit NO INHERIT constraints
 create table c1 () inherits (p1);
 \d p1
-                 Table "public.p1"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- ff1    | integer |           |          | 
-Check constraints:
-    "p1chk" CHECK (ff1 > 0) NO INHERIT
-    "p2chk" CHECK (ff1 > 10)
-Number of child tables: 1 (Use \d+ to list them.)
+dyld: lazy symbol binding failed: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
+
+dyld: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
 
-\d c1
-                 Table "public.c1"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- ff1    | integer |           |          | 
-Check constraints:
-    "p2chk" CHECK (ff1 > 10)
-Inherits: p1
-
--- Test that child does not override inheritable constraints of the parent
-create table c2 (constraint p2chk check (ff1 > 10) no inherit) inherits (p1);	--fails
-ERROR:  constraint "p2chk" conflicts with inherited constraint on relation "c2"
-drop table p1 cascade;
-NOTICE:  drop cascades to table c1
--- Tests for casting between the rowtypes of parent and child
--- tables. See the pgsql-hackers thread beginning Dec. 4/04
-create table base (i integer);
-create table derived () inherits (base);
-create table more_derived (like derived, b int) inherits (derived);
-NOTICE:  merging column "i" with inherited definition
-insert into derived (i) values (0);
-select derived::base from derived;
- derived 
----------
- (0)
-(1 row)
-
-select NULL::derived::base;
- base 
-------
- 
-(1 row)
-
--- remove redundant conversions.
-explain (verbose on, costs off) select row(i, b)::more_derived::derived::base from more_derived;
-                QUERY PLAN                 
--------------------------------------------
- Seq Scan on public.more_derived
-   Output: (ROW(i, b)::more_derived)::base
-(2 rows)
-
-explain (verbose on, costs off) select (1, 2)::more_derived::derived::base;
-      QUERY PLAN       
------------------------
- Result
-   Output: '(1)'::base
-(2 rows)
-
-drop table more_derived;
-drop table derived;
-drop table base;
-create table p1(ff1 int);
-create table p2(f1 text);
-create function p2text(p2) returns text as 'select $1.f1' language sql;
-create table c1(f3 int) inherits(p1,p2);
-insert into c1 values(123456789, 'hi', 42);
-select p2text(c1.*) from c1;
- p2text 
---------
- hi
-(1 row)
-
-drop function p2text(p2);
-drop table c1;
-drop table p2;
-drop table p1;
-CREATE TABLE ac (aa TEXT);
-alter table ac add constraint ac_check check (aa is not null);
-CREATE TABLE bc (bb TEXT) INHERITS (ac);
-select pc.relname, pgc.conname, pgc.contype, pgc.conislocal, pgc.coninhcount, pg_get_expr(pgc.conbin, pc.oid) as consrc from pg_class as pc inner join pg_constraint as pgc on (pgc.conrelid = pc.oid) where pc.relname in ('ac', 'bc') order by 1,2;
- relname | conname  | contype | conislocal | coninhcount |      consrc      
----------+----------+---------+------------+-------------+------------------
- ac      | ac_check | c       | t          |           0 | (aa IS NOT NULL)
- bc      | ac_check | c       | f          |           1 | (aa IS NOT NULL)
-(2 rows)
-
-insert into ac (aa) values (NULL);
-ERROR:  new row for relation "ac" violates check constraint "ac_check"
-DETAIL:  Failing row contains (null).
-insert into bc (aa) values (NULL);
-ERROR:  new row for relation "bc" violates check constraint "ac_check"
-DETAIL:  Failing row contains (null, null).
-alter table bc drop constraint ac_check;  -- fail, disallowed
-ERROR:  cannot drop inherited constraint "ac_check" of relation "bc"
-alter table ac drop constraint ac_check;
-select pc.relname, pgc.conname, pgc.contype, pgc.conislocal, pgc.coninhcount, pg_get_expr(pgc.conbin, pc.oid) as consrc from pg_class as pc inner join pg_constraint as pgc on (pgc.conrelid = pc.oid) where pc.relname in ('ac', 'bc') order by 1,2;
- relname | conname | contype | conislocal | coninhcount | consrc 
----------+---------+---------+------------+-------------+--------
-(0 rows)
-
--- try the unnamed-constraint case
-alter table ac add check (aa is not null);
-select pc.relname, pgc.conname, pgc.contype, pgc.conislocal, pgc.coninhcount, pg_get_expr(pgc.conbin, pc.oid) as consrc from pg_class as pc inner join pg_constraint as pgc on (pgc.conrelid = pc.oid) where pc.relname in ('ac', 'bc') order by 1,2;
- relname |   conname   | contype | conislocal | coninhcount |      consrc      
----------+-------------+---------+------------+-------------+------------------
- ac      | ac_aa_check | c       | t          |           0 | (aa IS NOT NULL)
- bc      | ac_aa_check | c       | f          |           1 | (aa IS NOT NULL)
-(2 rows)
-
-insert into ac (aa) values (NULL);
-ERROR:  new row for relation "ac" violates check constraint "ac_aa_check"
-DETAIL:  Failing row contains (null).
-insert into bc (aa) values (NULL);
-ERROR:  new row for relation "bc" violates check constraint "ac_aa_check"
-DETAIL:  Failing row contains (null, null).
-alter table bc drop constraint ac_aa_check;  -- fail, disallowed
-ERROR:  cannot drop inherited constraint "ac_aa_check" of relation "bc"
-alter table ac drop constraint ac_aa_check;
-select pc.relname, pgc.conname, pgc.contype, pgc.conislocal, pgc.coninhcount, pg_get_expr(pgc.conbin, pc.oid) as consrc from pg_class as pc inner join pg_constraint as pgc on (pgc.conrelid = pc.oid) where pc.relname in ('ac', 'bc') order by 1,2;
- relname | conname | contype | conislocal | coninhcount | consrc 
----------+---------+---------+------------+-------------+--------
-(0 rows)
-
-alter table ac add constraint ac_check check (aa is not null);
-alter table bc no inherit ac;
-select pc.relname, pgc.conname, pgc.contype, pgc.conislocal, pgc.coninhcount, pg_get_expr(pgc.conbin, pc.oid) as consrc from pg_class as pc inner join pg_constraint as pgc on (pgc.conrelid = pc.oid) where pc.relname in ('ac', 'bc') order by 1,2;
- relname | conname  | contype | conislocal | coninhcount |      consrc      
----------+----------+---------+------------+-------------+------------------
- ac      | ac_check | c       | t          |           0 | (aa IS NOT NULL)
- bc      | ac_check | c       | t          |           0 | (aa IS NOT NULL)
-(2 rows)
-
-alter table bc drop constraint ac_check;
-select pc.relname, pgc.conname, pgc.contype, pgc.conislocal, pgc.coninhcount, pg_get_expr(pgc.conbin, pc.oid) as consrc from pg_class as pc inner join pg_constraint as pgc on (pgc.conrelid = pc.oid) where pc.relname in ('ac', 'bc') order by 1,2;
- relname | conname  | contype | conislocal | coninhcount |      consrc      
----------+----------+---------+------------+-------------+------------------
- ac      | ac_check | c       | t          |           0 | (aa IS NOT NULL)
-(1 row)
-
-alter table ac drop constraint ac_check;
-select pc.relname, pgc.conname, pgc.contype, pgc.conislocal, pgc.coninhcount, pg_get_expr(pgc.conbin, pc.oid) as consrc from pg_class as pc inner join pg_constraint as pgc on (pgc.conrelid = pc.oid) where pc.relname in ('ac', 'bc') order by 1,2;
- relname | conname | contype | conislocal | coninhcount | consrc 
----------+---------+---------+------------+-------------+--------
-(0 rows)
-
-drop table bc;
-drop table ac;
-create table ac (a int constraint check_a check (a <> 0));
-create table bc (a int constraint check_a check (a <> 0), b int constraint check_b check (b <> 0)) inherits (ac);
-NOTICE:  merging column "a" with inherited definition
-NOTICE:  merging constraint "check_a" with inherited definition
-select pc.relname, pgc.conname, pgc.contype, pgc.conislocal, pgc.coninhcount, pg_get_expr(pgc.conbin, pc.oid) as consrc from pg_class as pc inner join pg_constraint as pgc on (pgc.conrelid = pc.oid) where pc.relname in ('ac', 'bc') order by 1,2;
- relname | conname | contype | conislocal | coninhcount |  consrc  
----------+---------+---------+------------+-------------+----------
- ac      | check_a | c       | t          |           0 | (a <> 0)
- bc      | check_a | c       | t          |           1 | (a <> 0)
- bc      | check_b | c       | t          |           0 | (b <> 0)
-(3 rows)
-
-drop table bc;
-drop table ac;
-create table ac (a int constraint check_a check (a <> 0));
-create table bc (b int constraint check_b check (b <> 0));
-create table cc (c int constraint check_c check (c <> 0)) inherits (ac, bc);
-select pc.relname, pgc.conname, pgc.contype, pgc.conislocal, pgc.coninhcount, pg_get_expr(pgc.conbin, pc.oid) as consrc from pg_class as pc inner join pg_constraint as pgc on (pgc.conrelid = pc.oid) where pc.relname in ('ac', 'bc', 'cc') order by 1,2;
- relname | conname | contype | conislocal | coninhcount |  consrc  
----------+---------+---------+------------+-------------+----------
- ac      | check_a | c       | t          |           0 | (a <> 0)
- bc      | check_b | c       | t          |           0 | (b <> 0)
- cc      | check_a | c       | f          |           1 | (a <> 0)
- cc      | check_b | c       | f          |           1 | (b <> 0)
- cc      | check_c | c       | t          |           0 | (c <> 0)
-(5 rows)
-
-alter table cc no inherit bc;
-select pc.relname, pgc.conname, pgc.contype, pgc.conislocal, pgc.coninhcount, pg_get_expr(pgc.conbin, pc.oid) as consrc from pg_class as pc inner join pg_constraint as pgc on (pgc.conrelid = pc.oid) where pc.relname in ('ac', 'bc', 'cc') order by 1,2;
- relname | conname | contype | conislocal | coninhcount |  consrc  
----------+---------+---------+------------+-------------+----------
- ac      | check_a | c       | t          |           0 | (a <> 0)
- bc      | check_b | c       | t          |           0 | (b <> 0)
- cc      | check_a | c       | f          |           1 | (a <> 0)
- cc      | check_b | c       | t          |           0 | (b <> 0)
- cc      | check_c | c       | t          |           0 | (c <> 0)
-(5 rows)
-
-drop table cc;
-drop table bc;
-drop table ac;
-create table p1(f1 int);
-create table p2(f2 int);
-create table c1(f3 int) inherits(p1,p2);
-insert into c1 values(1,-1,2);
-alter table p2 add constraint cc check (f2>0);  -- fail
-ERROR:  check constraint "cc" of relation "c1" is violated by some row
-alter table p2 add check (f2>0);  -- check it without a name, too
-ERROR:  check constraint "p2_f2_check" of relation "c1" is violated by some row
-delete from c1;
-insert into c1 values(1,1,2);
-alter table p2 add check (f2>0);
-insert into c1 values(1,-1,2);  -- fail
-ERROR:  new row for relation "c1" violates check constraint "p2_f2_check"
-DETAIL:  Failing row contains (1, -1, 2).
-create table c2(f3 int) inherits(p1,p2);
-\d c2
-                 Table "public.c2"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- f1     | integer |           |          | 
- f2     | integer |           |          | 
- f3     | integer |           |          | 
-Check constraints:
-    "p2_f2_check" CHECK (f2 > 0)
-Inherits: p1,
-          p2
-
-create table c3 (f4 int) inherits(c1,c2);
-NOTICE:  merging multiple inherited definitions of column "f1"
-NOTICE:  merging multiple inherited definitions of column "f2"
-NOTICE:  merging multiple inherited definitions of column "f3"
-\d c3
-                 Table "public.c3"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- f1     | integer |           |          | 
- f2     | integer |           |          | 
- f3     | integer |           |          | 
- f4     | integer |           |          | 
-Check constraints:
-    "p2_f2_check" CHECK (f2 > 0)
-Inherits: c1,
-          c2
-
-drop table p1 cascade;
-NOTICE:  drop cascades to 3 other objects
-DETAIL:  drop cascades to table c1
-drop cascades to table c2
-drop cascades to table c3
-drop table p2 cascade;
-create table pp1 (f1 int);
-create table cc1 (f2 text, f3 int) inherits (pp1);
-alter table pp1 add column a1 int check (a1 > 0);
-\d cc1
-                Table "public.cc1"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- f1     | integer |           |          | 
- f2     | text    |           |          | 
- f3     | integer |           |          | 
- a1     | integer |           |          | 
-Check constraints:
-    "pp1_a1_check" CHECK (a1 > 0)
-Inherits: pp1
-
-create table cc2(f4 float) inherits(pp1,cc1);
-NOTICE:  merging multiple inherited definitions of column "f1"
-NOTICE:  merging multiple inherited definitions of column "a1"
-\d cc2
-                     Table "public.cc2"
- Column |       Type       | Collation | Nullable | Default 
---------+------------------+-----------+----------+---------
- f1     | integer          |           |          | 
- a1     | integer          |           |          | 
- f2     | text             |           |          | 
- f3     | integer          |           |          | 
- f4     | double precision |           |          | 
-Check constraints:
-    "pp1_a1_check" CHECK (a1 > 0)
-Inherits: pp1,
-          cc1
-
-alter table pp1 add column a2 int check (a2 > 0);
-NOTICE:  merging definition of column "a2" for child "cc2"
-NOTICE:  merging constraint "pp1_a2_check" with inherited definition
-\d cc2
-                     Table "public.cc2"
- Column |       Type       | Collation | Nullable | Default 
---------+------------------+-----------+----------+---------
- f1     | integer          |           |          | 
- a1     | integer          |           |          | 
- f2     | text             |           |          | 
- f3     | integer          |           |          | 
- f4     | double precision |           |          | 
- a2     | integer          |           |          | 
-Check constraints:
-    "pp1_a1_check" CHECK (a1 > 0)
-    "pp1_a2_check" CHECK (a2 > 0)
-Inherits: pp1,
-          cc1
-
-drop table pp1 cascade;
-NOTICE:  drop cascades to 2 other objects
-DETAIL:  drop cascades to table cc1
-drop cascades to table cc2
--- Test for renaming in simple multiple inheritance
-CREATE TABLE inht1 (a int, b int);
-CREATE TABLE inhs1 (b int, c int);
-CREATE TABLE inhts (d int) INHERITS (inht1, inhs1);
-NOTICE:  merging multiple inherited definitions of column "b"
-ALTER TABLE inht1 RENAME a TO aa;
-ALTER TABLE inht1 RENAME b TO bb;                -- to be failed
-ERROR:  cannot rename inherited column "b"
-ALTER TABLE inhts RENAME aa TO aaa;      -- to be failed
-ERROR:  cannot rename inherited column "aa"
-ALTER TABLE inhts RENAME d TO dd;
-\d+ inhts
-                                   Table "public.inhts"
- Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
---------+---------+-----------+----------+---------+---------+--------------+-------------
- aa     | integer |           |          |         | plain   |              | 
- b      | integer |           |          |         | plain   |              | 
- c      | integer |           |          |         | plain   |              | 
- dd     | integer |           |          |         | plain   |              | 
-Inherits: inht1,
-          inhs1
-
-DROP TABLE inhts;
--- Test for renaming in diamond inheritance
-CREATE TABLE inht2 (x int) INHERITS (inht1);
-CREATE TABLE inht3 (y int) INHERITS (inht1);
-CREATE TABLE inht4 (z int) INHERITS (inht2, inht3);
-NOTICE:  merging multiple inherited definitions of column "aa"
-NOTICE:  merging multiple inherited definitions of column "b"
-ALTER TABLE inht1 RENAME aa TO aaa;
-\d+ inht4
-                                   Table "public.inht4"
- Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
---------+---------+-----------+----------+---------+---------+--------------+-------------
- aaa    | integer |           |          |         | plain   |              | 
- b      | integer |           |          |         | plain   |              | 
- x      | integer |           |          |         | plain   |              | 
- y      | integer |           |          |         | plain   |              | 
- z      | integer |           |          |         | plain   |              | 
-Inherits: inht2,
-          inht3
-
-CREATE TABLE inhts (d int) INHERITS (inht2, inhs1);
-NOTICE:  merging multiple inherited definitions of column "b"
-ALTER TABLE inht1 RENAME aaa TO aaaa;
-ALTER TABLE inht1 RENAME b TO bb;                -- to be failed
-ERROR:  cannot rename inherited column "b"
-\d+ inhts
-                                   Table "public.inhts"
- Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
---------+---------+-----------+----------+---------+---------+--------------+-------------
- aaaa   | integer |           |          |         | plain   |              | 
- b      | integer |           |          |         | plain   |              | 
- x      | integer |           |          |         | plain   |              | 
- c      | integer |           |          |         | plain   |              | 
- d      | integer |           |          |         | plain   |              | 
-Inherits: inht2,
-          inhs1
-
-WITH RECURSIVE r AS (
-  SELECT 'inht1'::regclass AS inhrelid
-UNION ALL
-  SELECT c.inhrelid FROM pg_inherits c, r WHERE r.inhrelid = c.inhparent
-)
-SELECT a.attrelid::regclass, a.attname, a.attinhcount, e.expected
-  FROM (SELECT inhrelid, count(*) AS expected FROM pg_inherits
-        WHERE inhparent IN (SELECT inhrelid FROM r) GROUP BY inhrelid) e
-  JOIN pg_attribute a ON e.inhrelid = a.attrelid WHERE NOT attislocal
-  ORDER BY a.attrelid::regclass::name, a.attnum;
- attrelid | attname | attinhcount | expected 
-----------+---------+-------------+----------
- inht2    | aaaa    |           1 |        1
- inht2    | b       |           1 |        1
- inht3    | aaaa    |           1 |        1
- inht3    | b       |           1 |        1
- inht4    | aaaa    |           2 |        2
- inht4    | b       |           2 |        2
- inht4    | x       |           1 |        2
- inht4    | y       |           1 |        2
- inhts    | aaaa    |           1 |        1
- inhts    | b       |           2 |        1
- inhts    | x       |           1 |        1
- inhts    | c       |           1 |        1
-(12 rows)
-
-DROP TABLE inht1, inhs1 CASCADE;
-NOTICE:  drop cascades to 4 other objects
-DETAIL:  drop cascades to table inht2
-drop cascades to table inhts
-drop cascades to table inht3
-drop cascades to table inht4
--- Test non-inheritable indices [UNIQUE, EXCLUDE] constraints
-CREATE TABLE test_constraints (id int, val1 varchar, val2 int, UNIQUE(val1, val2));
-CREATE TABLE test_constraints_inh () INHERITS (test_constraints);
-\d+ test_constraints
-                                   Table "public.test_constraints"
- Column |       Type        | Collation | Nullable | Default | Storage  | Stats target | Description 
---------+-------------------+-----------+----------+---------+----------+--------------+-------------
- id     | integer           |           |          |         | plain    |              | 
- val1   | character varying |           |          |         | extended |              | 
- val2   | integer           |           |          |         | plain    |              | 
-Indexes:
-    "test_constraints_val1_val2_key" UNIQUE CONSTRAINT, btree (val1, val2)
-Child tables: test_constraints_inh
-
-ALTER TABLE ONLY test_constraints DROP CONSTRAINT test_constraints_val1_val2_key;
-\d+ test_constraints
-                                   Table "public.test_constraints"
- Column |       Type        | Collation | Nullable | Default | Storage  | Stats target | Description 
---------+-------------------+-----------+----------+---------+----------+--------------+-------------
- id     | integer           |           |          |         | plain    |              | 
- val1   | character varying |           |          |         | extended |              | 
- val2   | integer           |           |          |         | plain    |              | 
-Child tables: test_constraints_inh
-
-\d+ test_constraints_inh
-                                 Table "public.test_constraints_inh"
- Column |       Type        | Collation | Nullable | Default | Storage  | Stats target | Description 
---------+-------------------+-----------+----------+---------+----------+--------------+-------------
- id     | integer           |           |          |         | plain    |              | 
- val1   | character varying |           |          |         | extended |              | 
- val2   | integer           |           |          |         | plain    |              | 
-Inherits: test_constraints
-
-DROP TABLE test_constraints_inh;
-DROP TABLE test_constraints;
-CREATE TABLE test_ex_constraints (
-    c circle,
-    EXCLUDE USING gist (c WITH &&)
-);
-CREATE TABLE test_ex_constraints_inh () INHERITS (test_ex_constraints);
-\d+ test_ex_constraints
-                           Table "public.test_ex_constraints"
- Column |  Type  | Collation | Nullable | Default | Storage | Stats target | Description 
---------+--------+-----------+----------+---------+---------+--------------+-------------
- c      | circle |           |          |         | plain   |              | 
-Indexes:
-    "test_ex_constraints_c_excl" EXCLUDE USING gist (c WITH &&)
-Child tables: test_ex_constraints_inh
-
-ALTER TABLE test_ex_constraints DROP CONSTRAINT test_ex_constraints_c_excl;
-\d+ test_ex_constraints
-                           Table "public.test_ex_constraints"
- Column |  Type  | Collation | Nullable | Default | Storage | Stats target | Description 
---------+--------+-----------+----------+---------+---------+--------------+-------------
- c      | circle |           |          |         | plain   |              | 
-Child tables: test_ex_constraints_inh
-
-\d+ test_ex_constraints_inh
-                         Table "public.test_ex_constraints_inh"
- Column |  Type  | Collation | Nullable | Default | Storage | Stats target | Description 
---------+--------+-----------+----------+---------+---------+--------------+-------------
- c      | circle |           |          |         | plain   |              | 
-Inherits: test_ex_constraints
-
-DROP TABLE test_ex_constraints_inh;
-DROP TABLE test_ex_constraints;
--- Test non-inheritable foreign key constraints
-CREATE TABLE test_primary_constraints(id int PRIMARY KEY);
-CREATE TABLE test_foreign_constraints(id1 int REFERENCES test_primary_constraints(id));
-CREATE TABLE test_foreign_constraints_inh () INHERITS (test_foreign_constraints);
-\d+ test_primary_constraints
-                         Table "public.test_primary_constraints"
- Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
---------+---------+-----------+----------+---------+---------+--------------+-------------
- id     | integer |           | not null |         | plain   |              | 
-Indexes:
-    "test_primary_constraints_pkey" PRIMARY KEY, btree (id)
-Referenced by:
-    TABLE "test_foreign_constraints" CONSTRAINT "test_foreign_constraints_id1_fkey" FOREIGN KEY (id1) REFERENCES test_primary_constraints(id)
-
-\d+ test_foreign_constraints
-                         Table "public.test_foreign_constraints"
- Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
---------+---------+-----------+----------+---------+---------+--------------+-------------
- id1    | integer |           |          |         | plain   |              | 
-Foreign-key constraints:
-    "test_foreign_constraints_id1_fkey" FOREIGN KEY (id1) REFERENCES test_primary_constraints(id)
-Child tables: test_foreign_constraints_inh
-
-ALTER TABLE test_foreign_constraints DROP CONSTRAINT test_foreign_constraints_id1_fkey;
-\d+ test_foreign_constraints
-                         Table "public.test_foreign_constraints"
- Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
---------+---------+-----------+----------+---------+---------+--------------+-------------
- id1    | integer |           |          |         | plain   |              | 
-Child tables: test_foreign_constraints_inh
-
-\d+ test_foreign_constraints_inh
-                       Table "public.test_foreign_constraints_inh"
- Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
---------+---------+-----------+----------+---------+---------+--------------+-------------
- id1    | integer |           |          |         | plain   |              | 
-Inherits: test_foreign_constraints
-
-DROP TABLE test_foreign_constraints_inh;
-DROP TABLE test_foreign_constraints;
-DROP TABLE test_primary_constraints;
--- Test foreign key behavior
-create table inh_fk_1 (a int primary key);
-insert into inh_fk_1 values (1), (2), (3);
-create table inh_fk_2 (x int primary key, y int references inh_fk_1 on delete cascade);
-insert into inh_fk_2 values (11, 1), (22, 2), (33, 3);
-create table inh_fk_2_child () inherits (inh_fk_2);
-insert into inh_fk_2_child values (111, 1), (222, 2);
-delete from inh_fk_1 where a = 1;
-select * from inh_fk_1 order by 1;
- a 
----
- 2
- 3
-(2 rows)
-
-select * from inh_fk_2 order by 1, 2;
-  x  | y 
------+---
-  22 | 2
-  33 | 3
- 111 | 1
- 222 | 2
-(4 rows)
-
-drop table inh_fk_1, inh_fk_2, inh_fk_2_child;
--- Test that parent and child CHECK constraints can be created in either order
-create table p1(f1 int);
-create table p1_c1() inherits(p1);
-alter table p1 add constraint inh_check_constraint1 check (f1 > 0);
-alter table p1_c1 add constraint inh_check_constraint1 check (f1 > 0);
-NOTICE:  merging constraint "inh_check_constraint1" with inherited definition
-alter table p1_c1 add constraint inh_check_constraint2 check (f1 < 10);
-alter table p1 add constraint inh_check_constraint2 check (f1 < 10);
-NOTICE:  merging constraint "inh_check_constraint2" with inherited definition
-select conrelid::regclass::text as relname, conname, conislocal, coninhcount
-from pg_constraint where conname like 'inh\_check\_constraint%'
-order by 1, 2;
- relname |        conname        | conislocal | coninhcount 
----------+-----------------------+------------+-------------
- p1      | inh_check_constraint1 | t          |           0
- p1      | inh_check_constraint2 | t          |           0
- p1_c1   | inh_check_constraint1 | t          |           1
- p1_c1   | inh_check_constraint2 | t          |           1
-(4 rows)
-
-drop table p1 cascade;
-NOTICE:  drop cascades to table p1_c1
--- Test that a valid child can have not-valid parent, but not vice versa
-create table invalid_check_con(f1 int);
-create table invalid_check_con_child() inherits(invalid_check_con);
-alter table invalid_check_con_child add constraint inh_check_constraint check(f1 > 0) not valid;
-alter table invalid_check_con add constraint inh_check_constraint check(f1 > 0); -- fail
-ERROR:  constraint "inh_check_constraint" conflicts with NOT VALID constraint on relation "invalid_check_con_child"
-alter table invalid_check_con_child drop constraint inh_check_constraint;
-insert into invalid_check_con values(0);
-alter table invalid_check_con_child add constraint inh_check_constraint check(f1 > 0);
-alter table invalid_check_con add constraint inh_check_constraint check(f1 > 0) not valid;
-NOTICE:  merging constraint "inh_check_constraint" with inherited definition
-insert into invalid_check_con values(0); -- fail
-ERROR:  new row for relation "invalid_check_con" violates check constraint "inh_check_constraint"
-DETAIL:  Failing row contains (0).
-insert into invalid_check_con_child values(0); -- fail
-ERROR:  new row for relation "invalid_check_con_child" violates check constraint "inh_check_constraint"
-DETAIL:  Failing row contains (0).
-select conrelid::regclass::text as relname, conname,
-       convalidated, conislocal, coninhcount, connoinherit
-from pg_constraint where conname like 'inh\_check\_constraint%'
-order by 1, 2;
-         relname         |       conname        | convalidated | conislocal | coninhcount | connoinherit 
--------------------------+----------------------+--------------+------------+-------------+--------------
- invalid_check_con       | inh_check_constraint | f            | t          |           0 | f
- invalid_check_con_child | inh_check_constraint | t            | t          |           1 | f
-(2 rows)
-
--- We don't drop the invalid_check_con* tables, to test dump/reload with
---
--- Test parameterized append plans for inheritance trees
---
-create temp table patest0 (id, x) as
-  select x, x from generate_series(0,1000) x;
-create temp table patest1() inherits (patest0);
-insert into patest1
-  select x, x from generate_series(0,1000) x;
-create temp table patest2() inherits (patest0);
-insert into patest2
-  select x, x from generate_series(0,1000) x;
-create index patest0i on patest0(id);
-create index patest1i on patest1(id);
-create index patest2i on patest2(id);
-analyze patest0;
-analyze patest1;
-analyze patest2;
-explain (costs off)
-select * from patest0 join (select f1 from int4_tbl limit 1) ss on id = f1;
-                         QUERY PLAN                         
-------------------------------------------------------------
- Nested Loop
-   ->  Limit
-         ->  Seq Scan on int4_tbl
-   ->  Append
-         ->  Index Scan using patest0i on patest0 patest0_1
-               Index Cond: (id = int4_tbl.f1)
-         ->  Index Scan using patest1i on patest1 patest0_2
-               Index Cond: (id = int4_tbl.f1)
-         ->  Index Scan using patest2i on patest2 patest0_3
-               Index Cond: (id = int4_tbl.f1)
-(10 rows)
-
-select * from patest0 join (select f1 from int4_tbl limit 1) ss on id = f1;
- id | x | f1 
-----+---+----
-  0 | 0 |  0
-  0 | 0 |  0
-  0 | 0 |  0
-(3 rows)
-
-drop index patest2i;
-explain (costs off)
-select * from patest0 join (select f1 from int4_tbl limit 1) ss on id = f1;
-                         QUERY PLAN                         
-------------------------------------------------------------
- Nested Loop
-   ->  Limit
-         ->  Seq Scan on int4_tbl
-   ->  Append
-         ->  Index Scan using patest0i on patest0 patest0_1
-               Index Cond: (id = int4_tbl.f1)
-         ->  Index Scan using patest1i on patest1 patest0_2
-               Index Cond: (id = int4_tbl.f1)
-         ->  Seq Scan on patest2 patest0_3
-               Filter: (int4_tbl.f1 = id)
-(10 rows)
-
-select * from patest0 join (select f1 from int4_tbl limit 1) ss on id = f1;
- id | x | f1 
-----+---+----
-  0 | 0 |  0
-  0 | 0 |  0
-  0 | 0 |  0
-(3 rows)
-
-drop table patest0 cascade;
-NOTICE:  drop cascades to 2 other objects
-DETAIL:  drop cascades to table patest1
-drop cascades to table patest2
---
--- Test merge-append plans for inheritance trees
---
-create table matest0 (id serial primary key, name text);
-create table matest1 (id integer primary key) inherits (matest0);
-NOTICE:  merging column "id" with inherited definition
-create table matest2 (id integer primary key) inherits (matest0);
-NOTICE:  merging column "id" with inherited definition
-create table matest3 (id integer primary key) inherits (matest0);
-NOTICE:  merging column "id" with inherited definition
-create index matest0i on matest0 ((1-id));
-create index matest1i on matest1 ((1-id));
--- create index matest2i on matest2 ((1-id));  -- intentionally missing
-create index matest3i on matest3 ((1-id));
-insert into matest1 (name) values ('Test 1');
-insert into matest1 (name) values ('Test 2');
-insert into matest2 (name) values ('Test 3');
-insert into matest2 (name) values ('Test 4');
-insert into matest3 (name) values ('Test 5');
-insert into matest3 (name) values ('Test 6');
-set enable_indexscan = off;  -- force use of seqscan/sort, so no merge
-explain (verbose, costs off) select * from matest0 order by 1-id;
-                         QUERY PLAN                         
-------------------------------------------------------------
- Sort
-   Output: matest0.id, matest0.name, ((1 - matest0.id))
-   Sort Key: ((1 - matest0.id))
-   ->  Result
-         Output: matest0.id, matest0.name, (1 - matest0.id)
-         ->  Append
-               ->  Seq Scan on public.matest0 matest0_1
-                     Output: matest0_1.id, matest0_1.name
-               ->  Seq Scan on public.matest1 matest0_2
-                     Output: matest0_2.id, matest0_2.name
-               ->  Seq Scan on public.matest2 matest0_3
-                     Output: matest0_3.id, matest0_3.name
-               ->  Seq Scan on public.matest3 matest0_4
-                     Output: matest0_4.id, matest0_4.name
-(14 rows)
-
-select * from matest0 order by 1-id;
- id |  name  
-----+--------
-  6 | Test 6
-  5 | Test 5
-  4 | Test 4
-  3 | Test 3
-  2 | Test 2
-  1 | Test 1
-(6 rows)
-
-explain (verbose, costs off) select min(1-id) from matest0;
-                    QUERY PLAN                    
---------------------------------------------------
- Aggregate
-   Output: min((1 - matest0.id))
-   ->  Append
-         ->  Seq Scan on public.matest0 matest0_1
-               Output: matest0_1.id
-         ->  Seq Scan on public.matest1 matest0_2
-               Output: matest0_2.id
-         ->  Seq Scan on public.matest2 matest0_3
-               Output: matest0_3.id
-         ->  Seq Scan on public.matest3 matest0_4
-               Output: matest0_4.id
-(11 rows)
-
-select min(1-id) from matest0;
- min 
------
-  -5
-(1 row)
-
-reset enable_indexscan;
-set enable_seqscan = off;  -- plan with fewest seqscans should be merge
-set enable_parallel_append = off; -- Don't let parallel-append interfere
-explain (verbose, costs off) select * from matest0 order by 1-id;
-                               QUERY PLAN                               
-------------------------------------------------------------------------
- Merge Append
-   Sort Key: ((1 - matest0.id))
-   ->  Index Scan using matest0i on public.matest0 matest0_1
-         Output: matest0_1.id, matest0_1.name, (1 - matest0_1.id)
-   ->  Index Scan using matest1i on public.matest1 matest0_2
-         Output: matest0_2.id, matest0_2.name, (1 - matest0_2.id)
-   ->  Sort
-         Output: matest0_3.id, matest0_3.name, ((1 - matest0_3.id))
-         Sort Key: ((1 - matest0_3.id))
-         ->  Seq Scan on public.matest2 matest0_3
-               Output: matest0_3.id, matest0_3.name, (1 - matest0_3.id)
-   ->  Index Scan using matest3i on public.matest3 matest0_4
-         Output: matest0_4.id, matest0_4.name, (1 - matest0_4.id)
-(13 rows)
-
-select * from matest0 order by 1-id;
- id |  name  
-----+--------
-  6 | Test 6
-  5 | Test 5
-  4 | Test 4
-  3 | Test 3
-  2 | Test 2
-  1 | Test 1
-(6 rows)
-
-explain (verbose, costs off) select min(1-id) from matest0;
-                                   QUERY PLAN                                    
----------------------------------------------------------------------------------
- Result
-   Output: $0
-   InitPlan 1 (returns $0)
-     ->  Limit
-           Output: ((1 - matest0.id))
-           ->  Result
-                 Output: ((1 - matest0.id))
-                 ->  Merge Append
-                       Sort Key: ((1 - matest0.id))
-                       ->  Index Scan using matest0i on public.matest0 matest0_1
-                             Output: matest0_1.id, (1 - matest0_1.id)
-                             Index Cond: ((1 - matest0_1.id) IS NOT NULL)
-                       ->  Index Scan using matest1i on public.matest1 matest0_2
-                             Output: matest0_2.id, (1 - matest0_2.id)
-                             Index Cond: ((1 - matest0_2.id) IS NOT NULL)
-                       ->  Sort
-                             Output: matest0_3.id, ((1 - matest0_3.id))
-                             Sort Key: ((1 - matest0_3.id))
-                             ->  Bitmap Heap Scan on public.matest2 matest0_3
-                                   Output: matest0_3.id, (1 - matest0_3.id)
-                                   Filter: ((1 - matest0_3.id) IS NOT NULL)
-                                   ->  Bitmap Index Scan on matest2_pkey
-                       ->  Index Scan using matest3i on public.matest3 matest0_4
-                             Output: matest0_4.id, (1 - matest0_4.id)
-                             Index Cond: ((1 - matest0_4.id) IS NOT NULL)
-(25 rows)
-
-select min(1-id) from matest0;
- min 
------
-  -5
-(1 row)
-
-reset enable_seqscan;
-reset enable_parallel_append;
-drop table matest0 cascade;
-NOTICE:  drop cascades to 3 other objects
-DETAIL:  drop cascades to table matest1
-drop cascades to table matest2
-drop cascades to table matest3
---
--- Check that use of an index with an extraneous column doesn't produce
--- a plan with extraneous sorting
---
-create table matest0 (a int, b int, c int, d int);
-create table matest1 () inherits(matest0);
-create index matest0i on matest0 (b, c);
-create index matest1i on matest1 (b, c);
-set enable_nestloop = off;  -- we want a plan with two MergeAppends
-explain (costs off)
-select t1.* from matest0 t1, matest0 t2
-where t1.b = t2.b and t2.c = t2.d
-order by t1.b limit 10;
-                            QUERY PLAN                             
--------------------------------------------------------------------
- Limit
-   ->  Merge Join
-         Merge Cond: (t1.b = t2.b)
-         ->  Merge Append
-               Sort Key: t1.b
-               ->  Index Scan using matest0i on matest0 t1_1
-               ->  Index Scan using matest1i on matest1 t1_2
-         ->  Materialize
-               ->  Merge Append
-                     Sort Key: t2.b
-                     ->  Index Scan using matest0i on matest0 t2_1
-                           Filter: (c = d)
-                     ->  Index Scan using matest1i on matest1 t2_2
-                           Filter: (c = d)
-(14 rows)
-
-reset enable_nestloop;
-drop table matest0 cascade;
-NOTICE:  drop cascades to table matest1
---
--- Test merge-append for UNION ALL append relations
---
-set enable_seqscan = off;
-set enable_indexscan = on;
-set enable_bitmapscan = off;
--- Check handling of duplicated, constant, or volatile targetlist items
-explain (costs off)
-SELECT thousand, tenthous FROM tenk1
-UNION ALL
-SELECT thousand, thousand FROM tenk1
-ORDER BY thousand, tenthous;
-                               QUERY PLAN                                
--------------------------------------------------------------------------
- Merge Append
-   Sort Key: tenk1.thousand, tenk1.tenthous
-   ->  Index Only Scan using tenk1_thous_tenthous on tenk1
-   ->  Sort
-         Sort Key: tenk1_1.thousand, tenk1_1.thousand
-         ->  Index Only Scan using tenk1_thous_tenthous on tenk1 tenk1_1
-(6 rows)
-
-explain (costs off)
-SELECT thousand, tenthous, thousand+tenthous AS x FROM tenk1
-UNION ALL
-SELECT 42, 42, hundred FROM tenk1
-ORDER BY thousand, tenthous;
-                            QUERY PLAN                            
-------------------------------------------------------------------
- Merge Append
-   Sort Key: tenk1.thousand, tenk1.tenthous
-   ->  Index Only Scan using tenk1_thous_tenthous on tenk1
-   ->  Sort
-         Sort Key: 42, 42
-         ->  Index Only Scan using tenk1_hundred on tenk1 tenk1_1
-(6 rows)
-
-explain (costs off)
-SELECT thousand, tenthous FROM tenk1
-UNION ALL
-SELECT thousand, random()::integer FROM tenk1
-ORDER BY thousand, tenthous;
-                               QUERY PLAN                                
--------------------------------------------------------------------------
- Merge Append
-   Sort Key: tenk1.thousand, tenk1.tenthous
-   ->  Index Only Scan using tenk1_thous_tenthous on tenk1
-   ->  Sort
-         Sort Key: tenk1_1.thousand, ((random())::integer)
-         ->  Index Only Scan using tenk1_thous_tenthous on tenk1 tenk1_1
-(6 rows)
-
--- Check min/max aggregate optimization
-explain (costs off)
-SELECT min(x) FROM
-  (SELECT unique1 AS x FROM tenk1 a
-   UNION ALL
-   SELECT unique2 AS x FROM tenk1 b) s;
-                             QUERY PLAN                             
---------------------------------------------------------------------
- Result
-   InitPlan 1 (returns $0)
-     ->  Limit
-           ->  Merge Append
-                 Sort Key: a.unique1
-                 ->  Index Only Scan using tenk1_unique1 on tenk1 a
-                       Index Cond: (unique1 IS NOT NULL)
-                 ->  Index Only Scan using tenk1_unique2 on tenk1 b
-                       Index Cond: (unique2 IS NOT NULL)
-(9 rows)
-
-explain (costs off)
-SELECT min(y) FROM
-  (SELECT unique1 AS x, unique1 AS y FROM tenk1 a
-   UNION ALL
-   SELECT unique2 AS x, unique2 AS y FROM tenk1 b) s;
-                             QUERY PLAN                             
---------------------------------------------------------------------
- Result
-   InitPlan 1 (returns $0)
-     ->  Limit
-           ->  Merge Append
-                 Sort Key: a.unique1
-                 ->  Index Only Scan using tenk1_unique1 on tenk1 a
-                       Index Cond: (unique1 IS NOT NULL)
-                 ->  Index Only Scan using tenk1_unique2 on tenk1 b
-                       Index Cond: (unique2 IS NOT NULL)
-(9 rows)
-
--- XXX planner doesn't recognize that index on unique2 is sufficiently sorted
-explain (costs off)
-SELECT x, y FROM
-  (SELECT thousand AS x, tenthous AS y FROM tenk1 a
-   UNION ALL
-   SELECT unique2 AS x, unique2 AS y FROM tenk1 b) s
-ORDER BY x, y;
-                         QUERY PLAN                          
--------------------------------------------------------------
- Merge Append
-   Sort Key: a.thousand, a.tenthous
-   ->  Index Only Scan using tenk1_thous_tenthous on tenk1 a
-   ->  Sort
-         Sort Key: b.unique2, b.unique2
-         ->  Index Only Scan using tenk1_unique2 on tenk1 b
-(6 rows)
-
--- exercise rescan code path via a repeatedly-evaluated subquery
-explain (costs off)
-SELECT
-    ARRAY(SELECT f.i FROM (
-        (SELECT d + g.i FROM generate_series(4, 30, 3) d ORDER BY 1)
-        UNION ALL
-        (SELECT d + g.i FROM generate_series(0, 30, 5) d ORDER BY 1)
-    ) f(i)
-    ORDER BY f.i LIMIT 10)
-FROM generate_series(1, 3) g(i);
-                           QUERY PLAN                           
-----------------------------------------------------------------
- Function Scan on generate_series g
-   SubPlan 1
-     ->  Limit
-           ->  Merge Append
-                 Sort Key: ((d.d + g.i))
-                 ->  Sort
-                       Sort Key: ((d.d + g.i))
-                       ->  Function Scan on generate_series d
-                 ->  Sort
-                       Sort Key: ((d_1.d + g.i))
-                       ->  Function Scan on generate_series d_1
-(11 rows)
-
-SELECT
-    ARRAY(SELECT f.i FROM (
-        (SELECT d + g.i FROM generate_series(4, 30, 3) d ORDER BY 1)
-        UNION ALL
-        (SELECT d + g.i FROM generate_series(0, 30, 5) d ORDER BY 1)
-    ) f(i)
-    ORDER BY f.i LIMIT 10)
-FROM generate_series(1, 3) g(i);
-            array             
-------------------------------
- {1,5,6,8,11,11,14,16,17,20}
- {2,6,7,9,12,12,15,17,18,21}
- {3,7,8,10,13,13,16,18,19,22}
-(3 rows)
-
-reset enable_seqscan;
-reset enable_indexscan;
-reset enable_bitmapscan;
---
--- Check handling of a constant-null CHECK constraint
---
-create table cnullparent (f1 int);
-create table cnullchild (check (f1 = 1 or f1 = null)) inherits(cnullparent);
-insert into cnullchild values(1);
-insert into cnullchild values(2);
-insert into cnullchild values(null);
-select * from cnullparent;
- f1 
-----
-  1
-  2
-   
-(3 rows)
-
-select * from cnullparent where f1 = 2;
- f1 
-----
-  2
-(1 row)
-
-drop table cnullparent cascade;
-NOTICE:  drop cascades to table cnullchild
---
--- Check use of temporary tables with inheritance trees
---
-create table inh_perm_parent (a1 int);
-create temp table inh_temp_parent (a1 int);
-create temp table inh_temp_child () inherits (inh_perm_parent); -- ok
-create table inh_perm_child () inherits (inh_temp_parent); -- error
-ERROR:  cannot inherit from temporary relation "inh_temp_parent"
-create temp table inh_temp_child_2 () inherits (inh_temp_parent); -- ok
-insert into inh_perm_parent values (1);
-insert into inh_temp_parent values (2);
-insert into inh_temp_child values (3);
-insert into inh_temp_child_2 values (4);
-select tableoid::regclass, a1 from inh_perm_parent;
-    tableoid     | a1 
------------------+----
- inh_perm_parent |  1
- inh_temp_child  |  3
-(2 rows)
-
-select tableoid::regclass, a1 from inh_temp_parent;
-     tableoid     | a1 
-------------------+----
- inh_temp_parent  |  2
- inh_temp_child_2 |  4
-(2 rows)
-
-drop table inh_perm_parent cascade;
-NOTICE:  drop cascades to table inh_temp_child
-drop table inh_temp_parent cascade;
-NOTICE:  drop cascades to table inh_temp_child_2
---
--- Check that constraint exclusion works correctly with partitions using
--- implicit constraints generated from the partition bound information.
---
-create table list_parted (
-	a	varchar
-) partition by list (a);
-create table part_ab_cd partition of list_parted for values in ('ab', 'cd');
-create table part_ef_gh partition of list_parted for values in ('ef', 'gh');
-create table part_null_xy partition of list_parted for values in (null, 'xy');
-explain (costs off) select * from list_parted;
-                  QUERY PLAN                  
-----------------------------------------------
- Append
-   ->  Seq Scan on part_ab_cd list_parted_1
-   ->  Seq Scan on part_ef_gh list_parted_2
-   ->  Seq Scan on part_null_xy list_parted_3
-(4 rows)
-
-explain (costs off) select * from list_parted where a is null;
-              QUERY PLAN              
---------------------------------------
- Seq Scan on part_null_xy list_parted
-   Filter: (a IS NULL)
-(2 rows)
-
-explain (costs off) select * from list_parted where a is not null;
-                  QUERY PLAN                  
-----------------------------------------------
- Append
-   ->  Seq Scan on part_ab_cd list_parted_1
-         Filter: (a IS NOT NULL)
-   ->  Seq Scan on part_ef_gh list_parted_2
-         Filter: (a IS NOT NULL)
-   ->  Seq Scan on part_null_xy list_parted_3
-         Filter: (a IS NOT NULL)
-(7 rows)
-
-explain (costs off) select * from list_parted where a in ('ab', 'cd', 'ef');
-                        QUERY PLAN                        
-----------------------------------------------------------
- Append
-   ->  Seq Scan on part_ab_cd list_parted_1
-         Filter: ((a)::text = ANY ('{ab,cd,ef}'::text[]))
-   ->  Seq Scan on part_ef_gh list_parted_2
-         Filter: ((a)::text = ANY ('{ab,cd,ef}'::text[]))
-(5 rows)
-
-explain (costs off) select * from list_parted where a = 'ab' or a in (null, 'cd');
-                                   QUERY PLAN                                    
----------------------------------------------------------------------------------
- Seq Scan on part_ab_cd list_parted
-   Filter: (((a)::text = 'ab'::text) OR ((a)::text = ANY ('{NULL,cd}'::text[])))
-(2 rows)
-
-explain (costs off) select * from list_parted where a = 'ab';
-             QUERY PLAN             
-------------------------------------
- Seq Scan on part_ab_cd list_parted
-   Filter: ((a)::text = 'ab'::text)
-(2 rows)
-
-create table range_list_parted (
-	a	int,
-	b	char(2)
-) partition by range (a);
-create table part_1_10 partition of range_list_parted for values from (1) to (10) partition by list (b);
-create table part_1_10_ab partition of part_1_10 for values in ('ab');
-create table part_1_10_cd partition of part_1_10 for values in ('cd');
-create table part_10_20 partition of range_list_parted for values from (10) to (20) partition by list (b);
-create table part_10_20_ab partition of part_10_20 for values in ('ab');
-create table part_10_20_cd partition of part_10_20 for values in ('cd');
-create table part_21_30 partition of range_list_parted for values from (21) to (30) partition by list (b);
-create table part_21_30_ab partition of part_21_30 for values in ('ab');
-create table part_21_30_cd partition of part_21_30 for values in ('cd');
-create table part_40_inf partition of range_list_parted for values from (40) to (maxvalue) partition by list (b);
-create table part_40_inf_ab partition of part_40_inf for values in ('ab');
-create table part_40_inf_cd partition of part_40_inf for values in ('cd');
-create table part_40_inf_null partition of part_40_inf for values in (null);
-explain (costs off) select * from range_list_parted;
-                       QUERY PLAN                       
---------------------------------------------------------
- Append
-   ->  Seq Scan on part_1_10_ab range_list_parted_1
-   ->  Seq Scan on part_1_10_cd range_list_parted_2
-   ->  Seq Scan on part_10_20_ab range_list_parted_3
-   ->  Seq Scan on part_10_20_cd range_list_parted_4
-   ->  Seq Scan on part_21_30_ab range_list_parted_5
-   ->  Seq Scan on part_21_30_cd range_list_parted_6
-   ->  Seq Scan on part_40_inf_ab range_list_parted_7
-   ->  Seq Scan on part_40_inf_cd range_list_parted_8
-   ->  Seq Scan on part_40_inf_null range_list_parted_9
-(10 rows)
-
-explain (costs off) select * from range_list_parted where a = 5;
-                     QUERY PLAN                     
-----------------------------------------------------
- Append
-   ->  Seq Scan on part_1_10_ab range_list_parted_1
-         Filter: (a = 5)
-   ->  Seq Scan on part_1_10_cd range_list_parted_2
-         Filter: (a = 5)
-(5 rows)
-
-explain (costs off) select * from range_list_parted where b = 'ab';
-                      QUERY PLAN                      
-------------------------------------------------------
- Append
-   ->  Seq Scan on part_1_10_ab range_list_parted_1
-         Filter: (b = 'ab'::bpchar)
-   ->  Seq Scan on part_10_20_ab range_list_parted_2
-         Filter: (b = 'ab'::bpchar)
-   ->  Seq Scan on part_21_30_ab range_list_parted_3
-         Filter: (b = 'ab'::bpchar)
-   ->  Seq Scan on part_40_inf_ab range_list_parted_4
-         Filter: (b = 'ab'::bpchar)
-(9 rows)
-
-explain (costs off) select * from range_list_parted where a between 3 and 23 and b in ('ab');
-                           QUERY PLAN                            
------------------------------------------------------------------
- Append
-   ->  Seq Scan on part_1_10_ab range_list_parted_1
-         Filter: ((a >= 3) AND (a <= 23) AND (b = 'ab'::bpchar))
-   ->  Seq Scan on part_10_20_ab range_list_parted_2
-         Filter: ((a >= 3) AND (a <= 23) AND (b = 'ab'::bpchar))
-   ->  Seq Scan on part_21_30_ab range_list_parted_3
-         Filter: ((a >= 3) AND (a <= 23) AND (b = 'ab'::bpchar))
-(7 rows)
-
-/* Should select no rows because range partition key cannot be null */
-explain (costs off) select * from range_list_parted where a is null;
-        QUERY PLAN        
---------------------------
- Result
-   One-Time Filter: false
-(2 rows)
-
-/* Should only select rows from the null-accepting partition */
-explain (costs off) select * from range_list_parted where b is null;
-                   QUERY PLAN                   
-------------------------------------------------
- Seq Scan on part_40_inf_null range_list_parted
-   Filter: (b IS NULL)
-(2 rows)
-
-explain (costs off) select * from range_list_parted where a is not null and a < 67;
-                       QUERY PLAN                       
---------------------------------------------------------
- Append
-   ->  Seq Scan on part_1_10_ab range_list_parted_1
-         Filter: ((a IS NOT NULL) AND (a < 67))
-   ->  Seq Scan on part_1_10_cd range_list_parted_2
-         Filter: ((a IS NOT NULL) AND (a < 67))
-   ->  Seq Scan on part_10_20_ab range_list_parted_3
-         Filter: ((a IS NOT NULL) AND (a < 67))
-   ->  Seq Scan on part_10_20_cd range_list_parted_4
-         Filter: ((a IS NOT NULL) AND (a < 67))
-   ->  Seq Scan on part_21_30_ab range_list_parted_5
-         Filter: ((a IS NOT NULL) AND (a < 67))
-   ->  Seq Scan on part_21_30_cd range_list_parted_6
-         Filter: ((a IS NOT NULL) AND (a < 67))
-   ->  Seq Scan on part_40_inf_ab range_list_parted_7
-         Filter: ((a IS NOT NULL) AND (a < 67))
-   ->  Seq Scan on part_40_inf_cd range_list_parted_8
-         Filter: ((a IS NOT NULL) AND (a < 67))
-   ->  Seq Scan on part_40_inf_null range_list_parted_9
-         Filter: ((a IS NOT NULL) AND (a < 67))
-(19 rows)
-
-explain (costs off) select * from range_list_parted where a >= 30;
-                       QUERY PLAN                       
---------------------------------------------------------
- Append
-   ->  Seq Scan on part_40_inf_ab range_list_parted_1
-         Filter: (a >= 30)
-   ->  Seq Scan on part_40_inf_cd range_list_parted_2
-         Filter: (a >= 30)
-   ->  Seq Scan on part_40_inf_null range_list_parted_3
-         Filter: (a >= 30)
-(7 rows)
-
-drop table list_parted;
-drop table range_list_parted;
--- check that constraint exclusion is able to cope with the partition
--- constraint emitted for multi-column range partitioned tables
-create table mcrparted (a int, b int, c int) partition by range (a, abs(b), c);
-create table mcrparted_def partition of mcrparted default;
-create table mcrparted0 partition of mcrparted for values from (minvalue, minvalue, minvalue) to (1, 1, 1);
-create table mcrparted1 partition of mcrparted for values from (1, 1, 1) to (10, 5, 10);
-create table mcrparted2 partition of mcrparted for values from (10, 5, 10) to (10, 10, 10);
-create table mcrparted3 partition of mcrparted for values from (11, 1, 1) to (20, 10, 10);
-create table mcrparted4 partition of mcrparted for values from (20, 10, 10) to (20, 20, 20);
-create table mcrparted5 partition of mcrparted for values from (20, 20, 20) to (maxvalue, maxvalue, maxvalue);
-explain (costs off) select * from mcrparted where a = 0;	-- scans mcrparted0, mcrparted_def
-                 QUERY PLAN                  
----------------------------------------------
- Append
-   ->  Seq Scan on mcrparted0 mcrparted_1
-         Filter: (a = 0)
-   ->  Seq Scan on mcrparted_def mcrparted_2
-         Filter: (a = 0)
-(5 rows)
-
-explain (costs off) select * from mcrparted where a = 10 and abs(b) < 5;	-- scans mcrparted1, mcrparted_def
-                 QUERY PLAN                  
----------------------------------------------
- Append
-   ->  Seq Scan on mcrparted1 mcrparted_1
-         Filter: ((a = 10) AND (abs(b) < 5))
-   ->  Seq Scan on mcrparted_def mcrparted_2
-         Filter: ((a = 10) AND (abs(b) < 5))
-(5 rows)
-
-explain (costs off) select * from mcrparted where a = 10 and abs(b) = 5;	-- scans mcrparted1, mcrparted2, mcrparted_def
-                 QUERY PLAN                  
----------------------------------------------
- Append
-   ->  Seq Scan on mcrparted1 mcrparted_1
-         Filter: ((a = 10) AND (abs(b) = 5))
-   ->  Seq Scan on mcrparted2 mcrparted_2
-         Filter: ((a = 10) AND (abs(b) = 5))
-   ->  Seq Scan on mcrparted_def mcrparted_3
-         Filter: ((a = 10) AND (abs(b) = 5))
-(7 rows)
-
-explain (costs off) select * from mcrparted where abs(b) = 5;	-- scans all partitions
-                 QUERY PLAN                  
----------------------------------------------
- Append
-   ->  Seq Scan on mcrparted0 mcrparted_1
-         Filter: (abs(b) = 5)
-   ->  Seq Scan on mcrparted1 mcrparted_2
-         Filter: (abs(b) = 5)
-   ->  Seq Scan on mcrparted2 mcrparted_3
-         Filter: (abs(b) = 5)
-   ->  Seq Scan on mcrparted3 mcrparted_4
-         Filter: (abs(b) = 5)
-   ->  Seq Scan on mcrparted4 mcrparted_5
-         Filter: (abs(b) = 5)
-   ->  Seq Scan on mcrparted5 mcrparted_6
-         Filter: (abs(b) = 5)
-   ->  Seq Scan on mcrparted_def mcrparted_7
-         Filter: (abs(b) = 5)
-(15 rows)
-
-explain (costs off) select * from mcrparted where a > -1;	-- scans all partitions
-                 QUERY PLAN                  
----------------------------------------------
- Append
-   ->  Seq Scan on mcrparted0 mcrparted_1
-         Filter: (a > '-1'::integer)
-   ->  Seq Scan on mcrparted1 mcrparted_2
-         Filter: (a > '-1'::integer)
-   ->  Seq Scan on mcrparted2 mcrparted_3
-         Filter: (a > '-1'::integer)
-   ->  Seq Scan on mcrparted3 mcrparted_4
-         Filter: (a > '-1'::integer)
-   ->  Seq Scan on mcrparted4 mcrparted_5
-         Filter: (a > '-1'::integer)
-   ->  Seq Scan on mcrparted5 mcrparted_6
-         Filter: (a > '-1'::integer)
-   ->  Seq Scan on mcrparted_def mcrparted_7
-         Filter: (a > '-1'::integer)
-(15 rows)
-
-explain (costs off) select * from mcrparted where a = 20 and abs(b) = 10 and c > 10;	-- scans mcrparted4
-                     QUERY PLAN                      
------------------------------------------------------
- Seq Scan on mcrparted4 mcrparted
-   Filter: ((c > 10) AND (a = 20) AND (abs(b) = 10))
-(2 rows)
-
-explain (costs off) select * from mcrparted where a = 20 and c > 20; -- scans mcrparted3, mcrparte4, mcrparte5, mcrparted_def
-                 QUERY PLAN                  
----------------------------------------------
- Append
-   ->  Seq Scan on mcrparted3 mcrparted_1
-         Filter: ((c > 20) AND (a = 20))
-   ->  Seq Scan on mcrparted4 mcrparted_2
-         Filter: ((c > 20) AND (a = 20))
-   ->  Seq Scan on mcrparted5 mcrparted_3
-         Filter: ((c > 20) AND (a = 20))
-   ->  Seq Scan on mcrparted_def mcrparted_4
-         Filter: ((c > 20) AND (a = 20))
-(9 rows)
-
--- check that partitioned table Appends cope with being referenced in
--- subplans
-create table parted_minmax (a int, b varchar(16)) partition by range (a);
-create table parted_minmax1 partition of parted_minmax for values from (1) to (10);
-create index parted_minmax1i on parted_minmax1 (a, b);
-insert into parted_minmax values (1,'12345');
-explain (costs off) select min(a), max(a) from parted_minmax where b = '12345';
-                                           QUERY PLAN                                           
-------------------------------------------------------------------------------------------------
- Result
-   InitPlan 1 (returns $0)
-     ->  Limit
-           ->  Index Only Scan using parted_minmax1i on parted_minmax1 parted_minmax
-                 Index Cond: ((a IS NOT NULL) AND (b = '12345'::text))
-   InitPlan 2 (returns $1)
-     ->  Limit
-           ->  Index Only Scan Backward using parted_minmax1i on parted_minmax1 parted_minmax_1
-                 Index Cond: ((a IS NOT NULL) AND (b = '12345'::text))
-(9 rows)
-
-select min(a), max(a) from parted_minmax where b = '12345';
- min | max 
------+-----
-   1 |   1
-(1 row)
-
-drop table parted_minmax;
--- Test code that uses Append nodes in place of MergeAppend when the
--- partition ordering matches the desired ordering.
-create index mcrparted_a_abs_c_idx on mcrparted (a, abs(b), c);
--- MergeAppend must be used when a default partition exists
-explain (costs off) select * from mcrparted order by a, abs(b), c;
-                                  QUERY PLAN                                   
--------------------------------------------------------------------------------
- Merge Append
-   Sort Key: mcrparted.a, (abs(mcrparted.b)), mcrparted.c
-   ->  Index Scan using mcrparted0_a_abs_c_idx on mcrparted0 mcrparted_1
-   ->  Index Scan using mcrparted1_a_abs_c_idx on mcrparted1 mcrparted_2
-   ->  Index Scan using mcrparted2_a_abs_c_idx on mcrparted2 mcrparted_3
-   ->  Index Scan using mcrparted3_a_abs_c_idx on mcrparted3 mcrparted_4
-   ->  Index Scan using mcrparted4_a_abs_c_idx on mcrparted4 mcrparted_5
-   ->  Index Scan using mcrparted5_a_abs_c_idx on mcrparted5 mcrparted_6
-   ->  Index Scan using mcrparted_def_a_abs_c_idx on mcrparted_def mcrparted_7
-(9 rows)
-
-drop table mcrparted_def;
--- Append is used for a RANGE partitioned table with no default
--- and no subpartitions
-explain (costs off) select * from mcrparted order by a, abs(b), c;
-                               QUERY PLAN                                
--------------------------------------------------------------------------
- Append
-   ->  Index Scan using mcrparted0_a_abs_c_idx on mcrparted0 mcrparted_1
-   ->  Index Scan using mcrparted1_a_abs_c_idx on mcrparted1 mcrparted_2
-   ->  Index Scan using mcrparted2_a_abs_c_idx on mcrparted2 mcrparted_3
-   ->  Index Scan using mcrparted3_a_abs_c_idx on mcrparted3 mcrparted_4
-   ->  Index Scan using mcrparted4_a_abs_c_idx on mcrparted4 mcrparted_5
-   ->  Index Scan using mcrparted5_a_abs_c_idx on mcrparted5 mcrparted_6
-(7 rows)
-
--- Append is used with subpaths in reverse order with backwards index scans
-explain (costs off) select * from mcrparted order by a desc, abs(b) desc, c desc;
-                                    QUERY PLAN                                    
-----------------------------------------------------------------------------------
- Append
-   ->  Index Scan Backward using mcrparted5_a_abs_c_idx on mcrparted5 mcrparted_6
-   ->  Index Scan Backward using mcrparted4_a_abs_c_idx on mcrparted4 mcrparted_5
-   ->  Index Scan Backward using mcrparted3_a_abs_c_idx on mcrparted3 mcrparted_4
-   ->  Index Scan Backward using mcrparted2_a_abs_c_idx on mcrparted2 mcrparted_3
-   ->  Index Scan Backward using mcrparted1_a_abs_c_idx on mcrparted1 mcrparted_2
-   ->  Index Scan Backward using mcrparted0_a_abs_c_idx on mcrparted0 mcrparted_1
-(7 rows)
-
--- check that Append plan is used containing a MergeAppend for sub-partitions
--- that are unordered.
-drop table mcrparted5;
-create table mcrparted5 partition of mcrparted for values from (20, 20, 20) to (maxvalue, maxvalue, maxvalue) partition by list (a);
-create table mcrparted5a partition of mcrparted5 for values in(20);
-create table mcrparted5_def partition of mcrparted5 default;
-explain (costs off) select * from mcrparted order by a, abs(b), c;
-                                      QUERY PLAN                                       
----------------------------------------------------------------------------------------
- Append
-   ->  Index Scan using mcrparted0_a_abs_c_idx on mcrparted0 mcrparted_1
-   ->  Index Scan using mcrparted1_a_abs_c_idx on mcrparted1 mcrparted_2
-   ->  Index Scan using mcrparted2_a_abs_c_idx on mcrparted2 mcrparted_3
-   ->  Index Scan using mcrparted3_a_abs_c_idx on mcrparted3 mcrparted_4
-   ->  Index Scan using mcrparted4_a_abs_c_idx on mcrparted4 mcrparted_5
-   ->  Merge Append
-         Sort Key: mcrparted_7.a, (abs(mcrparted_7.b)), mcrparted_7.c
-         ->  Index Scan using mcrparted5a_a_abs_c_idx on mcrparted5a mcrparted_7
-         ->  Index Scan using mcrparted5_def_a_abs_c_idx on mcrparted5_def mcrparted_8
-(10 rows)
-
-drop table mcrparted5_def;
--- check that an Append plan is used and the sub-partitions are flattened
--- into the main Append when the sub-partition is unordered but contains
--- just a single sub-partition.
-explain (costs off) select a, abs(b) from mcrparted order by a, abs(b), c;
-                                QUERY PLAN                                 
----------------------------------------------------------------------------
- Append
-   ->  Index Scan using mcrparted0_a_abs_c_idx on mcrparted0 mcrparted_1
-   ->  Index Scan using mcrparted1_a_abs_c_idx on mcrparted1 mcrparted_2
-   ->  Index Scan using mcrparted2_a_abs_c_idx on mcrparted2 mcrparted_3
-   ->  Index Scan using mcrparted3_a_abs_c_idx on mcrparted3 mcrparted_4
-   ->  Index Scan using mcrparted4_a_abs_c_idx on mcrparted4 mcrparted_5
-   ->  Index Scan using mcrparted5a_a_abs_c_idx on mcrparted5a mcrparted_6
-(7 rows)
-
--- check that Append is used when the sub-partitioned tables are pruned
--- during planning.
-explain (costs off) select * from mcrparted where a < 20 order by a, abs(b), c;
-                               QUERY PLAN                                
--------------------------------------------------------------------------
- Append
-   ->  Index Scan using mcrparted0_a_abs_c_idx on mcrparted0 mcrparted_1
-         Index Cond: (a < 20)
-   ->  Index Scan using mcrparted1_a_abs_c_idx on mcrparted1 mcrparted_2
-         Index Cond: (a < 20)
-   ->  Index Scan using mcrparted2_a_abs_c_idx on mcrparted2 mcrparted_3
-         Index Cond: (a < 20)
-   ->  Index Scan using mcrparted3_a_abs_c_idx on mcrparted3 mcrparted_4
-         Index Cond: (a < 20)
-(9 rows)
-
-set enable_bitmapscan to off;
-set enable_sort to off;
-create table mclparted (a int) partition by list(a);
-create table mclparted1 partition of mclparted for values in(1);
-create table mclparted2 partition of mclparted for values in(2);
-create index on mclparted (a);
--- Ensure an Append is used for a list partition with an order by.
-explain (costs off) select * from mclparted order by a;
-                               QUERY PLAN                               
-------------------------------------------------------------------------
- Append
-   ->  Index Only Scan using mclparted1_a_idx on mclparted1 mclparted_1
-   ->  Index Only Scan using mclparted2_a_idx on mclparted2 mclparted_2
-(3 rows)
-
--- Ensure a MergeAppend is used when a partition exists with interleaved
--- datums in the partition bound.
-create table mclparted3_5 partition of mclparted for values in(3,5);
-create table mclparted4 partition of mclparted for values in(4);
-explain (costs off) select * from mclparted order by a;
-                                 QUERY PLAN                                 
-----------------------------------------------------------------------------
- Merge Append
-   Sort Key: mclparted.a
-   ->  Index Only Scan using mclparted1_a_idx on mclparted1 mclparted_1
-   ->  Index Only Scan using mclparted2_a_idx on mclparted2 mclparted_2
-   ->  Index Only Scan using mclparted3_5_a_idx on mclparted3_5 mclparted_3
-   ->  Index Only Scan using mclparted4_a_idx on mclparted4 mclparted_4
-(6 rows)
-
-explain (costs off) select * from mclparted where a in(3,4,5) order by a;
-                                 QUERY PLAN                                 
-----------------------------------------------------------------------------
- Merge Append
-   Sort Key: mclparted.a
-   ->  Index Only Scan using mclparted3_5_a_idx on mclparted3_5 mclparted_1
-         Index Cond: (a = ANY ('{3,4,5}'::integer[]))
-   ->  Index Only Scan using mclparted4_a_idx on mclparted4 mclparted_2
-         Index Cond: (a = ANY ('{3,4,5}'::integer[]))
-(6 rows)
-
--- Introduce a NULL and DEFAULT partition so we can test more complex cases
-create table mclparted_null partition of mclparted for values in(null);
-create table mclparted_def partition of mclparted default;
--- Append can be used providing we don't scan the interleaved partition
-explain (costs off) select * from mclparted where a in(1,2,4) order by a;
-                               QUERY PLAN                               
-------------------------------------------------------------------------
- Append
-   ->  Index Only Scan using mclparted1_a_idx on mclparted1 mclparted_1
-         Index Cond: (a = ANY ('{1,2,4}'::integer[]))
-   ->  Index Only Scan using mclparted2_a_idx on mclparted2 mclparted_2
-         Index Cond: (a = ANY ('{1,2,4}'::integer[]))
-   ->  Index Only Scan using mclparted4_a_idx on mclparted4 mclparted_3
-         Index Cond: (a = ANY ('{1,2,4}'::integer[]))
-(7 rows)
-
-explain (costs off) select * from mclparted where a in(1,2,4) or a is null order by a;
-                                   QUERY PLAN                                   
---------------------------------------------------------------------------------
- Append
-   ->  Index Only Scan using mclparted1_a_idx on mclparted1 mclparted_1
-         Filter: ((a = ANY ('{1,2,4}'::integer[])) OR (a IS NULL))
-   ->  Index Only Scan using mclparted2_a_idx on mclparted2 mclparted_2
-         Filter: ((a = ANY ('{1,2,4}'::integer[])) OR (a IS NULL))
-   ->  Index Only Scan using mclparted4_a_idx on mclparted4 mclparted_3
-         Filter: ((a = ANY ('{1,2,4}'::integer[])) OR (a IS NULL))
-   ->  Index Only Scan using mclparted_null_a_idx on mclparted_null mclparted_4
-         Filter: ((a = ANY ('{1,2,4}'::integer[])) OR (a IS NULL))
-(9 rows)
-
--- Test a more complex case where the NULL partition allows some other value
-drop table mclparted_null;
-create table mclparted_0_null partition of mclparted for values in(0,null);
--- Ensure MergeAppend is used since 0 and NULLs are in the same partition.
-explain (costs off) select * from mclparted where a in(1,2,4) or a is null order by a;
-                                     QUERY PLAN                                     
-------------------------------------------------------------------------------------
- Merge Append
-   Sort Key: mclparted.a
-   ->  Index Only Scan using mclparted_0_null_a_idx on mclparted_0_null mclparted_1
-         Filter: ((a = ANY ('{1,2,4}'::integer[])) OR (a IS NULL))
-   ->  Index Only Scan using mclparted1_a_idx on mclparted1 mclparted_2
-         Filter: ((a = ANY ('{1,2,4}'::integer[])) OR (a IS NULL))
-   ->  Index Only Scan using mclparted2_a_idx on mclparted2 mclparted_3
-         Filter: ((a = ANY ('{1,2,4}'::integer[])) OR (a IS NULL))
-   ->  Index Only Scan using mclparted4_a_idx on mclparted4 mclparted_4
-         Filter: ((a = ANY ('{1,2,4}'::integer[])) OR (a IS NULL))
-(10 rows)
-
-explain (costs off) select * from mclparted where a in(0,1,2,4) order by a;
-                                     QUERY PLAN                                     
-------------------------------------------------------------------------------------
- Merge Append
-   Sort Key: mclparted.a
-   ->  Index Only Scan using mclparted_0_null_a_idx on mclparted_0_null mclparted_1
-         Index Cond: (a = ANY ('{0,1,2,4}'::integer[]))
-   ->  Index Only Scan using mclparted1_a_idx on mclparted1 mclparted_2
-         Index Cond: (a = ANY ('{0,1,2,4}'::integer[]))
-   ->  Index Only Scan using mclparted2_a_idx on mclparted2 mclparted_3
-         Index Cond: (a = ANY ('{0,1,2,4}'::integer[]))
-   ->  Index Only Scan using mclparted4_a_idx on mclparted4 mclparted_4
-         Index Cond: (a = ANY ('{0,1,2,4}'::integer[]))
-(10 rows)
-
--- Ensure Append is used when the null partition is pruned
-explain (costs off) select * from mclparted where a in(1,2,4) order by a;
-                               QUERY PLAN                               
-------------------------------------------------------------------------
- Append
-   ->  Index Only Scan using mclparted1_a_idx on mclparted1 mclparted_1
-         Index Cond: (a = ANY ('{1,2,4}'::integer[]))
-   ->  Index Only Scan using mclparted2_a_idx on mclparted2 mclparted_2
-         Index Cond: (a = ANY ('{1,2,4}'::integer[]))
-   ->  Index Only Scan using mclparted4_a_idx on mclparted4 mclparted_3
-         Index Cond: (a = ANY ('{1,2,4}'::integer[]))
-(7 rows)
-
--- Ensure MergeAppend is used when the default partition is not pruned
-explain (costs off) select * from mclparted where a in(1,2,4,100) order by a;
-                                  QUERY PLAN                                  
-------------------------------------------------------------------------------
- Merge Append
-   Sort Key: mclparted.a
-   ->  Index Only Scan using mclparted1_a_idx on mclparted1 mclparted_1
-         Index Cond: (a = ANY ('{1,2,4,100}'::integer[]))
-   ->  Index Only Scan using mclparted2_a_idx on mclparted2 mclparted_2
-         Index Cond: (a = ANY ('{1,2,4,100}'::integer[]))
-   ->  Index Only Scan using mclparted4_a_idx on mclparted4 mclparted_3
-         Index Cond: (a = ANY ('{1,2,4,100}'::integer[]))
-   ->  Index Only Scan using mclparted_def_a_idx on mclparted_def mclparted_4
-         Index Cond: (a = ANY ('{1,2,4,100}'::integer[]))
-(10 rows)
-
-drop table mclparted;
-reset enable_sort;
-reset enable_bitmapscan;
--- Ensure subplans which don't have a path with the correct pathkeys get
--- sorted correctly.
-drop index mcrparted_a_abs_c_idx;
-create index on mcrparted1 (a, abs(b), c);
-create index on mcrparted2 (a, abs(b), c);
-create index on mcrparted3 (a, abs(b), c);
-create index on mcrparted4 (a, abs(b), c);
-explain (costs off) select * from mcrparted where a < 20 order by a, abs(b), c limit 1;
-                                  QUERY PLAN                                   
--------------------------------------------------------------------------------
- Limit
-   ->  Append
-         ->  Sort
-               Sort Key: mcrparted_1.a, (abs(mcrparted_1.b)), mcrparted_1.c
-               ->  Seq Scan on mcrparted0 mcrparted_1
-                     Filter: (a < 20)
-         ->  Index Scan using mcrparted1_a_abs_c_idx on mcrparted1 mcrparted_2
-               Index Cond: (a < 20)
-         ->  Index Scan using mcrparted2_a_abs_c_idx on mcrparted2 mcrparted_3
-               Index Cond: (a < 20)
-         ->  Index Scan using mcrparted3_a_abs_c_idx on mcrparted3 mcrparted_4
-               Index Cond: (a < 20)
-(12 rows)
-
-set enable_bitmapscan = 0;
--- Ensure Append node can be used when the partition is ordered by some
--- pathkeys which were deemed redundant.
-explain (costs off) select * from mcrparted where a = 10 order by a, abs(b), c;
-                               QUERY PLAN                                
--------------------------------------------------------------------------
- Append
-   ->  Index Scan using mcrparted1_a_abs_c_idx on mcrparted1 mcrparted_1
-         Index Cond: (a = 10)
-   ->  Index Scan using mcrparted2_a_abs_c_idx on mcrparted2 mcrparted_2
-         Index Cond: (a = 10)
-(5 rows)
-
-reset enable_bitmapscan;
-drop table mcrparted;
--- Ensure LIST partitions allow an Append to be used instead of a MergeAppend
-create table bool_lp (b bool) partition by list(b);
-create table bool_lp_true partition of bool_lp for values in(true);
-create table bool_lp_false partition of bool_lp for values in(false);
-create index on bool_lp (b);
-explain (costs off) select * from bool_lp order by b;
-                                 QUERY PLAN                                 
-----------------------------------------------------------------------------
- Append
-   ->  Index Only Scan using bool_lp_false_b_idx on bool_lp_false bool_lp_1
-   ->  Index Only Scan using bool_lp_true_b_idx on bool_lp_true bool_lp_2
-(3 rows)
-
-drop table bool_lp;
--- Ensure const bool quals can be properly detected as redundant
-create table bool_rp (b bool, a int) partition by range(b,a);
-create table bool_rp_false_1k partition of bool_rp for values from (false,0) to (false,1000);
-create table bool_rp_true_1k partition of bool_rp for values from (true,0) to (true,1000);
-create table bool_rp_false_2k partition of bool_rp for values from (false,1000) to (false,2000);
-create table bool_rp_true_2k partition of bool_rp for values from (true,1000) to (true,2000);
-create index on bool_rp (b,a);
-explain (costs off) select * from bool_rp where b = true order by b,a;
-                                    QUERY PLAN                                    
-----------------------------------------------------------------------------------
- Append
-   ->  Index Only Scan using bool_rp_true_1k_b_a_idx on bool_rp_true_1k bool_rp_1
-         Index Cond: (b = true)
-   ->  Index Only Scan using bool_rp_true_2k_b_a_idx on bool_rp_true_2k bool_rp_2
-         Index Cond: (b = true)
-(5 rows)
-
-explain (costs off) select * from bool_rp where b = false order by b,a;
-                                     QUERY PLAN                                     
-------------------------------------------------------------------------------------
- Append
-   ->  Index Only Scan using bool_rp_false_1k_b_a_idx on bool_rp_false_1k bool_rp_1
-         Index Cond: (b = false)
-   ->  Index Only Scan using bool_rp_false_2k_b_a_idx on bool_rp_false_2k bool_rp_2
-         Index Cond: (b = false)
-(5 rows)
-
-explain (costs off) select * from bool_rp where b = true order by a;
-                                    QUERY PLAN                                    
-----------------------------------------------------------------------------------
- Append
-   ->  Index Only Scan using bool_rp_true_1k_b_a_idx on bool_rp_true_1k bool_rp_1
-         Index Cond: (b = true)
-   ->  Index Only Scan using bool_rp_true_2k_b_a_idx on bool_rp_true_2k bool_rp_2
-         Index Cond: (b = true)
-(5 rows)
-
-explain (costs off) select * from bool_rp where b = false order by a;
-                                     QUERY PLAN                                     
-------------------------------------------------------------------------------------
- Append
-   ->  Index Only Scan using bool_rp_false_1k_b_a_idx on bool_rp_false_1k bool_rp_1
-         Index Cond: (b = false)
-   ->  Index Only Scan using bool_rp_false_2k_b_a_idx on bool_rp_false_2k bool_rp_2
-         Index Cond: (b = false)
-(5 rows)
-
-drop table bool_rp;
--- Ensure an Append scan is chosen when the partition order is a subset of
--- the required order.
-create table range_parted (a int, b int, c int) partition by range(a, b);
-create table range_parted1 partition of range_parted for values from (0,0) to (10,10);
-create table range_parted2 partition of range_parted for values from (10,10) to (20,20);
-create index on range_parted (a,b,c);
-explain (costs off) select * from range_parted order by a,b,c;
-                                     QUERY PLAN                                      
--------------------------------------------------------------------------------------
- Append
-   ->  Index Only Scan using range_parted1_a_b_c_idx on range_parted1 range_parted_1
-   ->  Index Only Scan using range_parted2_a_b_c_idx on range_parted2 range_parted_2
-(3 rows)
-
-explain (costs off) select * from range_parted order by a desc,b desc,c desc;
-                                          QUERY PLAN                                          
-----------------------------------------------------------------------------------------------
- Append
-   ->  Index Only Scan Backward using range_parted2_a_b_c_idx on range_parted2 range_parted_2
-   ->  Index Only Scan Backward using range_parted1_a_b_c_idx on range_parted1 range_parted_1
-(3 rows)
-
-drop table range_parted;
--- Check that we allow access to a child table's statistics when the user
--- has permissions only for the parent table.
-create table permtest_parent (a int, b text, c text) partition by list (a);
-create table permtest_child (b text, c text, a int) partition by list (b);
-create table permtest_grandchild (c text, b text, a int);
-alter table permtest_child attach partition permtest_grandchild for values in ('a');
-alter table permtest_parent attach partition permtest_child for values in (1);
-create index on permtest_parent (left(c, 3));
-insert into permtest_parent
-  select 1, 'a', left(md5(i::text), 5) from generate_series(0, 100) i;
-analyze permtest_parent;
-create role regress_no_child_access;
-revoke all on permtest_grandchild from regress_no_child_access;
-grant select on permtest_parent to regress_no_child_access;
-set session authorization regress_no_child_access;
--- without stats access, these queries would produce hash join plans:
-explain (costs off)
-  select * from permtest_parent p1 inner join permtest_parent p2
-  on p1.a = p2.a and p1.c ~ 'a1$';
-                QUERY PLAN                
-------------------------------------------
- Nested Loop
-   Join Filter: (p1.a = p2.a)
-   ->  Seq Scan on permtest_grandchild p1
-         Filter: (c ~ 'a1$'::text)
-   ->  Seq Scan on permtest_grandchild p2
-(5 rows)
-
-explain (costs off)
-  select * from permtest_parent p1 inner join permtest_parent p2
-  on p1.a = p2.a and left(p1.c, 3) ~ 'a1$';
-                  QUERY PLAN                  
-----------------------------------------------
- Nested Loop
-   Join Filter: (p1.a = p2.a)
-   ->  Seq Scan on permtest_grandchild p1
-         Filter: ("left"(c, 3) ~ 'a1$'::text)
-   ->  Seq Scan on permtest_grandchild p2
-(5 rows)
-
-reset session authorization;
-revoke all on permtest_parent from regress_no_child_access;
-grant select(a,c) on permtest_parent to regress_no_child_access;
-set session authorization regress_no_child_access;
-explain (costs off)
-  select p2.a, p1.c from permtest_parent p1 inner join permtest_parent p2
-  on p1.a = p2.a and p1.c ~ 'a1$';
-                QUERY PLAN                
-------------------------------------------
- Nested Loop
-   Join Filter: (p1.a = p2.a)
-   ->  Seq Scan on permtest_grandchild p1
-         Filter: (c ~ 'a1$'::text)
-   ->  Seq Scan on permtest_grandchild p2
-(5 rows)
-
--- we will not have access to the expression index's stats here:
-explain (costs off)
-  select p2.a, p1.c from permtest_parent p1 inner join permtest_parent p2
-  on p1.a = p2.a and left(p1.c, 3) ~ 'a1$';
-                     QUERY PLAN                     
-----------------------------------------------------
- Hash Join
-   Hash Cond: (p2.a = p1.a)
-   ->  Seq Scan on permtest_grandchild p2
-   ->  Hash
-         ->  Seq Scan on permtest_grandchild p1
-               Filter: ("left"(c, 3) ~ 'a1$'::text)
-(6 rows)
-
-reset session authorization;
-revoke all on permtest_parent from regress_no_child_access;
-drop role regress_no_child_access;
-drop table permtest_parent;
--- Verify that constraint errors across partition root / child are
--- handled correctly (Bug #16293)
-CREATE TABLE errtst_parent (
-    partid int not null,
-    shdata int not null,
-    data int NOT NULL DEFAULT 0,
-    CONSTRAINT shdata_small CHECK(shdata < 3)
-) PARTITION BY RANGE (partid);
--- fast defaults lead to attribute mapping being used in one
--- direction, but not the other
-CREATE TABLE errtst_child_fastdef (
-    partid int not null,
-    shdata int not null,
-    CONSTRAINT shdata_small CHECK(shdata < 3)
-);
--- no remapping in either direction necessary
-CREATE TABLE errtst_child_plaindef (
-    partid int not null,
-    shdata int not null,
-    data int NOT NULL DEFAULT 0,
-    CONSTRAINT shdata_small CHECK(shdata < 3),
-    CHECK(data < 10)
-);
--- remapping in both direction
-CREATE TABLE errtst_child_reorder (
-    data int NOT NULL DEFAULT 0,
-    shdata int not null,
-    partid int not null,
-    CONSTRAINT shdata_small CHECK(shdata < 3),
-    CHECK(data < 10)
-);
-ALTER TABLE errtst_child_fastdef ADD COLUMN data int NOT NULL DEFAULT 0;
-ALTER TABLE errtst_child_fastdef ADD CONSTRAINT errtest_child_fastdef_data_check CHECK (data < 10);
-ALTER TABLE errtst_parent ATTACH PARTITION errtst_child_fastdef FOR VALUES FROM (0) TO (10);
-ALTER TABLE errtst_parent ATTACH PARTITION errtst_child_plaindef FOR VALUES FROM (10) TO (20);
-ALTER TABLE errtst_parent ATTACH PARTITION errtst_child_reorder FOR VALUES FROM (20) TO (30);
--- insert without child check constraint error
-INSERT INTO errtst_parent(partid, shdata, data) VALUES ( '0', '1', '5');
-INSERT INTO errtst_parent(partid, shdata, data) VALUES ('10', '1', '5');
-INSERT INTO errtst_parent(partid, shdata, data) VALUES ('20', '1', '5');
--- insert with child check constraint error
-INSERT INTO errtst_parent(partid, shdata, data) VALUES ( '0', '1', '10');
-ERROR:  new row for relation "errtst_child_fastdef" violates check constraint "errtest_child_fastdef_data_check"
-DETAIL:  Failing row contains (0, 1, 10).
-INSERT INTO errtst_parent(partid, shdata, data) VALUES ('10', '1', '10');
-ERROR:  new row for relation "errtst_child_plaindef" violates check constraint "errtst_child_plaindef_data_check"
-DETAIL:  Failing row contains (10, 1, 10).
-INSERT INTO errtst_parent(partid, shdata, data) VALUES ('20', '1', '10');
-ERROR:  new row for relation "errtst_child_reorder" violates check constraint "errtst_child_reorder_data_check"
-DETAIL:  Failing row contains (20, 1, 10).
--- insert with child not null constraint error
-INSERT INTO errtst_parent(partid, shdata, data) VALUES ( '0', '1', NULL);
-ERROR:  null value in column "data" of relation "errtst_child_fastdef" violates not-null constraint
-DETAIL:  Failing row contains (0, 1, null).
-INSERT INTO errtst_parent(partid, shdata, data) VALUES ('10', '1', NULL);
-ERROR:  null value in column "data" of relation "errtst_child_plaindef" violates not-null constraint
-DETAIL:  Failing row contains (10, 1, null).
-INSERT INTO errtst_parent(partid, shdata, data) VALUES ('20', '1', NULL);
-ERROR:  null value in column "data" of relation "errtst_child_reorder" violates not-null constraint
-DETAIL:  Failing row contains (20, 1, null).
--- insert with shared check constraint error
-INSERT INTO errtst_parent(partid, shdata, data) VALUES ( '0', '5', '5');
-ERROR:  new row for relation "errtst_child_fastdef" violates check constraint "shdata_small"
-DETAIL:  Failing row contains (0, 5, 5).
-INSERT INTO errtst_parent(partid, shdata, data) VALUES ('10', '5', '5');
-ERROR:  new row for relation "errtst_child_plaindef" violates check constraint "shdata_small"
-DETAIL:  Failing row contains (10, 5, 5).
-INSERT INTO errtst_parent(partid, shdata, data) VALUES ('20', '5', '5');
-ERROR:  new row for relation "errtst_child_reorder" violates check constraint "shdata_small"
-DETAIL:  Failing row contains (20, 5, 5).
--- within partition update without child check constraint violation
-BEGIN;
-UPDATE errtst_parent SET data = data + 1 WHERE partid = 0;
-UPDATE errtst_parent SET data = data + 1 WHERE partid = 10;
-UPDATE errtst_parent SET data = data + 1 WHERE partid = 20;
-ROLLBACK;
--- within partition update with child check constraint violation
-UPDATE errtst_parent SET data = data + 10 WHERE partid = 0;
-ERROR:  new row for relation "errtst_child_fastdef" violates check constraint "errtest_child_fastdef_data_check"
-DETAIL:  Failing row contains (0, 1, 15).
-UPDATE errtst_parent SET data = data + 10 WHERE partid = 10;
-ERROR:  new row for relation "errtst_child_plaindef" violates check constraint "errtst_child_plaindef_data_check"
-DETAIL:  Failing row contains (10, 1, 15).
-UPDATE errtst_parent SET data = data + 10 WHERE partid = 20;
-ERROR:  new row for relation "errtst_child_reorder" violates check constraint "errtst_child_reorder_data_check"
-DETAIL:  Failing row contains (20, 1, 15).
--- direct leaf partition update, without partition id violation
-BEGIN;
-UPDATE errtst_child_fastdef SET partid = 1 WHERE partid = 0;
-UPDATE errtst_child_plaindef SET partid = 11 WHERE partid = 10;
-UPDATE errtst_child_reorder SET partid = 21 WHERE partid = 20;
-ROLLBACK;
--- direct leaf partition update, with partition id violation
-UPDATE errtst_child_fastdef SET partid = partid + 10 WHERE partid = 0;
-ERROR:  new row for relation "errtst_child_fastdef" violates partition constraint
-DETAIL:  Failing row contains (10, 1, 5).
-UPDATE errtst_child_plaindef SET partid = partid + 10 WHERE partid = 10;
-ERROR:  new row for relation "errtst_child_plaindef" violates partition constraint
-DETAIL:  Failing row contains (20, 1, 5).
-UPDATE errtst_child_reorder SET partid = partid + 10 WHERE partid = 20;
-ERROR:  new row for relation "errtst_child_reorder" violates partition constraint
-DETAIL:  Failing row contains (5, 1, 30).
--- partition move, without child check constraint violation
-BEGIN;
-UPDATE errtst_parent SET partid = 10, data = data + 1 WHERE partid = 0;
-UPDATE errtst_parent SET partid = 20, data = data + 1 WHERE partid = 10;
-UPDATE errtst_parent SET partid = 0, data = data + 1 WHERE partid = 20;
-ROLLBACK;
--- partition move, with child check constraint violation
-UPDATE errtst_parent SET partid = 10, data = data + 10 WHERE partid = 0;
-ERROR:  new row for relation "errtst_child_plaindef" violates check constraint "errtst_child_plaindef_data_check"
-DETAIL:  Failing row contains (10, 1, 15).
-UPDATE errtst_parent SET partid = 20, data = data + 10 WHERE partid = 10;
-ERROR:  new row for relation "errtst_child_reorder" violates check constraint "errtst_child_reorder_data_check"
-DETAIL:  Failing row contains (20, 1, 15).
-UPDATE errtst_parent SET partid = 0, data = data + 10 WHERE partid = 20;
-ERROR:  new row for relation "errtst_child_fastdef" violates check constraint "errtest_child_fastdef_data_check"
-DETAIL:  Failing row contains (0, 1, 15).
--- partition move, without target partition
-UPDATE errtst_parent SET partid = 30, data = data + 10 WHERE partid = 20;
-ERROR:  no partition of relation "errtst_parent" found for row
-DETAIL:  Partition key of the failing row contains (partid) = (30).
-DROP TABLE errtst_parent;
diff -U3 /Users/kenaniah/workspace/postgres/src/test/regress/expected/typed_table.out /Users/kenaniah/workspace/postgres/src/test/regress/results/typed_table.out
--- /Users/kenaniah/workspace/postgres/src/test/regress/expected/typed_table.out	2021-10-03 17:41:49.000000000 -0700
+++ /Users/kenaniah/workspace/postgres/src/test/regress/results/typed_table.out	2021-10-03 20:08:14.000000000 -0700
@@ -10,124 +10,11 @@
 (0 rows)
 
 \d persons
-              Table "public.persons"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- id     | integer |           |          | 
- name   | text    |           |          | 
-Typed table of type: person_type
-
-CREATE FUNCTION get_all_persons() RETURNS SETOF person_type
-LANGUAGE SQL
-AS $$
-    SELECT * FROM persons;
-$$;
-SELECT * FROM get_all_persons();
- id | name 
-----+------
-(0 rows)
-
--- certain ALTER TABLE operations on typed tables are not allowed
-ALTER TABLE persons ADD COLUMN comment text;
-ERROR:  cannot add column to typed table
-ALTER TABLE persons DROP COLUMN name;
-ERROR:  cannot drop column from typed table
-ALTER TABLE persons RENAME COLUMN id TO num;
-ERROR:  cannot rename column of typed table
-ALTER TABLE persons ALTER COLUMN name TYPE varchar;
-ERROR:  cannot alter column type of typed table
-CREATE TABLE stuff (id int);
-ALTER TABLE persons INHERIT stuff;
-ERROR:  cannot change inheritance of typed table
-CREATE TABLE personsx OF person_type (myname WITH OPTIONS NOT NULL); -- error
-ERROR:  column "myname" does not exist
-CREATE TABLE persons2 OF person_type (
-    id WITH OPTIONS PRIMARY KEY,
-    UNIQUE (name)
-);
-\d persons2
-              Table "public.persons2"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- id     | integer |           | not null | 
- name   | text    |           |          | 
-Indexes:
-    "persons2_pkey" PRIMARY KEY, btree (id)
-    "persons2_name_key" UNIQUE CONSTRAINT, btree (name)
-Typed table of type: person_type
-
-CREATE TABLE persons3 OF person_type (
-    PRIMARY KEY (id),
-    name WITH OPTIONS DEFAULT ''
-);
-\d persons3
-              Table "public.persons3"
- Column |  Type   | Collation | Nullable | Default  
---------+---------+-----------+----------+----------
- id     | integer |           | not null | 
- name   | text    |           |          | ''::text
-Indexes:
-    "persons3_pkey" PRIMARY KEY, btree (id)
-Typed table of type: person_type
-
-CREATE TABLE persons4 OF person_type (
-    name WITH OPTIONS NOT NULL,
-    name WITH OPTIONS DEFAULT ''  -- error, specified more than once
-);
-ERROR:  column "name" specified more than once
-DROP TYPE person_type RESTRICT;
-ERROR:  cannot drop type person_type because other objects depend on it
-DETAIL:  table persons depends on type person_type
-function get_all_persons() depends on type person_type
-table persons2 depends on type person_type
-table persons3 depends on type person_type
-HINT:  Use DROP ... CASCADE to drop the dependent objects too.
-DROP TYPE person_type CASCADE;
-NOTICE:  drop cascades to 4 other objects
-DETAIL:  drop cascades to table persons
-drop cascades to function get_all_persons()
-drop cascades to table persons2
-drop cascades to table persons3
-CREATE TABLE persons5 OF stuff; -- only CREATE TYPE AS types may be used
-ERROR:  type stuff is not a composite type
-DROP TABLE stuff;
--- implicit casting
-CREATE TYPE person_type AS (id int, name text);
-CREATE TABLE persons OF person_type;
-INSERT INTO persons VALUES (1, 'test');
-CREATE FUNCTION namelen(person_type) RETURNS int LANGUAGE SQL AS $$ SELECT length($1.name) $$;
-SELECT id, namelen(persons) FROM persons;
- id | namelen 
-----+---------
-  1 |       4
-(1 row)
-
-CREATE TABLE persons2 OF person_type (
-    id WITH OPTIONS PRIMARY KEY,
-    UNIQUE (name)
-);
-\d persons2
-              Table "public.persons2"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- id     | integer |           | not null | 
- name   | text    |           |          | 
-Indexes:
-    "persons2_pkey" PRIMARY KEY, btree (id)
-    "persons2_name_key" UNIQUE CONSTRAINT, btree (name)
-Typed table of type: person_type
-
-CREATE TABLE persons3 OF person_type (
-    PRIMARY KEY (id),
-    name NOT NULL DEFAULT ''
-);
-\d persons3
-              Table "public.persons3"
- Column |  Type   | Collation | Nullable | Default  
---------+---------+-----------+----------+----------
- id     | integer |           | not null | 
- name   | text    |           | not null | ''::text
-Indexes:
-    "persons3_pkey" PRIMARY KEY, btree (id)
-Typed table of type: person_type
+dyld: lazy symbol binding failed: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
+
+dyld: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
 
diff -U3 /Users/kenaniah/workspace/postgres/src/test/regress/expected/updatable_views.out /Users/kenaniah/workspace/postgres/src/test/regress/results/updatable_views.out
--- /Users/kenaniah/workspace/postgres/src/test/regress/expected/updatable_views.out	2021-10-03 17:41:49.000000000 -0700
+++ /Users/kenaniah/workspace/postgres/src/test/regress/results/updatable_views.out	2021-10-03 20:08:14.000000000 -0700
@@ -981,230 +981,321 @@
 CREATE USER regress_view_user2;
 SET SESSION AUTHORIZATION regress_view_user1;
 CREATE TABLE base_tbl(a int, b text, c float);
+ERROR:  permission denied for schema public
+LINE 1: CREATE TABLE base_tbl(a int, b text, c float);
+                     ^
 INSERT INTO base_tbl VALUES (1, 'Row 1', 1.0);
+ERROR:  relation "base_tbl" does not exist
+LINE 1: INSERT INTO base_tbl VALUES (1, 'Row 1', 1.0);
+                    ^
 CREATE VIEW rw_view1 AS SELECT b AS bb, c AS cc, a AS aa FROM base_tbl;
+ERROR:  relation "base_tbl" does not exist
+LINE 1: ... rw_view1 AS SELECT b AS bb, c AS cc, a AS aa FROM base_tbl;
+                                                              ^
 INSERT INTO rw_view1 VALUES ('Row 2', 2.0, 2);
+ERROR:  relation "rw_view1" does not exist
+LINE 1: INSERT INTO rw_view1 VALUES ('Row 2', 2.0, 2);
+                    ^
 GRANT SELECT ON base_tbl TO regress_view_user2;
+ERROR:  relation "base_tbl" does not exist
 GRANT SELECT ON rw_view1 TO regress_view_user2;
+ERROR:  relation "rw_view1" does not exist
 GRANT UPDATE (a,c) ON base_tbl TO regress_view_user2;
+ERROR:  relation "base_tbl" does not exist
 GRANT UPDATE (bb,cc) ON rw_view1 TO regress_view_user2;
+ERROR:  relation "rw_view1" does not exist
 RESET SESSION AUTHORIZATION;
 SET SESSION AUTHORIZATION regress_view_user2;
 CREATE VIEW rw_view2 AS SELECT b AS bb, c AS cc, a AS aa FROM base_tbl;
+ERROR:  relation "base_tbl" does not exist
+LINE 1: ... rw_view2 AS SELECT b AS bb, c AS cc, a AS aa FROM base_tbl;
+                                                              ^
 SELECT * FROM base_tbl; -- ok
- a |   b   | c 
----+-------+---
- 1 | Row 1 | 1
- 2 | Row 2 | 2
-(2 rows)
-
+ERROR:  relation "base_tbl" does not exist
+LINE 1: SELECT * FROM base_tbl;
+                      ^
 SELECT * FROM rw_view1; -- ok
-  bb   | cc | aa 
--------+----+----
- Row 1 |  1 |  1
- Row 2 |  2 |  2
-(2 rows)
-
+ERROR:  relation "rw_view1" does not exist
+LINE 1: SELECT * FROM rw_view1;
+                      ^
 SELECT * FROM rw_view2; -- ok
-  bb   | cc | aa 
--------+----+----
- Row 1 |  1 |  1
- Row 2 |  2 |  2
-(2 rows)
-
+ERROR:  relation "rw_view2" does not exist
+LINE 1: SELECT * FROM rw_view2;
+                      ^
 INSERT INTO base_tbl VALUES (3, 'Row 3', 3.0); -- not allowed
-ERROR:  permission denied for table base_tbl
+ERROR:  relation "base_tbl" does not exist
+LINE 1: INSERT INTO base_tbl VALUES (3, 'Row 3', 3.0);
+                    ^
 INSERT INTO rw_view1 VALUES ('Row 3', 3.0, 3); -- not allowed
-ERROR:  permission denied for view rw_view1
+ERROR:  relation "rw_view1" does not exist
+LINE 1: INSERT INTO rw_view1 VALUES ('Row 3', 3.0, 3);
+                    ^
 INSERT INTO rw_view2 VALUES ('Row 3', 3.0, 3); -- not allowed
-ERROR:  permission denied for table base_tbl
+ERROR:  relation "rw_view2" does not exist
+LINE 1: INSERT INTO rw_view2 VALUES ('Row 3', 3.0, 3);
+                    ^
 UPDATE base_tbl SET a=a, c=c; -- ok
+ERROR:  relation "base_tbl" does not exist
+LINE 1: UPDATE base_tbl SET a=a, c=c;
+               ^
 UPDATE base_tbl SET b=b; -- not allowed
-ERROR:  permission denied for table base_tbl
+ERROR:  relation "base_tbl" does not exist
+LINE 1: UPDATE base_tbl SET b=b;
+               ^
 UPDATE rw_view1 SET bb=bb, cc=cc; -- ok
+ERROR:  relation "rw_view1" does not exist
+LINE 1: UPDATE rw_view1 SET bb=bb, cc=cc;
+               ^
 UPDATE rw_view1 SET aa=aa; -- not allowed
-ERROR:  permission denied for view rw_view1
+ERROR:  relation "rw_view1" does not exist
+LINE 1: UPDATE rw_view1 SET aa=aa;
+               ^
 UPDATE rw_view2 SET aa=aa, cc=cc; -- ok
+ERROR:  relation "rw_view2" does not exist
+LINE 1: UPDATE rw_view2 SET aa=aa, cc=cc;
+               ^
 UPDATE rw_view2 SET bb=bb; -- not allowed
-ERROR:  permission denied for table base_tbl
+ERROR:  relation "rw_view2" does not exist
+LINE 1: UPDATE rw_view2 SET bb=bb;
+               ^
 DELETE FROM base_tbl; -- not allowed
-ERROR:  permission denied for table base_tbl
+ERROR:  relation "base_tbl" does not exist
+LINE 1: DELETE FROM base_tbl;
+                    ^
 DELETE FROM rw_view1; -- not allowed
-ERROR:  permission denied for view rw_view1
+ERROR:  relation "rw_view1" does not exist
+LINE 1: DELETE FROM rw_view1;
+                    ^
 DELETE FROM rw_view2; -- not allowed
-ERROR:  permission denied for table base_tbl
+ERROR:  relation "rw_view2" does not exist
+LINE 1: DELETE FROM rw_view2;
+                    ^
 RESET SESSION AUTHORIZATION;
 SET SESSION AUTHORIZATION regress_view_user1;
 GRANT INSERT, DELETE ON base_tbl TO regress_view_user2;
+ERROR:  relation "base_tbl" does not exist
 RESET SESSION AUTHORIZATION;
 SET SESSION AUTHORIZATION regress_view_user2;
 INSERT INTO base_tbl VALUES (3, 'Row 3', 3.0); -- ok
+ERROR:  relation "base_tbl" does not exist
+LINE 1: INSERT INTO base_tbl VALUES (3, 'Row 3', 3.0);
+                    ^
 INSERT INTO rw_view1 VALUES ('Row 4', 4.0, 4); -- not allowed
-ERROR:  permission denied for view rw_view1
+ERROR:  relation "rw_view1" does not exist
+LINE 1: INSERT INTO rw_view1 VALUES ('Row 4', 4.0, 4);
+                    ^
 INSERT INTO rw_view2 VALUES ('Row 4', 4.0, 4); -- ok
+ERROR:  relation "rw_view2" does not exist
+LINE 1: INSERT INTO rw_view2 VALUES ('Row 4', 4.0, 4);
+                    ^
 DELETE FROM base_tbl WHERE a=1; -- ok
+ERROR:  relation "base_tbl" does not exist
+LINE 1: DELETE FROM base_tbl WHERE a=1;
+                    ^
 DELETE FROM rw_view1 WHERE aa=2; -- not allowed
-ERROR:  permission denied for view rw_view1
+ERROR:  relation "rw_view1" does not exist
+LINE 1: DELETE FROM rw_view1 WHERE aa=2;
+                    ^
 DELETE FROM rw_view2 WHERE aa=2; -- ok
-SELECT * FROM base_tbl;
- a |   b   | c 
----+-------+---
- 3 | Row 3 | 3
- 4 | Row 4 | 4
-(2 rows)
-
+ERROR:  relation "rw_view2" does not exist
+LINE 1: DELETE FROM rw_view2 WHERE aa=2;
+                    ^
+SELECT * FROM base_tbl;
+ERROR:  relation "base_tbl" does not exist
+LINE 1: SELECT * FROM base_tbl;
+                      ^
 RESET SESSION AUTHORIZATION;
 SET SESSION AUTHORIZATION regress_view_user1;
 REVOKE INSERT, DELETE ON base_tbl FROM regress_view_user2;
+ERROR:  relation "base_tbl" does not exist
 GRANT INSERT, DELETE ON rw_view1 TO regress_view_user2;
+ERROR:  relation "rw_view1" does not exist
 RESET SESSION AUTHORIZATION;
 SET SESSION AUTHORIZATION regress_view_user2;
 INSERT INTO base_tbl VALUES (5, 'Row 5', 5.0); -- not allowed
-ERROR:  permission denied for table base_tbl
+ERROR:  relation "base_tbl" does not exist
+LINE 1: INSERT INTO base_tbl VALUES (5, 'Row 5', 5.0);
+                    ^
 INSERT INTO rw_view1 VALUES ('Row 5', 5.0, 5); -- ok
+ERROR:  relation "rw_view1" does not exist
+LINE 1: INSERT INTO rw_view1 VALUES ('Row 5', 5.0, 5);
+                    ^
 INSERT INTO rw_view2 VALUES ('Row 6', 6.0, 6); -- not allowed
-ERROR:  permission denied for table base_tbl
+ERROR:  relation "rw_view2" does not exist
+LINE 1: INSERT INTO rw_view2 VALUES ('Row 6', 6.0, 6);
+                    ^
 DELETE FROM base_tbl WHERE a=3; -- not allowed
-ERROR:  permission denied for table base_tbl
+ERROR:  relation "base_tbl" does not exist
+LINE 1: DELETE FROM base_tbl WHERE a=3;
+                    ^
 DELETE FROM rw_view1 WHERE aa=3; -- ok
+ERROR:  relation "rw_view1" does not exist
+LINE 1: DELETE FROM rw_view1 WHERE aa=3;
+                    ^
 DELETE FROM rw_view2 WHERE aa=4; -- not allowed
-ERROR:  permission denied for table base_tbl
-SELECT * FROM base_tbl;
- a |   b   | c 
----+-------+---
- 4 | Row 4 | 4
- 5 | Row 5 | 5
-(2 rows)
-
+ERROR:  relation "rw_view2" does not exist
+LINE 1: DELETE FROM rw_view2 WHERE aa=4;
+                    ^
+SELECT * FROM base_tbl;
+ERROR:  relation "base_tbl" does not exist
+LINE 1: SELECT * FROM base_tbl;
+                      ^
 RESET SESSION AUTHORIZATION;
 DROP TABLE base_tbl CASCADE;
-NOTICE:  drop cascades to 2 other objects
-DETAIL:  drop cascades to view rw_view1
-drop cascades to view rw_view2
+ERROR:  table "base_tbl" does not exist
 -- nested-view permissions
 CREATE TABLE base_tbl(a int, b text, c float);
 INSERT INTO base_tbl VALUES (1, 'Row 1', 1.0);
 SET SESSION AUTHORIZATION regress_view_user1;
 CREATE VIEW rw_view1 AS SELECT * FROM base_tbl;
+ERROR:  permission denied for schema public
 SELECT * FROM rw_view1;  -- not allowed
-ERROR:  permission denied for table base_tbl
+ERROR:  relation "rw_view1" does not exist
+LINE 1: SELECT * FROM rw_view1;
+                      ^
 SELECT * FROM rw_view1 FOR UPDATE;  -- not allowed
-ERROR:  permission denied for table base_tbl
+ERROR:  relation "rw_view1" does not exist
+LINE 1: SELECT * FROM rw_view1 FOR UPDATE;
+                      ^
 UPDATE rw_view1 SET b = 'foo' WHERE a = 1;  -- not allowed
-ERROR:  permission denied for table base_tbl
+ERROR:  relation "rw_view1" does not exist
+LINE 1: UPDATE rw_view1 SET b = 'foo' WHERE a = 1;
+               ^
 SET SESSION AUTHORIZATION regress_view_user2;
 CREATE VIEW rw_view2 AS SELECT * FROM rw_view1;
+ERROR:  relation "rw_view1" does not exist
+LINE 1: CREATE VIEW rw_view2 AS SELECT * FROM rw_view1;
+                                              ^
 SELECT * FROM rw_view2;  -- not allowed
-ERROR:  permission denied for view rw_view1
+ERROR:  relation "rw_view2" does not exist
+LINE 1: SELECT * FROM rw_view2;
+                      ^
 SELECT * FROM rw_view2 FOR UPDATE;  -- not allowed
-ERROR:  permission denied for view rw_view1
+ERROR:  relation "rw_view2" does not exist
+LINE 1: SELECT * FROM rw_view2 FOR UPDATE;
+                      ^
 UPDATE rw_view2 SET b = 'bar' WHERE a = 1;  -- not allowed
-ERROR:  permission denied for view rw_view1
+ERROR:  relation "rw_view2" does not exist
+LINE 1: UPDATE rw_view2 SET b = 'bar' WHERE a = 1;
+               ^
 RESET SESSION AUTHORIZATION;
 GRANT SELECT ON base_tbl TO regress_view_user1;
 SET SESSION AUTHORIZATION regress_view_user1;
 SELECT * FROM rw_view1;
- a |   b   | c 
----+-------+---
- 1 | Row 1 | 1
-(1 row)
-
+ERROR:  relation "rw_view1" does not exist
+LINE 1: SELECT * FROM rw_view1;
+                      ^
 SELECT * FROM rw_view1 FOR UPDATE;  -- not allowed
-ERROR:  permission denied for table base_tbl
+ERROR:  relation "rw_view1" does not exist
+LINE 1: SELECT * FROM rw_view1 FOR UPDATE;
+                      ^
 UPDATE rw_view1 SET b = 'foo' WHERE a = 1;  -- not allowed
-ERROR:  permission denied for table base_tbl
+ERROR:  relation "rw_view1" does not exist
+LINE 1: UPDATE rw_view1 SET b = 'foo' WHERE a = 1;
+               ^
 SET SESSION AUTHORIZATION regress_view_user2;
 SELECT * FROM rw_view2;  -- not allowed
-ERROR:  permission denied for view rw_view1
+ERROR:  relation "rw_view2" does not exist
+LINE 1: SELECT * FROM rw_view2;
+                      ^
 SELECT * FROM rw_view2 FOR UPDATE;  -- not allowed
-ERROR:  permission denied for view rw_view1
+ERROR:  relation "rw_view2" does not exist
+LINE 1: SELECT * FROM rw_view2 FOR UPDATE;
+                      ^
 UPDATE rw_view2 SET b = 'bar' WHERE a = 1;  -- not allowed
-ERROR:  permission denied for view rw_view1
+ERROR:  relation "rw_view2" does not exist
+LINE 1: UPDATE rw_view2 SET b = 'bar' WHERE a = 1;
+               ^
 SET SESSION AUTHORIZATION regress_view_user1;
 GRANT SELECT ON rw_view1 TO regress_view_user2;
+ERROR:  relation "rw_view1" does not exist
 SET SESSION AUTHORIZATION regress_view_user2;
 SELECT * FROM rw_view2;
- a |   b   | c 
----+-------+---
- 1 | Row 1 | 1
-(1 row)
-
+ERROR:  relation "rw_view2" does not exist
+LINE 1: SELECT * FROM rw_view2;
+                      ^
 SELECT * FROM rw_view2 FOR UPDATE;  -- not allowed
-ERROR:  permission denied for view rw_view1
+ERROR:  relation "rw_view2" does not exist
+LINE 1: SELECT * FROM rw_view2 FOR UPDATE;
+                      ^
 UPDATE rw_view2 SET b = 'bar' WHERE a = 1;  -- not allowed
-ERROR:  permission denied for view rw_view1
+ERROR:  relation "rw_view2" does not exist
+LINE 1: UPDATE rw_view2 SET b = 'bar' WHERE a = 1;
+               ^
 RESET SESSION AUTHORIZATION;
 GRANT UPDATE ON base_tbl TO regress_view_user1;
 SET SESSION AUTHORIZATION regress_view_user1;
 SELECT * FROM rw_view1;
- a |   b   | c 
----+-------+---
- 1 | Row 1 | 1
-(1 row)
-
+ERROR:  relation "rw_view1" does not exist
+LINE 1: SELECT * FROM rw_view1;
+                      ^
 SELECT * FROM rw_view1 FOR UPDATE;
- a |   b   | c 
----+-------+---
- 1 | Row 1 | 1
-(1 row)
-
+ERROR:  relation "rw_view1" does not exist
+LINE 1: SELECT * FROM rw_view1 FOR UPDATE;
+                      ^
 UPDATE rw_view1 SET b = 'foo' WHERE a = 1;
+ERROR:  relation "rw_view1" does not exist
+LINE 1: UPDATE rw_view1 SET b = 'foo' WHERE a = 1;
+               ^
 SET SESSION AUTHORIZATION regress_view_user2;
 SELECT * FROM rw_view2;
- a |  b  | c 
----+-----+---
- 1 | foo | 1
-(1 row)
-
+ERROR:  relation "rw_view2" does not exist
+LINE 1: SELECT * FROM rw_view2;
+                      ^
 SELECT * FROM rw_view2 FOR UPDATE;  -- not allowed
-ERROR:  permission denied for view rw_view1
+ERROR:  relation "rw_view2" does not exist
+LINE 1: SELECT * FROM rw_view2 FOR UPDATE;
+                      ^
 UPDATE rw_view2 SET b = 'bar' WHERE a = 1;  -- not allowed
-ERROR:  permission denied for view rw_view1
+ERROR:  relation "rw_view2" does not exist
+LINE 1: UPDATE rw_view2 SET b = 'bar' WHERE a = 1;
+               ^
 SET SESSION AUTHORIZATION regress_view_user1;
 GRANT UPDATE ON rw_view1 TO regress_view_user2;
+ERROR:  relation "rw_view1" does not exist
 SET SESSION AUTHORIZATION regress_view_user2;
 SELECT * FROM rw_view2;
- a |  b  | c 
----+-----+---
- 1 | foo | 1
-(1 row)
-
+ERROR:  relation "rw_view2" does not exist
+LINE 1: SELECT * FROM rw_view2;
+                      ^
 SELECT * FROM rw_view2 FOR UPDATE;
- a |  b  | c 
----+-----+---
- 1 | foo | 1
-(1 row)
-
+ERROR:  relation "rw_view2" does not exist
+LINE 1: SELECT * FROM rw_view2 FOR UPDATE;
+                      ^
 UPDATE rw_view2 SET b = 'bar' WHERE a = 1;
+ERROR:  relation "rw_view2" does not exist
+LINE 1: UPDATE rw_view2 SET b = 'bar' WHERE a = 1;
+               ^
 RESET SESSION AUTHORIZATION;
 REVOKE UPDATE ON base_tbl FROM regress_view_user1;
 SET SESSION AUTHORIZATION regress_view_user1;
 SELECT * FROM rw_view1;
- a |  b  | c 
----+-----+---
- 1 | bar | 1
-(1 row)
-
+ERROR:  relation "rw_view1" does not exist
+LINE 1: SELECT * FROM rw_view1;
+                      ^
 SELECT * FROM rw_view1 FOR UPDATE;  -- not allowed
-ERROR:  permission denied for table base_tbl
+ERROR:  relation "rw_view1" does not exist
+LINE 1: SELECT * FROM rw_view1 FOR UPDATE;
+                      ^
 UPDATE rw_view1 SET b = 'foo' WHERE a = 1;  -- not allowed
-ERROR:  permission denied for table base_tbl
+ERROR:  relation "rw_view1" does not exist
+LINE 1: UPDATE rw_view1 SET b = 'foo' WHERE a = 1;
+               ^
 SET SESSION AUTHORIZATION regress_view_user2;
 SELECT * FROM rw_view2;
- a |  b  | c 
----+-----+---
- 1 | bar | 1
-(1 row)
-
+ERROR:  relation "rw_view2" does not exist
+LINE 1: SELECT * FROM rw_view2;
+                      ^
 SELECT * FROM rw_view2 FOR UPDATE;  -- not allowed
-ERROR:  permission denied for table base_tbl
+ERROR:  relation "rw_view2" does not exist
+LINE 1: SELECT * FROM rw_view2 FOR UPDATE;
+                      ^
 UPDATE rw_view2 SET b = 'bar' WHERE a = 1;  -- not allowed
-ERROR:  permission denied for table base_tbl
+ERROR:  relation "rw_view2" does not exist
+LINE 1: UPDATE rw_view2 SET b = 'bar' WHERE a = 1;
+               ^
 RESET SESSION AUTHORIZATION;
 DROP TABLE base_tbl CASCADE;
-NOTICE:  drop cascades to 2 other objects
-DETAIL:  drop cascades to view rw_view1
-drop cascades to view rw_view2
 DROP USER regress_view_user1;
 DROP USER regress_view_user2;
 -- column defaults
@@ -1660,1397 +1751,11 @@
 CREATE VIEW rw_view1 AS SELECT * FROM base_tbl WHERE a < b
   WITH LOCAL CHECK OPTION;
 \d+ rw_view1
-                          View "public.rw_view1"
- Column |  Type   | Collation | Nullable | Default | Storage | Description 
---------+---------+-----------+----------+---------+---------+-------------
- a      | integer |           |          |         | plain   | 
- b      | integer |           |          |         | plain   | 
-View definition:
- SELECT base_tbl.a,
-    base_tbl.b
-   FROM base_tbl
-  WHERE base_tbl.a < base_tbl.b;
-Options: check_option=local
-
-SELECT * FROM information_schema.views WHERE table_name = 'rw_view1';
- table_catalog | table_schema | table_name |          view_definition           | check_option | is_updatable | is_insertable_into | is_trigger_updatable | is_trigger_deletable | is_trigger_insertable_into 
----------------+--------------+------------+------------------------------------+--------------+--------------+--------------------+----------------------+----------------------+----------------------------
- regression    | public       | rw_view1   |  SELECT base_tbl.a,               +| LOCAL        | YES          | YES                | NO                   | NO                   | NO
-               |              |            |     base_tbl.b                    +|              |              |                    |                      |                      | 
-               |              |            |    FROM base_tbl                  +|              |              |                    |                      |                      | 
-               |              |            |   WHERE (base_tbl.a < base_tbl.b); |              |              |                    |                      |                      | 
-(1 row)
-
-INSERT INTO rw_view1 VALUES(3,4); -- ok
-INSERT INTO rw_view1 VALUES(4,3); -- should fail
-ERROR:  new row violates check option for view "rw_view1"
-DETAIL:  Failing row contains (4, 3).
-INSERT INTO rw_view1 VALUES(5,null); -- should fail
-ERROR:  new row violates check option for view "rw_view1"
-DETAIL:  Failing row contains (5, null).
-UPDATE rw_view1 SET b = 5 WHERE a = 3; -- ok
-UPDATE rw_view1 SET b = -5 WHERE a = 3; -- should fail
-ERROR:  new row violates check option for view "rw_view1"
-DETAIL:  Failing row contains (3, -5).
-INSERT INTO rw_view1(a) VALUES (9); -- ok
-INSERT INTO rw_view1(a) VALUES (10); -- should fail
-ERROR:  new row violates check option for view "rw_view1"
-DETAIL:  Failing row contains (10, 10).
-SELECT * FROM base_tbl;
- a | b  
----+----
- 1 |  2
- 2 |  3
- 1 | -1
- 3 |  5
- 9 | 10
-(5 rows)
-
-DROP TABLE base_tbl CASCADE;
-NOTICE:  drop cascades to view rw_view1
--- WITH LOCAL/CASCADED CHECK OPTION
-CREATE TABLE base_tbl (a int);
-CREATE VIEW rw_view1 AS SELECT * FROM base_tbl WHERE a > 0;
-CREATE VIEW rw_view2 AS SELECT * FROM rw_view1 WHERE a < 10
-  WITH CHECK OPTION; -- implicitly cascaded
-\d+ rw_view2
-                          View "public.rw_view2"
- Column |  Type   | Collation | Nullable | Default | Storage | Description 
---------+---------+-----------+----------+---------+---------+-------------
- a      | integer |           |          |         | plain   | 
-View definition:
- SELECT rw_view1.a
-   FROM rw_view1
-  WHERE rw_view1.a < 10;
-Options: check_option=cascaded
-
-SELECT * FROM information_schema.views WHERE table_name = 'rw_view2';
- table_catalog | table_schema | table_name |      view_definition       | check_option | is_updatable | is_insertable_into | is_trigger_updatable | is_trigger_deletable | is_trigger_insertable_into 
----------------+--------------+------------+----------------------------+--------------+--------------+--------------------+----------------------+----------------------+----------------------------
- regression    | public       | rw_view2   |  SELECT rw_view1.a        +| CASCADED     | YES          | YES                | NO                   | NO                   | NO
-               |              |            |    FROM rw_view1          +|              |              |                    |                      |                      | 
-               |              |            |   WHERE (rw_view1.a < 10); |              |              |                    |                      |                      | 
-(1 row)
-
-INSERT INTO rw_view2 VALUES (-5); -- should fail
-ERROR:  new row violates check option for view "rw_view1"
-DETAIL:  Failing row contains (-5).
-INSERT INTO rw_view2 VALUES (5); -- ok
-INSERT INTO rw_view2 VALUES (15); -- should fail
-ERROR:  new row violates check option for view "rw_view2"
-DETAIL:  Failing row contains (15).
-SELECT * FROM base_tbl;
- a 
----
- 5
-(1 row)
-
-UPDATE rw_view2 SET a = a - 10; -- should fail
-ERROR:  new row violates check option for view "rw_view1"
-DETAIL:  Failing row contains (-5).
-UPDATE rw_view2 SET a = a + 10; -- should fail
-ERROR:  new row violates check option for view "rw_view2"
-DETAIL:  Failing row contains (15).
-CREATE OR REPLACE VIEW rw_view2 AS SELECT * FROM rw_view1 WHERE a < 10
-  WITH LOCAL CHECK OPTION;
-\d+ rw_view2
-                          View "public.rw_view2"
- Column |  Type   | Collation | Nullable | Default | Storage | Description 
---------+---------+-----------+----------+---------+---------+-------------
- a      | integer |           |          |         | plain   | 
-View definition:
- SELECT rw_view1.a
-   FROM rw_view1
-  WHERE rw_view1.a < 10;
-Options: check_option=local
-
-SELECT * FROM information_schema.views WHERE table_name = 'rw_view2';
- table_catalog | table_schema | table_name |      view_definition       | check_option | is_updatable | is_insertable_into | is_trigger_updatable | is_trigger_deletable | is_trigger_insertable_into 
----------------+--------------+------------+----------------------------+--------------+--------------+--------------------+----------------------+----------------------+----------------------------
- regression    | public       | rw_view2   |  SELECT rw_view1.a        +| LOCAL        | YES          | YES                | NO                   | NO                   | NO
-               |              |            |    FROM rw_view1          +|              |              |                    |                      |                      | 
-               |              |            |   WHERE (rw_view1.a < 10); |              |              |                    |                      |                      | 
-(1 row)
-
-INSERT INTO rw_view2 VALUES (-10); -- ok, but not in view
-INSERT INTO rw_view2 VALUES (20); -- should fail
-ERROR:  new row violates check option for view "rw_view2"
-DETAIL:  Failing row contains (20).
-SELECT * FROM base_tbl;
-  a  
------
-   5
- -10
-(2 rows)
-
-ALTER VIEW rw_view1 SET (check_option=here); -- invalid
-ERROR:  invalid value for enum option "check_option": here
-DETAIL:  Valid values are "local" and "cascaded".
-ALTER VIEW rw_view1 SET (check_option=local);
-INSERT INTO rw_view2 VALUES (-20); -- should fail
-ERROR:  new row violates check option for view "rw_view1"
-DETAIL:  Failing row contains (-20).
-INSERT INTO rw_view2 VALUES (30); -- should fail
-ERROR:  new row violates check option for view "rw_view2"
-DETAIL:  Failing row contains (30).
-ALTER VIEW rw_view2 RESET (check_option);
-\d+ rw_view2
-                          View "public.rw_view2"
- Column |  Type   | Collation | Nullable | Default | Storage | Description 
---------+---------+-----------+----------+---------+---------+-------------
- a      | integer |           |          |         | plain   | 
-View definition:
- SELECT rw_view1.a
-   FROM rw_view1
-  WHERE rw_view1.a < 10;
-
-SELECT * FROM information_schema.views WHERE table_name = 'rw_view2';
- table_catalog | table_schema | table_name |      view_definition       | check_option | is_updatable | is_insertable_into | is_trigger_updatable | is_trigger_deletable | is_trigger_insertable_into 
----------------+--------------+------------+----------------------------+--------------+--------------+--------------------+----------------------+----------------------+----------------------------
- regression    | public       | rw_view2   |  SELECT rw_view1.a        +| NONE         | YES          | YES                | NO                   | NO                   | NO
-               |              |            |    FROM rw_view1          +|              |              |                    |                      |                      | 
-               |              |            |   WHERE (rw_view1.a < 10); |              |              |                    |                      |                      | 
-(1 row)
-
-INSERT INTO rw_view2 VALUES (30); -- ok, but not in view
-SELECT * FROM base_tbl;
-  a  
------
-   5
- -10
-  30
-(3 rows)
-
-DROP TABLE base_tbl CASCADE;
-NOTICE:  drop cascades to 2 other objects
-DETAIL:  drop cascades to view rw_view1
-drop cascades to view rw_view2
--- WITH CHECK OPTION with no local view qual
-CREATE TABLE base_tbl (a int);
-CREATE VIEW rw_view1 AS SELECT * FROM base_tbl WITH CHECK OPTION;
-CREATE VIEW rw_view2 AS SELECT * FROM rw_view1 WHERE a > 0;
-CREATE VIEW rw_view3 AS SELECT * FROM rw_view2 WITH CHECK OPTION;
-SELECT * FROM information_schema.views WHERE table_name LIKE E'rw\\_view_' ORDER BY table_name;
- table_catalog | table_schema | table_name |      view_definition      | check_option | is_updatable | is_insertable_into | is_trigger_updatable | is_trigger_deletable | is_trigger_insertable_into 
----------------+--------------+------------+---------------------------+--------------+--------------+--------------------+----------------------+----------------------+----------------------------
- regression    | public       | rw_view1   |  SELECT base_tbl.a       +| CASCADED     | YES          | YES                | NO                   | NO                   | NO
-               |              |            |    FROM base_tbl;         |              |              |                    |                      |                      | 
- regression    | public       | rw_view2   |  SELECT rw_view1.a       +| NONE         | YES          | YES                | NO                   | NO                   | NO
-               |              |            |    FROM rw_view1         +|              |              |                    |                      |                      | 
-               |              |            |   WHERE (rw_view1.a > 0); |              |              |                    |                      |                      | 
- regression    | public       | rw_view3   |  SELECT rw_view2.a       +| CASCADED     | YES          | YES                | NO                   | NO                   | NO
-               |              |            |    FROM rw_view2;         |              |              |                    |                      |                      | 
-(3 rows)
-
-INSERT INTO rw_view1 VALUES (-1); -- ok
-INSERT INTO rw_view1 VALUES (1); -- ok
-INSERT INTO rw_view2 VALUES (-2); -- ok, but not in view
-INSERT INTO rw_view2 VALUES (2); -- ok
-INSERT INTO rw_view3 VALUES (-3); -- should fail
-ERROR:  new row violates check option for view "rw_view2"
-DETAIL:  Failing row contains (-3).
-INSERT INTO rw_view3 VALUES (3); -- ok
-DROP TABLE base_tbl CASCADE;
-NOTICE:  drop cascades to 3 other objects
-DETAIL:  drop cascades to view rw_view1
-drop cascades to view rw_view2
-drop cascades to view rw_view3
--- WITH CHECK OPTION with scalar array ops
-CREATE TABLE base_tbl (a int, b int[]);
-CREATE VIEW rw_view1 AS SELECT * FROM base_tbl WHERE a = ANY (b)
-  WITH CHECK OPTION;
-INSERT INTO rw_view1 VALUES (1, ARRAY[1,2,3]); -- ok
-INSERT INTO rw_view1 VALUES (10, ARRAY[4,5]); -- should fail
-ERROR:  new row violates check option for view "rw_view1"
-DETAIL:  Failing row contains (10, {4,5}).
-UPDATE rw_view1 SET b[2] = -b[2] WHERE a = 1; -- ok
-UPDATE rw_view1 SET b[1] = -b[1] WHERE a = 1; -- should fail
-ERROR:  new row violates check option for view "rw_view1"
-DETAIL:  Failing row contains (1, {-1,-2,3}).
-PREPARE ins(int, int[]) AS INSERT INTO rw_view1 VALUES($1, $2);
-EXECUTE ins(2, ARRAY[1,2,3]); -- ok
-EXECUTE ins(10, ARRAY[4,5]); -- should fail
-ERROR:  new row violates check option for view "rw_view1"
-DETAIL:  Failing row contains (10, {4,5}).
-DEALLOCATE PREPARE ins;
-DROP TABLE base_tbl CASCADE;
-NOTICE:  drop cascades to view rw_view1
--- WITH CHECK OPTION with subquery
-CREATE TABLE base_tbl (a int);
-CREATE TABLE ref_tbl (a int PRIMARY KEY);
-INSERT INTO ref_tbl SELECT * FROM generate_series(1,10);
-CREATE VIEW rw_view1 AS
-  SELECT * FROM base_tbl b
-  WHERE EXISTS(SELECT 1 FROM ref_tbl r WHERE r.a = b.a)
-  WITH CHECK OPTION;
-INSERT INTO rw_view1 VALUES (5); -- ok
-INSERT INTO rw_view1 VALUES (15); -- should fail
-ERROR:  new row violates check option for view "rw_view1"
-DETAIL:  Failing row contains (15).
-UPDATE rw_view1 SET a = a + 5; -- ok
-UPDATE rw_view1 SET a = a + 5; -- should fail
-ERROR:  new row violates check option for view "rw_view1"
-DETAIL:  Failing row contains (15).
-EXPLAIN (costs off) INSERT INTO rw_view1 VALUES (5);
-                       QUERY PLAN                        
----------------------------------------------------------
- Insert on base_tbl b
-   ->  Result
-   SubPlan 1
-     ->  Index Only Scan using ref_tbl_pkey on ref_tbl r
-           Index Cond: (a = b.a)
-(5 rows)
-
-EXPLAIN (costs off) UPDATE rw_view1 SET a = a + 5;
-                        QUERY PLAN                         
------------------------------------------------------------
- Update on base_tbl b
-   ->  Hash Join
-         Hash Cond: (b.a = r.a)
-         ->  Seq Scan on base_tbl b
-         ->  Hash
-               ->  Seq Scan on ref_tbl r
-   SubPlan 1
-     ->  Index Only Scan using ref_tbl_pkey on ref_tbl r_1
-           Index Cond: (a = b.a)
-(9 rows)
-
-DROP TABLE base_tbl, ref_tbl CASCADE;
-NOTICE:  drop cascades to view rw_view1
--- WITH CHECK OPTION with BEFORE trigger on base table
-CREATE TABLE base_tbl (a int, b int);
-CREATE FUNCTION base_tbl_trig_fn()
-RETURNS trigger AS
-$$
-BEGIN
-  NEW.b := 10;
-  RETURN NEW;
-END;
-$$
-LANGUAGE plpgsql;
-CREATE TRIGGER base_tbl_trig BEFORE INSERT OR UPDATE ON base_tbl
-  FOR EACH ROW EXECUTE PROCEDURE base_tbl_trig_fn();
-CREATE VIEW rw_view1 AS SELECT * FROM base_tbl WHERE a < b WITH CHECK OPTION;
-INSERT INTO rw_view1 VALUES (5,0); -- ok
-INSERT INTO rw_view1 VALUES (15, 20); -- should fail
-ERROR:  new row violates check option for view "rw_view1"
-DETAIL:  Failing row contains (15, 10).
-UPDATE rw_view1 SET a = 20, b = 30; -- should fail
-ERROR:  new row violates check option for view "rw_view1"
-DETAIL:  Failing row contains (20, 10).
-DROP TABLE base_tbl CASCADE;
-NOTICE:  drop cascades to view rw_view1
-DROP FUNCTION base_tbl_trig_fn();
--- WITH LOCAL CHECK OPTION with INSTEAD OF trigger on base view
-CREATE TABLE base_tbl (a int, b int);
-CREATE VIEW rw_view1 AS SELECT a FROM base_tbl WHERE a < b;
-CREATE FUNCTION rw_view1_trig_fn()
-RETURNS trigger AS
-$$
-BEGIN
-  IF TG_OP = 'INSERT' THEN
-    INSERT INTO base_tbl VALUES (NEW.a, 10);
-    RETURN NEW;
-  ELSIF TG_OP = 'UPDATE' THEN
-    UPDATE base_tbl SET a=NEW.a WHERE a=OLD.a;
-    RETURN NEW;
-  ELSIF TG_OP = 'DELETE' THEN
-    DELETE FROM base_tbl WHERE a=OLD.a;
-    RETURN OLD;
-  END IF;
-END;
-$$
-LANGUAGE plpgsql;
-CREATE TRIGGER rw_view1_trig
-  INSTEAD OF INSERT OR UPDATE OR DELETE ON rw_view1
-  FOR EACH ROW EXECUTE PROCEDURE rw_view1_trig_fn();
-CREATE VIEW rw_view2 AS
-  SELECT * FROM rw_view1 WHERE a > 0 WITH LOCAL CHECK OPTION;
-INSERT INTO rw_view2 VALUES (-5); -- should fail
-ERROR:  new row violates check option for view "rw_view2"
-DETAIL:  Failing row contains (-5).
-INSERT INTO rw_view2 VALUES (5); -- ok
-INSERT INTO rw_view2 VALUES (50); -- ok, but not in view
-UPDATE rw_view2 SET a = a - 10; -- should fail
-ERROR:  new row violates check option for view "rw_view2"
-DETAIL:  Failing row contains (-5).
-SELECT * FROM base_tbl;
- a  | b  
-----+----
-  5 | 10
- 50 | 10
-(2 rows)
-
--- Check option won't cascade down to base view with INSTEAD OF triggers
-ALTER VIEW rw_view2 SET (check_option=cascaded);
-INSERT INTO rw_view2 VALUES (100); -- ok, but not in view (doesn't fail rw_view1's check)
-UPDATE rw_view2 SET a = 200 WHERE a = 5; -- ok, but not in view (doesn't fail rw_view1's check)
-SELECT * FROM base_tbl;
-  a  | b  
------+----
-  50 | 10
- 100 | 10
- 200 | 10
-(3 rows)
-
--- Neither local nor cascaded check options work with INSTEAD rules
-DROP TRIGGER rw_view1_trig ON rw_view1;
-CREATE RULE rw_view1_ins_rule AS ON INSERT TO rw_view1
-  DO INSTEAD INSERT INTO base_tbl VALUES (NEW.a, 10);
-CREATE RULE rw_view1_upd_rule AS ON UPDATE TO rw_view1
-  DO INSTEAD UPDATE base_tbl SET a=NEW.a WHERE a=OLD.a;
-INSERT INTO rw_view2 VALUES (-10); -- ok, but not in view (doesn't fail rw_view2's check)
-INSERT INTO rw_view2 VALUES (5); -- ok
-INSERT INTO rw_view2 VALUES (20); -- ok, but not in view (doesn't fail rw_view1's check)
-UPDATE rw_view2 SET a = 30 WHERE a = 5; -- ok, but not in view (doesn't fail rw_view1's check)
-INSERT INTO rw_view2 VALUES (5); -- ok
-UPDATE rw_view2 SET a = -5 WHERE a = 5; -- ok, but not in view (doesn't fail rw_view2's check)
-SELECT * FROM base_tbl;
-  a  | b  
------+----
-  50 | 10
- 100 | 10
- 200 | 10
- -10 | 10
-  20 | 10
-  30 | 10
-  -5 | 10
-(7 rows)
-
-DROP TABLE base_tbl CASCADE;
-NOTICE:  drop cascades to 2 other objects
-DETAIL:  drop cascades to view rw_view1
-drop cascades to view rw_view2
-DROP FUNCTION rw_view1_trig_fn();
-CREATE TABLE base_tbl (a int);
-CREATE VIEW rw_view1 AS SELECT a,10 AS b FROM base_tbl;
-CREATE RULE rw_view1_ins_rule AS ON INSERT TO rw_view1
-  DO INSTEAD INSERT INTO base_tbl VALUES (NEW.a);
-CREATE VIEW rw_view2 AS
-  SELECT * FROM rw_view1 WHERE a > b WITH LOCAL CHECK OPTION;
-INSERT INTO rw_view2 VALUES (2,3); -- ok, but not in view (doesn't fail rw_view2's check)
-DROP TABLE base_tbl CASCADE;
-NOTICE:  drop cascades to 2 other objects
-DETAIL:  drop cascades to view rw_view1
-drop cascades to view rw_view2
--- security barrier view
-CREATE TABLE base_tbl (person text, visibility text);
-INSERT INTO base_tbl VALUES ('Tom', 'public'),
-                            ('Dick', 'private'),
-                            ('Harry', 'public');
-CREATE VIEW rw_view1 AS
-  SELECT person FROM base_tbl WHERE visibility = 'public';
-CREATE FUNCTION snoop(anyelement)
-RETURNS boolean AS
-$$
-BEGIN
-  RAISE NOTICE 'snooped value: %', $1;
-  RETURN true;
-END;
-$$
-LANGUAGE plpgsql COST 0.000001;
-CREATE OR REPLACE FUNCTION leakproof(anyelement)
-RETURNS boolean AS
-$$
-BEGIN
-  RETURN true;
-END;
-$$
-LANGUAGE plpgsql STRICT IMMUTABLE LEAKPROOF;
-SELECT * FROM rw_view1 WHERE snoop(person);
-NOTICE:  snooped value: Tom
-NOTICE:  snooped value: Dick
-NOTICE:  snooped value: Harry
- person 
---------
- Tom
- Harry
-(2 rows)
-
-UPDATE rw_view1 SET person=person WHERE snoop(person);
-NOTICE:  snooped value: Tom
-NOTICE:  snooped value: Dick
-NOTICE:  snooped value: Harry
-DELETE FROM rw_view1 WHERE NOT snoop(person);
-NOTICE:  snooped value: Dick
-NOTICE:  snooped value: Tom
-NOTICE:  snooped value: Harry
-ALTER VIEW rw_view1 SET (security_barrier = true);
-SELECT table_name, is_insertable_into
-  FROM information_schema.tables
- WHERE table_name = 'rw_view1';
- table_name | is_insertable_into 
-------------+--------------------
- rw_view1   | YES
-(1 row)
-
-SELECT table_name, is_updatable, is_insertable_into
-  FROM information_schema.views
- WHERE table_name = 'rw_view1';
- table_name | is_updatable | is_insertable_into 
-------------+--------------+--------------------
- rw_view1   | YES          | YES
-(1 row)
-
-SELECT table_name, column_name, is_updatable
-  FROM information_schema.columns
- WHERE table_name = 'rw_view1'
- ORDER BY ordinal_position;
- table_name | column_name | is_updatable 
-------------+-------------+--------------
- rw_view1   | person      | YES
-(1 row)
-
-SELECT * FROM rw_view1 WHERE snoop(person);
-NOTICE:  snooped value: Tom
-NOTICE:  snooped value: Harry
- person 
---------
- Tom
- Harry
-(2 rows)
-
-UPDATE rw_view1 SET person=person WHERE snoop(person);
-NOTICE:  snooped value: Tom
-NOTICE:  snooped value: Harry
-DELETE FROM rw_view1 WHERE NOT snoop(person);
-NOTICE:  snooped value: Tom
-NOTICE:  snooped value: Harry
-EXPLAIN (costs off) SELECT * FROM rw_view1 WHERE snoop(person);
-                  QUERY PLAN                   
------------------------------------------------
- Subquery Scan on rw_view1
-   Filter: snoop(rw_view1.person)
-   ->  Seq Scan on base_tbl
-         Filter: (visibility = 'public'::text)
-(4 rows)
-
-EXPLAIN (costs off) UPDATE rw_view1 SET person=person WHERE snoop(person);
-                            QUERY PLAN                             
--------------------------------------------------------------------
- Update on base_tbl
-   ->  Seq Scan on base_tbl
-         Filter: ((visibility = 'public'::text) AND snoop(person))
-(3 rows)
-
-EXPLAIN (costs off) DELETE FROM rw_view1 WHERE NOT snoop(person);
-                               QUERY PLAN                                
--------------------------------------------------------------------------
- Delete on base_tbl
-   ->  Seq Scan on base_tbl
-         Filter: ((visibility = 'public'::text) AND (NOT snoop(person)))
-(3 rows)
-
--- security barrier view on top of security barrier view
-CREATE VIEW rw_view2 WITH (security_barrier = true) AS
-  SELECT * FROM rw_view1 WHERE snoop(person);
-SELECT table_name, is_insertable_into
-  FROM information_schema.tables
- WHERE table_name = 'rw_view2';
- table_name | is_insertable_into 
-------------+--------------------
- rw_view2   | YES
-(1 row)
-
-SELECT table_name, is_updatable, is_insertable_into
-  FROM information_schema.views
- WHERE table_name = 'rw_view2';
- table_name | is_updatable | is_insertable_into 
-------------+--------------+--------------------
- rw_view2   | YES          | YES
-(1 row)
-
-SELECT table_name, column_name, is_updatable
-  FROM information_schema.columns
- WHERE table_name = 'rw_view2'
- ORDER BY ordinal_position;
- table_name | column_name | is_updatable 
-------------+-------------+--------------
- rw_view2   | person      | YES
-(1 row)
-
-SELECT * FROM rw_view2 WHERE snoop(person);
-NOTICE:  snooped value: Tom
-NOTICE:  snooped value: Tom
-NOTICE:  snooped value: Harry
-NOTICE:  snooped value: Harry
- person 
---------
- Tom
- Harry
-(2 rows)
-
-UPDATE rw_view2 SET person=person WHERE snoop(person);
-NOTICE:  snooped value: Tom
-NOTICE:  snooped value: Tom
-NOTICE:  snooped value: Harry
-NOTICE:  snooped value: Harry
-DELETE FROM rw_view2 WHERE NOT snoop(person);
-NOTICE:  snooped value: Tom
-NOTICE:  snooped value: Tom
-NOTICE:  snooped value: Harry
-NOTICE:  snooped value: Harry
-EXPLAIN (costs off) SELECT * FROM rw_view2 WHERE snoop(person);
-                     QUERY PLAN                      
------------------------------------------------------
- Subquery Scan on rw_view2
-   Filter: snoop(rw_view2.person)
-   ->  Subquery Scan on rw_view1
-         Filter: snoop(rw_view1.person)
-         ->  Seq Scan on base_tbl
-               Filter: (visibility = 'public'::text)
-(6 rows)
-
-EXPLAIN (costs off) UPDATE rw_view2 SET person=person WHERE snoop(person);
-                                     QUERY PLAN                                      
--------------------------------------------------------------------------------------
- Update on base_tbl
-   ->  Seq Scan on base_tbl
-         Filter: ((visibility = 'public'::text) AND snoop(person) AND snoop(person))
-(3 rows)
-
-EXPLAIN (costs off) DELETE FROM rw_view2 WHERE NOT snoop(person);
-                                        QUERY PLAN                                         
--------------------------------------------------------------------------------------------
- Delete on base_tbl
-   ->  Seq Scan on base_tbl
-         Filter: ((visibility = 'public'::text) AND snoop(person) AND (NOT snoop(person)))
-(3 rows)
-
-DROP TABLE base_tbl CASCADE;
-NOTICE:  drop cascades to 2 other objects
-DETAIL:  drop cascades to view rw_view1
-drop cascades to view rw_view2
--- security barrier view on top of table with rules
-CREATE TABLE base_tbl(id int PRIMARY KEY, data text, deleted boolean);
-INSERT INTO base_tbl VALUES (1, 'Row 1', false), (2, 'Row 2', true);
-CREATE RULE base_tbl_ins_rule AS ON INSERT TO base_tbl
-  WHERE EXISTS (SELECT 1 FROM base_tbl t WHERE t.id = new.id)
-  DO INSTEAD
-    UPDATE base_tbl SET data = new.data, deleted = false WHERE id = new.id;
-CREATE RULE base_tbl_del_rule AS ON DELETE TO base_tbl
-  DO INSTEAD
-    UPDATE base_tbl SET deleted = true WHERE id = old.id;
-CREATE VIEW rw_view1 WITH (security_barrier=true) AS
-  SELECT id, data FROM base_tbl WHERE NOT deleted;
-SELECT * FROM rw_view1;
- id | data  
-----+-------
-  1 | Row 1
-(1 row)
-
-EXPLAIN (costs off) DELETE FROM rw_view1 WHERE id = 1 AND snoop(data);
-                            QUERY PLAN                             
--------------------------------------------------------------------
- Update on base_tbl base_tbl_1
-   ->  Nested Loop
-         ->  Index Scan using base_tbl_pkey on base_tbl base_tbl_1
-               Index Cond: (id = 1)
-         ->  Index Scan using base_tbl_pkey on base_tbl
-               Index Cond: (id = 1)
-               Filter: ((NOT deleted) AND snoop(data))
-(7 rows)
-
-DELETE FROM rw_view1 WHERE id = 1 AND snoop(data);
-NOTICE:  snooped value: Row 1
-EXPLAIN (costs off) INSERT INTO rw_view1 VALUES (2, 'New row 2');
-                        QUERY PLAN                         
------------------------------------------------------------
- Insert on base_tbl
-   InitPlan 1 (returns $0)
-     ->  Index Only Scan using base_tbl_pkey on base_tbl t
-           Index Cond: (id = 2)
-   ->  Result
-         One-Time Filter: ($0 IS NOT TRUE)
- 
- Update on base_tbl
-   InitPlan 1 (returns $0)
-     ->  Index Only Scan using base_tbl_pkey on base_tbl t
-           Index Cond: (id = 2)
-   ->  Result
-         One-Time Filter: $0
-         ->  Index Scan using base_tbl_pkey on base_tbl
-               Index Cond: (id = 2)
-(15 rows)
-
-INSERT INTO rw_view1 VALUES (2, 'New row 2');
-SELECT * FROM base_tbl;
- id |   data    | deleted 
-----+-----------+---------
-  1 | Row 1     | t
-  2 | New row 2 | f
-(2 rows)
-
-DROP TABLE base_tbl CASCADE;
-NOTICE:  drop cascades to view rw_view1
--- security barrier view based on inheritance set
-CREATE TABLE t1 (a int, b float, c text);
-CREATE INDEX t1_a_idx ON t1(a);
-INSERT INTO t1
-SELECT i,i,'t1' FROM generate_series(1,10) g(i);
-ANALYZE t1;
-CREATE TABLE t11 (d text) INHERITS (t1);
-CREATE INDEX t11_a_idx ON t11(a);
-INSERT INTO t11
-SELECT i,i,'t11','t11d' FROM generate_series(1,10) g(i);
-ANALYZE t11;
-CREATE TABLE t12 (e int[]) INHERITS (t1);
-CREATE INDEX t12_a_idx ON t12(a);
-INSERT INTO t12
-SELECT i,i,'t12','{1,2}'::int[] FROM generate_series(1,10) g(i);
-ANALYZE t12;
-CREATE TABLE t111 () INHERITS (t11, t12);
-NOTICE:  merging multiple inherited definitions of column "a"
-NOTICE:  merging multiple inherited definitions of column "b"
-NOTICE:  merging multiple inherited definitions of column "c"
-CREATE INDEX t111_a_idx ON t111(a);
-INSERT INTO t111
-SELECT i,i,'t111','t111d','{1,1,1}'::int[] FROM generate_series(1,10) g(i);
-ANALYZE t111;
-CREATE VIEW v1 WITH (security_barrier=true) AS
-SELECT *, (SELECT d FROM t11 WHERE t11.a = t1.a LIMIT 1) AS d
-FROM t1
-WHERE a > 5 AND EXISTS(SELECT 1 FROM t12 WHERE t12.a = t1.a);
-SELECT * FROM v1 WHERE a=3; -- should not see anything
- a | b | c | d 
----+---+---+---
-(0 rows)
-
-SELECT * FROM v1 WHERE a=8;
- a | b |  c   |  d   
----+---+------+------
- 8 | 8 | t1   | t11d
- 8 | 8 | t11  | t11d
- 8 | 8 | t12  | t11d
- 8 | 8 | t111 | t11d
-(4 rows)
-
-EXPLAIN (VERBOSE, COSTS OFF)
-UPDATE v1 SET a=100 WHERE snoop(a) AND leakproof(a) AND a < 7 AND a != 6;
-                                             QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
- Update on public.t1
-   Update on public.t1 t1_1
-   Update on public.t11 t1_2
-   Update on public.t12 t1_3
-   Update on public.t111 t1_4
-   ->  Result
-         Output: 100, t1.tableoid, t1.ctid
-         ->  Append
-               ->  Index Scan using t1_a_idx on public.t1 t1_1
-                     Output: t1_1.tableoid, t1_1.ctid
-                     Index Cond: ((t1_1.a > 5) AND (t1_1.a < 7))
-                     Filter: ((t1_1.a <> 6) AND (SubPlan 1) AND snoop(t1_1.a) AND leakproof(t1_1.a))
-                     SubPlan 1
-                       ->  Append
-                             ->  Seq Scan on public.t12 t12_1
-                                   Filter: (t12_1.a = t1_1.a)
-                             ->  Seq Scan on public.t111 t12_2
-                                   Filter: (t12_2.a = t1_1.a)
-               ->  Index Scan using t11_a_idx on public.t11 t1_2
-                     Output: t1_2.tableoid, t1_2.ctid
-                     Index Cond: ((t1_2.a > 5) AND (t1_2.a < 7))
-                     Filter: ((t1_2.a <> 6) AND (SubPlan 1) AND snoop(t1_2.a) AND leakproof(t1_2.a))
-               ->  Index Scan using t12_a_idx on public.t12 t1_3
-                     Output: t1_3.tableoid, t1_3.ctid
-                     Index Cond: ((t1_3.a > 5) AND (t1_3.a < 7))
-                     Filter: ((t1_3.a <> 6) AND (SubPlan 1) AND snoop(t1_3.a) AND leakproof(t1_3.a))
-               ->  Index Scan using t111_a_idx on public.t111 t1_4
-                     Output: t1_4.tableoid, t1_4.ctid
-                     Index Cond: ((t1_4.a > 5) AND (t1_4.a < 7))
-                     Filter: ((t1_4.a <> 6) AND (SubPlan 1) AND snoop(t1_4.a) AND leakproof(t1_4.a))
-(30 rows)
-
-UPDATE v1 SET a=100 WHERE snoop(a) AND leakproof(a) AND a < 7 AND a != 6;
-SELECT * FROM v1 WHERE a=100; -- Nothing should have been changed to 100
- a | b | c | d 
----+---+---+---
-(0 rows)
-
-SELECT * FROM t1 WHERE a=100; -- Nothing should have been changed to 100
- a | b | c 
----+---+---
-(0 rows)
-
-EXPLAIN (VERBOSE, COSTS OFF)
-UPDATE v1 SET a=a+1 WHERE snoop(a) AND leakproof(a) AND a = 8;
-                                    QUERY PLAN                                     
------------------------------------------------------------------------------------
- Update on public.t1
-   Update on public.t1 t1_1
-   Update on public.t11 t1_2
-   Update on public.t12 t1_3
-   Update on public.t111 t1_4
-   ->  Result
-         Output: (t1.a + 1), t1.tableoid, t1.ctid
-         ->  Append
-               ->  Index Scan using t1_a_idx on public.t1 t1_1
-                     Output: t1_1.a, t1_1.tableoid, t1_1.ctid
-                     Index Cond: ((t1_1.a > 5) AND (t1_1.a = 8))
-                     Filter: ((SubPlan 1) AND snoop(t1_1.a) AND leakproof(t1_1.a))
-                     SubPlan 1
-                       ->  Append
-                             ->  Seq Scan on public.t12 t12_1
-                                   Filter: (t12_1.a = t1_1.a)
-                             ->  Seq Scan on public.t111 t12_2
-                                   Filter: (t12_2.a = t1_1.a)
-               ->  Index Scan using t11_a_idx on public.t11 t1_2
-                     Output: t1_2.a, t1_2.tableoid, t1_2.ctid
-                     Index Cond: ((t1_2.a > 5) AND (t1_2.a = 8))
-                     Filter: ((SubPlan 1) AND snoop(t1_2.a) AND leakproof(t1_2.a))
-               ->  Index Scan using t12_a_idx on public.t12 t1_3
-                     Output: t1_3.a, t1_3.tableoid, t1_3.ctid
-                     Index Cond: ((t1_3.a > 5) AND (t1_3.a = 8))
-                     Filter: ((SubPlan 1) AND snoop(t1_3.a) AND leakproof(t1_3.a))
-               ->  Index Scan using t111_a_idx on public.t111 t1_4
-                     Output: t1_4.a, t1_4.tableoid, t1_4.ctid
-                     Index Cond: ((t1_4.a > 5) AND (t1_4.a = 8))
-                     Filter: ((SubPlan 1) AND snoop(t1_4.a) AND leakproof(t1_4.a))
-(30 rows)
-
-UPDATE v1 SET a=a+1 WHERE snoop(a) AND leakproof(a) AND a = 8;
-NOTICE:  snooped value: 8
-NOTICE:  snooped value: 8
-NOTICE:  snooped value: 8
-NOTICE:  snooped value: 8
-SELECT * FROM v1 WHERE b=8;
- a | b |  c   |  d   
----+---+------+------
- 9 | 8 | t1   | t11d
- 9 | 8 | t11  | t11d
- 9 | 8 | t12  | t11d
- 9 | 8 | t111 | t11d
-(4 rows)
-
-DELETE FROM v1 WHERE snoop(a) AND leakproof(a); -- should not delete everything, just where a>5
-NOTICE:  snooped value: 6
-NOTICE:  snooped value: 7
-NOTICE:  snooped value: 9
-NOTICE:  snooped value: 10
-NOTICE:  snooped value: 9
-NOTICE:  snooped value: 6
-NOTICE:  snooped value: 7
-NOTICE:  snooped value: 9
-NOTICE:  snooped value: 10
-NOTICE:  snooped value: 9
-NOTICE:  snooped value: 6
-NOTICE:  snooped value: 7
-NOTICE:  snooped value: 9
-NOTICE:  snooped value: 10
-NOTICE:  snooped value: 9
-NOTICE:  snooped value: 6
-NOTICE:  snooped value: 7
-NOTICE:  snooped value: 9
-NOTICE:  snooped value: 10
-NOTICE:  snooped value: 9
-TABLE t1; -- verify all a<=5 are intact
- a | b |  c   
----+---+------
- 1 | 1 | t1
- 2 | 2 | t1
- 3 | 3 | t1
- 4 | 4 | t1
- 5 | 5 | t1
- 1 | 1 | t11
- 2 | 2 | t11
- 3 | 3 | t11
- 4 | 4 | t11
- 5 | 5 | t11
- 1 | 1 | t12
- 2 | 2 | t12
- 3 | 3 | t12
- 4 | 4 | t12
- 5 | 5 | t12
- 1 | 1 | t111
- 2 | 2 | t111
- 3 | 3 | t111
- 4 | 4 | t111
- 5 | 5 | t111
-(20 rows)
-
-DROP TABLE t1, t11, t12, t111 CASCADE;
-NOTICE:  drop cascades to view v1
-DROP FUNCTION snoop(anyelement);
-DROP FUNCTION leakproof(anyelement);
-CREATE TABLE tx1 (a integer);
-CREATE TABLE tx2 (b integer);
-CREATE TABLE tx3 (c integer);
-CREATE VIEW vx1 AS SELECT a FROM tx1 WHERE EXISTS(SELECT 1 FROM tx2 JOIN tx3 ON b=c);
-INSERT INTO vx1 values (1);
-SELECT * FROM tx1;
- a 
----
- 1
-(1 row)
-
-SELECT * FROM vx1;
- a 
----
-(0 rows)
-
-DROP VIEW vx1;
-DROP TABLE tx1;
-DROP TABLE tx2;
-DROP TABLE tx3;
-CREATE TABLE tx1 (a integer);
-CREATE TABLE tx2 (b integer);
-CREATE TABLE tx3 (c integer);
-CREATE VIEW vx1 AS SELECT a FROM tx1 WHERE EXISTS(SELECT 1 FROM tx2 JOIN tx3 ON b=c);
-INSERT INTO vx1 VALUES (1);
-INSERT INTO vx1 VALUES (1);
-SELECT * FROM tx1;
- a 
----
- 1
- 1
-(2 rows)
-
-SELECT * FROM vx1;
- a 
----
-(0 rows)
-
-DROP VIEW vx1;
-DROP TABLE tx1;
-DROP TABLE tx2;
-DROP TABLE tx3;
-CREATE TABLE tx1 (a integer, b integer);
-CREATE TABLE tx2 (b integer, c integer);
-CREATE TABLE tx3 (c integer, d integer);
-ALTER TABLE tx1 DROP COLUMN b;
-ALTER TABLE tx2 DROP COLUMN c;
-ALTER TABLE tx3 DROP COLUMN d;
-CREATE VIEW vx1 AS SELECT a FROM tx1 WHERE EXISTS(SELECT 1 FROM tx2 JOIN tx3 ON b=c);
-INSERT INTO vx1 VALUES (1);
-INSERT INTO vx1 VALUES (1);
-SELECT * FROM tx1;
- a 
----
- 1
- 1
-(2 rows)
-
-SELECT * FROM vx1;
- a 
----
-(0 rows)
-
-DROP VIEW vx1;
-DROP TABLE tx1;
-DROP TABLE tx2;
-DROP TABLE tx3;
---
--- Test handling of vars from correlated subqueries in quals from outer
--- security barrier views, per bug #13988
---
-CREATE TABLE t1 (a int, b text, c int);
-INSERT INTO t1 VALUES (1, 'one', 10);
-CREATE TABLE t2 (cc int);
-INSERT INTO t2 VALUES (10), (20);
-CREATE VIEW v1 WITH (security_barrier = true) AS
-  SELECT * FROM t1 WHERE (a > 0)
-  WITH CHECK OPTION;
-CREATE VIEW v2 WITH (security_barrier = true) AS
-  SELECT * FROM v1 WHERE EXISTS (SELECT 1 FROM t2 WHERE t2.cc = v1.c)
-  WITH CHECK OPTION;
-INSERT INTO v2 VALUES (2, 'two', 20); -- ok
-INSERT INTO v2 VALUES (-2, 'minus two', 20); -- not allowed
-ERROR:  new row violates check option for view "v1"
-DETAIL:  Failing row contains (-2, minus two, 20).
-INSERT INTO v2 VALUES (3, 'three', 30); -- not allowed
-ERROR:  new row violates check option for view "v2"
-DETAIL:  Failing row contains (3, three, 30).
-UPDATE v2 SET b = 'ONE' WHERE a = 1; -- ok
-UPDATE v2 SET a = -1 WHERE a = 1; -- not allowed
-ERROR:  new row violates check option for view "v1"
-DETAIL:  Failing row contains (-1, ONE, 10).
-UPDATE v2 SET c = 30 WHERE a = 1; -- not allowed
-ERROR:  new row violates check option for view "v2"
-DETAIL:  Failing row contains (1, ONE, 30).
-DELETE FROM v2 WHERE a = 2; -- ok
-SELECT * FROM v2;
- a |  b  | c  
----+-----+----
- 1 | ONE | 10
-(1 row)
-
-DROP VIEW v2;
-DROP VIEW v1;
-DROP TABLE t2;
-DROP TABLE t1;
---
--- Test CREATE OR REPLACE VIEW turning a non-updatable view into an
--- auto-updatable view and adding check options in a single step
---
-CREATE TABLE t1 (a int, b text);
-CREATE VIEW v1 AS SELECT null::int AS a;
-CREATE OR REPLACE VIEW v1 AS SELECT * FROM t1 WHERE a > 0 WITH CHECK OPTION;
-INSERT INTO v1 VALUES (1, 'ok'); -- ok
-INSERT INTO v1 VALUES (-1, 'invalid'); -- should fail
-ERROR:  new row violates check option for view "v1"
-DETAIL:  Failing row contains (-1, invalid).
-DROP VIEW v1;
-DROP TABLE t1;
--- check that an auto-updatable view on a partitioned table works correctly
-create table uv_pt (a int, b int, v varchar) partition by range (a, b);
-create table uv_pt1 (b int not null, v varchar, a int not null) partition by range (b);
-create table uv_pt11 (like uv_pt1);
-alter table uv_pt11 drop a;
-alter table uv_pt11 add a int;
-alter table uv_pt11 drop a;
-alter table uv_pt11 add a int not null;
-alter table uv_pt1 attach partition uv_pt11 for values from (2) to (5);
-alter table uv_pt attach partition uv_pt1 for values from (1, 2) to (1, 10);
-create view uv_ptv as select * from uv_pt;
-select events & 4 != 0 AS upd,
-       events & 8 != 0 AS ins,
-       events & 16 != 0 AS del
-  from pg_catalog.pg_relation_is_updatable('uv_pt'::regclass, false) t(events);
- upd | ins | del 
------+-----+-----
- t   | t   | t
-(1 row)
-
-select pg_catalog.pg_column_is_updatable('uv_pt'::regclass, 1::smallint, false);
- pg_column_is_updatable 
-------------------------
- t
-(1 row)
-
-select pg_catalog.pg_column_is_updatable('uv_pt'::regclass, 2::smallint, false);
- pg_column_is_updatable 
-------------------------
- t
-(1 row)
-
-select table_name, is_updatable, is_insertable_into
-  from information_schema.views where table_name = 'uv_ptv';
- table_name | is_updatable | is_insertable_into 
-------------+--------------+--------------------
- uv_ptv     | YES          | YES
-(1 row)
-
-select table_name, column_name, is_updatable
-  from information_schema.columns where table_name = 'uv_ptv' order by column_name;
- table_name | column_name | is_updatable 
-------------+-------------+--------------
- uv_ptv     | a           | YES
- uv_ptv     | b           | YES
- uv_ptv     | v           | YES
-(3 rows)
-
-insert into uv_ptv values (1, 2);
-select tableoid::regclass, * from uv_pt;
- tableoid | a | b | v 
-----------+---+---+---
- uv_pt11  | 1 | 2 | 
-(1 row)
-
-create view uv_ptv_wco as select * from uv_pt where a = 0 with check option;
-insert into uv_ptv_wco values (1, 2);
-ERROR:  new row violates check option for view "uv_ptv_wco"
-DETAIL:  Failing row contains (1, 2, null).
-drop view uv_ptv, uv_ptv_wco;
-drop table uv_pt, uv_pt1, uv_pt11;
--- check that wholerow vars appearing in WITH CHECK OPTION constraint expressions
--- work fine with partitioned tables
-create table wcowrtest (a int) partition by list (a);
-create table wcowrtest1 partition of wcowrtest for values in (1);
-create view wcowrtest_v as select * from wcowrtest where wcowrtest = '(2)'::wcowrtest with check option;
-insert into wcowrtest_v values (1);
-ERROR:  new row violates check option for view "wcowrtest_v"
-DETAIL:  Failing row contains (1).
-alter table wcowrtest add b text;
-create table wcowrtest2 (b text, c int, a int);
-alter table wcowrtest2 drop c;
-alter table wcowrtest attach partition wcowrtest2 for values in (2);
-create table sometable (a int, b text);
-insert into sometable values (1, 'a'), (2, 'b');
-create view wcowrtest_v2 as
-    select *
-      from wcowrtest r
-      where r in (select s from sometable s where r.a = s.a)
-with check option;
--- WITH CHECK qual will be processed with wcowrtest2's
--- rowtype after tuple-routing
-insert into wcowrtest_v2 values (2, 'no such row in sometable');
-ERROR:  new row violates check option for view "wcowrtest_v2"
-DETAIL:  Failing row contains (2, no such row in sometable).
-drop view wcowrtest_v, wcowrtest_v2;
-drop table wcowrtest, sometable;
--- Check INSERT .. ON CONFLICT DO UPDATE works correctly when the view's
--- columns are named and ordered differently than the underlying table's.
-create table uv_iocu_tab (a text unique, b float);
-insert into uv_iocu_tab values ('xyxyxy', 0);
-create view uv_iocu_view as
-   select b, b+1 as c, a, '2.0'::text as two from uv_iocu_tab;
-insert into uv_iocu_view (a, b) values ('xyxyxy', 1)
-   on conflict (a) do update set b = uv_iocu_view.b;
-select * from uv_iocu_tab;
-   a    | b 
---------+---
- xyxyxy | 0
-(1 row)
-
-insert into uv_iocu_view (a, b) values ('xyxyxy', 1)
-   on conflict (a) do update set b = excluded.b;
-select * from uv_iocu_tab;
-   a    | b 
---------+---
- xyxyxy | 1
-(1 row)
-
--- OK to access view columns that are not present in underlying base
--- relation in the ON CONFLICT portion of the query
-insert into uv_iocu_view (a, b) values ('xyxyxy', 3)
-   on conflict (a) do update set b = cast(excluded.two as float);
-select * from uv_iocu_tab;
-   a    | b 
---------+---
- xyxyxy | 2
-(1 row)
-
-explain (costs off)
-insert into uv_iocu_view (a, b) values ('xyxyxy', 3)
-   on conflict (a) do update set b = excluded.b where excluded.c > 0;
-                                    QUERY PLAN                                     
------------------------------------------------------------------------------------
- Insert on uv_iocu_tab
-   Conflict Resolution: UPDATE
-   Conflict Arbiter Indexes: uv_iocu_tab_a_key
-   Conflict Filter: ((excluded.b + '1'::double precision) > '0'::double precision)
-   ->  Result
-(5 rows)
-
-insert into uv_iocu_view (a, b) values ('xyxyxy', 3)
-   on conflict (a) do update set b = excluded.b where excluded.c > 0;
-select * from uv_iocu_tab;
-   a    | b 
---------+---
- xyxyxy | 3
-(1 row)
-
-drop view uv_iocu_view;
-drop table uv_iocu_tab;
--- Test whole-row references to the view
-create table uv_iocu_tab (a int unique, b text);
-create view uv_iocu_view as
-    select b as bb, a as aa, uv_iocu_tab::text as cc from uv_iocu_tab;
-insert into uv_iocu_view (aa,bb) values (1,'x');
-explain (costs off)
-insert into uv_iocu_view (aa,bb) values (1,'y')
-   on conflict (aa) do update set bb = 'Rejected: '||excluded.*
-   where excluded.aa > 0
-   and excluded.bb != ''
-   and excluded.cc is not null;
-                                               QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
- Insert on uv_iocu_tab
-   Conflict Resolution: UPDATE
-   Conflict Arbiter Indexes: uv_iocu_tab_a_key
-   Conflict Filter: ((excluded.a > 0) AND (excluded.b <> ''::text) AND ((excluded.*)::text IS NOT NULL))
-   ->  Result
-(5 rows)
-
-insert into uv_iocu_view (aa,bb) values (1,'y')
-   on conflict (aa) do update set bb = 'Rejected: '||excluded.*
-   where excluded.aa > 0
-   and excluded.bb != ''
-   and excluded.cc is not null;
-select * from uv_iocu_view;
-           bb            | aa |               cc                
--------------------------+----+---------------------------------
- Rejected: (y,1,"(1,y)") |  1 | (1,"Rejected: (y,1,""(1,y)"")")
-(1 row)
-
--- Test omitting a column of the base relation
-delete from uv_iocu_view;
-insert into uv_iocu_view (aa,bb) values (1,'x');
-insert into uv_iocu_view (aa) values (1)
-   on conflict (aa) do update set bb = 'Rejected: '||excluded.*;
-select * from uv_iocu_view;
-          bb           | aa |              cc               
------------------------+----+-------------------------------
- Rejected: (,1,"(1,)") |  1 | (1,"Rejected: (,1,""(1,)"")")
-(1 row)
-
-alter table uv_iocu_tab alter column b set default 'table default';
-insert into uv_iocu_view (aa) values (1)
-   on conflict (aa) do update set bb = 'Rejected: '||excluded.*;
-select * from uv_iocu_view;
-                          bb                           | aa |                                 cc                                  
--------------------------------------------------------+----+---------------------------------------------------------------------
- Rejected: ("table default",1,"(1,""table default"")") |  1 | (1,"Rejected: (""table default"",1,""(1,""""table default"""")"")")
-(1 row)
-
-alter view uv_iocu_view alter column bb set default 'view default';
-insert into uv_iocu_view (aa) values (1)
-   on conflict (aa) do update set bb = 'Rejected: '||excluded.*;
-select * from uv_iocu_view;
-                         bb                          | aa |                                cc                                 
------------------------------------------------------+----+-------------------------------------------------------------------
- Rejected: ("view default",1,"(1,""view default"")") |  1 | (1,"Rejected: (""view default"",1,""(1,""""view default"""")"")")
-(1 row)
-
--- Should fail to update non-updatable columns
-insert into uv_iocu_view (aa) values (1)
-   on conflict (aa) do update set cc = 'XXX';
-ERROR:  cannot insert into column "cc" of view "uv_iocu_view"
-DETAIL:  View columns that are not columns of their base relation are not updatable.
-drop view uv_iocu_view;
-drop table uv_iocu_tab;
--- ON CONFLICT DO UPDATE permissions checks
-create user regress_view_user1;
-create user regress_view_user2;
-set session authorization regress_view_user1;
-create table base_tbl(a int unique, b text, c float);
-insert into base_tbl values (1,'xxx',1.0);
-create view rw_view1 as select b as bb, c as cc, a as aa from base_tbl;
-grant select (aa,bb) on rw_view1 to regress_view_user2;
-grant insert on rw_view1 to regress_view_user2;
-grant update (bb) on rw_view1 to regress_view_user2;
-set session authorization regress_view_user2;
-insert into rw_view1 values ('yyy',2.0,1)
-  on conflict (aa) do update set bb = excluded.cc; -- Not allowed
-ERROR:  permission denied for view rw_view1
-insert into rw_view1 values ('yyy',2.0,1)
-  on conflict (aa) do update set bb = rw_view1.cc; -- Not allowed
-ERROR:  permission denied for view rw_view1
-insert into rw_view1 values ('yyy',2.0,1)
-  on conflict (aa) do update set bb = excluded.bb; -- OK
-insert into rw_view1 values ('zzz',2.0,1)
-  on conflict (aa) do update set bb = rw_view1.bb||'xxx'; -- OK
-insert into rw_view1 values ('zzz',2.0,1)
-  on conflict (aa) do update set cc = 3.0; -- Not allowed
-ERROR:  permission denied for view rw_view1
-reset session authorization;
-select * from base_tbl;
- a |   b    | c 
----+--------+---
- 1 | yyyxxx | 1
-(1 row)
-
-set session authorization regress_view_user1;
-grant select (a,b) on base_tbl to regress_view_user2;
-grant insert (a,b) on base_tbl to regress_view_user2;
-grant update (a,b) on base_tbl to regress_view_user2;
-set session authorization regress_view_user2;
-create view rw_view2 as select b as bb, c as cc, a as aa from base_tbl;
-insert into rw_view2 (aa,bb) values (1,'xxx')
-  on conflict (aa) do update set bb = excluded.bb; -- Not allowed
-ERROR:  permission denied for table base_tbl
-create view rw_view3 as select b as bb, a as aa from base_tbl;
-insert into rw_view3 (aa,bb) values (1,'xxx')
-  on conflict (aa) do update set bb = excluded.bb; -- OK
-reset session authorization;
-select * from base_tbl;
- a |  b  | c 
----+-----+---
- 1 | xxx | 1
-(1 row)
-
-set session authorization regress_view_user2;
-create view rw_view4 as select aa, bb, cc FROM rw_view1;
-insert into rw_view4 (aa,bb) values (1,'yyy')
-  on conflict (aa) do update set bb = excluded.bb; -- Not allowed
-ERROR:  permission denied for view rw_view1
-create view rw_view5 as select aa, bb FROM rw_view1;
-insert into rw_view5 (aa,bb) values (1,'yyy')
-  on conflict (aa) do update set bb = excluded.bb; -- OK
-reset session authorization;
-select * from base_tbl;
- a |  b  | c 
----+-----+---
- 1 | yyy | 1
-(1 row)
-
-drop view rw_view5;
-drop view rw_view4;
-drop view rw_view3;
-drop view rw_view2;
-drop view rw_view1;
-drop table base_tbl;
-drop user regress_view_user1;
-drop user regress_view_user2;
--- Test single- and multi-row inserts with table and view defaults.
--- Table defaults should be used, unless overridden by view defaults.
-create table base_tab_def (a int, b text default 'Table default',
-                           c text default 'Table default', d text, e text);
-create view base_tab_def_view as select * from base_tab_def;
-alter view base_tab_def_view alter b set default 'View default';
-alter view base_tab_def_view alter d set default 'View default';
-insert into base_tab_def values (1);
-insert into base_tab_def values (2), (3);
-insert into base_tab_def values (4, default, default, default, default);
-insert into base_tab_def values (5, default, default, default, default),
-                                (6, default, default, default, default);
-insert into base_tab_def_view values (11);
-insert into base_tab_def_view values (12), (13);
-insert into base_tab_def_view values (14, default, default, default, default);
-insert into base_tab_def_view values (15, default, default, default, default),
-                                     (16, default, default, default, default);
-insert into base_tab_def_view values (17), (default);
-select * from base_tab_def order by a;
- a  |       b       |       c       |      d       | e 
-----+---------------+---------------+--------------+---
-  1 | Table default | Table default |              | 
-  2 | Table default | Table default |              | 
-  3 | Table default | Table default |              | 
-  4 | Table default | Table default |              | 
-  5 | Table default | Table default |              | 
-  6 | Table default | Table default |              | 
- 11 | View default  | Table default | View default | 
- 12 | View default  | Table default | View default | 
- 13 | View default  | Table default | View default | 
- 14 | View default  | Table default | View default | 
- 15 | View default  | Table default | View default | 
- 16 | View default  | Table default | View default | 
- 17 | View default  | Table default | View default | 
-    | View default  | Table default | View default | 
-(14 rows)
-
--- Adding an INSTEAD OF trigger should cause NULLs to be inserted instead of
--- table defaults, where there are no view defaults.
-create function base_tab_def_view_instrig_func() returns trigger
-as
-$$
-begin
-  insert into base_tab_def values (new.a, new.b, new.c, new.d, new.e);
-  return new;
-end;
-$$
-language plpgsql;
-create trigger base_tab_def_view_instrig instead of insert on base_tab_def_view
-  for each row execute function base_tab_def_view_instrig_func();
-truncate base_tab_def;
-insert into base_tab_def values (1);
-insert into base_tab_def values (2), (3);
-insert into base_tab_def values (4, default, default, default, default);
-insert into base_tab_def values (5, default, default, default, default),
-                                (6, default, default, default, default);
-insert into base_tab_def_view values (11);
-insert into base_tab_def_view values (12), (13);
-insert into base_tab_def_view values (14, default, default, default, default);
-insert into base_tab_def_view values (15, default, default, default, default),
-                                     (16, default, default, default, default);
-insert into base_tab_def_view values (17), (default);
-select * from base_tab_def order by a;
- a  |       b       |       c       |      d       | e 
-----+---------------+---------------+--------------+---
-  1 | Table default | Table default |              | 
-  2 | Table default | Table default |              | 
-  3 | Table default | Table default |              | 
-  4 | Table default | Table default |              | 
-  5 | Table default | Table default |              | 
-  6 | Table default | Table default |              | 
- 11 | View default  |               | View default | 
- 12 | View default  |               | View default | 
- 13 | View default  |               | View default | 
- 14 | View default  |               | View default | 
- 15 | View default  |               | View default | 
- 16 | View default  |               | View default | 
- 17 | View default  |               | View default | 
-    | View default  |               | View default | 
-(14 rows)
-
--- Using an unconditional DO INSTEAD rule should also cause NULLs to be
--- inserted where there are no view defaults.
-drop trigger base_tab_def_view_instrig on base_tab_def_view;
-drop function base_tab_def_view_instrig_func;
-create rule base_tab_def_view_ins_rule as on insert to base_tab_def_view
-  do instead insert into base_tab_def values (new.a, new.b, new.c, new.d, new.e);
-truncate base_tab_def;
-insert into base_tab_def values (1);
-insert into base_tab_def values (2), (3);
-insert into base_tab_def values (4, default, default, default, default);
-insert into base_tab_def values (5, default, default, default, default),
-                                (6, default, default, default, default);
-insert into base_tab_def_view values (11);
-insert into base_tab_def_view values (12), (13);
-insert into base_tab_def_view values (14, default, default, default, default);
-insert into base_tab_def_view values (15, default, default, default, default),
-                                     (16, default, default, default, default);
-insert into base_tab_def_view values (17), (default);
-select * from base_tab_def order by a;
- a  |       b       |       c       |      d       | e 
-----+---------------+---------------+--------------+---
-  1 | Table default | Table default |              | 
-  2 | Table default | Table default |              | 
-  3 | Table default | Table default |              | 
-  4 | Table default | Table default |              | 
-  5 | Table default | Table default |              | 
-  6 | Table default | Table default |              | 
- 11 | View default  |               | View default | 
- 12 | View default  |               | View default | 
- 13 | View default  |               | View default | 
- 14 | View default  |               | View default | 
- 15 | View default  |               | View default | 
- 16 | View default  |               | View default | 
- 17 | View default  |               | View default | 
-    | View default  |               | View default | 
-(14 rows)
-
--- A DO ALSO rule should cause each row to be inserted twice. The first
--- insert should behave the same as an auto-updatable view (using table
--- defaults, unless overridden by view defaults). The second insert should
--- behave the same as a rule-updatable view (inserting NULLs where there are
--- no view defaults).
-drop rule base_tab_def_view_ins_rule on base_tab_def_view;
-create rule base_tab_def_view_ins_rule as on insert to base_tab_def_view
-  do also insert into base_tab_def values (new.a, new.b, new.c, new.d, new.e);
-truncate base_tab_def;
-insert into base_tab_def values (1);
-insert into base_tab_def values (2), (3);
-insert into base_tab_def values (4, default, default, default, default);
-insert into base_tab_def values (5, default, default, default, default),
-                                (6, default, default, default, default);
-insert into base_tab_def_view values (11);
-insert into base_tab_def_view values (12), (13);
-insert into base_tab_def_view values (14, default, default, default, default);
-insert into base_tab_def_view values (15, default, default, default, default),
-                                     (16, default, default, default, default);
-insert into base_tab_def_view values (17), (default);
-select * from base_tab_def order by a, c NULLS LAST;
- a  |       b       |       c       |      d       | e 
-----+---------------+---------------+--------------+---
-  1 | Table default | Table default |              | 
-  2 | Table default | Table default |              | 
-  3 | Table default | Table default |              | 
-  4 | Table default | Table default |              | 
-  5 | Table default | Table default |              | 
-  6 | Table default | Table default |              | 
- 11 | View default  | Table default | View default | 
- 11 | View default  |               | View default | 
- 12 | View default  | Table default | View default | 
- 12 | View default  |               | View default | 
- 13 | View default  | Table default | View default | 
- 13 | View default  |               | View default | 
- 14 | View default  | Table default | View default | 
- 14 | View default  |               | View default | 
- 15 | View default  | Table default | View default | 
- 15 | View default  |               | View default | 
- 16 | View default  | Table default | View default | 
- 16 | View default  |               | View default | 
- 17 | View default  | Table default | View default | 
- 17 | View default  |               | View default | 
-    | View default  | Table default | View default | 
-    | View default  |               | View default | 
-(22 rows)
-
-drop view base_tab_def_view;
-drop table base_tab_def;
--- Test defaults with array assignments
-create table base_tab (a serial, b int[], c text, d text default 'Table default');
-create view base_tab_view as select c, a, b from base_tab;
-alter view base_tab_view alter column c set default 'View default';
-insert into base_tab_view (b[1], b[2], c, b[5], b[4], a, b[3])
-values (1, 2, default, 5, 4, default, 3), (10, 11, 'C value', 14, 13, 100, 12);
-select * from base_tab order by a;
-  a  |        b         |      c       |       d       
------+------------------+--------------+---------------
-   1 | {1,2,3,4,5}      | View default | Table default
- 100 | {10,11,12,13,14} | C value      | Table default
-(2 rows)
+dyld: lazy symbol binding failed: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
+
+dyld: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
 
-drop view base_tab_view;
-drop table base_tab;
diff -U3 /Users/kenaniah/workspace/postgres/src/test/regress/expected/sanity_check.out /Users/kenaniah/workspace/postgres/src/test/regress/results/sanity_check.out
--- /Users/kenaniah/workspace/postgres/src/test/regress/expected/sanity_check.out	2021-10-03 18:09:17.000000000 -0700
+++ /Users/kenaniah/workspace/postgres/src/test/regress/results/sanity_check.out	2021-10-03 20:08:15.000000000 -0700
@@ -16,8 +16,13 @@
 aggtest|f
 array_index_op_test|t
 array_op_test|f
+asexecute|f
+asselect|f
 b|f
 b_star|f
+base_table|f
+base_table2|f
+base_tbl|f
 bit_defaults|f
 box_tbl|f
 bprime|f
@@ -26,6 +31,7 @@
 bt_name_heap|t
 bt_txt_heap|t
 c|f
+c1|f
 c_star|f
 char_tbl|f
 check2_tbl|f
@@ -33,13 +39,14 @@
 circle_tbl|t
 city|f
 copy_tbl|f
+copydml_test|f
+cp_test|f
 d|f
 d_star|f
 date_tbl|f
 default_tbl|f
 defaultexpr_tbl|f
 dept|f
-dupindexcols|t
 e_star|f
 emp|f
 equipment_r|f
@@ -48,38 +55,27 @@
 fast_emp4000|t
 float4_tbl|f
 float8_tbl|f
-func_index_heap|t
-hash_f8_heap|t
-hash_i4_heap|t
-hash_name_heap|t
-hash_txt_heap|t
+foo|t
+hash_f8_heap|f
+hash_i4_heap|f
+hash_name_heap|f
+hash_txt_heap|f
 hobbies_r|f
 ihighway|t
 inet_tbl|f
 insert_tbl|f
+inserttest|f
+inserttest2|f
 int2_tbl|f
 int4_tbl|f
 int8_tbl|f
 interval_tbl|f
-invalid_check_con|f
-invalid_check_con_child|f
 iportaltest|f
 kd_point_tbl|t
 line_tbl|f
 log_table|f
 lseg_tbl|f
 main_table|f
-mlparted|f
-mlparted1|f
-mlparted11|f
-mlparted12|f
-mlparted2|f
-mlparted3|f
-mlparted4|f
-mlparted_def|f
-mlparted_def1|f
-mlparted_def2|f
-mlparted_defd|f
 money_data|f
 num_data|f
 num_exp_add|t
@@ -97,11 +93,12 @@
 numrange_test|t
 onek|t
 onek2|t
+p1|f
+partitioned|f
+partitioned2|f
 path_tbl|f
 person|f
 persons|f
-persons2|t
-persons3|t
 pg_aggregate|t
 pg_am|t
 pg_amop|t
@@ -184,6 +181,8 @@
 sql_sizing|f
 stud_emp|f
 student|f
+t1|f
+t2|f
 tableam_parted_a_heap2|f
 tableam_parted_b_heap2|f
 tableam_parted_c_heap2|f
@@ -191,14 +190,16 @@
 tableam_parted_heap2|f
 tableam_tbl_heap2|f
 tableam_tblas_heap2|f
-tbl_include_box|t
-tbl_include_box_pk|f
-tbl_include_pk|t
+tbl1|f
+tbl2|f
+tbl3|f
+tbl4|f
+tbl_gist|t
 tbl_include_reg|t
-tbl_include_unique1|t
-tbl_include_unique2|f
 tenk1|t
 tenk2|t
+test1|f
+test2|f
 test_range_excl|t
 test_range_gist|t
 test_range_spgist|t
@@ -211,11 +212,6 @@
 timestamptz_tbl|f
 timetz_tbl|f
 tmp|f
-trigger_parted|t
-trigger_parted_p1|t
-trigger_parted_p1_1|t
-trigger_parted_p2|t
-trigger_parted_p2_2|t
 varchar_tbl|f
 view_base_table|t
 -- restore normal output mode
diff -U3 /Users/kenaniah/workspace/postgres/src/test/regress/expected/update.out /Users/kenaniah/workspace/postgres/src/test/regress/results/update.out
--- /Users/kenaniah/workspace/postgres/src/test/regress/expected/update.out	2021-10-03 17:41:49.000000000 -0700
+++ /Users/kenaniah/workspace/postgres/src/test/regress/results/update.out	2021-10-03 20:08:16.000000000 -0700
@@ -743,286 +743,11 @@
 :init_range_parted;
 create table part_def partition of range_parted default;
 \d+ part_def
-                                       Table "public.part_def"
- Column |       Type        | Collation | Nullable | Default | Storage  | Stats target | Description 
---------+-------------------+-----------+----------+---------+----------+--------------+-------------
- a      | text              |           |          |         | extended |              | 
- b      | bigint            |           |          |         | plain    |              | 
- c      | numeric           |           |          |         | main     |              | 
- d      | integer           |           |          |         | plain    |              | 
- e      | character varying |           |          |         | extended |              | 
-Partition of: range_parted DEFAULT
-Partition constraint: (NOT ((a IS NOT NULL) AND (b IS NOT NULL) AND (((a = 'a'::text) AND (b >= '1'::bigint) AND (b < '10'::bigint)) OR ((a = 'a'::text) AND (b >= '10'::bigint) AND (b < '20'::bigint)) OR ((a = 'b'::text) AND (b >= '1'::bigint) AND (b < '10'::bigint)) OR ((a = 'b'::text) AND (b >= '10'::bigint) AND (b < '20'::bigint)) OR ((a = 'b'::text) AND (b >= '20'::bigint) AND (b < '30'::bigint)))))
+dyld: lazy symbol binding failed: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
+
+dyld: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
 
-insert into range_parted values ('c', 9);
--- ok
-update part_def set a = 'd' where a = 'c';
--- fail
-update part_def set a = 'a' where a = 'd';
-ERROR:  new row for relation "part_def" violates partition constraint
-DETAIL:  Failing row contains (a, 9, null, null, null).
-:show_data;
-    partname    | a | b  |  c  | d  | e 
-----------------+---+----+-----+----+---
- part_a_10_a_20 | a | 10 | 200 |  1 | 
- part_a_1_a_10  | a |  1 |   1 |  1 | 
- part_c_1_100   | b | 12 |  96 |  1 | 
- part_c_1_100   | b | 13 |  97 |  2 | 
- part_d_15_20   | b | 15 | 105 | 16 | 
- part_d_15_20   | b | 17 | 105 | 19 | 
- part_def       | d |  9 |     |    | 
-(7 rows)
-
--- Update row movement from non-default to default partition.
--- fail, default partition is not under part_a_10_a_20;
-UPDATE part_a_10_a_20 set a = 'ad' WHERE a = 'a';
-ERROR:  new row for relation "part_a_10_a_20" violates partition constraint
-DETAIL:  Failing row contains (ad, 10, 200, 1, null).
--- ok
-UPDATE range_parted set a = 'ad' WHERE a = 'a';
-UPDATE range_parted set a = 'bd' WHERE a = 'b';
-:show_data;
- partname | a  | b  |  c  | d  | e 
-----------+----+----+-----+----+---
- part_def | ad |  1 |   1 |  1 | 
- part_def | ad | 10 | 200 |  1 | 
- part_def | bd | 12 |  96 |  1 | 
- part_def | bd | 13 |  97 |  2 | 
- part_def | bd | 15 | 105 | 16 | 
- part_def | bd | 17 | 105 | 19 | 
- part_def | d  |  9 |     |    | 
-(7 rows)
-
--- Update row movement from default to non-default partitions.
--- ok
-UPDATE range_parted set a = 'a' WHERE a = 'ad';
-UPDATE range_parted set a = 'b' WHERE a = 'bd';
-:show_data;
-    partname    | a | b  |  c  | d  | e 
-----------------+---+----+-----+----+---
- part_a_10_a_20 | a | 10 | 200 |  1 | 
- part_a_1_a_10  | a |  1 |   1 |  1 | 
- part_c_1_100   | b | 12 |  96 |  1 | 
- part_c_1_100   | b | 13 |  97 |  2 | 
- part_d_15_20   | b | 15 | 105 | 16 | 
- part_d_15_20   | b | 17 | 105 | 19 | 
- part_def       | d |  9 |     |    | 
-(7 rows)
-
--- Cleanup: range_parted no longer needed.
-DROP TABLE range_parted;
-CREATE TABLE list_parted (
-	a text,
-	b int
-) PARTITION BY list (a);
-CREATE TABLE list_part1  PARTITION OF list_parted for VALUES in ('a', 'b');
-CREATE TABLE list_default PARTITION OF list_parted default;
-INSERT into list_part1 VALUES ('a', 1);
-INSERT into list_default VALUES ('d', 10);
--- fail
-UPDATE list_default set a = 'a' WHERE a = 'd';
-ERROR:  new row for relation "list_default" violates partition constraint
-DETAIL:  Failing row contains (a, 10).
--- ok
-UPDATE list_default set a = 'x' WHERE a = 'd';
-DROP TABLE list_parted;
--- Test retrieval of system columns with non-consistent partition row types.
--- This is only partially supported, as seen in the results.
-create table utrtest (a int, b text) partition by list (a);
-create table utr1 (a int check (a in (1)), q text, b text);
-create table utr2 (a int check (a in (2)), b text);
-alter table utr1 drop column q;
-alter table utrtest attach partition utr1 for values in (1);
-alter table utrtest attach partition utr2 for values in (2);
-insert into utrtest values (1, 'foo')
-  returning *, tableoid::regclass, xmin = pg_current_xact_id()::xid as xmin_ok;
- a |  b  | tableoid | xmin_ok 
----+-----+----------+---------
- 1 | foo | utr1     | t
-(1 row)
-
-insert into utrtest values (2, 'bar')
-  returning *, tableoid::regclass, xmin = pg_current_xact_id()::xid as xmin_ok;  -- fails
-ERROR:  cannot retrieve a system column in this context
-insert into utrtest values (2, 'bar')
-  returning *, tableoid::regclass;
- a |  b  | tableoid 
----+-----+----------
- 2 | bar | utr2
-(1 row)
-
-update utrtest set b = b || b from (values (1), (2)) s(x) where a = s.x
-  returning *, tableoid::regclass, xmin = pg_current_xact_id()::xid as xmin_ok;
- a |   b    | x | tableoid | xmin_ok 
----+--------+---+----------+---------
- 1 | foofoo | 1 | utr1     | t
- 2 | barbar | 2 | utr2     | t
-(2 rows)
-
-update utrtest set a = 3 - a from (values (1), (2)) s(x) where a = s.x
-  returning *, tableoid::regclass, xmin = pg_current_xact_id()::xid as xmin_ok;  -- fails
-ERROR:  cannot retrieve a system column in this context
-update utrtest set a = 3 - a from (values (1), (2)) s(x) where a = s.x
-  returning *, tableoid::regclass;
- a |   b    | x | tableoid 
----+--------+---+----------
- 2 | foofoo | 1 | utr2
- 1 | barbar | 2 | utr1
-(2 rows)
-
-delete from utrtest
-  returning *, tableoid::regclass, xmax = pg_current_xact_id()::xid as xmax_ok;
- a |   b    | tableoid | xmax_ok 
----+--------+----------+---------
- 1 | barbar | utr1     | t
- 2 | foofoo | utr2     | t
-(2 rows)
-
-drop table utrtest;
---------------
--- Some more update-partition-key test scenarios below. This time use list
--- partitions.
---------------
--- Setup for list partitions
-CREATE TABLE list_parted (a numeric, b int, c int8) PARTITION BY list (a);
-CREATE TABLE sub_parted PARTITION OF list_parted for VALUES in (1) PARTITION BY list (b);
-CREATE TABLE sub_part1(b int, c int8, a numeric);
-ALTER TABLE sub_parted ATTACH PARTITION sub_part1 for VALUES in (1);
-CREATE TABLE sub_part2(b int, c int8, a numeric);
-ALTER TABLE sub_parted ATTACH PARTITION sub_part2 for VALUES in (2);
-CREATE TABLE list_part1(a numeric, b int, c int8);
-ALTER TABLE list_parted ATTACH PARTITION list_part1 for VALUES in (2,3);
-INSERT into list_parted VALUES (2,5,50);
-INSERT into list_parted VALUES (3,6,60);
-INSERT into sub_parted VALUES (1,1,60);
-INSERT into sub_parted VALUES (1,2,10);
--- Test partition constraint violation when intermediate ancestor is used and
--- constraint is inherited from upper root.
-UPDATE sub_parted set a = 2 WHERE c = 10;
-ERROR:  new row for relation "sub_parted" violates partition constraint
-DETAIL:  Failing row contains (2, 2, 10).
--- Test update-partition-key, where the unpruned partitions do not have their
--- partition keys updated.
-SELECT tableoid::regclass::text, * FROM list_parted WHERE a = 2 ORDER BY 1;
-  tableoid  | a | b | c  
-------------+---+---+----
- list_part1 | 2 | 5 | 50
-(1 row)
-
-UPDATE list_parted set b = c + a WHERE a = 2;
-SELECT tableoid::regclass::text, * FROM list_parted WHERE a = 2 ORDER BY 1;
-  tableoid  | a | b  | c  
-------------+---+----+----
- list_part1 | 2 | 52 | 50
-(1 row)
-
--- Test the case where BR UPDATE triggers change the partition key.
-CREATE FUNCTION func_parted_mod_b() returns trigger as $$
-BEGIN
-   NEW.b = 2; -- This is changing partition key column.
-   return NEW;
-END $$ LANGUAGE plpgsql;
-CREATE TRIGGER parted_mod_b before update on sub_part1
-   for each row execute procedure func_parted_mod_b();
-SELECT tableoid::regclass::text, * FROM list_parted ORDER BY 1, 2, 3, 4;
-  tableoid  | a | b  | c  
-------------+---+----+----
- list_part1 | 2 | 52 | 50
- list_part1 | 3 |  6 | 60
- sub_part1  | 1 |  1 | 60
- sub_part2  | 1 |  2 | 10
-(4 rows)
-
--- This should do the tuple routing even though there is no explicit
--- partition-key update, because there is a trigger on sub_part1.
-UPDATE list_parted set c = 70 WHERE b  = 1;
-SELECT tableoid::regclass::text, * FROM list_parted ORDER BY 1, 2, 3, 4;
-  tableoid  | a | b  | c  
-------------+---+----+----
- list_part1 | 2 | 52 | 50
- list_part1 | 3 |  6 | 60
- sub_part2  | 1 |  2 | 10
- sub_part2  | 1 |  2 | 70
-(4 rows)
-
-DROP TRIGGER parted_mod_b ON sub_part1;
--- If BR DELETE trigger prevented DELETE from happening, we should also skip
--- the INSERT if that delete is part of UPDATE=>DELETE+INSERT.
-CREATE OR REPLACE FUNCTION func_parted_mod_b() returns trigger as $$
-BEGIN
-   raise notice 'Trigger: Got OLD row %, but returning NULL', OLD;
-   return NULL;
-END $$ LANGUAGE plpgsql;
-CREATE TRIGGER trig_skip_delete before delete on sub_part2
-   for each row execute procedure func_parted_mod_b();
-UPDATE list_parted set b = 1 WHERE c = 70;
-NOTICE:  Trigger: Got OLD row (2,70,1), but returning NULL
-SELECT tableoid::regclass::text, * FROM list_parted ORDER BY 1, 2, 3, 4;
-  tableoid  | a | b  | c  
-------------+---+----+----
- list_part1 | 2 | 52 | 50
- list_part1 | 3 |  6 | 60
- sub_part2  | 1 |  2 | 10
- sub_part2  | 1 |  2 | 70
-(4 rows)
-
--- Drop the trigger. Now the row should be moved.
-DROP TRIGGER trig_skip_delete ON sub_part2;
-UPDATE list_parted set b = 1 WHERE c = 70;
-SELECT tableoid::regclass::text, * FROM list_parted ORDER BY 1, 2, 3, 4;
-  tableoid  | a | b  | c  
-------------+---+----+----
- list_part1 | 2 | 52 | 50
- list_part1 | 3 |  6 | 60
- sub_part1  | 1 |  1 | 70
- sub_part2  | 1 |  2 | 10
-(4 rows)
-
-DROP FUNCTION func_parted_mod_b();
--- UPDATE partition-key with FROM clause. If join produces multiple output
--- rows for the same row to be modified, we should tuple-route the row only
--- once. There should not be any rows inserted.
-CREATE TABLE non_parted (id int);
-INSERT into non_parted VALUES (1), (1), (1), (2), (2), (2), (3), (3), (3);
-UPDATE list_parted t1 set a = 2 FROM non_parted t2 WHERE t1.a = t2.id and a = 1;
-SELECT tableoid::regclass::text, * FROM list_parted ORDER BY 1, 2, 3, 4;
-  tableoid  | a | b  | c  
-------------+---+----+----
- list_part1 | 2 |  1 | 70
- list_part1 | 2 |  2 | 10
- list_part1 | 2 | 52 | 50
- list_part1 | 3 |  6 | 60
-(4 rows)
-
-DROP TABLE non_parted;
--- Cleanup: list_parted no longer needed.
-DROP TABLE list_parted;
--- create custom operator class and hash function, for the same reason
--- explained in alter_table.sql
-create or replace function dummy_hashint4(a int4, seed int8) returns int8 as
-$$ begin return (a + seed); end; $$ language 'plpgsql' immutable;
-create operator class custom_opclass for type int4 using hash as
-operator 1 = , function 2 dummy_hashint4(int4, int8);
-create table hash_parted (
-	a int,
-	b int
-) partition by hash (a custom_opclass, b custom_opclass);
-create table hpart1 partition of hash_parted for values with (modulus 2, remainder 1);
-create table hpart2 partition of hash_parted for values with (modulus 4, remainder 2);
-create table hpart3 partition of hash_parted for values with (modulus 8, remainder 0);
-create table hpart4 partition of hash_parted for values with (modulus 8, remainder 4);
-insert into hpart1 values (1, 1);
-insert into hpart2 values (2, 5);
-insert into hpart4 values (3, 4);
--- fail
-update hpart1 set a = 3, b=4 where a = 1;
-ERROR:  new row for relation "hpart1" violates partition constraint
-DETAIL:  Failing row contains (3, 4).
--- ok, row movement
-update hash_parted set b = b - 1 where b = 1;
--- ok
-update hash_parted set b = b + 8 where b = 1;
--- cleanup
-drop table hash_parted;
-drop operator class custom_opclass using hash;
-drop function dummy_hashint4(a int4, seed int8);
diff -U3 /Users/kenaniah/workspace/postgres/src/test/regress/expected/prepared_xacts.out /Users/kenaniah/workspace/postgres/src/test/regress/results/prepared_xacts.out
--- /Users/kenaniah/workspace/postgres/src/test/regress/expected/prepared_xacts.out	2021-10-03 17:41:49.000000000 -0700
+++ /Users/kenaniah/workspace/postgres/src/test/regress/results/prepared_xacts.out	2021-10-03 20:08:15.000000000 -0700
@@ -216,55 +216,11 @@
 rollback;
 -- Disconnect, we will continue testing in a different backend
 \c -
--- There should still be two prepared transactions
-SELECT gid FROM pg_prepared_xacts;
-     gid     
--------------
- regress-one
- regress-two
-(2 rows)
+dyld: lazy symbol binding failed: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
 
--- pxtest3 should still be locked because of the pending DROP
-begin;
-lock table pxtest3 in access share mode nowait;
-ERROR:  could not obtain lock on relation "pxtest3"
-rollback;
--- Commit table creation
-COMMIT PREPARED 'regress-one';
-\d pxtest2
-              Table "public.pxtest2"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
-
-SELECT * FROM pxtest2;
- a 
----
- 1
- 3
-(2 rows)
-
--- There should be one prepared transaction
-SELECT gid FROM pg_prepared_xacts;
-     gid     
--------------
- regress-two
-(1 row)
-
--- Commit table drop
-COMMIT PREPARED 'regress-two';
-SELECT * FROM pxtest3;
-ERROR:  relation "pxtest3" does not exist
-LINE 1: SELECT * FROM pxtest3;
-                      ^
--- There should be no prepared transactions
-SELECT gid FROM pg_prepared_xacts;
- gid 
------
-(0 rows)
+dyld: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
 
--- Clean up
-DROP TABLE pxtest2;
-DROP TABLE pxtest3;  -- will still be there if prepared xacts are disabled
-ERROR:  table "pxtest3" does not exist
-DROP TABLE pxtest4;
diff -U3 /Users/kenaniah/workspace/postgres/src/test/regress/expected/privileges.out /Users/kenaniah/workspace/postgres/src/test/regress/results/privileges.out
--- /Users/kenaniah/workspace/postgres/src/test/regress/expected/privileges.out	2021-10-03 17:41:49.000000000 -0700
+++ /Users/kenaniah/workspace/postgres/src/test/regress/results/privileges.out	2021-10-03 20:08:17.000000000 -0700
@@ -52,36 +52,57 @@
 (1 row)
 
 CREATE TABLE atest1 ( a int, b text );
+ERROR:  permission denied for schema public
+LINE 1: CREATE TABLE atest1 ( a int, b text );
+                     ^
 SELECT * FROM atest1;
- a | b 
----+---
-(0 rows)
-
+ERROR:  relation "atest1" does not exist
+LINE 1: SELECT * FROM atest1;
+                      ^
 INSERT INTO atest1 VALUES (1, 'one');
+ERROR:  relation "atest1" does not exist
+LINE 1: INSERT INTO atest1 VALUES (1, 'one');
+                    ^
 DELETE FROM atest1;
+ERROR:  relation "atest1" does not exist
+LINE 1: DELETE FROM atest1;
+                    ^
 UPDATE atest1 SET a = 1 WHERE b = 'blech';
+ERROR:  relation "atest1" does not exist
+LINE 1: UPDATE atest1 SET a = 1 WHERE b = 'blech';
+               ^
 TRUNCATE atest1;
+ERROR:  relation "atest1" does not exist
 BEGIN;
 LOCK atest1 IN ACCESS EXCLUSIVE MODE;
+ERROR:  relation "atest1" does not exist
 COMMIT;
 REVOKE ALL ON atest1 FROM PUBLIC;
+ERROR:  relation "atest1" does not exist
 SELECT * FROM atest1;
- a | b 
----+---
-(0 rows)
-
+ERROR:  relation "atest1" does not exist
+LINE 1: SELECT * FROM atest1;
+                      ^
 GRANT ALL ON atest1 TO regress_priv_user2;
+ERROR:  relation "atest1" does not exist
 GRANT SELECT ON atest1 TO regress_priv_user3, regress_priv_user4;
+ERROR:  relation "atest1" does not exist
 SELECT * FROM atest1;
- a | b 
----+---
-(0 rows)
-
+ERROR:  relation "atest1" does not exist
+LINE 1: SELECT * FROM atest1;
+                      ^
 CREATE TABLE atest2 (col1 varchar(10), col2 boolean);
+ERROR:  permission denied for schema public
+LINE 1: CREATE TABLE atest2 (col1 varchar(10), col2 boolean);
+                     ^
 GRANT SELECT ON atest2 TO regress_priv_user2;
+ERROR:  relation "atest2" does not exist
 GRANT UPDATE ON atest2 TO regress_priv_user3;
+ERROR:  relation "atest2" does not exist
 GRANT INSERT ON atest2 TO regress_priv_user4 GRANTED BY CURRENT_USER;
+ERROR:  relation "atest2" does not exist
 GRANT TRUNCATE ON atest2 TO regress_priv_user5 GRANTED BY CURRENT_ROLE;
+ERROR:  relation "atest2" does not exist
 GRANT TRUNCATE ON atest2 TO regress_priv_user4 GRANTED BY regress_priv_user5;  -- error
 ERROR:  grantor must be current user
 SET SESSION AUTHORIZATION regress_priv_user2;
@@ -93,77 +114,98 @@
 
 -- try various combinations of queries on atest1 and atest2
 SELECT * FROM atest1; -- ok
- a | b 
----+---
-(0 rows)
-
+ERROR:  relation "atest1" does not exist
+LINE 1: SELECT * FROM atest1;
+                      ^
 SELECT * FROM atest2; -- ok
- col1 | col2 
-------+------
-(0 rows)
-
+ERROR:  relation "atest2" does not exist
+LINE 1: SELECT * FROM atest2;
+                      ^
 INSERT INTO atest1 VALUES (2, 'two'); -- ok
+ERROR:  relation "atest1" does not exist
+LINE 1: INSERT INTO atest1 VALUES (2, 'two');
+                    ^
 INSERT INTO atest2 VALUES ('foo', true); -- fail
-ERROR:  permission denied for table atest2
+ERROR:  relation "atest2" does not exist
+LINE 1: INSERT INTO atest2 VALUES ('foo', true);
+                    ^
 INSERT INTO atest1 SELECT 1, b FROM atest1; -- ok
+ERROR:  relation "atest1" does not exist
+LINE 1: INSERT INTO atest1 SELECT 1, b FROM atest1;
+                    ^
 UPDATE atest1 SET a = 1 WHERE a = 2; -- ok
+ERROR:  relation "atest1" does not exist
+LINE 1: UPDATE atest1 SET a = 1 WHERE a = 2;
+               ^
 UPDATE atest2 SET col2 = NOT col2; -- fail
-ERROR:  permission denied for table atest2
+ERROR:  relation "atest2" does not exist
+LINE 1: UPDATE atest2 SET col2 = NOT col2;
+               ^
 SELECT * FROM atest1 FOR UPDATE; -- ok
- a |  b  
----+-----
- 1 | two
- 1 | two
-(2 rows)
-
+ERROR:  relation "atest1" does not exist
+LINE 1: SELECT * FROM atest1 FOR UPDATE;
+                      ^
 SELECT * FROM atest2 FOR UPDATE; -- fail
-ERROR:  permission denied for table atest2
+ERROR:  relation "atest2" does not exist
+LINE 1: SELECT * FROM atest2 FOR UPDATE;
+                      ^
 DELETE FROM atest2; -- fail
-ERROR:  permission denied for table atest2
+ERROR:  relation "atest2" does not exist
+LINE 1: DELETE FROM atest2;
+                    ^
 TRUNCATE atest2; -- fail
-ERROR:  permission denied for table atest2
+ERROR:  relation "atest2" does not exist
 BEGIN;
 LOCK atest2 IN ACCESS EXCLUSIVE MODE; -- fail
-ERROR:  permission denied for table atest2
+ERROR:  relation "atest2" does not exist
 COMMIT;
 COPY atest2 FROM stdin; -- fail
-ERROR:  permission denied for table atest2
+ERROR:  relation "atest2" does not exist
 GRANT ALL ON atest1 TO PUBLIC; -- fail
-WARNING:  no privileges were granted for "atest1"
+ERROR:  relation "atest1" does not exist
 -- checks in subquery, both ok
 SELECT * FROM atest1 WHERE ( b IN ( SELECT col1 FROM atest2 ) );
- a | b 
----+---
-(0 rows)
-
+ERROR:  relation "atest1" does not exist
+LINE 1: SELECT * FROM atest1 WHERE ( b IN ( SELECT col1 FROM atest2 ...
+                      ^
 SELECT * FROM atest2 WHERE ( col1 IN ( SELECT b FROM atest1 ) );
- col1 | col2 
-------+------
-(0 rows)
-
+ERROR:  relation "atest2" does not exist
+LINE 1: SELECT * FROM atest2 WHERE ( col1 IN ( SELECT b FROM atest1 ...
+                      ^
 SET SESSION AUTHORIZATION regress_priv_user6;
 SELECT * FROM atest1; -- ok
- a |  b  
----+-----
- 1 | two
- 1 | two
-(2 rows)
-
+ERROR:  relation "atest1" does not exist
+LINE 1: SELECT * FROM atest1;
+                      ^
 SELECT * FROM atest2; -- ok
- col1 | col2 
-------+------
-(0 rows)
-
+ERROR:  relation "atest2" does not exist
+LINE 1: SELECT * FROM atest2;
+                      ^
 INSERT INTO atest2 VALUES ('foo', true); -- fail
-ERROR:  permission denied for table atest2
+ERROR:  relation "atest2" does not exist
+LINE 1: INSERT INTO atest2 VALUES ('foo', true);
+                    ^
 SET SESSION AUTHORIZATION regress_priv_user7;
 SELECT * FROM atest1; -- fail
-ERROR:  permission denied for table atest1
+ERROR:  relation "atest1" does not exist
+LINE 1: SELECT * FROM atest1;
+                      ^
 SELECT * FROM atest2; -- fail
-ERROR:  permission denied for table atest2
+ERROR:  relation "atest2" does not exist
+LINE 1: SELECT * FROM atest2;
+                      ^
 INSERT INTO atest2 VALUES ('foo', true); -- ok
+ERROR:  relation "atest2" does not exist
+LINE 1: INSERT INTO atest2 VALUES ('foo', true);
+                    ^
 UPDATE atest2 SET col2 = true; -- ok
+ERROR:  relation "atest2" does not exist
+LINE 1: UPDATE atest2 SET col2 = true;
+               ^
 DELETE FROM atest2; -- ok
+ERROR:  relation "atest2" does not exist
+LINE 1: DELETE FROM atest2;
+                    ^
 -- Make sure we are not able to modify system catalogs
 UPDATE pg_catalog.pg_class SET relname = '123'; -- fail
 ERROR:  permission denied for table pg_class
@@ -179,259 +221,261 @@
 (1 row)
 
 SELECT * FROM atest1; -- ok
- a |  b  
----+-----
- 1 | two
- 1 | two
-(2 rows)
-
+ERROR:  relation "atest1" does not exist
+LINE 1: SELECT * FROM atest1;
+                      ^
 SELECT * FROM atest2; -- fail
-ERROR:  permission denied for table atest2
+ERROR:  relation "atest2" does not exist
+LINE 1: SELECT * FROM atest2;
+                      ^
 INSERT INTO atest1 VALUES (2, 'two'); -- fail
-ERROR:  permission denied for table atest1
+ERROR:  relation "atest1" does not exist
+LINE 1: INSERT INTO atest1 VALUES (2, 'two');
+                    ^
 INSERT INTO atest2 VALUES ('foo', true); -- fail
-ERROR:  permission denied for table atest2
+ERROR:  relation "atest2" does not exist
+LINE 1: INSERT INTO atest2 VALUES ('foo', true);
+                    ^
 INSERT INTO atest1 SELECT 1, b FROM atest1; -- fail
-ERROR:  permission denied for table atest1
+ERROR:  relation "atest1" does not exist
+LINE 1: INSERT INTO atest1 SELECT 1, b FROM atest1;
+                    ^
 UPDATE atest1 SET a = 1 WHERE a = 2; -- fail
-ERROR:  permission denied for table atest1
+ERROR:  relation "atest1" does not exist
+LINE 1: UPDATE atest1 SET a = 1 WHERE a = 2;
+               ^
 UPDATE atest2 SET col2 = NULL; -- ok
+ERROR:  relation "atest2" does not exist
+LINE 1: UPDATE atest2 SET col2 = NULL;
+               ^
 UPDATE atest2 SET col2 = NOT col2; -- fails; requires SELECT on atest2
-ERROR:  permission denied for table atest2
+ERROR:  relation "atest2" does not exist
+LINE 1: UPDATE atest2 SET col2 = NOT col2;
+               ^
 UPDATE atest2 SET col2 = true FROM atest1 WHERE atest1.a = 5; -- ok
+ERROR:  relation "atest2" does not exist
+LINE 1: UPDATE atest2 SET col2 = true FROM atest1 WHERE atest1.a = 5...
+               ^
 SELECT * FROM atest1 FOR UPDATE; -- fail
-ERROR:  permission denied for table atest1
+ERROR:  relation "atest1" does not exist
+LINE 1: SELECT * FROM atest1 FOR UPDATE;
+                      ^
 SELECT * FROM atest2 FOR UPDATE; -- fail
-ERROR:  permission denied for table atest2
+ERROR:  relation "atest2" does not exist
+LINE 1: SELECT * FROM atest2 FOR UPDATE;
+                      ^
 DELETE FROM atest2; -- fail
-ERROR:  permission denied for table atest2
+ERROR:  relation "atest2" does not exist
+LINE 1: DELETE FROM atest2;
+                    ^
 TRUNCATE atest2; -- fail
-ERROR:  permission denied for table atest2
+ERROR:  relation "atest2" does not exist
 BEGIN;
 LOCK atest2 IN ACCESS EXCLUSIVE MODE; -- ok
+ERROR:  relation "atest2" does not exist
 COMMIT;
 COPY atest2 FROM stdin; -- fail
-ERROR:  permission denied for table atest2
+ERROR:  relation "atest2" does not exist
 -- checks in subquery, both fail
 SELECT * FROM atest1 WHERE ( b IN ( SELECT col1 FROM atest2 ) );
-ERROR:  permission denied for table atest2
+ERROR:  relation "atest1" does not exist
+LINE 1: SELECT * FROM atest1 WHERE ( b IN ( SELECT col1 FROM atest2 ...
+                      ^
 SELECT * FROM atest2 WHERE ( col1 IN ( SELECT b FROM atest1 ) );
-ERROR:  permission denied for table atest2
+ERROR:  relation "atest2" does not exist
+LINE 1: SELECT * FROM atest2 WHERE ( col1 IN ( SELECT b FROM atest1 ...
+                      ^
 SET SESSION AUTHORIZATION regress_priv_user4;
 COPY atest2 FROM stdin; -- ok
+ERROR:  relation "atest2" does not exist
+bar	true
+\.
+invalid command \.
 SELECT * FROM atest1; -- ok
- a |  b  
----+-----
- 1 | two
- 1 | two
-(2 rows)
-
+ERROR:  syntax error at or near "bar"
+LINE 1: bar true
+        ^
 -- test leaky-function protections in selfuncs
 -- regress_priv_user1 will own a table and provide views for it.
 SET SESSION AUTHORIZATION regress_priv_user1;
 CREATE TABLE atest12 as
   SELECT x AS a, 10001 - x AS b FROM generate_series(1,10000) x;
+ERROR:  permission denied for schema public
 CREATE INDEX ON atest12 (a);
+ERROR:  relation "atest12" does not exist
 CREATE INDEX ON atest12 (abs(a));
+ERROR:  relation "atest12" does not exist
 -- results below depend on having quite accurate stats for atest12, so...
 ALTER TABLE atest12 SET (autovacuum_enabled = off);
+ERROR:  relation "atest12" does not exist
 SET default_statistics_target = 10000;
 VACUUM ANALYZE atest12;
+ERROR:  relation "atest12" does not exist
 RESET default_statistics_target;
 CREATE OPERATOR <<< (procedure = leak, leftarg = integer, rightarg = integer,
                      restrict = scalarltsel);
+ERROR:  permission denied for schema public
 -- views with leaky operator
 CREATE VIEW atest12v AS
   SELECT * FROM atest12 WHERE b <<< 5;
+ERROR:  relation "atest12" does not exist
+LINE 2:   SELECT * FROM atest12 WHERE b <<< 5;
+                        ^
 CREATE VIEW atest12sbv WITH (security_barrier=true) AS
   SELECT * FROM atest12 WHERE b <<< 5;
+ERROR:  relation "atest12" does not exist
+LINE 2:   SELECT * FROM atest12 WHERE b <<< 5;
+                        ^
 GRANT SELECT ON atest12v TO PUBLIC;
+ERROR:  relation "atest12v" does not exist
 GRANT SELECT ON atest12sbv TO PUBLIC;
+ERROR:  relation "atest12sbv" does not exist
 -- This plan should use nestloop, knowing that few rows will be selected.
 EXPLAIN (COSTS OFF) SELECT * FROM atest12v x, atest12v y WHERE x.a = y.b;
-                   QUERY PLAN                    
--------------------------------------------------
- Nested Loop
-   ->  Seq Scan on atest12 atest12_1
-         Filter: (b <<< 5)
-   ->  Index Scan using atest12_a_idx on atest12
-         Index Cond: (a = atest12_1.b)
-         Filter: (b <<< 5)
-(6 rows)
-
+ERROR:  relation "atest12v" does not exist
+LINE 1: EXPLAIN (COSTS OFF) SELECT * FROM atest12v x, atest12v y WHE...
+                                          ^
 -- And this one.
 EXPLAIN (COSTS OFF) SELECT * FROM atest12 x, atest12 y
   WHERE x.a = y.b and abs(y.a) <<< 5;
-                    QUERY PLAN                     
----------------------------------------------------
- Nested Loop
-   ->  Seq Scan on atest12 y
-         Filter: (abs(a) <<< 5)
-   ->  Index Scan using atest12_a_idx on atest12 x
-         Index Cond: (a = y.b)
-(5 rows)
-
+ERROR:  relation "atest12" does not exist
+LINE 1: EXPLAIN (COSTS OFF) SELECT * FROM atest12 x, atest12 y
+                                          ^
 -- This should also be a nestloop, but the security barrier forces the inner
 -- scan to be materialized
 EXPLAIN (COSTS OFF) SELECT * FROM atest12sbv x, atest12sbv y WHERE x.a = y.b;
-                QUERY PLAN                 
--------------------------------------------
- Nested Loop
-   Join Filter: (atest12.a = atest12_1.b)
-   ->  Seq Scan on atest12
-         Filter: (b <<< 5)
-   ->  Materialize
-         ->  Seq Scan on atest12 atest12_1
-               Filter: (b <<< 5)
-(7 rows)
-
+ERROR:  relation "atest12sbv" does not exist
+LINE 1: EXPLAIN (COSTS OFF) SELECT * FROM atest12sbv x, atest12sbv y...
+                                          ^
 -- Check if regress_priv_user2 can break security.
 SET SESSION AUTHORIZATION regress_priv_user2;
 CREATE FUNCTION leak2(integer,integer) RETURNS boolean
   AS $$begin raise notice 'leak % %', $1, $2; return $1 > $2; end$$
   LANGUAGE plpgsql immutable;
+ERROR:  permission denied for schema public
 CREATE OPERATOR >>> (procedure = leak2, leftarg = integer, rightarg = integer,
                      restrict = scalargtsel);
+ERROR:  permission denied for schema public
 -- This should not show any "leak" notices before failing.
 EXPLAIN (COSTS OFF) SELECT * FROM atest12 WHERE a >>> 0;
-ERROR:  permission denied for table atest12
+ERROR:  relation "atest12" does not exist
+LINE 1: EXPLAIN (COSTS OFF) SELECT * FROM atest12 WHERE a >>> 0;
+                                          ^
 -- These plans should continue to use a nestloop, since they execute with the
 -- privileges of the view owner.
 EXPLAIN (COSTS OFF) SELECT * FROM atest12v x, atest12v y WHERE x.a = y.b;
-                   QUERY PLAN                    
--------------------------------------------------
- Nested Loop
-   ->  Seq Scan on atest12 atest12_1
-         Filter: (b <<< 5)
-   ->  Index Scan using atest12_a_idx on atest12
-         Index Cond: (a = atest12_1.b)
-         Filter: (b <<< 5)
-(6 rows)
-
+ERROR:  relation "atest12v" does not exist
+LINE 1: EXPLAIN (COSTS OFF) SELECT * FROM atest12v x, atest12v y WHE...
+                                          ^
 EXPLAIN (COSTS OFF) SELECT * FROM atest12sbv x, atest12sbv y WHERE x.a = y.b;
-                QUERY PLAN                 
--------------------------------------------
- Nested Loop
-   Join Filter: (atest12.a = atest12_1.b)
-   ->  Seq Scan on atest12
-         Filter: (b <<< 5)
-   ->  Materialize
-         ->  Seq Scan on atest12 atest12_1
-               Filter: (b <<< 5)
-(7 rows)
-
+ERROR:  relation "atest12sbv" does not exist
+LINE 1: EXPLAIN (COSTS OFF) SELECT * FROM atest12sbv x, atest12sbv y...
+                                          ^
 -- A non-security barrier view does not guard against information leakage.
 EXPLAIN (COSTS OFF) SELECT * FROM atest12v x, atest12v y
   WHERE x.a = y.b and abs(y.a) <<< 5;
-                   QUERY PLAN                    
--------------------------------------------------
- Nested Loop
-   ->  Seq Scan on atest12 atest12_1
-         Filter: ((b <<< 5) AND (abs(a) <<< 5))
-   ->  Index Scan using atest12_a_idx on atest12
-         Index Cond: (a = atest12_1.b)
-         Filter: (b <<< 5)
-(6 rows)
-
+ERROR:  relation "atest12v" does not exist
+LINE 1: EXPLAIN (COSTS OFF) SELECT * FROM atest12v x, atest12v y
+                                          ^
 -- But a security barrier view isolates the leaky operator.
 EXPLAIN (COSTS OFF) SELECT * FROM atest12sbv x, atest12sbv y
   WHERE x.a = y.b and abs(y.a) <<< 5;
-             QUERY PLAN              
--------------------------------------
- Nested Loop
-   Join Filter: (atest12_1.a = y.b)
-   ->  Subquery Scan on y
-         Filter: (abs(y.a) <<< 5)
-         ->  Seq Scan on atest12
-               Filter: (b <<< 5)
-   ->  Seq Scan on atest12 atest12_1
-         Filter: (b <<< 5)
-(8 rows)
-
+ERROR:  relation "atest12sbv" does not exist
+LINE 1: EXPLAIN (COSTS OFF) SELECT * FROM atest12sbv x, atest12sbv y
+                                          ^
 -- Now regress_priv_user1 grants sufficient access to regress_priv_user2.
 SET SESSION AUTHORIZATION regress_priv_user1;
 GRANT SELECT (a, b) ON atest12 TO PUBLIC;
+ERROR:  relation "atest12" does not exist
 SET SESSION AUTHORIZATION regress_priv_user2;
 -- regress_priv_user2 should continue to get a good row estimate.
 EXPLAIN (COSTS OFF) SELECT * FROM atest12v x, atest12v y WHERE x.a = y.b;
-                   QUERY PLAN                    
--------------------------------------------------
- Nested Loop
-   ->  Seq Scan on atest12 atest12_1
-         Filter: (b <<< 5)
-   ->  Index Scan using atest12_a_idx on atest12
-         Index Cond: (a = atest12_1.b)
-         Filter: (b <<< 5)
-(6 rows)
-
+ERROR:  relation "atest12v" does not exist
+LINE 1: EXPLAIN (COSTS OFF) SELECT * FROM atest12v x, atest12v y WHE...
+                                          ^
 -- But not for this, due to lack of table-wide permissions needed
 -- to make use of the expression index's statistics.
 EXPLAIN (COSTS OFF) SELECT * FROM atest12 x, atest12 y
   WHERE x.a = y.b and abs(y.a) <<< 5;
-              QUERY PLAN              
---------------------------------------
- Hash Join
-   Hash Cond: (x.a = y.b)
-   ->  Seq Scan on atest12 x
-   ->  Hash
-         ->  Seq Scan on atest12 y
-               Filter: (abs(a) <<< 5)
-(6 rows)
-
+ERROR:  relation "atest12" does not exist
+LINE 1: EXPLAIN (COSTS OFF) SELECT * FROM atest12 x, atest12 y
+                                          ^
 -- clean up (regress_priv_user1's objects are all dropped later)
 DROP FUNCTION leak2(integer, integer) CASCADE;
-NOTICE:  drop cascades to operator >>>(integer,integer)
+ERROR:  function leak2(integer, integer) does not exist
 -- groups
 SET SESSION AUTHORIZATION regress_priv_user3;
 CREATE TABLE atest3 (one int, two int, three int);
+ERROR:  permission denied for schema public
+LINE 1: CREATE TABLE atest3 (one int, two int, three int);
+                     ^
 GRANT DELETE ON atest3 TO GROUP regress_priv_group2;
+ERROR:  relation "atest3" does not exist
 SET SESSION AUTHORIZATION regress_priv_user1;
 SELECT * FROM atest3; -- fail
-ERROR:  permission denied for table atest3
+ERROR:  relation "atest3" does not exist
+LINE 1: SELECT * FROM atest3;
+                      ^
 DELETE FROM atest3; -- ok
+ERROR:  relation "atest3" does not exist
+LINE 1: DELETE FROM atest3;
+                    ^
 BEGIN;
 RESET SESSION AUTHORIZATION;
 ALTER ROLE regress_priv_user1 NOINHERIT;
 SET SESSION AUTHORIZATION regress_priv_user1;
 DELETE FROM atest3;
-ERROR:  permission denied for table atest3
+ERROR:  relation "atest3" does not exist
+LINE 1: DELETE FROM atest3;
+                    ^
 ROLLBACK;
 -- views
 SET SESSION AUTHORIZATION regress_priv_user3;
 CREATE VIEW atestv1 AS SELECT * FROM atest1; -- ok
+ERROR:  relation "atest1" does not exist
+LINE 1: CREATE VIEW atestv1 AS SELECT * FROM atest1;
+                                             ^
 /* The next *should* fail, but it's not implemented that way yet. */
 CREATE VIEW atestv2 AS SELECT * FROM atest2;
+ERROR:  relation "atest2" does not exist
+LINE 2: CREATE VIEW atestv2 AS SELECT * FROM atest2;
+                                             ^
 CREATE VIEW atestv3 AS SELECT * FROM atest3; -- ok
+ERROR:  relation "atest3" does not exist
+LINE 1: CREATE VIEW atestv3 AS SELECT * FROM atest3;
+                                             ^
 /* Empty view is a corner case that failed in 9.2. */
 CREATE VIEW atestv0 AS SELECT 0 as x WHERE false; -- ok
+ERROR:  permission denied for schema public
 SELECT * FROM atestv1; -- ok
- a |  b  
----+-----
- 1 | two
- 1 | two
-(2 rows)
-
+ERROR:  relation "atestv1" does not exist
+LINE 1: SELECT * FROM atestv1;
+                      ^
 SELECT * FROM atestv2; -- fail
-ERROR:  permission denied for table atest2
+ERROR:  relation "atestv2" does not exist
+LINE 1: SELECT * FROM atestv2;
+                      ^
 GRANT SELECT ON atestv1, atestv3 TO regress_priv_user4;
+ERROR:  relation "atestv1" does not exist
 GRANT SELECT ON atestv2 TO regress_priv_user2;
+ERROR:  relation "atestv2" does not exist
 SET SESSION AUTHORIZATION regress_priv_user4;
 SELECT * FROM atestv1; -- ok
- a |  b  
----+-----
- 1 | two
- 1 | two
-(2 rows)
-
+ERROR:  relation "atestv1" does not exist
+LINE 1: SELECT * FROM atestv1;
+                      ^
 SELECT * FROM atestv2; -- fail
-ERROR:  permission denied for view atestv2
+ERROR:  relation "atestv2" does not exist
+LINE 1: SELECT * FROM atestv2;
+                      ^
 SELECT * FROM atestv3; -- ok
- one | two | three 
------+-----+-------
-(0 rows)
-
+ERROR:  relation "atestv3" does not exist
+LINE 1: SELECT * FROM atestv3;
+                      ^
 SELECT * FROM atestv0; -- fail
-ERROR:  permission denied for view atestv0
+ERROR:  relation "atestv0" does not exist
+LINE 1: SELECT * FROM atestv0;
+                      ^
 -- Appendrels excluded by constraints failed to check permissions in 8.4-9.2.
 select * from
   ((select a.q1 as x from int8_tbl a offset 0)
@@ -448,1968 +492,623 @@
 ERROR:  permission denied for table int8_tbl
 reset constraint_exclusion;
 CREATE VIEW atestv4 AS SELECT * FROM atestv3; -- nested view
+ERROR:  relation "atestv3" does not exist
+LINE 1: CREATE VIEW atestv4 AS SELECT * FROM atestv3;
+                                             ^
 SELECT * FROM atestv4; -- ok
- one | two | three 
------+-----+-------
-(0 rows)
-
+ERROR:  relation "atestv4" does not exist
+LINE 1: SELECT * FROM atestv4;
+                      ^
 GRANT SELECT ON atestv4 TO regress_priv_user2;
+ERROR:  relation "atestv4" does not exist
 SET SESSION AUTHORIZATION regress_priv_user2;
 -- Two complex cases:
 SELECT * FROM atestv3; -- fail
-ERROR:  permission denied for view atestv3
+ERROR:  relation "atestv3" does not exist
+LINE 1: SELECT * FROM atestv3;
+                      ^
 SELECT * FROM atestv4; -- ok (even though regress_priv_user2 cannot access underlying atestv3)
- one | two | three 
------+-----+-------
-(0 rows)
-
+ERROR:  relation "atestv4" does not exist
+LINE 1: SELECT * FROM atestv4;
+                      ^
 SELECT * FROM atest2; -- ok
- col1 | col2 
-------+------
- bar  | t
-(1 row)
-
+ERROR:  relation "atest2" does not exist
+LINE 1: SELECT * FROM atest2;
+                      ^
 SELECT * FROM atestv2; -- fail (even though regress_priv_user2 can access underlying atest2)
-ERROR:  permission denied for table atest2
+ERROR:  relation "atestv2" does not exist
+LINE 1: SELECT * FROM atestv2;
+                      ^
 -- Test column level permissions
 SET SESSION AUTHORIZATION regress_priv_user1;
 CREATE TABLE atest5 (one int, two int unique, three int, four int unique);
+ERROR:  permission denied for schema public
+LINE 1: CREATE TABLE atest5 (one int, two int unique, three int, fou...
+                     ^
 CREATE TABLE atest6 (one int, two int, blue int);
+ERROR:  permission denied for schema public
+LINE 1: CREATE TABLE atest6 (one int, two int, blue int);
+                     ^
 GRANT SELECT (one), INSERT (two), UPDATE (three) ON atest5 TO regress_priv_user4;
+ERROR:  relation "atest5" does not exist
 GRANT ALL (one) ON atest5 TO regress_priv_user3;
+ERROR:  relation "atest5" does not exist
 INSERT INTO atest5 VALUES (1,2,3);
+ERROR:  relation "atest5" does not exist
+LINE 1: INSERT INTO atest5 VALUES (1,2,3);
+                    ^
 SET SESSION AUTHORIZATION regress_priv_user4;
 SELECT * FROM atest5; -- fail
-ERROR:  permission denied for table atest5
+ERROR:  relation "atest5" does not exist
+LINE 1: SELECT * FROM atest5;
+                      ^
 SELECT one FROM atest5; -- ok
- one 
------
-   1
-(1 row)
-
+ERROR:  relation "atest5" does not exist
+LINE 1: SELECT one FROM atest5;
+                        ^
 COPY atest5 (one) TO stdout; -- ok
-1
+ERROR:  relation "atest5" does not exist
 SELECT two FROM atest5; -- fail
-ERROR:  permission denied for table atest5
+ERROR:  relation "atest5" does not exist
+LINE 1: SELECT two FROM atest5;
+                        ^
 COPY atest5 (two) TO stdout; -- fail
-ERROR:  permission denied for table atest5
+ERROR:  relation "atest5" does not exist
 SELECT atest5 FROM atest5; -- fail
-ERROR:  permission denied for table atest5
+ERROR:  relation "atest5" does not exist
+LINE 1: SELECT atest5 FROM atest5;
+                           ^
 COPY atest5 (one,two) TO stdout; -- fail
-ERROR:  permission denied for table atest5
+ERROR:  relation "atest5" does not exist
 SELECT 1 FROM atest5; -- ok
- ?column? 
-----------
-        1
-(1 row)
-
+ERROR:  relation "atest5" does not exist
+LINE 1: SELECT 1 FROM atest5;
+                      ^
 SELECT 1 FROM atest5 a JOIN atest5 b USING (one); -- ok
- ?column? 
-----------
-        1
-(1 row)
-
+ERROR:  relation "atest5" does not exist
+LINE 1: SELECT 1 FROM atest5 a JOIN atest5 b USING (one);
+                      ^
 SELECT 1 FROM atest5 a JOIN atest5 b USING (two); -- fail
-ERROR:  permission denied for table atest5
+ERROR:  relation "atest5" does not exist
+LINE 1: SELECT 1 FROM atest5 a JOIN atest5 b USING (two);
+                      ^
 SELECT 1 FROM atest5 a NATURAL JOIN atest5 b; -- fail
-ERROR:  permission denied for table atest5
+ERROR:  relation "atest5" does not exist
+LINE 1: SELECT 1 FROM atest5 a NATURAL JOIN atest5 b;
+                      ^
 SELECT * FROM (atest5 a JOIN atest5 b USING (one)) j; -- fail
-ERROR:  permission denied for table atest5
+ERROR:  relation "atest5" does not exist
+LINE 1: SELECT * FROM (atest5 a JOIN atest5 b USING (one)) j;
+                       ^
 SELECT j.* FROM (atest5 a JOIN atest5 b USING (one)) j; -- fail
-ERROR:  permission denied for table atest5
+ERROR:  relation "atest5" does not exist
+LINE 1: SELECT j.* FROM (atest5 a JOIN atest5 b USING (one)) j;
+                         ^
 SELECT (j.*) IS NULL FROM (atest5 a JOIN atest5 b USING (one)) j; -- fail
-ERROR:  permission denied for table atest5
+ERROR:  relation "atest5" does not exist
+LINE 1: SELECT (j.*) IS NULL FROM (atest5 a JOIN atest5 b USING (one...
+                                   ^
 SELECT one FROM (atest5 a JOIN atest5 b(one,x,y,z) USING (one)) j; -- ok
- one 
------
-   1
-(1 row)
-
+ERROR:  relation "atest5" does not exist
+LINE 1: SELECT one FROM (atest5 a JOIN atest5 b(one,x,y,z) USING (on...
+                         ^
 SELECT j.one FROM (atest5 a JOIN atest5 b(one,x,y,z) USING (one)) j; -- ok
- one 
------
-   1
-(1 row)
-
+ERROR:  relation "atest5" does not exist
+LINE 1: SELECT j.one FROM (atest5 a JOIN atest5 b(one,x,y,z) USING (...
+                           ^
 SELECT two FROM (atest5 a JOIN atest5 b(one,x,y,z) USING (one)) j; -- fail
-ERROR:  permission denied for table atest5
+ERROR:  relation "atest5" does not exist
+LINE 1: SELECT two FROM (atest5 a JOIN atest5 b(one,x,y,z) USING (on...
+                         ^
 SELECT j.two FROM (atest5 a JOIN atest5 b(one,x,y,z) USING (one)) j; -- fail
-ERROR:  permission denied for table atest5
+ERROR:  relation "atest5" does not exist
+LINE 1: SELECT j.two FROM (atest5 a JOIN atest5 b(one,x,y,z) USING (...
+                           ^
 SELECT y FROM (atest5 a JOIN atest5 b(one,x,y,z) USING (one)) j; -- fail
-ERROR:  permission denied for table atest5
+ERROR:  relation "atest5" does not exist
+LINE 1: SELECT y FROM (atest5 a JOIN atest5 b(one,x,y,z) USING (one)...
+                       ^
 SELECT j.y FROM (atest5 a JOIN atest5 b(one,x,y,z) USING (one)) j; -- fail
-ERROR:  permission denied for table atest5
+ERROR:  relation "atest5" does not exist
+LINE 1: SELECT j.y FROM (atest5 a JOIN atest5 b(one,x,y,z) USING (on...
+                         ^
 SELECT * FROM (atest5 a JOIN atest5 b USING (one)); -- fail
-ERROR:  permission denied for table atest5
+ERROR:  relation "atest5" does not exist
+LINE 1: SELECT * FROM (atest5 a JOIN atest5 b USING (one));
+                       ^
 SELECT a.* FROM (atest5 a JOIN atest5 b USING (one)); -- fail
-ERROR:  permission denied for table atest5
+ERROR:  relation "atest5" does not exist
+LINE 1: SELECT a.* FROM (atest5 a JOIN atest5 b USING (one));
+                         ^
 SELECT (a.*) IS NULL FROM (atest5 a JOIN atest5 b USING (one)); -- fail
-ERROR:  permission denied for table atest5
+ERROR:  relation "atest5" does not exist
+LINE 1: SELECT (a.*) IS NULL FROM (atest5 a JOIN atest5 b USING (one...
+                                   ^
 SELECT two FROM (atest5 a JOIN atest5 b(one,x,y,z) USING (one)); -- fail
-ERROR:  permission denied for table atest5
+ERROR:  relation "atest5" does not exist
+LINE 1: SELECT two FROM (atest5 a JOIN atest5 b(one,x,y,z) USING (on...
+                         ^
 SELECT a.two FROM (atest5 a JOIN atest5 b(one,x,y,z) USING (one)); -- fail
-ERROR:  permission denied for table atest5
+ERROR:  relation "atest5" does not exist
+LINE 1: SELECT a.two FROM (atest5 a JOIN atest5 b(one,x,y,z) USING (...
+                           ^
 SELECT y FROM (atest5 a JOIN atest5 b(one,x,y,z) USING (one)); -- fail
-ERROR:  permission denied for table atest5
+ERROR:  relation "atest5" does not exist
+LINE 1: SELECT y FROM (atest5 a JOIN atest5 b(one,x,y,z) USING (one)...
+                       ^
 SELECT b.y FROM (atest5 a JOIN atest5 b(one,x,y,z) USING (one)); -- fail
-ERROR:  permission denied for table atest5
+ERROR:  relation "atest5" does not exist
+LINE 1: SELECT b.y FROM (atest5 a JOIN atest5 b(one,x,y,z) USING (on...
+                         ^
 SELECT y FROM (atest5 a LEFT JOIN atest5 b(one,x,y,z) USING (one)); -- fail
-ERROR:  permission denied for table atest5
+ERROR:  relation "atest5" does not exist
+LINE 1: SELECT y FROM (atest5 a LEFT JOIN atest5 b(one,x,y,z) USING ...
+                       ^
 SELECT b.y FROM (atest5 a LEFT JOIN atest5 b(one,x,y,z) USING (one)); -- fail
-ERROR:  permission denied for table atest5
+ERROR:  relation "atest5" does not exist
+LINE 1: SELECT b.y FROM (atest5 a LEFT JOIN atest5 b(one,x,y,z) USIN...
+                         ^
 SELECT y FROM (atest5 a FULL JOIN atest5 b(one,x,y,z) USING (one)); -- fail
-ERROR:  permission denied for table atest5
+ERROR:  relation "atest5" does not exist
+LINE 1: SELECT y FROM (atest5 a FULL JOIN atest5 b(one,x,y,z) USING ...
+                       ^
 SELECT b.y FROM (atest5 a FULL JOIN atest5 b(one,x,y,z) USING (one)); -- fail
-ERROR:  permission denied for table atest5
+ERROR:  relation "atest5" does not exist
+LINE 1: SELECT b.y FROM (atest5 a FULL JOIN atest5 b(one,x,y,z) USIN...
+                         ^
 SELECT 1 FROM atest5 WHERE two = 2; -- fail
-ERROR:  permission denied for table atest5
+ERROR:  relation "atest5" does not exist
+LINE 1: SELECT 1 FROM atest5 WHERE two = 2;
+                      ^
 SELECT * FROM atest1, atest5; -- fail
-ERROR:  permission denied for table atest5
+ERROR:  relation "atest1" does not exist
+LINE 1: SELECT * FROM atest1, atest5;
+                      ^
 SELECT atest1.* FROM atest1, atest5; -- ok
- a |  b  
----+-----
- 1 | two
- 1 | two
-(2 rows)
-
+ERROR:  relation "atest1" does not exist
+LINE 1: SELECT atest1.* FROM atest1, atest5;
+                             ^
 SELECT atest1.*,atest5.one FROM atest1, atest5; -- ok
- a |  b  | one 
----+-----+-----
- 1 | two |   1
- 1 | two |   1
-(2 rows)
-
+ERROR:  relation "atest1" does not exist
+LINE 1: SELECT atest1.*,atest5.one FROM atest1, atest5;
+                                        ^
 SELECT atest1.*,atest5.one FROM atest1 JOIN atest5 ON (atest1.a = atest5.two); -- fail
-ERROR:  permission denied for table atest5
+ERROR:  relation "atest1" does not exist
+LINE 1: SELECT atest1.*,atest5.one FROM atest1 JOIN atest5 ON (atest...
+                                        ^
 SELECT atest1.*,atest5.one FROM atest1 JOIN atest5 ON (atest1.a = atest5.one); -- ok
- a |  b  | one 
----+-----+-----
- 1 | two |   1
- 1 | two |   1
-(2 rows)
-
+ERROR:  relation "atest1" does not exist
+LINE 1: SELECT atest1.*,atest5.one FROM atest1 JOIN atest5 ON (atest...
+                                        ^
 SELECT one, two FROM atest5; -- fail
-ERROR:  permission denied for table atest5
+ERROR:  relation "atest5" does not exist
+LINE 1: SELECT one, two FROM atest5;
+                             ^
 SET SESSION AUTHORIZATION regress_priv_user1;
 GRANT SELECT (one,two) ON atest6 TO regress_priv_user4;
+ERROR:  relation "atest6" does not exist
 SET SESSION AUTHORIZATION regress_priv_user4;
 SELECT one, two FROM atest5 NATURAL JOIN atest6; -- fail still
-ERROR:  permission denied for table atest5
+ERROR:  relation "atest5" does not exist
+LINE 1: SELECT one, two FROM atest5 NATURAL JOIN atest6;
+                             ^
 SET SESSION AUTHORIZATION regress_priv_user1;
 GRANT SELECT (two) ON atest5 TO regress_priv_user4;
+ERROR:  relation "atest5" does not exist
 SET SESSION AUTHORIZATION regress_priv_user4;
 SELECT one, two FROM atest5 NATURAL JOIN atest6; -- ok now
- one | two 
------+-----
-(0 rows)
-
+ERROR:  relation "atest5" does not exist
+LINE 1: SELECT one, two FROM atest5 NATURAL JOIN atest6;
+                             ^
 -- test column-level privileges for INSERT and UPDATE
 INSERT INTO atest5 (two) VALUES (3); -- ok
+ERROR:  relation "atest5" does not exist
+LINE 1: INSERT INTO atest5 (two) VALUES (3);
+                    ^
 COPY atest5 FROM stdin; -- fail
-ERROR:  permission denied for table atest5
+ERROR:  relation "atest5" does not exist
 COPY atest5 (two) FROM stdin; -- ok
+ERROR:  relation "atest5" does not exist
+1
+\.
+invalid command \.
 INSERT INTO atest5 (three) VALUES (4); -- fail
-ERROR:  permission denied for table atest5
+ERROR:  syntax error at or near "1"
+LINE 1: 1
+        ^
 INSERT INTO atest5 VALUES (5,5,5); -- fail
-ERROR:  permission denied for table atest5
+ERROR:  relation "atest5" does not exist
+LINE 1: INSERT INTO atest5 VALUES (5,5,5);
+                    ^
 UPDATE atest5 SET three = 10; -- ok
+ERROR:  relation "atest5" does not exist
+LINE 1: UPDATE atest5 SET three = 10;
+               ^
 UPDATE atest5 SET one = 8; -- fail
-ERROR:  permission denied for table atest5
+ERROR:  relation "atest5" does not exist
+LINE 1: UPDATE atest5 SET one = 8;
+               ^
 UPDATE atest5 SET three = 5, one = 2; -- fail
-ERROR:  permission denied for table atest5
+ERROR:  relation "atest5" does not exist
+LINE 1: UPDATE atest5 SET three = 5, one = 2;
+               ^
 -- Check that column level privs are enforced in RETURNING
 -- Ok.
 INSERT INTO atest5(two) VALUES (6) ON CONFLICT (two) DO UPDATE set three = 10;
+ERROR:  relation "atest5" does not exist
+LINE 1: INSERT INTO atest5(two) VALUES (6) ON CONFLICT (two) DO UPDA...
+                    ^
 -- Error. No SELECT on column three.
 INSERT INTO atest5(two) VALUES (6) ON CONFLICT (two) DO UPDATE set three = 10 RETURNING atest5.three;
-ERROR:  permission denied for table atest5
+ERROR:  relation "atest5" does not exist
+LINE 1: INSERT INTO atest5(two) VALUES (6) ON CONFLICT (two) DO UPDA...
+                    ^
 -- Ok.  May SELECT on column "one":
 INSERT INTO atest5(two) VALUES (6) ON CONFLICT (two) DO UPDATE set three = 10 RETURNING atest5.one;
- one 
------
-    
-(1 row)
-
+ERROR:  relation "atest5" does not exist
+LINE 1: INSERT INTO atest5(two) VALUES (6) ON CONFLICT (two) DO UPDA...
+                    ^
 -- Check that column level privileges are enforced for EXCLUDED
 -- Ok. we may select one
 INSERT INTO atest5(two) VALUES (6) ON CONFLICT (two) DO UPDATE set three = EXCLUDED.one;
+ERROR:  relation "atest5" does not exist
+LINE 1: INSERT INTO atest5(two) VALUES (6) ON CONFLICT (two) DO UPDA...
+                    ^
 -- Error. No select rights on three
 INSERT INTO atest5(two) VALUES (6) ON CONFLICT (two) DO UPDATE set three = EXCLUDED.three;
-ERROR:  permission denied for table atest5
+ERROR:  relation "atest5" does not exist
+LINE 1: INSERT INTO atest5(two) VALUES (6) ON CONFLICT (two) DO UPDA...
+                    ^
 INSERT INTO atest5(two) VALUES (6) ON CONFLICT (two) DO UPDATE set one = 8; -- fails (due to UPDATE)
-ERROR:  permission denied for table atest5
+ERROR:  relation "atest5" does not exist
+LINE 1: INSERT INTO atest5(two) VALUES (6) ON CONFLICT (two) DO UPDA...
+                    ^
 INSERT INTO atest5(three) VALUES (4) ON CONFLICT (two) DO UPDATE set three = 10; -- fails (due to INSERT)
-ERROR:  permission denied for table atest5
+ERROR:  relation "atest5" does not exist
+LINE 1: INSERT INTO atest5(three) VALUES (4) ON CONFLICT (two) DO UP...
+                    ^
 -- Check that the columns in the inference require select privileges
 INSERT INTO atest5(four) VALUES (4); -- fail
-ERROR:  permission denied for table atest5
+ERROR:  relation "atest5" does not exist
+LINE 1: INSERT INTO atest5(four) VALUES (4);
+                    ^
 SET SESSION AUTHORIZATION regress_priv_user1;
 GRANT INSERT (four) ON atest5 TO regress_priv_user4;
+ERROR:  relation "atest5" does not exist
 SET SESSION AUTHORIZATION regress_priv_user4;
 INSERT INTO atest5(four) VALUES (4) ON CONFLICT (four) DO UPDATE set three = 3; -- fails (due to SELECT)
-ERROR:  permission denied for table atest5
+ERROR:  relation "atest5" does not exist
+LINE 1: INSERT INTO atest5(four) VALUES (4) ON CONFLICT (four) DO UP...
+                    ^
 INSERT INTO atest5(four) VALUES (4) ON CONFLICT ON CONSTRAINT atest5_four_key DO UPDATE set three = 3; -- fails (due to SELECT)
-ERROR:  permission denied for table atest5
+ERROR:  relation "atest5" does not exist
+LINE 1: INSERT INTO atest5(four) VALUES (4) ON CONFLICT ON CONSTRAIN...
+                    ^
 INSERT INTO atest5(four) VALUES (4); -- ok
+ERROR:  relation "atest5" does not exist
+LINE 1: INSERT INTO atest5(four) VALUES (4);
+                    ^
 SET SESSION AUTHORIZATION regress_priv_user1;
 GRANT SELECT (four) ON atest5 TO regress_priv_user4;
+ERROR:  relation "atest5" does not exist
 SET SESSION AUTHORIZATION regress_priv_user4;
 INSERT INTO atest5(four) VALUES (4) ON CONFLICT (four) DO UPDATE set three = 3; -- ok
+ERROR:  relation "atest5" does not exist
+LINE 1: INSERT INTO atest5(four) VALUES (4) ON CONFLICT (four) DO UP...
+                    ^
 INSERT INTO atest5(four) VALUES (4) ON CONFLICT ON CONSTRAINT atest5_four_key DO UPDATE set three = 3; -- ok
+ERROR:  relation "atest5" does not exist
+LINE 1: INSERT INTO atest5(four) VALUES (4) ON CONFLICT ON CONSTRAIN...
+                    ^
 SET SESSION AUTHORIZATION regress_priv_user1;
 REVOKE ALL (one) ON atest5 FROM regress_priv_user4;
+ERROR:  relation "atest5" does not exist
 GRANT SELECT (one,two,blue) ON atest6 TO regress_priv_user4;
+ERROR:  relation "atest6" does not exist
 SET SESSION AUTHORIZATION regress_priv_user4;
 SELECT one FROM atest5; -- fail
-ERROR:  permission denied for table atest5
+ERROR:  relation "atest5" does not exist
+LINE 1: SELECT one FROM atest5;
+                        ^
 UPDATE atest5 SET one = 1; -- fail
-ERROR:  permission denied for table atest5
+ERROR:  relation "atest5" does not exist
+LINE 1: UPDATE atest5 SET one = 1;
+               ^
 SELECT atest6 FROM atest6; -- ok
- atest6 
---------
-(0 rows)
-
+ERROR:  relation "atest6" does not exist
+LINE 1: SELECT atest6 FROM atest6;
+                           ^
 COPY atest6 TO stdout; -- ok
+ERROR:  relation "atest6" does not exist
 -- check error reporting with column privs
 SET SESSION AUTHORIZATION regress_priv_user1;
 CREATE TABLE t1 (c1 int, c2 int, c3 int check (c3 < 5), primary key (c1, c2));
+ERROR:  permission denied for schema public
+LINE 1: CREATE TABLE t1 (c1 int, c2 int, c3 int check (c3 < 5), prim...
+                     ^
 GRANT SELECT (c1) ON t1 TO regress_priv_user2;
+ERROR:  relation "t1" does not exist
 GRANT INSERT (c1, c2, c3) ON t1 TO regress_priv_user2;
+ERROR:  relation "t1" does not exist
 GRANT UPDATE (c1, c2, c3) ON t1 TO regress_priv_user2;
+ERROR:  relation "t1" does not exist
 -- seed data
 INSERT INTO t1 VALUES (1, 1, 1);
+ERROR:  relation "t1" does not exist
+LINE 1: INSERT INTO t1 VALUES (1, 1, 1);
+                    ^
 INSERT INTO t1 VALUES (1, 2, 1);
+ERROR:  relation "t1" does not exist
+LINE 1: INSERT INTO t1 VALUES (1, 2, 1);
+                    ^
 INSERT INTO t1 VALUES (2, 1, 2);
+ERROR:  relation "t1" does not exist
+LINE 1: INSERT INTO t1 VALUES (2, 1, 2);
+                    ^
 INSERT INTO t1 VALUES (2, 2, 2);
+ERROR:  relation "t1" does not exist
+LINE 1: INSERT INTO t1 VALUES (2, 2, 2);
+                    ^
 INSERT INTO t1 VALUES (3, 1, 3);
+ERROR:  relation "t1" does not exist
+LINE 1: INSERT INTO t1 VALUES (3, 1, 3);
+                    ^
 SET SESSION AUTHORIZATION regress_priv_user2;
 INSERT INTO t1 (c1, c2) VALUES (1, 1); -- fail, but row not shown
-ERROR:  duplicate key value violates unique constraint "t1_pkey"
+ERROR:  relation "t1" does not exist
+LINE 1: INSERT INTO t1 (c1, c2) VALUES (1, 1);
+                    ^
 UPDATE t1 SET c2 = 1; -- fail, but row not shown
-ERROR:  duplicate key value violates unique constraint "t1_pkey"
+ERROR:  relation "t1" does not exist
+LINE 1: UPDATE t1 SET c2 = 1;
+               ^
 INSERT INTO t1 (c1, c2) VALUES (null, null); -- fail, but see columns being inserted
-ERROR:  null value in column "c1" of relation "t1" violates not-null constraint
-DETAIL:  Failing row contains (c1, c2) = (null, null).
+ERROR:  relation "t1" does not exist
+LINE 1: INSERT INTO t1 (c1, c2) VALUES (null, null);
+                    ^
 INSERT INTO t1 (c3) VALUES (null); -- fail, but see columns being inserted or have SELECT
-ERROR:  null value in column "c1" of relation "t1" violates not-null constraint
-DETAIL:  Failing row contains (c1, c3) = (null, null).
+ERROR:  relation "t1" does not exist
+LINE 1: INSERT INTO t1 (c3) VALUES (null);
+                    ^
 INSERT INTO t1 (c1) VALUES (5); -- fail, but see columns being inserted or have SELECT
-ERROR:  null value in column "c2" of relation "t1" violates not-null constraint
-DETAIL:  Failing row contains (c1) = (5).
+ERROR:  relation "t1" does not exist
+LINE 1: INSERT INTO t1 (c1) VALUES (5);
+                    ^
 UPDATE t1 SET c3 = 10; -- fail, but see columns with SELECT rights, or being modified
-ERROR:  new row for relation "t1" violates check constraint "t1_c3_check"
-DETAIL:  Failing row contains (c1, c3) = (1, 10).
+ERROR:  relation "t1" does not exist
+LINE 1: UPDATE t1 SET c3 = 10;
+               ^
 SET SESSION AUTHORIZATION regress_priv_user1;
 DROP TABLE t1;
+ERROR:  table "t1" does not exist
 -- check error reporting with column privs on a partitioned table
 CREATE TABLE errtst(a text, b text NOT NULL, c text, secret1 text, secret2 text) PARTITION BY LIST (a);
+ERROR:  permission denied for schema public
+LINE 1: CREATE TABLE errtst(a text, b text NOT NULL, c text, secret1...
+                     ^
 CREATE TABLE errtst_part_1(secret2 text, c text, a text, b text NOT NULL, secret1 text);
+ERROR:  permission denied for schema public
+LINE 1: CREATE TABLE errtst_part_1(secret2 text, c text, a text, b t...
+                     ^
 CREATE TABLE errtst_part_2(secret1 text, secret2 text, a text, c text, b text NOT NULL);
+ERROR:  permission denied for schema public
+LINE 1: CREATE TABLE errtst_part_2(secret1 text, secret2 text, a tex...
+                     ^
 ALTER TABLE errtst ATTACH PARTITION errtst_part_1 FOR VALUES IN ('aaa');
+ERROR:  relation "errtst" does not exist
 ALTER TABLE errtst ATTACH PARTITION errtst_part_2 FOR VALUES IN ('aaaa');
+ERROR:  relation "errtst" does not exist
 GRANT SELECT (a, b, c) ON TABLE errtst TO regress_priv_user2;
+ERROR:  relation "errtst" does not exist
 GRANT UPDATE (a, b, c) ON TABLE errtst TO regress_priv_user2;
+ERROR:  relation "errtst" does not exist
 GRANT INSERT (a, b, c) ON TABLE errtst TO regress_priv_user2;
+ERROR:  relation "errtst" does not exist
 INSERT INTO errtst_part_1 (a, b, c, secret1, secret2)
 VALUES ('aaa', 'bbb', 'ccc', 'the body', 'is in the attic');
+ERROR:  relation "errtst_part_1" does not exist
+LINE 1: INSERT INTO errtst_part_1 (a, b, c, secret1, secret2)
+                    ^
 SET SESSION AUTHORIZATION regress_priv_user2;
 -- Perform a few updates that violate the NOT NULL constraint. Make sure
 -- the error messages don't leak the secret fields.
 -- simple insert.
 INSERT INTO errtst (a, b) VALUES ('aaa', NULL);
-ERROR:  null value in column "b" of relation "errtst_part_1" violates not-null constraint
-DETAIL:  Failing row contains (a, b, c) = (aaa, null, null).
+ERROR:  relation "errtst" does not exist
+LINE 1: INSERT INTO errtst (a, b) VALUES ('aaa', NULL);
+                    ^
 -- simple update.
 UPDATE errtst SET b = NULL;
-ERROR:  null value in column "b" of relation "errtst_part_1" violates not-null constraint
-DETAIL:  Failing row contains (a, b, c) = (aaa, null, ccc).
+ERROR:  relation "errtst" does not exist
+LINE 1: UPDATE errtst SET b = NULL;
+               ^
 -- partitioning key is updated, doesn't move the row.
 UPDATE errtst SET a = 'aaa', b = NULL;
-ERROR:  null value in column "b" of relation "errtst_part_1" violates not-null constraint
-DETAIL:  Failing row contains (a, b, c) = (aaa, null, ccc).
+ERROR:  relation "errtst" does not exist
+LINE 1: UPDATE errtst SET a = 'aaa', b = NULL;
+               ^
 -- row is moved to another partition.
 UPDATE errtst SET a = 'aaaa', b = NULL;
-ERROR:  null value in column "b" of relation "errtst_part_2" violates not-null constraint
-DETAIL:  Failing row contains (a, b, c) = (aaaa, null, ccc).
+ERROR:  relation "errtst" does not exist
+LINE 1: UPDATE errtst SET a = 'aaaa', b = NULL;
+               ^
 -- row is moved to another partition. This differs from the previous case in
 -- that the new partition is excluded by constraint exclusion, so its
 -- ResultRelInfo is not created at ExecInitModifyTable, but needs to be
 -- constructed on the fly when the updated tuple is routed to it.
 UPDATE errtst SET a = 'aaaa', b = NULL WHERE a = 'aaa';
-ERROR:  null value in column "b" of relation "errtst_part_2" violates not-null constraint
-DETAIL:  Failing row contains (a, b, c) = (aaaa, null, ccc).
+ERROR:  relation "errtst" does not exist
+LINE 1: UPDATE errtst SET a = 'aaaa', b = NULL WHERE a = 'aaa';
+               ^
 SET SESSION AUTHORIZATION regress_priv_user1;
 DROP TABLE errtst;
+ERROR:  table "errtst" does not exist
 -- test column-level privileges when involved with DELETE
 SET SESSION AUTHORIZATION regress_priv_user1;
 ALTER TABLE atest6 ADD COLUMN three integer;
+ERROR:  relation "atest6" does not exist
 GRANT DELETE ON atest5 TO regress_priv_user3;
+ERROR:  relation "atest5" does not exist
 GRANT SELECT (two) ON atest5 TO regress_priv_user3;
+ERROR:  relation "atest5" does not exist
 REVOKE ALL (one) ON atest5 FROM regress_priv_user3;
+ERROR:  relation "atest5" does not exist
 GRANT SELECT (one) ON atest5 TO regress_priv_user4;
+ERROR:  relation "atest5" does not exist
 SET SESSION AUTHORIZATION regress_priv_user4;
 SELECT atest6 FROM atest6; -- fail
-ERROR:  permission denied for table atest6
+ERROR:  relation "atest6" does not exist
+LINE 1: SELECT atest6 FROM atest6;
+                           ^
 SELECT one FROM atest5 NATURAL JOIN atest6; -- fail
-ERROR:  permission denied for table atest5
+ERROR:  relation "atest5" does not exist
+LINE 1: SELECT one FROM atest5 NATURAL JOIN atest6;
+                        ^
 SET SESSION AUTHORIZATION regress_priv_user1;
 ALTER TABLE atest6 DROP COLUMN three;
+ERROR:  relation "atest6" does not exist
 SET SESSION AUTHORIZATION regress_priv_user4;
 SELECT atest6 FROM atest6; -- ok
- atest6 
---------
-(0 rows)
-
+ERROR:  relation "atest6" does not exist
+LINE 1: SELECT atest6 FROM atest6;
+                           ^
 SELECT one FROM atest5 NATURAL JOIN atest6; -- ok
- one 
------
-(0 rows)
-
+ERROR:  relation "atest5" does not exist
+LINE 1: SELECT one FROM atest5 NATURAL JOIN atest6;
+                        ^
 SET SESSION AUTHORIZATION regress_priv_user1;
 ALTER TABLE atest6 DROP COLUMN two;
+ERROR:  relation "atest6" does not exist
 REVOKE SELECT (one,blue) ON atest6 FROM regress_priv_user4;
+ERROR:  relation "atest6" does not exist
 SET SESSION AUTHORIZATION regress_priv_user4;
 SELECT * FROM atest6; -- fail
-ERROR:  permission denied for table atest6
+ERROR:  relation "atest6" does not exist
+LINE 1: SELECT * FROM atest6;
+                      ^
 SELECT 1 FROM atest6; -- fail
-ERROR:  permission denied for table atest6
+ERROR:  relation "atest6" does not exist
+LINE 1: SELECT 1 FROM atest6;
+                      ^
 SET SESSION AUTHORIZATION regress_priv_user3;
 DELETE FROM atest5 WHERE one = 1; -- fail
-ERROR:  permission denied for table atest5
+ERROR:  relation "atest5" does not exist
+LINE 1: DELETE FROM atest5 WHERE one = 1;
+                    ^
 DELETE FROM atest5 WHERE two = 2; -- ok
+ERROR:  relation "atest5" does not exist
+LINE 1: DELETE FROM atest5 WHERE two = 2;
+                    ^
 -- check inheritance cases
 SET SESSION AUTHORIZATION regress_priv_user1;
 CREATE TABLE atestp1 (f1 int, f2 int);
+ERROR:  permission denied for schema public
+LINE 1: CREATE TABLE atestp1 (f1 int, f2 int);
+                     ^
 CREATE TABLE atestp2 (fx int, fy int);
+ERROR:  permission denied for schema public
+LINE 1: CREATE TABLE atestp2 (fx int, fy int);
+                     ^
 CREATE TABLE atestc (fz int) INHERITS (atestp1, atestp2);
+ERROR:  permission denied for schema public
+LINE 1: CREATE TABLE atestc (fz int) INHERITS (atestp1, atestp2);
+                     ^
 GRANT SELECT(fx,fy,tableoid) ON atestp2 TO regress_priv_user2;
+ERROR:  relation "atestp2" does not exist
 GRANT SELECT(fx) ON atestc TO regress_priv_user2;
+ERROR:  relation "atestc" does not exist
 SET SESSION AUTHORIZATION regress_priv_user2;
 SELECT fx FROM atestp2; -- ok
- fx 
-----
-(0 rows)
-
+ERROR:  relation "atestp2" does not exist
+LINE 1: SELECT fx FROM atestp2;
+                       ^
 SELECT fy FROM atestp2; -- ok
- fy 
-----
-(0 rows)
-
+ERROR:  relation "atestp2" does not exist
+LINE 1: SELECT fy FROM atestp2;
+                       ^
 SELECT atestp2 FROM atestp2; -- ok
- atestp2 
----------
-(0 rows)
-
+ERROR:  relation "atestp2" does not exist
+LINE 1: SELECT atestp2 FROM atestp2;
+                            ^
 SELECT tableoid FROM atestp2; -- ok
- tableoid 
-----------
-(0 rows)
-
+ERROR:  relation "atestp2" does not exist
+LINE 1: SELECT tableoid FROM atestp2;
+                             ^
 SELECT fy FROM atestc; -- fail
-ERROR:  permission denied for table atestc
+ERROR:  relation "atestc" does not exist
+LINE 1: SELECT fy FROM atestc;
+                       ^
 SET SESSION AUTHORIZATION regress_priv_user1;
 GRANT SELECT(fy,tableoid) ON atestc TO regress_priv_user2;
+ERROR:  relation "atestc" does not exist
 SET SESSION AUTHORIZATION regress_priv_user2;
 SELECT fx FROM atestp2; -- still ok
- fx 
-----
-(0 rows)
-
+ERROR:  relation "atestp2" does not exist
+LINE 1: SELECT fx FROM atestp2;
+                       ^
 SELECT fy FROM atestp2; -- ok
- fy 
-----
-(0 rows)
-
+ERROR:  relation "atestp2" does not exist
+LINE 1: SELECT fy FROM atestp2;
+                       ^
 SELECT atestp2 FROM atestp2; -- ok
- atestp2 
----------
-(0 rows)
-
+ERROR:  relation "atestp2" does not exist
+LINE 1: SELECT atestp2 FROM atestp2;
+                            ^
 SELECT tableoid FROM atestp2; -- ok
- tableoid 
-----------
-(0 rows)
-
+ERROR:  relation "atestp2" does not exist
+LINE 1: SELECT tableoid FROM atestp2;
+                             ^
 -- child's permissions do not apply when operating on parent
 SET SESSION AUTHORIZATION regress_priv_user1;
 REVOKE ALL ON atestc FROM regress_priv_user2;
+ERROR:  relation "atestc" does not exist
 GRANT ALL ON atestp1 TO regress_priv_user2;
+ERROR:  relation "atestp1" does not exist
 SET SESSION AUTHORIZATION regress_priv_user2;
 SELECT f2 FROM atestp1; -- ok
- f2 
-----
-(0 rows)
-
+ERROR:  relation "atestp1" does not exist
+LINE 1: SELECT f2 FROM atestp1;
+                       ^
 SELECT f2 FROM atestc; -- fail
-ERROR:  permission denied for table atestc
+ERROR:  relation "atestc" does not exist
+LINE 1: SELECT f2 FROM atestc;
+                       ^
 DELETE FROM atestp1; -- ok
+ERROR:  relation "atestp1" does not exist
+LINE 1: DELETE FROM atestp1;
+                    ^
 DELETE FROM atestc; -- fail
-ERROR:  permission denied for table atestc
+ERROR:  relation "atestc" does not exist
+LINE 1: DELETE FROM atestc;
+                    ^
 UPDATE atestp1 SET f1 = 1; -- ok
+ERROR:  relation "atestp1" does not exist
+LINE 1: UPDATE atestp1 SET f1 = 1;
+               ^
 UPDATE atestc SET f1 = 1; -- fail
-ERROR:  permission denied for table atestc
+ERROR:  relation "atestc" does not exist
+LINE 1: UPDATE atestc SET f1 = 1;
+               ^
 TRUNCATE atestp1; -- ok
+ERROR:  relation "atestp1" does not exist
 TRUNCATE atestc; -- fail
-ERROR:  permission denied for table atestc
+ERROR:  relation "atestc" does not exist
 BEGIN;
 LOCK atestp1;
+ERROR:  relation "atestp1" does not exist
 END;
 BEGIN;
 LOCK atestc;
-ERROR:  permission denied for table atestc
+ERROR:  relation "atestc" does not exist
 END;
 -- privileges on functions, languages
 -- switch to superuser
 \c -
-REVOKE ALL PRIVILEGES ON LANGUAGE sql FROM PUBLIC;
-GRANT USAGE ON LANGUAGE sql TO regress_priv_user1; -- ok
-GRANT USAGE ON LANGUAGE c TO PUBLIC; -- fail
-ERROR:  language "c" is not trusted
-DETAIL:  GRANT and REVOKE are not allowed on untrusted languages, because only superusers can use untrusted languages.
-SET SESSION AUTHORIZATION regress_priv_user1;
-GRANT USAGE ON LANGUAGE sql TO regress_priv_user2; -- fail
-WARNING:  no privileges were granted for "sql"
-CREATE FUNCTION priv_testfunc1(int) RETURNS int AS 'select 2 * $1;' LANGUAGE sql;
-CREATE FUNCTION priv_testfunc2(int) RETURNS int AS 'select 3 * $1;' LANGUAGE sql;
-CREATE AGGREGATE priv_testagg1(int) (sfunc = int4pl, stype = int4);
-CREATE PROCEDURE priv_testproc1(int) AS 'select $1;' LANGUAGE sql;
-REVOKE ALL ON FUNCTION priv_testfunc1(int), priv_testfunc2(int), priv_testagg1(int) FROM PUBLIC;
-GRANT EXECUTE ON FUNCTION priv_testfunc1(int), priv_testfunc2(int), priv_testagg1(int) TO regress_priv_user2;
-REVOKE ALL ON FUNCTION priv_testproc1(int) FROM PUBLIC; -- fail, not a function
-ERROR:  priv_testproc1(integer) is not a function
-REVOKE ALL ON PROCEDURE priv_testproc1(int) FROM PUBLIC;
-GRANT EXECUTE ON PROCEDURE priv_testproc1(int) TO regress_priv_user2;
-GRANT USAGE ON FUNCTION priv_testfunc1(int) TO regress_priv_user3; -- semantic error
-ERROR:  invalid privilege type USAGE for function
-GRANT USAGE ON FUNCTION priv_testagg1(int) TO regress_priv_user3; -- semantic error
-ERROR:  invalid privilege type USAGE for function
-GRANT USAGE ON PROCEDURE priv_testproc1(int) TO regress_priv_user3; -- semantic error
-ERROR:  invalid privilege type USAGE for procedure
-GRANT ALL PRIVILEGES ON FUNCTION priv_testfunc1(int) TO regress_priv_user4;
-GRANT ALL PRIVILEGES ON FUNCTION priv_testfunc_nosuch(int) TO regress_priv_user4;
-ERROR:  function priv_testfunc_nosuch(integer) does not exist
-GRANT ALL PRIVILEGES ON FUNCTION priv_testagg1(int) TO regress_priv_user4;
-GRANT ALL PRIVILEGES ON PROCEDURE priv_testproc1(int) TO regress_priv_user4;
-CREATE FUNCTION priv_testfunc4(boolean) RETURNS text
-  AS 'select col1 from atest2 where col2 = $1;'
-  LANGUAGE sql SECURITY DEFINER;
-GRANT EXECUTE ON FUNCTION priv_testfunc4(boolean) TO regress_priv_user3;
-SET SESSION AUTHORIZATION regress_priv_user2;
-SELECT priv_testfunc1(5), priv_testfunc2(5); -- ok
- priv_testfunc1 | priv_testfunc2 
-----------------+----------------
-             10 |             15
-(1 row)
-
-CREATE FUNCTION priv_testfunc3(int) RETURNS int AS 'select 2 * $1;' LANGUAGE sql; -- fail
-ERROR:  permission denied for language sql
-SELECT priv_testagg1(x) FROM (VALUES (1), (2), (3)) _(x); -- ok
- priv_testagg1 
----------------
-             6
-(1 row)
-
-CALL priv_testproc1(6); -- ok
-SET SESSION AUTHORIZATION regress_priv_user3;
-SELECT priv_testfunc1(5); -- fail
-ERROR:  permission denied for function priv_testfunc1
-SELECT priv_testagg1(x) FROM (VALUES (1), (2), (3)) _(x); -- fail
-ERROR:  permission denied for aggregate priv_testagg1
-CALL priv_testproc1(6); -- fail
-ERROR:  permission denied for procedure priv_testproc1
-SELECT col1 FROM atest2 WHERE col2 = true; -- fail
-ERROR:  permission denied for table atest2
-SELECT priv_testfunc4(true); -- ok
- priv_testfunc4 
-----------------
- bar
-(1 row)
-
-SET SESSION AUTHORIZATION regress_priv_user4;
-SELECT priv_testfunc1(5); -- ok
- priv_testfunc1 
-----------------
-             10
-(1 row)
-
-SELECT priv_testagg1(x) FROM (VALUES (1), (2), (3)) _(x); -- ok
- priv_testagg1 
----------------
-             6
-(1 row)
-
-CALL priv_testproc1(6); -- ok
-DROP FUNCTION priv_testfunc1(int); -- fail
-ERROR:  must be owner of function priv_testfunc1
-DROP AGGREGATE priv_testagg1(int); -- fail
-ERROR:  must be owner of aggregate priv_testagg1
-DROP PROCEDURE priv_testproc1(int); -- fail
-ERROR:  must be owner of procedure priv_testproc1
-\c -
-DROP FUNCTION priv_testfunc1(int); -- ok
--- restore to sanity
-GRANT ALL PRIVILEGES ON LANGUAGE sql TO PUBLIC;
--- verify privilege checks on array-element coercions
-BEGIN;
-SELECT '{1}'::int4[]::int8[];
- int8 
-------
- {1}
-(1 row)
-
-REVOKE ALL ON FUNCTION int8(integer) FROM PUBLIC;
-SELECT '{1}'::int4[]::int8[]; --superuser, succeed
- int8 
-------
- {1}
-(1 row)
-
-SET SESSION AUTHORIZATION regress_priv_user4;
-SELECT '{1}'::int4[]::int8[]; --other user, fail
-ERROR:  permission denied for function int8
-ROLLBACK;
--- privileges on types
--- switch to superuser
-\c -
-CREATE TYPE priv_testtype1 AS (a int, b text);
-REVOKE USAGE ON TYPE priv_testtype1 FROM PUBLIC;
-GRANT USAGE ON TYPE priv_testtype1 TO regress_priv_user2;
-GRANT USAGE ON TYPE _priv_testtype1 TO regress_priv_user2; -- fail
-ERROR:  cannot set privileges of array types
-HINT:  Set the privileges of the element type instead.
-GRANT USAGE ON DOMAIN priv_testtype1 TO regress_priv_user2; -- fail
-ERROR:  "priv_testtype1" is not a domain
-CREATE DOMAIN priv_testdomain1 AS int;
-REVOKE USAGE on DOMAIN priv_testdomain1 FROM PUBLIC;
-GRANT USAGE ON DOMAIN priv_testdomain1 TO regress_priv_user2;
-GRANT USAGE ON TYPE priv_testdomain1 TO regress_priv_user2; -- ok
-SET SESSION AUTHORIZATION regress_priv_user1;
--- commands that should fail
-CREATE AGGREGATE priv_testagg1a(priv_testdomain1) (sfunc = int4_sum, stype = bigint);
-ERROR:  permission denied for type priv_testdomain1
-CREATE DOMAIN priv_testdomain2a AS priv_testdomain1;
-ERROR:  permission denied for type priv_testdomain1
-CREATE DOMAIN priv_testdomain3a AS int;
-CREATE FUNCTION castfunc(int) RETURNS priv_testdomain3a AS $$ SELECT $1::priv_testdomain3a $$ LANGUAGE SQL;
-CREATE CAST (priv_testdomain1 AS priv_testdomain3a) WITH FUNCTION castfunc(int);
-ERROR:  permission denied for type priv_testdomain1
-DROP FUNCTION castfunc(int) CASCADE;
-DROP DOMAIN priv_testdomain3a;
-CREATE FUNCTION priv_testfunc5a(a priv_testdomain1) RETURNS int LANGUAGE SQL AS $$ SELECT $1 $$;
-ERROR:  permission denied for type priv_testdomain1
-CREATE FUNCTION priv_testfunc6a(b int) RETURNS priv_testdomain1 LANGUAGE SQL AS $$ SELECT $1::priv_testdomain1 $$;
-ERROR:  permission denied for type priv_testdomain1
-CREATE OPERATOR !+! (PROCEDURE = int4pl, LEFTARG = priv_testdomain1, RIGHTARG = priv_testdomain1);
-ERROR:  permission denied for type priv_testdomain1
-CREATE TABLE test5a (a int, b priv_testdomain1);
-ERROR:  permission denied for type priv_testdomain1
-CREATE TABLE test6a OF priv_testtype1;
-ERROR:  permission denied for type priv_testtype1
-CREATE TABLE test10a (a int[], b priv_testtype1[]);
-ERROR:  permission denied for type priv_testtype1
-CREATE TABLE test9a (a int, b int);
-ALTER TABLE test9a ADD COLUMN c priv_testdomain1;
-ERROR:  permission denied for type priv_testdomain1
-ALTER TABLE test9a ALTER COLUMN b TYPE priv_testdomain1;
-ERROR:  permission denied for type priv_testdomain1
-CREATE TYPE test7a AS (a int, b priv_testdomain1);
-ERROR:  permission denied for type priv_testdomain1
-CREATE TYPE test8a AS (a int, b int);
-ALTER TYPE test8a ADD ATTRIBUTE c priv_testdomain1;
-ERROR:  permission denied for type priv_testdomain1
-ALTER TYPE test8a ALTER ATTRIBUTE b TYPE priv_testdomain1;
-ERROR:  permission denied for type priv_testdomain1
-CREATE TABLE test11a AS (SELECT 1::priv_testdomain1 AS a);
-ERROR:  permission denied for type priv_testdomain1
-REVOKE ALL ON TYPE priv_testtype1 FROM PUBLIC;
-ERROR:  permission denied for type priv_testtype1
-SET SESSION AUTHORIZATION regress_priv_user2;
--- commands that should succeed
-CREATE AGGREGATE priv_testagg1b(priv_testdomain1) (sfunc = int4_sum, stype = bigint);
-CREATE DOMAIN priv_testdomain2b AS priv_testdomain1;
-CREATE DOMAIN priv_testdomain3b AS int;
-CREATE FUNCTION castfunc(int) RETURNS priv_testdomain3b AS $$ SELECT $1::priv_testdomain3b $$ LANGUAGE SQL;
-CREATE CAST (priv_testdomain1 AS priv_testdomain3b) WITH FUNCTION castfunc(int);
-WARNING:  cast will be ignored because the source data type is a domain
-CREATE FUNCTION priv_testfunc5b(a priv_testdomain1) RETURNS int LANGUAGE SQL AS $$ SELECT $1 $$;
-CREATE FUNCTION priv_testfunc6b(b int) RETURNS priv_testdomain1 LANGUAGE SQL AS $$ SELECT $1::priv_testdomain1 $$;
-CREATE OPERATOR !! (PROCEDURE = priv_testfunc5b, RIGHTARG = priv_testdomain1);
-CREATE TABLE test5b (a int, b priv_testdomain1);
-CREATE TABLE test6b OF priv_testtype1;
-CREATE TABLE test10b (a int[], b priv_testtype1[]);
-CREATE TABLE test9b (a int, b int);
-ALTER TABLE test9b ADD COLUMN c priv_testdomain1;
-ALTER TABLE test9b ALTER COLUMN b TYPE priv_testdomain1;
-CREATE TYPE test7b AS (a int, b priv_testdomain1);
-CREATE TYPE test8b AS (a int, b int);
-ALTER TYPE test8b ADD ATTRIBUTE c priv_testdomain1;
-ALTER TYPE test8b ALTER ATTRIBUTE b TYPE priv_testdomain1;
-CREATE TABLE test11b AS (SELECT 1::priv_testdomain1 AS a);
-REVOKE ALL ON TYPE priv_testtype1 FROM PUBLIC;
-WARNING:  no privileges could be revoked for "priv_testtype1"
-\c -
-DROP AGGREGATE priv_testagg1b(priv_testdomain1);
-DROP DOMAIN priv_testdomain2b;
-DROP OPERATOR !! (NONE, priv_testdomain1);
-DROP FUNCTION priv_testfunc5b(a priv_testdomain1);
-DROP FUNCTION priv_testfunc6b(b int);
-DROP TABLE test5b;
-DROP TABLE test6b;
-DROP TABLE test9b;
-DROP TABLE test10b;
-DROP TYPE test7b;
-DROP TYPE test8b;
-DROP CAST (priv_testdomain1 AS priv_testdomain3b);
-DROP FUNCTION castfunc(int) CASCADE;
-DROP DOMAIN priv_testdomain3b;
-DROP TABLE test11b;
-DROP TYPE priv_testtype1; -- ok
-DROP DOMAIN priv_testdomain1; -- ok
--- truncate
-SET SESSION AUTHORIZATION regress_priv_user5;
-TRUNCATE atest2; -- ok
-TRUNCATE atest3; -- fail
-ERROR:  permission denied for table atest3
--- has_table_privilege function
--- bad-input checks
-select has_table_privilege(NULL,'pg_authid','select');
- has_table_privilege 
----------------------
- 
-(1 row)
-
-select has_table_privilege('pg_shad','select');
-ERROR:  relation "pg_shad" does not exist
-select has_table_privilege('nosuchuser','pg_authid','select');
-ERROR:  role "nosuchuser" does not exist
-select has_table_privilege('pg_authid','sel');
-ERROR:  unrecognized privilege type: "sel"
-select has_table_privilege(-999999,'pg_authid','update');
- has_table_privilege 
----------------------
- f
-(1 row)
-
-select has_table_privilege(1,'select');
- has_table_privilege 
----------------------
- 
-(1 row)
-
--- superuser
-\c -
-select has_table_privilege(current_user,'pg_authid','select');
- has_table_privilege 
----------------------
- t
-(1 row)
-
-select has_table_privilege(current_user,'pg_authid','insert');
- has_table_privilege 
----------------------
- t
-(1 row)
-
-select has_table_privilege(t2.oid,'pg_authid','update')
-from (select oid from pg_roles where rolname = current_user) as t2;
- has_table_privilege 
----------------------
- t
-(1 row)
-
-select has_table_privilege(t2.oid,'pg_authid','delete')
-from (select oid from pg_roles where rolname = current_user) as t2;
- has_table_privilege 
----------------------
- t
-(1 row)
-
--- 'rule' privilege no longer exists, but for backwards compatibility
--- has_table_privilege still recognizes the keyword and says FALSE
-select has_table_privilege(current_user,t1.oid,'rule')
-from (select oid from pg_class where relname = 'pg_authid') as t1;
- has_table_privilege 
----------------------
- f
-(1 row)
-
-select has_table_privilege(current_user,t1.oid,'references')
-from (select oid from pg_class where relname = 'pg_authid') as t1;
- has_table_privilege 
----------------------
- t
-(1 row)
-
-select has_table_privilege(t2.oid,t1.oid,'select')
-from (select oid from pg_class where relname = 'pg_authid') as t1,
-  (select oid from pg_roles where rolname = current_user) as t2;
- has_table_privilege 
----------------------
- t
-(1 row)
-
-select has_table_privilege(t2.oid,t1.oid,'insert')
-from (select oid from pg_class where relname = 'pg_authid') as t1,
-  (select oid from pg_roles where rolname = current_user) as t2;
- has_table_privilege 
----------------------
- t
-(1 row)
-
-select has_table_privilege('pg_authid','update');
- has_table_privilege 
----------------------
- t
-(1 row)
-
-select has_table_privilege('pg_authid','delete');
- has_table_privilege 
----------------------
- t
-(1 row)
-
-select has_table_privilege('pg_authid','truncate');
- has_table_privilege 
----------------------
- t
-(1 row)
-
-select has_table_privilege(t1.oid,'select')
-from (select oid from pg_class where relname = 'pg_authid') as t1;
- has_table_privilege 
----------------------
- t
-(1 row)
-
-select has_table_privilege(t1.oid,'trigger')
-from (select oid from pg_class where relname = 'pg_authid') as t1;
- has_table_privilege 
----------------------
- t
-(1 row)
-
--- non-superuser
-SET SESSION AUTHORIZATION regress_priv_user3;
-select has_table_privilege(current_user,'pg_class','select');
- has_table_privilege 
----------------------
- t
-(1 row)
-
-select has_table_privilege(current_user,'pg_class','insert');
- has_table_privilege 
----------------------
- f
-(1 row)
-
-select has_table_privilege(t2.oid,'pg_class','update')
-from (select oid from pg_roles where rolname = current_user) as t2;
- has_table_privilege 
----------------------
- f
-(1 row)
-
-select has_table_privilege(t2.oid,'pg_class','delete')
-from (select oid from pg_roles where rolname = current_user) as t2;
- has_table_privilege 
----------------------
- f
-(1 row)
-
-select has_table_privilege(current_user,t1.oid,'references')
-from (select oid from pg_class where relname = 'pg_class') as t1;
- has_table_privilege 
----------------------
- f
-(1 row)
-
-select has_table_privilege(t2.oid,t1.oid,'select')
-from (select oid from pg_class where relname = 'pg_class') as t1,
-  (select oid from pg_roles where rolname = current_user) as t2;
- has_table_privilege 
----------------------
- t
-(1 row)
-
-select has_table_privilege(t2.oid,t1.oid,'insert')
-from (select oid from pg_class where relname = 'pg_class') as t1,
-  (select oid from pg_roles where rolname = current_user) as t2;
- has_table_privilege 
----------------------
- f
-(1 row)
-
-select has_table_privilege('pg_class','update');
- has_table_privilege 
----------------------
- f
-(1 row)
-
-select has_table_privilege('pg_class','delete');
- has_table_privilege 
----------------------
- f
-(1 row)
-
-select has_table_privilege('pg_class','truncate');
- has_table_privilege 
----------------------
- f
-(1 row)
-
-select has_table_privilege(t1.oid,'select')
-from (select oid from pg_class where relname = 'pg_class') as t1;
- has_table_privilege 
----------------------
- t
-(1 row)
-
-select has_table_privilege(t1.oid,'trigger')
-from (select oid from pg_class where relname = 'pg_class') as t1;
- has_table_privilege 
----------------------
- f
-(1 row)
-
-select has_table_privilege(current_user,'atest1','select');
- has_table_privilege 
----------------------
- t
-(1 row)
-
-select has_table_privilege(current_user,'atest1','insert');
- has_table_privilege 
----------------------
- f
-(1 row)
-
-select has_table_privilege(t2.oid,'atest1','update')
-from (select oid from pg_roles where rolname = current_user) as t2;
- has_table_privilege 
----------------------
- f
-(1 row)
-
-select has_table_privilege(t2.oid,'atest1','delete')
-from (select oid from pg_roles where rolname = current_user) as t2;
- has_table_privilege 
----------------------
- f
-(1 row)
-
-select has_table_privilege(current_user,t1.oid,'references')
-from (select oid from pg_class where relname = 'atest1') as t1;
- has_table_privilege 
----------------------
- f
-(1 row)
-
-select has_table_privilege(t2.oid,t1.oid,'select')
-from (select oid from pg_class where relname = 'atest1') as t1,
-  (select oid from pg_roles where rolname = current_user) as t2;
- has_table_privilege 
----------------------
- t
-(1 row)
-
-select has_table_privilege(t2.oid,t1.oid,'insert')
-from (select oid from pg_class where relname = 'atest1') as t1,
-  (select oid from pg_roles where rolname = current_user) as t2;
- has_table_privilege 
----------------------
- f
-(1 row)
-
-select has_table_privilege('atest1','update');
- has_table_privilege 
----------------------
- f
-(1 row)
-
-select has_table_privilege('atest1','delete');
- has_table_privilege 
----------------------
- f
-(1 row)
-
-select has_table_privilege('atest1','truncate');
- has_table_privilege 
----------------------
- f
-(1 row)
-
-select has_table_privilege(t1.oid,'select')
-from (select oid from pg_class where relname = 'atest1') as t1;
- has_table_privilege 
----------------------
- t
-(1 row)
-
-select has_table_privilege(t1.oid,'trigger')
-from (select oid from pg_class where relname = 'atest1') as t1;
- has_table_privilege 
----------------------
- f
-(1 row)
-
--- has_column_privilege function
--- bad-input checks (as non-super-user)
-select has_column_privilege('pg_authid',NULL,'select');
- has_column_privilege 
-----------------------
- 
-(1 row)
-
-select has_column_privilege('pg_authid','nosuchcol','select');
-ERROR:  column "nosuchcol" of relation "pg_authid" does not exist
-select has_column_privilege(9999,'nosuchcol','select');
- has_column_privilege 
-----------------------
- 
-(1 row)
-
-select has_column_privilege(9999,99::int2,'select');
- has_column_privilege 
-----------------------
- 
-(1 row)
-
-select has_column_privilege('pg_authid',99::int2,'select');
- has_column_privilege 
-----------------------
- 
-(1 row)
-
-select has_column_privilege(9999,99::int2,'select');
- has_column_privilege 
-----------------------
- 
-(1 row)
-
-create temp table mytable(f1 int, f2 int, f3 int);
-alter table mytable drop column f2;
-select has_column_privilege('mytable','f2','select');
-ERROR:  column "f2" of relation "mytable" does not exist
-select has_column_privilege('mytable','........pg.dropped.2........','select');
- has_column_privilege 
-----------------------
- 
-(1 row)
-
-select has_column_privilege('mytable',2::int2,'select');
- has_column_privilege 
-----------------------
- 
-(1 row)
-
-select has_column_privilege('mytable',99::int2,'select');
- has_column_privilege 
-----------------------
- 
-(1 row)
-
-revoke select on table mytable from regress_priv_user3;
-select has_column_privilege('mytable',2::int2,'select');
- has_column_privilege 
-----------------------
- 
-(1 row)
-
-select has_column_privilege('mytable',99::int2,'select');
- has_column_privilege 
-----------------------
- 
-(1 row)
-
-drop table mytable;
--- Grant options
-SET SESSION AUTHORIZATION regress_priv_user1;
-CREATE TABLE atest4 (a int);
-GRANT SELECT ON atest4 TO regress_priv_user2 WITH GRANT OPTION;
-GRANT UPDATE ON atest4 TO regress_priv_user2;
-GRANT SELECT ON atest4 TO GROUP regress_priv_group1 WITH GRANT OPTION;
-SET SESSION AUTHORIZATION regress_priv_user2;
-GRANT SELECT ON atest4 TO regress_priv_user3;
-GRANT UPDATE ON atest4 TO regress_priv_user3; -- fail
-WARNING:  no privileges were granted for "atest4"
-SET SESSION AUTHORIZATION regress_priv_user1;
-REVOKE SELECT ON atest4 FROM regress_priv_user3; -- does nothing
-SELECT has_table_privilege('regress_priv_user3', 'atest4', 'SELECT'); -- true
- has_table_privilege 
----------------------
- t
-(1 row)
-
-REVOKE SELECT ON atest4 FROM regress_priv_user2; -- fail
-ERROR:  dependent privileges exist
-HINT:  Use CASCADE to revoke them too.
-REVOKE GRANT OPTION FOR SELECT ON atest4 FROM regress_priv_user2 CASCADE; -- ok
-SELECT has_table_privilege('regress_priv_user2', 'atest4', 'SELECT'); -- true
- has_table_privilege 
----------------------
- t
-(1 row)
-
-SELECT has_table_privilege('regress_priv_user3', 'atest4', 'SELECT'); -- false
- has_table_privilege 
----------------------
- f
-(1 row)
-
-SELECT has_table_privilege('regress_priv_user1', 'atest4', 'SELECT WITH GRANT OPTION'); -- true
- has_table_privilege 
----------------------
- t
-(1 row)
-
--- security-restricted operations
-\c -
-CREATE ROLE regress_sro_user;
-SET SESSION AUTHORIZATION regress_sro_user;
-CREATE FUNCTION unwanted_grant() RETURNS void LANGUAGE sql AS
-	'GRANT regress_priv_group2 TO regress_sro_user';
-CREATE FUNCTION mv_action() RETURNS bool LANGUAGE sql AS
-	'DECLARE c CURSOR WITH HOLD FOR SELECT unwanted_grant(); SELECT true';
--- REFRESH of this MV will queue a GRANT at end of transaction
-CREATE MATERIALIZED VIEW sro_mv AS SELECT mv_action() WITH NO DATA;
-REFRESH MATERIALIZED VIEW sro_mv;
-ERROR:  cannot create a cursor WITH HOLD within security-restricted operation
-CONTEXT:  SQL function "mv_action" statement 1
-\c -
-REFRESH MATERIALIZED VIEW sro_mv;
-ERROR:  cannot create a cursor WITH HOLD within security-restricted operation
-CONTEXT:  SQL function "mv_action" statement 1
-SET SESSION AUTHORIZATION regress_sro_user;
--- INSERT to this table will queue a GRANT at end of transaction
-CREATE TABLE sro_trojan_table ();
-CREATE FUNCTION sro_trojan() RETURNS trigger LANGUAGE plpgsql AS
-	'BEGIN PERFORM unwanted_grant(); RETURN NULL; END';
-CREATE CONSTRAINT TRIGGER t AFTER INSERT ON sro_trojan_table
-    INITIALLY DEFERRED FOR EACH ROW EXECUTE PROCEDURE sro_trojan();
--- Now, REFRESH will issue such an INSERT, queueing the GRANT
-CREATE OR REPLACE FUNCTION mv_action() RETURNS bool LANGUAGE sql AS
-	'INSERT INTO sro_trojan_table DEFAULT VALUES; SELECT true';
-REFRESH MATERIALIZED VIEW sro_mv;
-ERROR:  cannot fire deferred trigger within security-restricted operation
-CONTEXT:  SQL function "mv_action" statement 1
-\c -
-REFRESH MATERIALIZED VIEW sro_mv;
-ERROR:  cannot fire deferred trigger within security-restricted operation
-CONTEXT:  SQL function "mv_action" statement 1
-BEGIN; SET CONSTRAINTS ALL IMMEDIATE; REFRESH MATERIALIZED VIEW sro_mv; COMMIT;
-ERROR:  must have admin option on role "regress_priv_group2"
-CONTEXT:  SQL function "unwanted_grant" statement 1
-SQL statement "SELECT unwanted_grant()"
-PL/pgSQL function sro_trojan() line 1 at PERFORM
-SQL function "mv_action" statement 1
-DROP OWNED BY regress_sro_user;
-DROP ROLE regress_sro_user;
--- Admin options
-SET SESSION AUTHORIZATION regress_priv_user4;
-CREATE FUNCTION dogrant_ok() RETURNS void LANGUAGE sql SECURITY DEFINER AS
-	'GRANT regress_priv_group2 TO regress_priv_user5';
-GRANT regress_priv_group2 TO regress_priv_user5; -- ok: had ADMIN OPTION
-SET ROLE regress_priv_group2;
-GRANT regress_priv_group2 TO regress_priv_user5; -- fails: SET ROLE suspended privilege
-ERROR:  must have admin option on role "regress_priv_group2"
-SET SESSION AUTHORIZATION regress_priv_user1;
-GRANT regress_priv_group2 TO regress_priv_user5; -- fails: no ADMIN OPTION
-ERROR:  must have admin option on role "regress_priv_group2"
-SELECT dogrant_ok();			-- ok: SECURITY DEFINER conveys ADMIN
-NOTICE:  role "regress_priv_user5" is already a member of role "regress_priv_group2"
- dogrant_ok 
-------------
- 
-(1 row)
-
-SET ROLE regress_priv_group2;
-GRANT regress_priv_group2 TO regress_priv_user5; -- fails: SET ROLE did not help
-ERROR:  must have admin option on role "regress_priv_group2"
-SET SESSION AUTHORIZATION regress_priv_group2;
-GRANT regress_priv_group2 TO regress_priv_user5; -- ok: a role can self-admin
-NOTICE:  role "regress_priv_user5" is already a member of role "regress_priv_group2"
-CREATE FUNCTION dogrant_fails() RETURNS void LANGUAGE sql SECURITY DEFINER AS
-	'GRANT regress_priv_group2 TO regress_priv_user5';
-SELECT dogrant_fails();			-- fails: no self-admin in SECURITY DEFINER
-ERROR:  must have admin option on role "regress_priv_group2"
-CONTEXT:  SQL function "dogrant_fails" statement 1
-DROP FUNCTION dogrant_fails();
-SET SESSION AUTHORIZATION regress_priv_user4;
-DROP FUNCTION dogrant_ok();
-REVOKE regress_priv_group2 FROM regress_priv_user5;
--- has_sequence_privilege tests
-\c -
-CREATE SEQUENCE x_seq;
-GRANT USAGE on x_seq to regress_priv_user2;
-SELECT has_sequence_privilege('regress_priv_user1', 'atest1', 'SELECT');
-ERROR:  "atest1" is not a sequence
-SELECT has_sequence_privilege('regress_priv_user1', 'x_seq', 'INSERT');
-ERROR:  unrecognized privilege type: "INSERT"
-SELECT has_sequence_privilege('regress_priv_user1', 'x_seq', 'SELECT');
- has_sequence_privilege 
-------------------------
- f
-(1 row)
-
-SET SESSION AUTHORIZATION regress_priv_user2;
-SELECT has_sequence_privilege('x_seq', 'USAGE');
- has_sequence_privilege 
-------------------------
- t
-(1 row)
+dyld: lazy symbol binding failed: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
+
+dyld: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
 
--- largeobject privilege tests
-\c -
-SET SESSION AUTHORIZATION regress_priv_user1;
-SELECT lo_create(1001);
- lo_create 
------------
-      1001
-(1 row)
-
-SELECT lo_create(1002);
- lo_create 
------------
-      1002
-(1 row)
-
-SELECT lo_create(1003);
- lo_create 
------------
-      1003
-(1 row)
-
-SELECT lo_create(1004);
- lo_create 
------------
-      1004
-(1 row)
-
-SELECT lo_create(1005);
- lo_create 
------------
-      1005
-(1 row)
-
-GRANT ALL ON LARGE OBJECT 1001 TO PUBLIC;
-GRANT SELECT ON LARGE OBJECT 1003 TO regress_priv_user2;
-GRANT SELECT,UPDATE ON LARGE OBJECT 1004 TO regress_priv_user2;
-GRANT ALL ON LARGE OBJECT 1005 TO regress_priv_user2;
-GRANT SELECT ON LARGE OBJECT 1005 TO regress_priv_user2 WITH GRANT OPTION;
-GRANT SELECT, INSERT ON LARGE OBJECT 1001 TO PUBLIC;	-- to be failed
-ERROR:  invalid privilege type INSERT for large object
-GRANT SELECT, UPDATE ON LARGE OBJECT 1001 TO nosuchuser;	-- to be failed
-ERROR:  role "nosuchuser" does not exist
-GRANT SELECT, UPDATE ON LARGE OBJECT  999 TO PUBLIC;	-- to be failed
-ERROR:  large object 999 does not exist
-\c -
-SET SESSION AUTHORIZATION regress_priv_user2;
-SELECT lo_create(2001);
- lo_create 
------------
-      2001
-(1 row)
-
-SELECT lo_create(2002);
- lo_create 
------------
-      2002
-(1 row)
-
-SELECT loread(lo_open(1001, x'20000'::int), 32);	-- allowed, for now
- loread 
---------
- \x
-(1 row)
-
-SELECT lowrite(lo_open(1001, x'40000'::int), 'abcd');	-- fail, wrong mode
-ERROR:  large object descriptor 0 was not opened for writing
-SELECT loread(lo_open(1001, x'40000'::int), 32);
- loread 
---------
- \x
-(1 row)
-
-SELECT loread(lo_open(1002, x'40000'::int), 32);	-- to be denied
-ERROR:  permission denied for large object 1002
-SELECT loread(lo_open(1003, x'40000'::int), 32);
- loread 
---------
- \x
-(1 row)
-
-SELECT loread(lo_open(1004, x'40000'::int), 32);
- loread 
---------
- \x
-(1 row)
-
-SELECT lowrite(lo_open(1001, x'20000'::int), 'abcd');
- lowrite 
----------
-       4
-(1 row)
-
-SELECT lowrite(lo_open(1002, x'20000'::int), 'abcd');	-- to be denied
-ERROR:  permission denied for large object 1002
-SELECT lowrite(lo_open(1003, x'20000'::int), 'abcd');	-- to be denied
-ERROR:  permission denied for large object 1003
-SELECT lowrite(lo_open(1004, x'20000'::int), 'abcd');
- lowrite 
----------
-       4
-(1 row)
-
-GRANT SELECT ON LARGE OBJECT 1005 TO regress_priv_user3;
-GRANT UPDATE ON LARGE OBJECT 1006 TO regress_priv_user3;	-- to be denied
-ERROR:  large object 1006 does not exist
-REVOKE ALL ON LARGE OBJECT 2001, 2002 FROM PUBLIC;
-GRANT ALL ON LARGE OBJECT 2001 TO regress_priv_user3;
-SELECT lo_unlink(1001);		-- to be denied
-ERROR:  must be owner of large object 1001
-SELECT lo_unlink(2002);
- lo_unlink 
------------
-         1
-(1 row)
-
-\c -
--- confirm ACL setting
-SELECT oid, pg_get_userbyid(lomowner) ownername, lomacl FROM pg_largeobject_metadata WHERE oid >= 1000 AND oid < 3000 ORDER BY oid;
- oid  |     ownername      |                                                            lomacl                                                            
-------+--------------------+------------------------------------------------------------------------------------------------------------------------------
- 1001 | regress_priv_user1 | {regress_priv_user1=rw/regress_priv_user1,=rw/regress_priv_user1}
- 1002 | regress_priv_user1 | 
- 1003 | regress_priv_user1 | {regress_priv_user1=rw/regress_priv_user1,regress_priv_user2=r/regress_priv_user1}
- 1004 | regress_priv_user1 | {regress_priv_user1=rw/regress_priv_user1,regress_priv_user2=rw/regress_priv_user1}
- 1005 | regress_priv_user1 | {regress_priv_user1=rw/regress_priv_user1,regress_priv_user2=r*w/regress_priv_user1,regress_priv_user3=r/regress_priv_user2}
- 2001 | regress_priv_user2 | {regress_priv_user2=rw/regress_priv_user2,regress_priv_user3=rw/regress_priv_user2}
-(6 rows)
-
-SET SESSION AUTHORIZATION regress_priv_user3;
-SELECT loread(lo_open(1001, x'40000'::int), 32);
-   loread   
-------------
- \x61626364
-(1 row)
-
-SELECT loread(lo_open(1003, x'40000'::int), 32);	-- to be denied
-ERROR:  permission denied for large object 1003
-SELECT loread(lo_open(1005, x'40000'::int), 32);
- loread 
---------
- \x
-(1 row)
-
-SELECT lo_truncate(lo_open(1005, x'20000'::int), 10);	-- to be denied
-ERROR:  permission denied for large object 1005
-SELECT lo_truncate(lo_open(2001, x'20000'::int), 10);
- lo_truncate 
--------------
-           0
-(1 row)
-
--- compatibility mode in largeobject permission
-\c -
-SET lo_compat_privileges = false;	-- default setting
-SET SESSION AUTHORIZATION regress_priv_user4;
-SELECT loread(lo_open(1002, x'40000'::int), 32);	-- to be denied
-ERROR:  permission denied for large object 1002
-SELECT lowrite(lo_open(1002, x'20000'::int), 'abcd');	-- to be denied
-ERROR:  permission denied for large object 1002
-SELECT lo_truncate(lo_open(1002, x'20000'::int), 10);	-- to be denied
-ERROR:  permission denied for large object 1002
-SELECT lo_put(1002, 1, 'abcd');				-- to be denied
-ERROR:  permission denied for large object 1002
-SELECT lo_unlink(1002);					-- to be denied
-ERROR:  must be owner of large object 1002
-SELECT lo_export(1001, '/dev/null');			-- to be denied
-ERROR:  permission denied for function lo_export
-SELECT lo_import('/dev/null');				-- to be denied
-ERROR:  permission denied for function lo_import
-SELECT lo_import('/dev/null', 2003);			-- to be denied
-ERROR:  permission denied for function lo_import
-\c -
-SET lo_compat_privileges = true;	-- compatibility mode
-SET SESSION AUTHORIZATION regress_priv_user4;
-SELECT loread(lo_open(1002, x'40000'::int), 32);
- loread 
---------
- \x
-(1 row)
-
-SELECT lowrite(lo_open(1002, x'20000'::int), 'abcd');
- lowrite 
----------
-       4
-(1 row)
-
-SELECT lo_truncate(lo_open(1002, x'20000'::int), 10);
- lo_truncate 
--------------
-           0
-(1 row)
-
-SELECT lo_unlink(1002);
- lo_unlink 
------------
-         1
-(1 row)
-
-SELECT lo_export(1001, '/dev/null');			-- to be denied
-ERROR:  permission denied for function lo_export
--- don't allow unpriv users to access pg_largeobject contents
-\c -
-SELECT * FROM pg_largeobject LIMIT 0;
- loid | pageno | data 
-------+--------+------
-(0 rows)
-
-SET SESSION AUTHORIZATION regress_priv_user1;
-SELECT * FROM pg_largeobject LIMIT 0;			-- to be denied
-ERROR:  permission denied for table pg_largeobject
--- test pg_database_owner
-RESET SESSION AUTHORIZATION;
-GRANT pg_database_owner TO regress_priv_user1;
-ERROR:  role "pg_database_owner" cannot have explicit members
-GRANT regress_priv_user1 TO pg_database_owner;
-ERROR:  role "pg_database_owner" cannot be a member of any role
-CREATE TABLE datdba_only ();
-ALTER TABLE datdba_only OWNER TO pg_database_owner;
-REVOKE DELETE ON datdba_only FROM pg_database_owner;
-SELECT
-	pg_has_role('regress_priv_user1', 'pg_database_owner', 'USAGE') as priv,
-	pg_has_role('regress_priv_user1', 'pg_database_owner', 'MEMBER') as mem,
-	pg_has_role('regress_priv_user1', 'pg_database_owner',
-				'MEMBER WITH ADMIN OPTION') as admin;
- priv | mem | admin 
-------+-----+-------
- f    | f   | f
-(1 row)
-
-BEGIN;
-DO $$BEGIN EXECUTE format(
-	'ALTER DATABASE %I OWNER TO regress_priv_group2', current_catalog); END$$;
-SELECT
-	pg_has_role('regress_priv_user1', 'pg_database_owner', 'USAGE') as priv,
-	pg_has_role('regress_priv_user1', 'pg_database_owner', 'MEMBER') as mem,
-	pg_has_role('regress_priv_user1', 'pg_database_owner',
-				'MEMBER WITH ADMIN OPTION') as admin;
- priv | mem | admin 
-------+-----+-------
- t    | t   | f
-(1 row)
-
-SET SESSION AUTHORIZATION regress_priv_user1;
-TABLE information_schema.enabled_roles ORDER BY role_name COLLATE "C";
-      role_name      
----------------------
- pg_database_owner
- regress_priv_group2
- regress_priv_user1
-(3 rows)
-
-TABLE information_schema.applicable_roles ORDER BY role_name COLLATE "C";
-       grantee       |      role_name      | is_grantable 
----------------------+---------------------+--------------
- regress_priv_group2 | pg_database_owner   | NO
- regress_priv_user1  | regress_priv_group2 | NO
-(2 rows)
-
-INSERT INTO datdba_only DEFAULT VALUES;
-SAVEPOINT q; DELETE FROM datdba_only; ROLLBACK TO q;
-ERROR:  permission denied for table datdba_only
-SET SESSION AUTHORIZATION regress_priv_user2;
-TABLE information_schema.enabled_roles;
-     role_name      
---------------------
- regress_priv_user2
-(1 row)
-
-INSERT INTO datdba_only DEFAULT VALUES;
-ERROR:  permission denied for table datdba_only
-ROLLBACK;
--- test default ACLs
-\c -
-CREATE SCHEMA testns;
-GRANT ALL ON SCHEMA testns TO regress_priv_user1;
-CREATE TABLE testns.acltest1 (x int);
-SELECT has_table_privilege('regress_priv_user1', 'testns.acltest1', 'SELECT'); -- no
- has_table_privilege 
----------------------
- f
-(1 row)
-
-SELECT has_table_privilege('regress_priv_user1', 'testns.acltest1', 'INSERT'); -- no
- has_table_privilege 
----------------------
- f
-(1 row)
-
--- placeholder for test with duplicated schema and role names
-ALTER DEFAULT PRIVILEGES IN SCHEMA testns,testns GRANT SELECT ON TABLES TO public,public;
-SELECT has_table_privilege('regress_priv_user1', 'testns.acltest1', 'SELECT'); -- no
- has_table_privilege 
----------------------
- f
-(1 row)
-
-SELECT has_table_privilege('regress_priv_user1', 'testns.acltest1', 'INSERT'); -- no
- has_table_privilege 
----------------------
- f
-(1 row)
-
-DROP TABLE testns.acltest1;
-CREATE TABLE testns.acltest1 (x int);
-SELECT has_table_privilege('regress_priv_user1', 'testns.acltest1', 'SELECT'); -- yes
- has_table_privilege 
----------------------
- t
-(1 row)
-
-SELECT has_table_privilege('regress_priv_user1', 'testns.acltest1', 'INSERT'); -- no
- has_table_privilege 
----------------------
- f
-(1 row)
-
-ALTER DEFAULT PRIVILEGES IN SCHEMA testns GRANT INSERT ON TABLES TO regress_priv_user1;
-DROP TABLE testns.acltest1;
-CREATE TABLE testns.acltest1 (x int);
-SELECT has_table_privilege('regress_priv_user1', 'testns.acltest1', 'SELECT'); -- yes
- has_table_privilege 
----------------------
- t
-(1 row)
-
-SELECT has_table_privilege('regress_priv_user1', 'testns.acltest1', 'INSERT'); -- yes
- has_table_privilege 
----------------------
- t
-(1 row)
-
-ALTER DEFAULT PRIVILEGES IN SCHEMA testns REVOKE INSERT ON TABLES FROM regress_priv_user1;
-DROP TABLE testns.acltest1;
-CREATE TABLE testns.acltest1 (x int);
-SELECT has_table_privilege('regress_priv_user1', 'testns.acltest1', 'SELECT'); -- yes
- has_table_privilege 
----------------------
- t
-(1 row)
-
-SELECT has_table_privilege('regress_priv_user1', 'testns.acltest1', 'INSERT'); -- no
- has_table_privilege 
----------------------
- f
-(1 row)
-
-ALTER DEFAULT PRIVILEGES FOR ROLE regress_priv_user1 REVOKE EXECUTE ON FUNCTIONS FROM public;
-ALTER DEFAULT PRIVILEGES IN SCHEMA testns GRANT USAGE ON SCHEMAS TO regress_priv_user2; -- error
-ERROR:  cannot use IN SCHEMA clause when using GRANT/REVOKE ON SCHEMAS
---
--- Testing blanket default grants is very hazardous since it might change
--- the privileges attached to objects created by concurrent regression tests.
--- To avoid that, be sure to revoke the privileges again before committing.
---
-BEGIN;
-ALTER DEFAULT PRIVILEGES GRANT USAGE ON SCHEMAS TO regress_priv_user2;
-CREATE SCHEMA testns2;
-SELECT has_schema_privilege('regress_priv_user2', 'testns2', 'USAGE'); -- yes
- has_schema_privilege 
-----------------------
- t
-(1 row)
-
-SELECT has_schema_privilege('regress_priv_user6', 'testns2', 'USAGE'); -- yes
- has_schema_privilege 
-----------------------
- t
-(1 row)
-
-SELECT has_schema_privilege('regress_priv_user2', 'testns2', 'CREATE'); -- no
- has_schema_privilege 
-----------------------
- f
-(1 row)
-
-ALTER DEFAULT PRIVILEGES REVOKE USAGE ON SCHEMAS FROM regress_priv_user2;
-CREATE SCHEMA testns3;
-SELECT has_schema_privilege('regress_priv_user2', 'testns3', 'USAGE'); -- no
- has_schema_privilege 
-----------------------
- f
-(1 row)
-
-SELECT has_schema_privilege('regress_priv_user2', 'testns3', 'CREATE'); -- no
- has_schema_privilege 
-----------------------
- f
-(1 row)
-
-ALTER DEFAULT PRIVILEGES GRANT ALL ON SCHEMAS TO regress_priv_user2;
-CREATE SCHEMA testns4;
-SELECT has_schema_privilege('regress_priv_user2', 'testns4', 'USAGE'); -- yes
- has_schema_privilege 
-----------------------
- t
-(1 row)
-
-SELECT has_schema_privilege('regress_priv_user2', 'testns4', 'CREATE'); -- yes
- has_schema_privilege 
-----------------------
- t
-(1 row)
-
-ALTER DEFAULT PRIVILEGES REVOKE ALL ON SCHEMAS FROM regress_priv_user2;
-COMMIT;
--- Test for DROP OWNED BY with shared dependencies.  This is done in a
--- separate, rollbacked, transaction to avoid any trouble with other
--- regression sessions.
-BEGIN;
-ALTER DEFAULT PRIVILEGES GRANT ALL ON FUNCTIONS TO regress_priv_user2;
-ALTER DEFAULT PRIVILEGES GRANT ALL ON SCHEMAS TO regress_priv_user2;
-ALTER DEFAULT PRIVILEGES GRANT ALL ON SEQUENCES TO regress_priv_user2;
-ALTER DEFAULT PRIVILEGES GRANT ALL ON TABLES TO regress_priv_user2;
-ALTER DEFAULT PRIVILEGES GRANT ALL ON TYPES TO regress_priv_user2;
-SELECT count(*) FROM pg_shdepend
-  WHERE deptype = 'a' AND
-        refobjid = 'regress_priv_user2'::regrole AND
-	classid = 'pg_default_acl'::regclass;
- count 
--------
-     5
-(1 row)
-
-DROP OWNED BY regress_priv_user2, regress_priv_user2;
-SELECT count(*) FROM pg_shdepend
-  WHERE deptype = 'a' AND
-        refobjid = 'regress_priv_user2'::regrole AND
-	classid = 'pg_default_acl'::regclass;
- count 
--------
-     0
-(1 row)
-
-ROLLBACK;
-CREATE SCHEMA testns5;
-SELECT has_schema_privilege('regress_priv_user2', 'testns5', 'USAGE'); -- no
- has_schema_privilege 
-----------------------
- f
-(1 row)
-
-SELECT has_schema_privilege('regress_priv_user2', 'testns5', 'CREATE'); -- no
- has_schema_privilege 
-----------------------
- f
-(1 row)
-
-SET ROLE regress_priv_user1;
-CREATE FUNCTION testns.foo() RETURNS int AS 'select 1' LANGUAGE sql;
-CREATE AGGREGATE testns.agg1(int) (sfunc = int4pl, stype = int4);
-CREATE PROCEDURE testns.bar() AS 'select 1' LANGUAGE sql;
-SELECT has_function_privilege('regress_priv_user2', 'testns.foo()', 'EXECUTE'); -- no
- has_function_privilege 
-------------------------
- f
-(1 row)
-
-SELECT has_function_privilege('regress_priv_user2', 'testns.agg1(int)', 'EXECUTE'); -- no
- has_function_privilege 
-------------------------
- f
-(1 row)
-
-SELECT has_function_privilege('regress_priv_user2', 'testns.bar()', 'EXECUTE'); -- no
- has_function_privilege 
-------------------------
- f
-(1 row)
-
-ALTER DEFAULT PRIVILEGES IN SCHEMA testns GRANT EXECUTE ON ROUTINES to public;
-DROP FUNCTION testns.foo();
-CREATE FUNCTION testns.foo() RETURNS int AS 'select 1' LANGUAGE sql;
-DROP AGGREGATE testns.agg1(int);
-CREATE AGGREGATE testns.agg1(int) (sfunc = int4pl, stype = int4);
-DROP PROCEDURE testns.bar();
-CREATE PROCEDURE testns.bar() AS 'select 1' LANGUAGE sql;
-SELECT has_function_privilege('regress_priv_user2', 'testns.foo()', 'EXECUTE'); -- yes
- has_function_privilege 
-------------------------
- t
-(1 row)
-
-SELECT has_function_privilege('regress_priv_user2', 'testns.agg1(int)', 'EXECUTE'); -- yes
- has_function_privilege 
-------------------------
- t
-(1 row)
-
-SELECT has_function_privilege('regress_priv_user2', 'testns.bar()', 'EXECUTE'); -- yes (counts as function here)
- has_function_privilege 
-------------------------
- t
-(1 row)
-
-DROP FUNCTION testns.foo();
-DROP AGGREGATE testns.agg1(int);
-DROP PROCEDURE testns.bar();
-ALTER DEFAULT PRIVILEGES FOR ROLE regress_priv_user1 REVOKE USAGE ON TYPES FROM public;
-CREATE DOMAIN testns.priv_testdomain1 AS int;
-SELECT has_type_privilege('regress_priv_user2', 'testns.priv_testdomain1', 'USAGE'); -- no
- has_type_privilege 
---------------------
- f
-(1 row)
-
-ALTER DEFAULT PRIVILEGES IN SCHEMA testns GRANT USAGE ON TYPES to public;
-DROP DOMAIN testns.priv_testdomain1;
-CREATE DOMAIN testns.priv_testdomain1 AS int;
-SELECT has_type_privilege('regress_priv_user2', 'testns.priv_testdomain1', 'USAGE'); -- yes
- has_type_privilege 
---------------------
- t
-(1 row)
-
-DROP DOMAIN testns.priv_testdomain1;
-RESET ROLE;
-SELECT count(*)
-  FROM pg_default_acl d LEFT JOIN pg_namespace n ON defaclnamespace = n.oid
-  WHERE nspname = 'testns';
- count 
--------
-     3
-(1 row)
-
-DROP SCHEMA testns CASCADE;
-NOTICE:  drop cascades to table testns.acltest1
-DROP SCHEMA testns2 CASCADE;
-DROP SCHEMA testns3 CASCADE;
-DROP SCHEMA testns4 CASCADE;
-DROP SCHEMA testns5 CASCADE;
-SELECT d.*     -- check that entries went away
-  FROM pg_default_acl d LEFT JOIN pg_namespace n ON defaclnamespace = n.oid
-  WHERE nspname IS NULL AND defaclnamespace != 0;
- oid | defaclrole | defaclnamespace | defaclobjtype | defaclacl 
------+------------+-----------------+---------------+-----------
-(0 rows)
-
--- Grant on all objects of given type in a schema
-\c -
-CREATE SCHEMA testns;
-CREATE TABLE testns.t1 (f1 int);
-CREATE TABLE testns.t2 (f1 int);
-SELECT has_table_privilege('regress_priv_user1', 'testns.t1', 'SELECT'); -- false
- has_table_privilege 
----------------------
- f
-(1 row)
-
-GRANT ALL ON ALL TABLES IN SCHEMA testns TO regress_priv_user1;
-SELECT has_table_privilege('regress_priv_user1', 'testns.t1', 'SELECT'); -- true
- has_table_privilege 
----------------------
- t
-(1 row)
-
-SELECT has_table_privilege('regress_priv_user1', 'testns.t2', 'SELECT'); -- true
- has_table_privilege 
----------------------
- t
-(1 row)
-
-REVOKE ALL ON ALL TABLES IN SCHEMA testns FROM regress_priv_user1;
-SELECT has_table_privilege('regress_priv_user1', 'testns.t1', 'SELECT'); -- false
- has_table_privilege 
----------------------
- f
-(1 row)
-
-SELECT has_table_privilege('regress_priv_user1', 'testns.t2', 'SELECT'); -- false
- has_table_privilege 
----------------------
- f
-(1 row)
-
-CREATE FUNCTION testns.priv_testfunc(int) RETURNS int AS 'select 3 * $1;' LANGUAGE sql;
-CREATE AGGREGATE testns.priv_testagg(int) (sfunc = int4pl, stype = int4);
-CREATE PROCEDURE testns.priv_testproc(int) AS 'select 3' LANGUAGE sql;
-SELECT has_function_privilege('regress_priv_user1', 'testns.priv_testfunc(int)', 'EXECUTE'); -- true by default
- has_function_privilege 
-------------------------
- t
-(1 row)
-
-SELECT has_function_privilege('regress_priv_user1', 'testns.priv_testagg(int)', 'EXECUTE'); -- true by default
- has_function_privilege 
-------------------------
- t
-(1 row)
-
-SELECT has_function_privilege('regress_priv_user1', 'testns.priv_testproc(int)', 'EXECUTE'); -- true by default
- has_function_privilege 
-------------------------
- t
-(1 row)
-
-REVOKE ALL ON ALL FUNCTIONS IN SCHEMA testns FROM PUBLIC;
-SELECT has_function_privilege('regress_priv_user1', 'testns.priv_testfunc(int)', 'EXECUTE'); -- false
- has_function_privilege 
-------------------------
- f
-(1 row)
-
-SELECT has_function_privilege('regress_priv_user1', 'testns.priv_testagg(int)', 'EXECUTE'); -- false
- has_function_privilege 
-------------------------
- f
-(1 row)
-
-SELECT has_function_privilege('regress_priv_user1', 'testns.priv_testproc(int)', 'EXECUTE'); -- still true, not a function
- has_function_privilege 
-------------------------
- t
-(1 row)
-
-REVOKE ALL ON ALL PROCEDURES IN SCHEMA testns FROM PUBLIC;
-SELECT has_function_privilege('regress_priv_user1', 'testns.priv_testproc(int)', 'EXECUTE'); -- now false
- has_function_privilege 
-------------------------
- f
-(1 row)
-
-GRANT ALL ON ALL ROUTINES IN SCHEMA testns TO PUBLIC;
-SELECT has_function_privilege('regress_priv_user1', 'testns.priv_testfunc(int)', 'EXECUTE'); -- true
- has_function_privilege 
-------------------------
- t
-(1 row)
-
-SELECT has_function_privilege('regress_priv_user1', 'testns.priv_testagg(int)', 'EXECUTE'); -- true
- has_function_privilege 
-------------------------
- t
-(1 row)
-
-SELECT has_function_privilege('regress_priv_user1', 'testns.priv_testproc(int)', 'EXECUTE'); -- true
- has_function_privilege 
-------------------------
- t
-(1 row)
-
-DROP SCHEMA testns CASCADE;
-NOTICE:  drop cascades to 5 other objects
-DETAIL:  drop cascades to table testns.t1
-drop cascades to table testns.t2
-drop cascades to function testns.priv_testfunc(integer)
-drop cascades to function testns.priv_testagg(integer)
-drop cascades to function testns.priv_testproc(integer)
--- Change owner of the schema & and rename of new schema owner
-\c -
-CREATE ROLE regress_schemauser1 superuser login;
-CREATE ROLE regress_schemauser2 superuser login;
-SET SESSION ROLE regress_schemauser1;
-CREATE SCHEMA testns;
-SELECT nspname, rolname FROM pg_namespace, pg_roles WHERE pg_namespace.nspname = 'testns' AND pg_namespace.nspowner = pg_roles.oid;
- nspname |       rolname       
----------+---------------------
- testns  | regress_schemauser1
-(1 row)
-
-ALTER SCHEMA testns OWNER TO regress_schemauser2;
-ALTER ROLE regress_schemauser2 RENAME TO regress_schemauser_renamed;
-SELECT nspname, rolname FROM pg_namespace, pg_roles WHERE pg_namespace.nspname = 'testns' AND pg_namespace.nspowner = pg_roles.oid;
- nspname |          rolname           
----------+----------------------------
- testns  | regress_schemauser_renamed
-(1 row)
-
-set session role regress_schemauser_renamed;
-DROP SCHEMA testns CASCADE;
--- clean up
-\c -
-DROP ROLE regress_schemauser1;
-DROP ROLE regress_schemauser_renamed;
--- test that dependent privileges are revoked (or not) properly
-\c -
-set session role regress_priv_user1;
-create table dep_priv_test (a int);
-grant select on dep_priv_test to regress_priv_user2 with grant option;
-grant select on dep_priv_test to regress_priv_user3 with grant option;
-set session role regress_priv_user2;
-grant select on dep_priv_test to regress_priv_user4 with grant option;
-set session role regress_priv_user3;
-grant select on dep_priv_test to regress_priv_user4 with grant option;
-set session role regress_priv_user4;
-grant select on dep_priv_test to regress_priv_user5;
-\dp dep_priv_test
-                                               Access privileges
- Schema |     Name      | Type  |               Access privileges               | Column privileges | Policies 
---------+---------------+-------+-----------------------------------------------+-------------------+----------
- public | dep_priv_test | table | regress_priv_user1=arwdDxt/regress_priv_user1+|                   | 
-        |               |       | regress_priv_user2=r*/regress_priv_user1     +|                   | 
-        |               |       | regress_priv_user3=r*/regress_priv_user1     +|                   | 
-        |               |       | regress_priv_user4=r*/regress_priv_user2     +|                   | 
-        |               |       | regress_priv_user4=r*/regress_priv_user3     +|                   | 
-        |               |       | regress_priv_user5=r/regress_priv_user4       |                   | 
-(1 row)
-
-set session role regress_priv_user2;
-revoke select on dep_priv_test from regress_priv_user4 cascade;
-\dp dep_priv_test
-                                               Access privileges
- Schema |     Name      | Type  |               Access privileges               | Column privileges | Policies 
---------+---------------+-------+-----------------------------------------------+-------------------+----------
- public | dep_priv_test | table | regress_priv_user1=arwdDxt/regress_priv_user1+|                   | 
-        |               |       | regress_priv_user2=r*/regress_priv_user1     +|                   | 
-        |               |       | regress_priv_user3=r*/regress_priv_user1     +|                   | 
-        |               |       | regress_priv_user4=r*/regress_priv_user3     +|                   | 
-        |               |       | regress_priv_user5=r/regress_priv_user4       |                   | 
-(1 row)
-
-set session role regress_priv_user3;
-revoke select on dep_priv_test from regress_priv_user4 cascade;
-\dp dep_priv_test
-                                               Access privileges
- Schema |     Name      | Type  |               Access privileges               | Column privileges | Policies 
---------+---------------+-------+-----------------------------------------------+-------------------+----------
- public | dep_priv_test | table | regress_priv_user1=arwdDxt/regress_priv_user1+|                   | 
-        |               |       | regress_priv_user2=r*/regress_priv_user1     +|                   | 
-        |               |       | regress_priv_user3=r*/regress_priv_user1      |                   | 
-(1 row)
-
-set session role regress_priv_user1;
-drop table dep_priv_test;
--- clean up
-\c
-drop sequence x_seq;
-DROP AGGREGATE priv_testagg1(int);
-DROP FUNCTION priv_testfunc2(int);
-DROP FUNCTION priv_testfunc4(boolean);
-DROP PROCEDURE priv_testproc1(int);
-DROP VIEW atestv0;
-DROP VIEW atestv1;
-DROP VIEW atestv2;
--- this should cascade to drop atestv4
-DROP VIEW atestv3 CASCADE;
-NOTICE:  drop cascades to view atestv4
--- this should complain "does not exist"
-DROP VIEW atestv4;
-ERROR:  view "atestv4" does not exist
-DROP TABLE atest1;
-DROP TABLE atest2;
-DROP TABLE atest3;
-DROP TABLE atest4;
-DROP TABLE atest5;
-DROP TABLE atest6;
-DROP TABLE atestc;
-DROP TABLE atestp1;
-DROP TABLE atestp2;
-SELECT lo_unlink(oid) FROM pg_largeobject_metadata WHERE oid >= 1000 AND oid < 3000 ORDER BY oid;
- lo_unlink 
------------
-         1
-         1
-         1
-         1
-         1
-(5 rows)
-
-DROP GROUP regress_priv_group1;
-DROP GROUP regress_priv_group2;
--- these are needed to clean up permissions
-REVOKE USAGE ON LANGUAGE sql FROM regress_priv_user1;
-DROP OWNED BY regress_priv_user1;
-DROP USER regress_priv_user1;
-DROP USER regress_priv_user2;
-DROP USER regress_priv_user3;
-DROP USER regress_priv_user4;
-DROP USER regress_priv_user5;
-DROP USER regress_priv_user6;
-DROP USER regress_priv_user7;
-DROP USER regress_priv_user8; -- does not exist
-ERROR:  role "regress_priv_user8" does not exist
--- permissions with LOCK TABLE
-CREATE USER regress_locktable_user;
-CREATE TABLE lock_table (a int);
--- LOCK TABLE and SELECT permission
-GRANT SELECT ON lock_table TO regress_locktable_user;
-SET SESSION AUTHORIZATION regress_locktable_user;
-BEGIN;
-LOCK TABLE lock_table IN ROW EXCLUSIVE MODE; -- should fail
-ERROR:  permission denied for table lock_table
-ROLLBACK;
-BEGIN;
-LOCK TABLE lock_table IN ACCESS SHARE MODE; -- should pass
-COMMIT;
-BEGIN;
-LOCK TABLE lock_table IN ACCESS EXCLUSIVE MODE; -- should fail
-ERROR:  permission denied for table lock_table
-ROLLBACK;
-\c
-REVOKE SELECT ON lock_table FROM regress_locktable_user;
--- LOCK TABLE and INSERT permission
-GRANT INSERT ON lock_table TO regress_locktable_user;
-SET SESSION AUTHORIZATION regress_locktable_user;
-BEGIN;
-LOCK TABLE lock_table IN ROW EXCLUSIVE MODE; -- should pass
-COMMIT;
-BEGIN;
-LOCK TABLE lock_table IN ACCESS SHARE MODE; -- should fail
-ERROR:  permission denied for table lock_table
-ROLLBACK;
-BEGIN;
-LOCK TABLE lock_table IN ACCESS EXCLUSIVE MODE; -- should fail
-ERROR:  permission denied for table lock_table
-ROLLBACK;
-\c
-REVOKE INSERT ON lock_table FROM regress_locktable_user;
--- LOCK TABLE and UPDATE permission
-GRANT UPDATE ON lock_table TO regress_locktable_user;
-SET SESSION AUTHORIZATION regress_locktable_user;
-BEGIN;
-LOCK TABLE lock_table IN ROW EXCLUSIVE MODE; -- should pass
-COMMIT;
-BEGIN;
-LOCK TABLE lock_table IN ACCESS SHARE MODE; -- should fail
-ERROR:  permission denied for table lock_table
-ROLLBACK;
-BEGIN;
-LOCK TABLE lock_table IN ACCESS EXCLUSIVE MODE; -- should pass
-COMMIT;
-\c
-REVOKE UPDATE ON lock_table FROM regress_locktable_user;
--- LOCK TABLE and DELETE permission
-GRANT DELETE ON lock_table TO regress_locktable_user;
-SET SESSION AUTHORIZATION regress_locktable_user;
-BEGIN;
-LOCK TABLE lock_table IN ROW EXCLUSIVE MODE; -- should pass
-COMMIT;
-BEGIN;
-LOCK TABLE lock_table IN ACCESS SHARE MODE; -- should fail
-ERROR:  permission denied for table lock_table
-ROLLBACK;
-BEGIN;
-LOCK TABLE lock_table IN ACCESS EXCLUSIVE MODE; -- should pass
-COMMIT;
-\c
-REVOKE DELETE ON lock_table FROM regress_locktable_user;
--- LOCK TABLE and TRUNCATE permission
-GRANT TRUNCATE ON lock_table TO regress_locktable_user;
-SET SESSION AUTHORIZATION regress_locktable_user;
-BEGIN;
-LOCK TABLE lock_table IN ROW EXCLUSIVE MODE; -- should pass
-COMMIT;
-BEGIN;
-LOCK TABLE lock_table IN ACCESS SHARE MODE; -- should fail
-ERROR:  permission denied for table lock_table
-ROLLBACK;
-BEGIN;
-LOCK TABLE lock_table IN ACCESS EXCLUSIVE MODE; -- should pass
-COMMIT;
-\c
-REVOKE TRUNCATE ON lock_table FROM regress_locktable_user;
--- clean up
-DROP TABLE lock_table;
-DROP USER regress_locktable_user;
diff -U3 /Users/kenaniah/workspace/postgres/src/test/regress/expected/collate.out /Users/kenaniah/workspace/postgres/src/test/regress/results/collate.out
--- /Users/kenaniah/workspace/postgres/src/test/regress/expected/collate.out	2021-10-03 18:09:17.000000000 -0700
+++ /Users/kenaniah/workspace/postgres/src/test/regress/results/collate.out	2021-10-03 20:08:17.000000000 -0700
@@ -16,761 +16,11 @@
     b text COLLATE "C" NOT NULL
 );
 \d collate_test1
-        Table "collate_tests.collate_test1"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
- b      | text    | C         | not null | 
+dyld: lazy symbol binding failed: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
+
+dyld: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
 
-CREATE TABLE collate_test_fail (
-    a int COLLATE "C",
-    b text
-);
-ERROR:  collations are not supported by type integer
-LINE 2:     a int COLLATE "C",
-                  ^
-CREATE TABLE collate_test_like (
-    LIKE collate_test1
-);
-\d collate_test_like
-      Table "collate_tests.collate_test_like"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
- b      | text    | C         | not null | 
-
-CREATE TABLE collate_test2 (
-    a int,
-    b text COLLATE "POSIX"
-);
-INSERT INTO collate_test1 VALUES (1, 'abc'), (2, 'Abc'), (3, 'bbc'), (4, 'ABD');
-INSERT INTO collate_test2 SELECT * FROM collate_test1;
-SELECT * FROM collate_test1 WHERE b COLLATE "C" >= 'abc';
- a |  b  
----+-----
- 1 | abc
- 3 | bbc
-(2 rows)
-
-SELECT * FROM collate_test1 WHERE b >= 'abc' COLLATE "C";
- a |  b  
----+-----
- 1 | abc
- 3 | bbc
-(2 rows)
-
-SELECT * FROM collate_test1 WHERE b COLLATE "C" >= 'abc' COLLATE "C";
- a |  b  
----+-----
- 1 | abc
- 3 | bbc
-(2 rows)
-
-SELECT * FROM collate_test1 WHERE b COLLATE "C" >= 'bbc' COLLATE "POSIX"; -- fail
-ERROR:  collation mismatch between explicit collations "C" and "POSIX"
-LINE 1: ...* FROM collate_test1 WHERE b COLLATE "C" >= 'bbc' COLLATE "P...
-                                                             ^
-CREATE DOMAIN testdomain_p AS text COLLATE "POSIX";
-CREATE DOMAIN testdomain_i AS int COLLATE "POSIX"; -- fail
-ERROR:  collations are not supported by type integer
-CREATE TABLE collate_test4 (
-    a int,
-    b testdomain_p
-);
-INSERT INTO collate_test4 SELECT * FROM collate_test1;
-SELECT a, b FROM collate_test4 ORDER BY b;
- a |  b  
----+-----
- 4 | ABD
- 2 | Abc
- 1 | abc
- 3 | bbc
-(4 rows)
-
-CREATE TABLE collate_test5 (
-    a int,
-    b testdomain_p COLLATE "C"
-);
-INSERT INTO collate_test5 SELECT * FROM collate_test1;
-SELECT a, b FROM collate_test5 ORDER BY b;
- a |  b  
----+-----
- 4 | ABD
- 2 | Abc
- 1 | abc
- 3 | bbc
-(4 rows)
-
-SELECT a, b FROM collate_test1 ORDER BY b;
- a |  b  
----+-----
- 4 | ABD
- 2 | Abc
- 1 | abc
- 3 | bbc
-(4 rows)
-
-SELECT a, b FROM collate_test2 ORDER BY b;
- a |  b  
----+-----
- 4 | ABD
- 2 | Abc
- 1 | abc
- 3 | bbc
-(4 rows)
-
-SELECT a, b FROM collate_test1 ORDER BY b COLLATE "C";
- a |  b  
----+-----
- 4 | ABD
- 2 | Abc
- 1 | abc
- 3 | bbc
-(4 rows)
-
--- star expansion
-SELECT * FROM collate_test1 ORDER BY b;
- a |  b  
----+-----
- 4 | ABD
- 2 | Abc
- 1 | abc
- 3 | bbc
-(4 rows)
-
-SELECT * FROM collate_test2 ORDER BY b;
- a |  b  
----+-----
- 4 | ABD
- 2 | Abc
- 1 | abc
- 3 | bbc
-(4 rows)
-
--- constant expression folding
-SELECT 'bbc' COLLATE "C" > 'Abc' COLLATE "C" AS "true";
- true 
-------
- t
-(1 row)
-
-SELECT 'bbc' COLLATE "POSIX" < 'Abc' COLLATE "POSIX" AS "false";
- false 
--------
- f
-(1 row)
-
--- upper/lower
-CREATE TABLE collate_test10 (
-    a int,
-    x text COLLATE "C",
-    y text COLLATE "POSIX"
-);
-INSERT INTO collate_test10 VALUES (1, 'hij', 'hij'), (2, 'HIJ', 'HIJ');
-SELECT a, lower(x), lower(y), upper(x), upper(y), initcap(x), initcap(y) FROM collate_test10;
- a | lower | lower | upper | upper | initcap | initcap 
----+-------+-------+-------+-------+---------+---------
- 1 | hij   | hij   | HIJ   | HIJ   | Hij     | Hij
- 2 | hij   | hij   | HIJ   | HIJ   | Hij     | Hij
-(2 rows)
-
-SELECT a, lower(x COLLATE "C"), lower(y COLLATE "C") FROM collate_test10;
- a | lower | lower 
----+-------+-------
- 1 | hij   | hij
- 2 | hij   | hij
-(2 rows)
-
-SELECT a, x, y FROM collate_test10 ORDER BY lower(y), a;
- a |  x  |  y  
----+-----+-----
- 1 | hij | hij
- 2 | HIJ | HIJ
-(2 rows)
-
--- backwards parsing
-CREATE VIEW collview1 AS SELECT * FROM collate_test1 WHERE b COLLATE "C" >= 'bbc';
-CREATE VIEW collview2 AS SELECT a, b FROM collate_test1 ORDER BY b COLLATE "C";
-CREATE VIEW collview3 AS SELECT a, lower((x || x) COLLATE "POSIX") FROM collate_test10;
-SELECT table_name, view_definition FROM information_schema.views
-  WHERE table_name LIKE 'collview%' ORDER BY 1;
- table_name |                               view_definition                                
-------------+------------------------------------------------------------------------------
- collview1  |  SELECT collate_test1.a,                                                    +
-            |     collate_test1.b                                                         +
-            |    FROM collate_test1                                                       +
-            |   WHERE ((collate_test1.b COLLATE "C") >= 'bbc'::text);
- collview2  |  SELECT collate_test1.a,                                                    +
-            |     collate_test1.b                                                         +
-            |    FROM collate_test1                                                       +
-            |   ORDER BY (collate_test1.b COLLATE "C");
- collview3  |  SELECT collate_test10.a,                                                   +
-            |     lower(((collate_test10.x || collate_test10.x) COLLATE "POSIX")) AS lower+
-            |    FROM collate_test10;
-(3 rows)
-
--- collation propagation in various expression types
-SELECT a, coalesce(b, 'foo') FROM collate_test1 ORDER BY 2;
- a | coalesce 
----+----------
- 4 | ABD
- 2 | Abc
- 1 | abc
- 3 | bbc
-(4 rows)
-
-SELECT a, coalesce(b, 'foo') FROM collate_test2 ORDER BY 2;
- a | coalesce 
----+----------
- 4 | ABD
- 2 | Abc
- 1 | abc
- 3 | bbc
-(4 rows)
-
-SELECT a, lower(coalesce(x, 'foo')), lower(coalesce(y, 'foo')) FROM collate_test10;
- a | lower | lower 
----+-------+-------
- 1 | hij   | hij
- 2 | hij   | hij
-(2 rows)
-
-SELECT a, b, greatest(b, 'CCC') FROM collate_test1 ORDER BY 3;
- a |  b  | greatest 
----+-----+----------
- 2 | Abc | CCC
- 4 | ABD | CCC
- 1 | abc | abc
- 3 | bbc | bbc
-(4 rows)
-
-SELECT a, b, greatest(b, 'CCC') FROM collate_test2 ORDER BY 3;
- a |  b  | greatest 
----+-----+----------
- 2 | Abc | CCC
- 4 | ABD | CCC
- 1 | abc | abc
- 3 | bbc | bbc
-(4 rows)
-
-SELECT a, x, y, lower(greatest(x, 'foo')), lower(greatest(y, 'foo')) FROM collate_test10;
- a |  x  |  y  | lower | lower 
----+-----+-----+-------+-------
- 1 | hij | hij | hij   | hij
- 2 | HIJ | HIJ | foo   | foo
-(2 rows)
-
-SELECT a, nullif(b, 'abc') FROM collate_test1 ORDER BY 2;
- a | nullif 
----+--------
- 4 | ABD
- 2 | Abc
- 3 | bbc
- 1 | 
-(4 rows)
-
-SELECT a, nullif(b, 'abc') FROM collate_test2 ORDER BY 2;
- a | nullif 
----+--------
- 4 | ABD
- 2 | Abc
- 3 | bbc
- 1 | 
-(4 rows)
-
-SELECT a, lower(nullif(x, 'foo')), lower(nullif(y, 'foo')) FROM collate_test10;
- a | lower | lower 
----+-------+-------
- 1 | hij   | hij
- 2 | hij   | hij
-(2 rows)
-
-SELECT a, CASE b WHEN 'abc' THEN 'abcd' ELSE b END FROM collate_test1 ORDER BY 2;
- a |  b   
----+------
- 4 | ABD
- 2 | Abc
- 1 | abcd
- 3 | bbc
-(4 rows)
-
-SELECT a, CASE b WHEN 'abc' THEN 'abcd' ELSE b END FROM collate_test2 ORDER BY 2;
- a |  b   
----+------
- 4 | ABD
- 2 | Abc
- 1 | abcd
- 3 | bbc
-(4 rows)
-
-CREATE DOMAIN testdomain AS text;
-SELECT a, b::testdomain FROM collate_test1 ORDER BY 2;
- a |  b  
----+-----
- 4 | ABD
- 2 | Abc
- 1 | abc
- 3 | bbc
-(4 rows)
-
-SELECT a, b::testdomain FROM collate_test2 ORDER BY 2;
- a |  b  
----+-----
- 4 | ABD
- 2 | Abc
- 1 | abc
- 3 | bbc
-(4 rows)
-
-SELECT a, b::testdomain_p FROM collate_test2 ORDER BY 2;
- a |  b  
----+-----
- 4 | ABD
- 2 | Abc
- 1 | abc
- 3 | bbc
-(4 rows)
-
-SELECT a, lower(x::testdomain), lower(y::testdomain) FROM collate_test10;
- a | lower | lower 
----+-------+-------
- 1 | hij   | hij
- 2 | hij   | hij
-(2 rows)
-
-SELECT min(b), max(b) FROM collate_test1;
- min | max 
------+-----
- ABD | bbc
-(1 row)
-
-SELECT min(b), max(b) FROM collate_test2;
- min | max 
------+-----
- ABD | bbc
-(1 row)
-
-SELECT array_agg(b ORDER BY b) FROM collate_test1;
-     array_agg     
--------------------
- {ABD,Abc,abc,bbc}
-(1 row)
-
-SELECT array_agg(b ORDER BY b) FROM collate_test2;
-     array_agg     
--------------------
- {ABD,Abc,abc,bbc}
-(1 row)
-
--- In aggregates, ORDER BY expressions don't affect aggregate's collation
-SELECT string_agg(x COLLATE "C", y COLLATE "POSIX") FROM collate_test10;  -- fail
-ERROR:  collation mismatch between explicit collations "C" and "POSIX"
-LINE 1: SELECT string_agg(x COLLATE "C", y COLLATE "POSIX") FROM col...
-                                           ^
-SELECT array_agg(x COLLATE "C" ORDER BY y COLLATE "POSIX") FROM collate_test10;
- array_agg 
------------
- {HIJ,hij}
-(1 row)
-
-SELECT array_agg(a ORDER BY x COLLATE "C", y COLLATE "POSIX") FROM collate_test10;
- array_agg 
------------
- {2,1}
-(1 row)
-
-SELECT array_agg(a ORDER BY x||y) FROM collate_test10;  -- fail
-ERROR:  collation mismatch between implicit collations "C" and "POSIX"
-LINE 1: SELECT array_agg(a ORDER BY x||y) FROM collate_test10;
-                                       ^
-HINT:  You can choose the collation by applying the COLLATE clause to one or both expressions.
-SELECT a, b FROM collate_test1 UNION ALL SELECT a, b FROM collate_test1 ORDER BY 2;
- a |  b  
----+-----
- 4 | ABD
- 4 | ABD
- 2 | Abc
- 2 | Abc
- 1 | abc
- 1 | abc
- 3 | bbc
- 3 | bbc
-(8 rows)
-
-SELECT a, b FROM collate_test2 UNION SELECT a, b FROM collate_test2 ORDER BY 2;
- a |  b  
----+-----
- 4 | ABD
- 2 | Abc
- 1 | abc
- 3 | bbc
-(4 rows)
-
-SELECT a, b FROM collate_test2 WHERE a < 4 INTERSECT SELECT a, b FROM collate_test2 WHERE a > 1 ORDER BY 2;
- a |  b  
----+-----
- 2 | Abc
- 3 | bbc
-(2 rows)
-
-SELECT a, b FROM collate_test2 EXCEPT SELECT a, b FROM collate_test2 WHERE a < 2 ORDER BY 2;
- a |  b  
----+-----
- 4 | ABD
- 2 | Abc
- 3 | bbc
-(3 rows)
-
-SELECT a, b FROM collate_test1 UNION ALL SELECT a, b FROM collate_test2 ORDER BY 2; -- fail
-ERROR:  could not determine which collation to use for string comparison
-HINT:  Use the COLLATE clause to set the collation explicitly.
-SELECT a, b FROM collate_test1 UNION ALL SELECT a, b FROM collate_test2; -- ok
- a |  b  
----+-----
- 1 | abc
- 2 | Abc
- 3 | bbc
- 4 | ABD
- 1 | abc
- 2 | Abc
- 3 | bbc
- 4 | ABD
-(8 rows)
-
-SELECT a, b FROM collate_test1 UNION SELECT a, b FROM collate_test2 ORDER BY 2; -- fail
-ERROR:  collation mismatch between implicit collations "C" and "POSIX"
-LINE 1: SELECT a, b FROM collate_test1 UNION SELECT a, b FROM collat...
-                                                       ^
-HINT:  You can choose the collation by applying the COLLATE clause to one or both expressions.
-SELECT a, b COLLATE "C" FROM collate_test1 UNION SELECT a, b FROM collate_test2 ORDER BY 2; -- ok
- a |  b  
----+-----
- 4 | ABD
- 2 | Abc
- 1 | abc
- 3 | bbc
-(4 rows)
-
-SELECT a, b FROM collate_test1 INTERSECT SELECT a, b FROM collate_test2 ORDER BY 2; -- fail
-ERROR:  collation mismatch between implicit collations "C" and "POSIX"
-LINE 1: ...ELECT a, b FROM collate_test1 INTERSECT SELECT a, b FROM col...
-                                                             ^
-HINT:  You can choose the collation by applying the COLLATE clause to one or both expressions.
-SELECT a, b FROM collate_test1 EXCEPT SELECT a, b FROM collate_test2 ORDER BY 2; -- fail
-ERROR:  collation mismatch between implicit collations "C" and "POSIX"
-LINE 1: SELECT a, b FROM collate_test1 EXCEPT SELECT a, b FROM colla...
-                                                        ^
-HINT:  You can choose the collation by applying the COLLATE clause to one or both expressions.
-CREATE TABLE test_u AS SELECT a, b FROM collate_test1 UNION ALL SELECT a, b FROM collate_test2; -- fail
-ERROR:  no collation was derived for column "b" with collatable type text
-HINT:  Use the COLLATE clause to set the collation explicitly.
--- ideally this would be a parse-time error, but for now it must be run-time:
-select x < y from collate_test10; -- fail
-ERROR:  could not determine which collation to use for string comparison
-HINT:  Use the COLLATE clause to set the collation explicitly.
-select x || y from collate_test10; -- ok, because || is not collation aware
- ?column? 
-----------
- hijhij
- HIJHIJ
-(2 rows)
-
-select x, y from collate_test10 order by x || y; -- not so ok
-ERROR:  collation mismatch between implicit collations "C" and "POSIX"
-LINE 1: select x, y from collate_test10 order by x || y;
-                                                      ^
-HINT:  You can choose the collation by applying the COLLATE clause to one or both expressions.
--- collation mismatch between recursive and non-recursive term
-WITH RECURSIVE foo(x) AS
-   (SELECT x FROM (VALUES('a' COLLATE "C"),('b')) t(x)
-   UNION ALL
-   SELECT (x || 'c') COLLATE "POSIX" FROM foo WHERE length(x) < 10)
-SELECT * FROM foo;
-ERROR:  recursive query "foo" column 1 has collation "C" in non-recursive term but collation "POSIX" overall
-LINE 2:    (SELECT x FROM (VALUES('a' COLLATE "C"),('b')) t(x)
-                   ^
-HINT:  Use the COLLATE clause to set the collation of the non-recursive term.
-SELECT a, b, a < b as lt FROM
-  (VALUES ('a', 'B'), ('A', 'b' COLLATE "C")) v(a,b);
- a | b | lt 
----+---+----
- a | B | f
- A | b | t
-(2 rows)
-
--- collation mismatch in subselects
-SELECT * FROM collate_test10 WHERE (x, y) NOT IN (SELECT y, x FROM collate_test10);
-ERROR:  could not determine which collation to use for string hashing
-HINT:  Use the COLLATE clause to set the collation explicitly.
--- now it works with overrides
-SELECT * FROM collate_test10 WHERE (x COLLATE "POSIX", y COLLATE "C") NOT IN (SELECT y, x FROM collate_test10);
- a | x | y 
----+---+---
-(0 rows)
-
-SELECT * FROM collate_test10 WHERE (x, y) NOT IN (SELECT y COLLATE "C", x COLLATE "POSIX" FROM collate_test10);
- a | x | y 
----+---+---
-(0 rows)
-
--- casting
-SELECT CAST('42' AS text COLLATE "C");
-ERROR:  syntax error at or near "COLLATE"
-LINE 1: SELECT CAST('42' AS text COLLATE "C");
-                                 ^
-SELECT a, CAST(b AS varchar) FROM collate_test1 ORDER BY 2;
- a |  b  
----+-----
- 4 | ABD
- 2 | Abc
- 1 | abc
- 3 | bbc
-(4 rows)
-
-SELECT a, CAST(b AS varchar) FROM collate_test2 ORDER BY 2;
- a |  b  
----+-----
- 4 | ABD
- 2 | Abc
- 1 | abc
- 3 | bbc
-(4 rows)
-
--- result of a SQL function
-CREATE FUNCTION vc (text) RETURNS text LANGUAGE sql
-    AS 'select $1::varchar';
-SELECT a, b FROM collate_test1 ORDER BY a, vc(b);
- a |  b  
----+-----
- 1 | abc
- 2 | Abc
- 3 | bbc
- 4 | ABD
-(4 rows)
-
--- polymorphism
-SELECT * FROM unnest((SELECT array_agg(b ORDER BY b) FROM collate_test1)) ORDER BY 1;
- unnest 
---------
- ABD
- Abc
- abc
- bbc
-(4 rows)
-
-SELECT * FROM unnest((SELECT array_agg(b ORDER BY b) FROM collate_test2)) ORDER BY 1;
- unnest 
---------
- ABD
- Abc
- abc
- bbc
-(4 rows)
-
-CREATE FUNCTION dup (anyelement) RETURNS anyelement
-    AS 'select $1' LANGUAGE sql;
-SELECT a, dup(b) FROM collate_test1 ORDER BY 2;
- a | dup 
----+-----
- 4 | ABD
- 2 | Abc
- 1 | abc
- 3 | bbc
-(4 rows)
-
-SELECT a, dup(b) FROM collate_test2 ORDER BY 2;
- a | dup 
----+-----
- 4 | ABD
- 2 | Abc
- 1 | abc
- 3 | bbc
-(4 rows)
-
--- indexes
-CREATE INDEX collate_test1_idx1 ON collate_test1 (b);
-CREATE INDEX collate_test1_idx2 ON collate_test1 (b COLLATE "POSIX");
-CREATE INDEX collate_test1_idx3 ON collate_test1 ((b COLLATE "POSIX")); -- this is different grammatically
-CREATE INDEX collate_test1_idx4 ON collate_test1 (((b||'foo') COLLATE "POSIX"));
-CREATE INDEX collate_test1_idx5 ON collate_test1 (a COLLATE "POSIX"); -- fail
-ERROR:  collations are not supported by type integer
-CREATE INDEX collate_test1_idx6 ON collate_test1 ((a COLLATE "POSIX")); -- fail
-ERROR:  collations are not supported by type integer
-LINE 1: ...ATE INDEX collate_test1_idx6 ON collate_test1 ((a COLLATE "P...
-                                                             ^
-SELECT relname, pg_get_indexdef(oid) FROM pg_class WHERE relname LIKE 'collate_test%_idx%' ORDER BY 1;
-      relname       |                                                  pg_get_indexdef                                                  
---------------------+-------------------------------------------------------------------------------------------------------------------
- collate_test1_idx1 | CREATE INDEX collate_test1_idx1 ON collate_tests.collate_test1 USING btree (b)
- collate_test1_idx2 | CREATE INDEX collate_test1_idx2 ON collate_tests.collate_test1 USING btree (b COLLATE "POSIX")
- collate_test1_idx3 | CREATE INDEX collate_test1_idx3 ON collate_tests.collate_test1 USING btree (b COLLATE "POSIX")
- collate_test1_idx4 | CREATE INDEX collate_test1_idx4 ON collate_tests.collate_test1 USING btree (((b || 'foo'::text)) COLLATE "POSIX")
-(4 rows)
-
--- foreign keys
--- force indexes and mergejoins to be used for FK checking queries,
--- else they might not exercise collation-dependent operators
-SET enable_seqscan TO 0;
-SET enable_hashjoin TO 0;
-SET enable_nestloop TO 0;
-CREATE TABLE collate_test20 (f1 text COLLATE "C" PRIMARY KEY);
-INSERT INTO collate_test20 VALUES ('foo'), ('bar');
-CREATE TABLE collate_test21 (f2 text COLLATE "POSIX" REFERENCES collate_test20);
-INSERT INTO collate_test21 VALUES ('foo'), ('bar');
-INSERT INTO collate_test21 VALUES ('baz'); -- fail
-ERROR:  insert or update on table "collate_test21" violates foreign key constraint "collate_test21_f2_fkey"
-DETAIL:  Key (f2)=(baz) is not present in table "collate_test20".
-CREATE TABLE collate_test22 (f2 text COLLATE "POSIX");
-INSERT INTO collate_test22 VALUES ('foo'), ('bar'), ('baz');
-ALTER TABLE collate_test22 ADD FOREIGN KEY (f2) REFERENCES collate_test20; -- fail
-ERROR:  insert or update on table "collate_test22" violates foreign key constraint "collate_test22_f2_fkey"
-DETAIL:  Key (f2)=(baz) is not present in table "collate_test20".
-DELETE FROM collate_test22 WHERE f2 = 'baz';
-ALTER TABLE collate_test22 ADD FOREIGN KEY (f2) REFERENCES collate_test20;
-RESET enable_seqscan;
-RESET enable_hashjoin;
-RESET enable_nestloop;
--- EXPLAIN
-EXPLAIN (COSTS OFF)
-  SELECT * FROM collate_test10 ORDER BY x, y;
-                  QUERY PLAN                  
-----------------------------------------------
- Sort
-   Sort Key: x COLLATE "C", y COLLATE "POSIX"
-   ->  Seq Scan on collate_test10
-(3 rows)
-
-EXPLAIN (COSTS OFF)
-  SELECT * FROM collate_test10 ORDER BY x DESC, y COLLATE "C" ASC NULLS FIRST;
-                        QUERY PLAN                         
------------------------------------------------------------
- Sort
-   Sort Key: x COLLATE "C" DESC, y COLLATE "C" NULLS FIRST
-   ->  Seq Scan on collate_test10
-(3 rows)
-
--- CREATE/DROP COLLATION
-CREATE COLLATION mycoll1 FROM "C";
-CREATE COLLATION mycoll2 ( LC_COLLATE = "POSIX", LC_CTYPE = "POSIX" );
-CREATE COLLATION mycoll3 FROM "default";  -- intentionally unsupported
-ERROR:  collation "default" cannot be copied
-DROP COLLATION mycoll1;
-CREATE TABLE collate_test23 (f1 text collate mycoll2);
-DROP COLLATION mycoll2;  -- fail
-ERROR:  cannot drop collation mycoll2 because other objects depend on it
-DETAIL:  column f1 of table collate_test23 depends on collation mycoll2
-HINT:  Use DROP ... CASCADE to drop the dependent objects too.
--- invalid: non-lowercase quoted identifiers
-CREATE COLLATION case_coll ("Lc_Collate" = "POSIX", "Lc_Ctype" = "POSIX");
-ERROR:  collation attribute "Lc_Collate" not recognized
-LINE 1: CREATE COLLATION case_coll ("Lc_Collate" = "POSIX", "Lc_Ctyp...
-                                    ^
--- 9.1 bug with useless COLLATE in an expression subject to length coercion
-CREATE TEMP TABLE vctable (f1 varchar(25));
-INSERT INTO vctable VALUES ('foo' COLLATE "C");
-SELECT collation for ('foo'); -- unknown type - null
- pg_collation_for 
-------------------
- 
-(1 row)
-
-SELECT collation for ('foo'::text);
- pg_collation_for 
-------------------
- "default"
-(1 row)
-
-SELECT collation for ((SELECT a FROM collate_test1 LIMIT 1)); -- non-collatable type - error
-ERROR:  collations are not supported by type integer
-SELECT collation for ((SELECT b FROM collate_test1 LIMIT 1));
- pg_collation_for 
-------------------
- "C"
-(1 row)
-
--- old bug with not dropping COLLATE when coercing to non-collatable type
-CREATE VIEW collate_on_int AS
-SELECT c1+1 AS c1p FROM
-  (SELECT ('4' COLLATE "C")::INT AS c1) ss;
-\d+ collate_on_int
-                    View "collate_tests.collate_on_int"
- Column |  Type   | Collation | Nullable | Default | Storage | Description 
---------+---------+-----------+----------+---------+---------+-------------
- c1p    | integer |           |          |         | plain   | 
-View definition:
- SELECT ss.c1 + 1 AS c1p
-   FROM ( SELECT 4 AS c1) ss;
-
--- Check conflicting or redundant options in CREATE COLLATION
--- LC_COLLATE
-CREATE COLLATION coll_dup_chk (LC_COLLATE = "POSIX", LC_COLLATE = "NONSENSE", LC_CTYPE = "POSIX");
-ERROR:  conflicting or redundant options
-LINE 1: ...ATE COLLATION coll_dup_chk (LC_COLLATE = "POSIX", LC_COLLATE...
-                                                             ^
--- LC_CTYPE
-CREATE COLLATION coll_dup_chk (LC_CTYPE = "POSIX", LC_CTYPE = "NONSENSE", LC_COLLATE = "POSIX");
-ERROR:  conflicting or redundant options
-LINE 1: ...REATE COLLATION coll_dup_chk (LC_CTYPE = "POSIX", LC_CTYPE =...
-                                                             ^
--- PROVIDER
-CREATE COLLATION coll_dup_chk (PROVIDER = icu, PROVIDER = NONSENSE, LC_COLLATE = "POSIX", LC_CTYPE = "POSIX");
-ERROR:  conflicting or redundant options
-LINE 1: CREATE COLLATION coll_dup_chk (PROVIDER = icu, PROVIDER = NO...
-                                                       ^
--- LOCALE
-CREATE COLLATION case_sensitive (LOCALE = '', LOCALE = "NONSENSE");
-ERROR:  conflicting or redundant options
-LINE 1: CREATE COLLATION case_sensitive (LOCALE = '', LOCALE = "NONS...
-                                                      ^
--- DETERMINISTIC
-CREATE COLLATION coll_dup_chk (DETERMINISTIC = TRUE, DETERMINISTIC = NONSENSE, LOCALE = '');
-ERROR:  conflicting or redundant options
-LINE 1: ...ATE COLLATION coll_dup_chk (DETERMINISTIC = TRUE, DETERMINIS...
-                                                             ^
--- VERSION
-CREATE COLLATION coll_dup_chk (VERSION = '1', VERSION = "NONSENSE", LOCALE = '');
-ERROR:  conflicting or redundant options
-LINE 1: CREATE COLLATION coll_dup_chk (VERSION = '1', VERSION = "NON...
-                                                      ^
--- LOCALE conflicts with LC_COLLATE and LC_CTYPE
-CREATE COLLATION coll_dup_chk (LC_COLLATE = "POSIX", LC_CTYPE = "POSIX", LOCALE = '');
-ERROR:  conflicting or redundant options
-DETAIL:  LOCALE cannot be specified together with LC_COLLATE or LC_CTYPE.
--- LOCALE conflicts with LC_COLLATE
-CREATE COLLATION coll_dup_chk (LC_COLLATE = "POSIX", LOCALE = '');
-ERROR:  conflicting or redundant options
-DETAIL:  LOCALE cannot be specified together with LC_COLLATE or LC_CTYPE.
--- LOCALE conflicts with LC_CTYPE
-CREATE COLLATION coll_dup_chk (LC_CTYPE = "POSIX", LOCALE = '');
-ERROR:  conflicting or redundant options
-DETAIL:  LOCALE cannot be specified together with LC_COLLATE or LC_CTYPE.
--- FROM conflicts with any other option
-CREATE COLLATION coll_dup_chk (FROM = "C", VERSION = "1");
-ERROR:  conflicting or redundant options
-DETAIL:  FROM cannot be specified together with any other options.
---
--- Clean up.  Many of these table names will be re-used if the user is
--- trying to run any platform-specific collation tests later, so we
--- must get rid of them.
---
-DROP SCHEMA collate_tests CASCADE;
-NOTICE:  drop cascades to 19 other objects
-DETAIL:  drop cascades to table collate_test1
-drop cascades to table collate_test_like
-drop cascades to table collate_test2
-drop cascades to type testdomain_p
-drop cascades to table collate_test4
-drop cascades to table collate_test5
-drop cascades to table collate_test10
-drop cascades to view collview1
-drop cascades to view collview2
-drop cascades to view collview3
-drop cascades to type testdomain
-drop cascades to function vc(text)
-drop cascades to function dup(anyelement)
-drop cascades to table collate_test20
-drop cascades to table collate_test21
-drop cascades to table collate_test22
-drop cascades to collation mycoll2
-drop cascades to table collate_test23
-drop cascades to view collate_on_int
diff -U3 /Users/kenaniah/workspace/postgres/src/test/regress/expected/matview.out /Users/kenaniah/workspace/postgres/src/test/regress/results/matview.out
--- /Users/kenaniah/workspace/postgres/src/test/regress/expected/matview.out	2021-10-03 17:41:49.000000000 -0700
+++ /Users/kenaniah/workspace/postgres/src/test/regress/results/matview.out	2021-10-03 20:08:17.000000000 -0700
@@ -94,585 +94,11 @@
 CREATE INDEX mvtest_aa ON mvtest_bb (grandtot);
 -- check that plans seem reasonable
 \d+ mvtest_tvm
-                           Materialized view "public.mvtest_tvm"
- Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
---------+---------+-----------+----------+---------+----------+--------------+-------------
- type   | text    |           |          |         | extended |              | 
- totamt | numeric |           |          |         | main     |              | 
-View definition:
- SELECT mvtest_tv.type,
-    mvtest_tv.totamt
-   FROM mvtest_tv
-  ORDER BY mvtest_tv.type;
+dyld: lazy symbol binding failed: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
+
+dyld: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
 
-\d+ mvtest_tvm
-                           Materialized view "public.mvtest_tvm"
- Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
---------+---------+-----------+----------+---------+----------+--------------+-------------
- type   | text    |           |          |         | extended |              | 
- totamt | numeric |           |          |         | main     |              | 
-View definition:
- SELECT mvtest_tv.type,
-    mvtest_tv.totamt
-   FROM mvtest_tv
-  ORDER BY mvtest_tv.type;
-
-\d+ mvtest_tvvm
-                           Materialized view "public.mvtest_tvvm"
-  Column  |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
-----------+---------+-----------+----------+---------+---------+--------------+-------------
- grandtot | numeric |           |          |         | main    |              | 
-View definition:
- SELECT mvtest_tvv.grandtot
-   FROM mvtest_tvv;
-
-\d+ mvtest_bb
-                            Materialized view "public.mvtest_bb"
-  Column  |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
-----------+---------+-----------+----------+---------+---------+--------------+-------------
- grandtot | numeric |           |          |         | main    |              | 
-Indexes:
-    "mvtest_aa" btree (grandtot)
-View definition:
- SELECT mvtest_tvvmv.grandtot
-   FROM mvtest_tvvmv;
-
--- test schema behavior
-CREATE SCHEMA mvtest_mvschema;
-ALTER MATERIALIZED VIEW mvtest_tvm SET SCHEMA mvtest_mvschema;
-\d+ mvtest_tvm
-\d+ mvtest_tvmm
-                           Materialized view "public.mvtest_tvmm"
-  Column  |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
-----------+---------+-----------+----------+---------+---------+--------------+-------------
- grandtot | numeric |           |          |         | main    |              | 
-Indexes:
-    "mvtest_tvmm_expr" UNIQUE, btree ((grandtot > 0::numeric))
-    "mvtest_tvmm_pred" UNIQUE, btree (grandtot) WHERE grandtot < 0::numeric
-View definition:
- SELECT sum(mvtest_tvm.totamt) AS grandtot
-   FROM mvtest_mvschema.mvtest_tvm;
-
-SET search_path = mvtest_mvschema, public;
-\d+ mvtest_tvm
-                      Materialized view "mvtest_mvschema.mvtest_tvm"
- Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
---------+---------+-----------+----------+---------+----------+--------------+-------------
- type   | text    |           |          |         | extended |              | 
- totamt | numeric |           |          |         | main     |              | 
-View definition:
- SELECT mvtest_tv.type,
-    mvtest_tv.totamt
-   FROM mvtest_tv
-  ORDER BY mvtest_tv.type;
-
--- modify the underlying table data
-INSERT INTO mvtest_t VALUES (6, 'z', 13);
--- confirm pre- and post-refresh contents of fairly simple materialized views
-SELECT * FROM mvtest_tm ORDER BY type;
- type | totamt 
-------+--------
- x    |      5
- y    |     12
- z    |     11
-(3 rows)
-
-SELECT * FROM mvtest_tvm ORDER BY type;
- type | totamt 
-------+--------
- x    |      5
- y    |     12
- z    |     11
-(3 rows)
-
-REFRESH MATERIALIZED VIEW CONCURRENTLY mvtest_tm;
-REFRESH MATERIALIZED VIEW mvtest_tvm;
-SELECT * FROM mvtest_tm ORDER BY type;
- type | totamt 
-------+--------
- x    |      5
- y    |     12
- z    |     24
-(3 rows)
-
-SELECT * FROM mvtest_tvm ORDER BY type;
- type | totamt 
-------+--------
- x    |      5
- y    |     12
- z    |     24
-(3 rows)
-
-RESET search_path;
--- confirm pre- and post-refresh contents of nested materialized views
-EXPLAIN (costs off)
-  SELECT * FROM mvtest_tmm;
-       QUERY PLAN       
-------------------------
- Seq Scan on mvtest_tmm
-(1 row)
-
-EXPLAIN (costs off)
-  SELECT * FROM mvtest_tvmm;
-       QUERY PLAN        
--------------------------
- Seq Scan on mvtest_tvmm
-(1 row)
-
-EXPLAIN (costs off)
-  SELECT * FROM mvtest_tvvm;
-       QUERY PLAN        
--------------------------
- Seq Scan on mvtest_tvvm
-(1 row)
-
-SELECT * FROM mvtest_tmm;
- grandtot 
-----------
-       28
-(1 row)
-
-SELECT * FROM mvtest_tvmm;
- grandtot 
-----------
-       28
-(1 row)
-
-SELECT * FROM mvtest_tvvm;
- grandtot 
-----------
-       28
-(1 row)
-
-REFRESH MATERIALIZED VIEW mvtest_tmm;
-REFRESH MATERIALIZED VIEW CONCURRENTLY mvtest_tvmm;
-ERROR:  cannot refresh materialized view "public.mvtest_tvmm" concurrently
-HINT:  Create a unique index with no WHERE clause on one or more columns of the materialized view.
-REFRESH MATERIALIZED VIEW mvtest_tvmm;
-REFRESH MATERIALIZED VIEW mvtest_tvvm;
-EXPLAIN (costs off)
-  SELECT * FROM mvtest_tmm;
-       QUERY PLAN       
-------------------------
- Seq Scan on mvtest_tmm
-(1 row)
-
-EXPLAIN (costs off)
-  SELECT * FROM mvtest_tvmm;
-       QUERY PLAN        
--------------------------
- Seq Scan on mvtest_tvmm
-(1 row)
-
-EXPLAIN (costs off)
-  SELECT * FROM mvtest_tvvm;
-       QUERY PLAN        
--------------------------
- Seq Scan on mvtest_tvvm
-(1 row)
-
-SELECT * FROM mvtest_tmm;
- grandtot 
-----------
-       41
-(1 row)
-
-SELECT * FROM mvtest_tvmm;
- grandtot 
-----------
-       41
-(1 row)
-
-SELECT * FROM mvtest_tvvm;
- grandtot 
-----------
-       41
-(1 row)
-
--- test diemv when the mv does not exist
-DROP MATERIALIZED VIEW IF EXISTS no_such_mv;
-NOTICE:  materialized view "no_such_mv" does not exist, skipping
--- make sure invalid combination of options is prohibited
-REFRESH MATERIALIZED VIEW CONCURRENTLY mvtest_tvmm WITH NO DATA;
-ERROR:  CONCURRENTLY and WITH NO DATA options cannot be used together
--- no tuple locks on materialized views
-SELECT * FROM mvtest_tvvm FOR SHARE;
-ERROR:  cannot lock rows in materialized view "mvtest_tvvm"
--- test join of mv and view
-SELECT type, m.totamt AS mtot, v.totamt AS vtot FROM mvtest_tm m LEFT JOIN mvtest_tv v USING (type) ORDER BY type;
- type | mtot | vtot 
-------+------+------
- x    |    5 |    5
- y    |   12 |   12
- z    |   24 |   24
-(3 rows)
-
--- make sure that dependencies are reported properly when they block the drop
-DROP TABLE mvtest_t;
-ERROR:  cannot drop table mvtest_t because other objects depend on it
-DETAIL:  view mvtest_tv depends on table mvtest_t
-materialized view mvtest_mvschema.mvtest_tvm depends on view mvtest_tv
-materialized view mvtest_tvmm depends on materialized view mvtest_mvschema.mvtest_tvm
-view mvtest_tvv depends on view mvtest_tv
-materialized view mvtest_tvvm depends on view mvtest_tvv
-view mvtest_tvvmv depends on materialized view mvtest_tvvm
-materialized view mvtest_bb depends on view mvtest_tvvmv
-materialized view mvtest_tm depends on table mvtest_t
-materialized view mvtest_tmm depends on materialized view mvtest_tm
-HINT:  Use DROP ... CASCADE to drop the dependent objects too.
--- make sure dependencies are dropped and reported
--- and make sure that transactional behavior is correct on rollback
--- incidentally leaving some interesting materialized views for pg_dump testing
-BEGIN;
-DROP TABLE mvtest_t CASCADE;
-NOTICE:  drop cascades to 9 other objects
-DETAIL:  drop cascades to view mvtest_tv
-drop cascades to materialized view mvtest_mvschema.mvtest_tvm
-drop cascades to materialized view mvtest_tvmm
-drop cascades to view mvtest_tvv
-drop cascades to materialized view mvtest_tvvm
-drop cascades to view mvtest_tvvmv
-drop cascades to materialized view mvtest_bb
-drop cascades to materialized view mvtest_tm
-drop cascades to materialized view mvtest_tmm
-ROLLBACK;
--- some additional tests not using base tables
-CREATE VIEW mvtest_vt1 AS SELECT 1 moo;
-CREATE VIEW mvtest_vt2 AS SELECT moo, 2*moo FROM mvtest_vt1 UNION ALL SELECT moo, 3*moo FROM mvtest_vt1;
-\d+ mvtest_vt2
-                          View "public.mvtest_vt2"
-  Column  |  Type   | Collation | Nullable | Default | Storage | Description 
-----------+---------+-----------+----------+---------+---------+-------------
- moo      | integer |           |          |         | plain   | 
- ?column? | integer |           |          |         | plain   | 
-View definition:
- SELECT mvtest_vt1.moo,
-    2 * mvtest_vt1.moo
-   FROM mvtest_vt1
-UNION ALL
- SELECT mvtest_vt1.moo,
-    3 * mvtest_vt1.moo
-   FROM mvtest_vt1;
-
-CREATE MATERIALIZED VIEW mv_test2 AS SELECT moo, 2*moo FROM mvtest_vt2 UNION ALL SELECT moo, 3*moo FROM mvtest_vt2;
-\d+ mv_test2
-                            Materialized view "public.mv_test2"
-  Column  |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
-----------+---------+-----------+----------+---------+---------+--------------+-------------
- moo      | integer |           |          |         | plain   |              | 
- ?column? | integer |           |          |         | plain   |              | 
-View definition:
- SELECT mvtest_vt2.moo,
-    2 * mvtest_vt2.moo
-   FROM mvtest_vt2
-UNION ALL
- SELECT mvtest_vt2.moo,
-    3 * mvtest_vt2.moo
-   FROM mvtest_vt2;
-
-CREATE MATERIALIZED VIEW mv_test3 AS SELECT * FROM mv_test2 WHERE moo = 12345;
-SELECT relispopulated FROM pg_class WHERE oid = 'mv_test3'::regclass;
- relispopulated 
-----------------
- t
-(1 row)
-
-DROP VIEW mvtest_vt1 CASCADE;
-NOTICE:  drop cascades to 3 other objects
-DETAIL:  drop cascades to view mvtest_vt2
-drop cascades to materialized view mv_test2
-drop cascades to materialized view mv_test3
--- test that duplicate values on unique index prevent refresh
-CREATE TABLE mvtest_foo(a, b) AS VALUES(1, 10);
-CREATE MATERIALIZED VIEW mvtest_mv AS SELECT * FROM mvtest_foo;
-CREATE UNIQUE INDEX ON mvtest_mv(a);
-INSERT INTO mvtest_foo SELECT * FROM mvtest_foo;
-REFRESH MATERIALIZED VIEW mvtest_mv;
-ERROR:  could not create unique index "mvtest_mv_a_idx"
-DETAIL:  Key (a)=(1) is duplicated.
-REFRESH MATERIALIZED VIEW CONCURRENTLY mvtest_mv;
-ERROR:  new data for materialized view "mvtest_mv" contains duplicate rows without any null columns
-DETAIL:  Row: (1,10)
-DROP TABLE mvtest_foo CASCADE;
-NOTICE:  drop cascades to materialized view mvtest_mv
--- make sure that all columns covered by unique indexes works
-CREATE TABLE mvtest_foo(a, b, c) AS VALUES(1, 2, 3);
-CREATE MATERIALIZED VIEW mvtest_mv AS SELECT * FROM mvtest_foo;
-CREATE UNIQUE INDEX ON mvtest_mv (a);
-CREATE UNIQUE INDEX ON mvtest_mv (b);
-CREATE UNIQUE INDEX on mvtest_mv (c);
-INSERT INTO mvtest_foo VALUES(2, 3, 4);
-INSERT INTO mvtest_foo VALUES(3, 4, 5);
-REFRESH MATERIALIZED VIEW mvtest_mv;
-REFRESH MATERIALIZED VIEW CONCURRENTLY mvtest_mv;
-DROP TABLE mvtest_foo CASCADE;
-NOTICE:  drop cascades to materialized view mvtest_mv
--- allow subquery to reference unpopulated matview if WITH NO DATA is specified
-CREATE MATERIALIZED VIEW mvtest_mv1 AS SELECT 1 AS col1 WITH NO DATA;
-CREATE MATERIALIZED VIEW mvtest_mv2 AS SELECT * FROM mvtest_mv1
-  WHERE col1 = (SELECT LEAST(col1) FROM mvtest_mv1) WITH NO DATA;
-DROP MATERIALIZED VIEW mvtest_mv1 CASCADE;
-NOTICE:  drop cascades to materialized view mvtest_mv2
--- make sure that types with unusual equality tests work
-CREATE TABLE mvtest_boxes (id serial primary key, b box);
-INSERT INTO mvtest_boxes (b) VALUES
-  ('(32,32),(31,31)'),
-  ('(2.0000004,2.0000004),(1,1)'),
-  ('(1.9999996,1.9999996),(1,1)');
-CREATE MATERIALIZED VIEW mvtest_boxmv AS SELECT * FROM mvtest_boxes;
-CREATE UNIQUE INDEX mvtest_boxmv_id ON mvtest_boxmv (id);
-UPDATE mvtest_boxes SET b = '(2,2),(1,1)' WHERE id = 2;
-REFRESH MATERIALIZED VIEW CONCURRENTLY mvtest_boxmv;
-SELECT * FROM mvtest_boxmv ORDER BY id;
- id |              b              
-----+-----------------------------
-  1 | (32,32),(31,31)
-  2 | (2,2),(1,1)
-  3 | (1.9999996,1.9999996),(1,1)
-(3 rows)
-
-DROP TABLE mvtest_boxes CASCADE;
-NOTICE:  drop cascades to materialized view mvtest_boxmv
--- make sure that column names are handled correctly
-CREATE TABLE mvtest_v (i int, j int);
-CREATE MATERIALIZED VIEW mvtest_mv_v (ii, jj, kk) AS SELECT i, j FROM mvtest_v; -- error
-ERROR:  too many column names were specified
-CREATE MATERIALIZED VIEW mvtest_mv_v (ii, jj) AS SELECT i, j FROM mvtest_v; -- ok
-CREATE MATERIALIZED VIEW mvtest_mv_v_2 (ii) AS SELECT i, j FROM mvtest_v; -- ok
-CREATE MATERIALIZED VIEW mvtest_mv_v_3 (ii, jj, kk) AS SELECT i, j FROM mvtest_v WITH NO DATA; -- error
-ERROR:  too many column names were specified
-CREATE MATERIALIZED VIEW mvtest_mv_v_3 (ii, jj) AS SELECT i, j FROM mvtest_v WITH NO DATA; -- ok
-CREATE MATERIALIZED VIEW mvtest_mv_v_4 (ii) AS SELECT i, j FROM mvtest_v WITH NO DATA; -- ok
-ALTER TABLE mvtest_v RENAME COLUMN i TO x;
-INSERT INTO mvtest_v values (1, 2);
-CREATE UNIQUE INDEX mvtest_mv_v_ii ON mvtest_mv_v (ii);
-REFRESH MATERIALIZED VIEW mvtest_mv_v;
-UPDATE mvtest_v SET j = 3 WHERE x = 1;
-REFRESH MATERIALIZED VIEW CONCURRENTLY mvtest_mv_v;
-REFRESH MATERIALIZED VIEW mvtest_mv_v_2;
-REFRESH MATERIALIZED VIEW mvtest_mv_v_3;
-REFRESH MATERIALIZED VIEW mvtest_mv_v_4;
-SELECT * FROM mvtest_v;
- x | j 
----+---
- 1 | 3
-(1 row)
-
-SELECT * FROM mvtest_mv_v;
- ii | jj 
-----+----
-  1 |  3
-(1 row)
-
-SELECT * FROM mvtest_mv_v_2;
- ii | j 
-----+---
-  1 | 3
-(1 row)
-
-SELECT * FROM mvtest_mv_v_3;
- ii | jj 
-----+----
-  1 |  3
-(1 row)
-
-SELECT * FROM mvtest_mv_v_4;
- ii | j 
-----+---
-  1 | 3
-(1 row)
-
-DROP TABLE mvtest_v CASCADE;
-NOTICE:  drop cascades to 4 other objects
-DETAIL:  drop cascades to materialized view mvtest_mv_v
-drop cascades to materialized view mvtest_mv_v_2
-drop cascades to materialized view mvtest_mv_v_3
-drop cascades to materialized view mvtest_mv_v_4
--- Check that unknown literals are converted to "text" in CREATE MATVIEW,
--- so that we don't end up with unknown-type columns.
-CREATE MATERIALIZED VIEW mv_unspecified_types AS
-  SELECT 42 as i, 42.5 as num, 'foo' as u, 'foo'::unknown as u2, null as n;
-\d+ mv_unspecified_types
-                      Materialized view "public.mv_unspecified_types"
- Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
---------+---------+-----------+----------+---------+----------+--------------+-------------
- i      | integer |           |          |         | plain    |              | 
- num    | numeric |           |          |         | main     |              | 
- u      | text    |           |          |         | extended |              | 
- u2     | text    |           |          |         | extended |              | 
- n      | text    |           |          |         | extended |              | 
-View definition:
- SELECT 42 AS i,
-    42.5 AS num,
-    'foo'::text AS u,
-    'foo'::text AS u2,
-    NULL::text AS n;
-
-SELECT * FROM mv_unspecified_types;
- i  | num  |  u  | u2  | n 
-----+------+-----+-----+---
- 42 | 42.5 | foo | foo | 
-(1 row)
-
-DROP MATERIALIZED VIEW mv_unspecified_types;
--- make sure that create WITH NO DATA does not plan the query (bug #13907)
-create materialized view mvtest_error as select 1/0 as x;  -- fail
-ERROR:  division by zero
-create materialized view mvtest_error as select 1/0 as x with no data;
-refresh materialized view mvtest_error;  -- fail here
-ERROR:  division by zero
-drop materialized view mvtest_error;
--- make sure that matview rows can be referenced as source rows (bug #9398)
-CREATE TABLE mvtest_v AS SELECT generate_series(1,10) AS a;
-CREATE MATERIALIZED VIEW mvtest_mv_v AS SELECT a FROM mvtest_v WHERE a <= 5;
-DELETE FROM mvtest_v WHERE EXISTS ( SELECT * FROM mvtest_mv_v WHERE mvtest_mv_v.a = mvtest_v.a );
-SELECT * FROM mvtest_v;
- a  
-----
-  6
-  7
-  8
-  9
- 10
-(5 rows)
-
-SELECT * FROM mvtest_mv_v;
- a 
----
- 1
- 2
- 3
- 4
- 5
-(5 rows)
-
-DROP TABLE mvtest_v CASCADE;
-NOTICE:  drop cascades to materialized view mvtest_mv_v
--- make sure running as superuser works when MV owned by another role (bug #11208)
-CREATE ROLE regress_user_mvtest;
-SET ROLE regress_user_mvtest;
--- this test case also checks for ambiguity in the queries issued by
--- refresh_by_match_merge(), by choosing column names that intentionally
--- duplicate all the aliases used in those queries
-CREATE TABLE mvtest_foo_data AS SELECT i,
-  i+1 AS tid,
-  md5(random()::text) AS mv,
-  md5(random()::text) AS newdata,
-  md5(random()::text) AS newdata2,
-  md5(random()::text) AS diff
-  FROM generate_series(1, 10) i;
-CREATE MATERIALIZED VIEW mvtest_mv_foo AS SELECT * FROM mvtest_foo_data;
-CREATE MATERIALIZED VIEW mvtest_mv_foo AS SELECT * FROM mvtest_foo_data;
-ERROR:  relation "mvtest_mv_foo" already exists
-CREATE MATERIALIZED VIEW IF NOT EXISTS mvtest_mv_foo AS SELECT * FROM mvtest_foo_data;
-NOTICE:  relation "mvtest_mv_foo" already exists, skipping
-CREATE UNIQUE INDEX ON mvtest_mv_foo (i);
-RESET ROLE;
-REFRESH MATERIALIZED VIEW mvtest_mv_foo;
-REFRESH MATERIALIZED VIEW CONCURRENTLY mvtest_mv_foo;
-DROP OWNED BY regress_user_mvtest CASCADE;
-DROP ROLE regress_user_mvtest;
--- make sure that create WITH NO DATA works via SPI
-BEGIN;
-CREATE FUNCTION mvtest_func()
-  RETURNS void AS $$
-BEGIN
-  CREATE MATERIALIZED VIEW mvtest1 AS SELECT 1 AS x;
-  CREATE MATERIALIZED VIEW mvtest2 AS SELECT 1 AS x WITH NO DATA;
-END;
-$$ LANGUAGE plpgsql;
-SELECT mvtest_func();
- mvtest_func 
--------------
- 
-(1 row)
-
-SELECT * FROM mvtest1;
- x 
----
- 1
-(1 row)
-
-SELECT * FROM mvtest2;
-ERROR:  materialized view "mvtest2" has not been populated
-HINT:  Use the REFRESH MATERIALIZED VIEW command.
-ROLLBACK;
--- INSERT privileges if relation owner is not allowed to insert.
-CREATE SCHEMA matview_schema;
-CREATE USER regress_matview_user;
-ALTER DEFAULT PRIVILEGES FOR ROLE regress_matview_user
-  REVOKE INSERT ON TABLES FROM regress_matview_user;
-GRANT ALL ON SCHEMA matview_schema TO public;
-SET SESSION AUTHORIZATION regress_matview_user;
-CREATE MATERIALIZED VIEW matview_schema.mv_withdata1 (a) AS
-  SELECT generate_series(1, 10) WITH DATA;
-EXPLAIN (ANALYZE, COSTS OFF, SUMMARY OFF, TIMING OFF)
-  CREATE MATERIALIZED VIEW matview_schema.mv_withdata2 (a) AS
-  SELECT generate_series(1, 10) WITH DATA;
-              QUERY PLAN              
---------------------------------------
- ProjectSet (actual rows=10 loops=1)
-   ->  Result (actual rows=1 loops=1)
-(2 rows)
-
-REFRESH MATERIALIZED VIEW matview_schema.mv_withdata2;
-CREATE MATERIALIZED VIEW matview_schema.mv_nodata1 (a) AS
-  SELECT generate_series(1, 10) WITH NO DATA;
-EXPLAIN (ANALYZE, COSTS OFF, SUMMARY OFF, TIMING OFF)
-  CREATE MATERIALIZED VIEW matview_schema.mv_nodata2 (a) AS
-  SELECT generate_series(1, 10) WITH NO DATA;
-          QUERY PLAN           
--------------------------------
- ProjectSet (never executed)
-   ->  Result (never executed)
-(2 rows)
-
-REFRESH MATERIALIZED VIEW matview_schema.mv_nodata2;
-RESET SESSION AUTHORIZATION;
-ALTER DEFAULT PRIVILEGES FOR ROLE regress_matview_user
-  GRANT INSERT ON TABLES TO regress_matview_user;
-DROP SCHEMA matview_schema CASCADE;
-NOTICE:  drop cascades to 4 other objects
-DETAIL:  drop cascades to materialized view matview_schema.mv_withdata1
-drop cascades to materialized view matview_schema.mv_withdata2
-drop cascades to materialized view matview_schema.mv_nodata1
-drop cascades to materialized view matview_schema.mv_nodata2
-DROP USER regress_matview_user;
--- CREATE MATERIALIZED VIEW ... IF NOT EXISTS
-CREATE MATERIALIZED VIEW matview_ine_tab AS SELECT 1;
-CREATE MATERIALIZED VIEW matview_ine_tab AS SELECT 1 / 0; -- error
-ERROR:  relation "matview_ine_tab" already exists
-CREATE MATERIALIZED VIEW IF NOT EXISTS matview_ine_tab AS
-  SELECT 1 / 0; -- ok
-NOTICE:  relation "matview_ine_tab" already exists, skipping
-CREATE MATERIALIZED VIEW matview_ine_tab AS
-  SELECT 1 / 0 WITH NO DATA; -- error
-ERROR:  relation "matview_ine_tab" already exists
-CREATE MATERIALIZED VIEW IF NOT EXISTS matview_ine_tab AS
-  SELECT 1 / 0 WITH NO DATA; -- ok
-NOTICE:  relation "matview_ine_tab" already exists, skipping
-EXPLAIN (ANALYZE, COSTS OFF, SUMMARY OFF, TIMING OFF)
-  CREATE MATERIALIZED VIEW matview_ine_tab AS
-    SELECT 1 / 0; -- error
-ERROR:  relation "matview_ine_tab" already exists
-EXPLAIN (ANALYZE, COSTS OFF, SUMMARY OFF, TIMING OFF)
-  CREATE MATERIALIZED VIEW IF NOT EXISTS matview_ine_tab AS
-    SELECT 1 / 0; -- ok
-NOTICE:  relation "matview_ine_tab" already exists, skipping
- QUERY PLAN 
-------------
-(0 rows)
-
-EXPLAIN (ANALYZE, COSTS OFF, SUMMARY OFF, TIMING OFF)
-  CREATE MATERIALIZED VIEW matview_ine_tab AS
-    SELECT 1 / 0 WITH NO DATA; -- error
-ERROR:  relation "matview_ine_tab" already exists
-EXPLAIN (ANALYZE, COSTS OFF, SUMMARY OFF, TIMING OFF)
-  CREATE MATERIALIZED VIEW IF NOT EXISTS matview_ine_tab AS
-    SELECT 1 / 0 WITH NO DATA; -- ok
-NOTICE:  relation "matview_ine_tab" already exists, skipping
- QUERY PLAN 
-------------
-(0 rows)
-
-DROP MATERIALIZED VIEW matview_ine_tab;
diff -U3 /Users/kenaniah/workspace/postgres/src/test/regress/expected/replica_identity.out /Users/kenaniah/workspace/postgres/src/test/regress/results/replica_identity.out
--- /Users/kenaniah/workspace/postgres/src/test/regress/expected/replica_identity.out	2021-10-03 17:41:49.000000000 -0700
+++ /Users/kenaniah/workspace/postgres/src/test/regress/results/replica_identity.out	2021-10-03 20:08:17.000000000 -0700
@@ -75,155 +75,11 @@
 (1 row)
 
 \d test_replica_identity
-                            Table "public.test_replica_identity"
- Column |  Type   | Collation | Nullable |                      Default                      
---------+---------+-----------+----------+---------------------------------------------------
- id     | integer |           | not null | nextval('test_replica_identity_id_seq'::regclass)
- keya   | text    |           | not null | 
- keyb   | text    |           | not null | 
- nonkey | text    |           |          | 
-Indexes:
-    "test_replica_identity_pkey" PRIMARY KEY, btree (id) REPLICA IDENTITY
-    "test_replica_identity_expr" UNIQUE, btree (keya, keyb, (3))
-    "test_replica_identity_hash" hash (nonkey)
-    "test_replica_identity_keyab" btree (keya, keyb)
-    "test_replica_identity_keyab_key" UNIQUE, btree (keya, keyb)
-    "test_replica_identity_nonkey" UNIQUE, btree (keya, nonkey)
-    "test_replica_identity_partial" UNIQUE, btree (keya, keyb) WHERE keyb <> '3'::text
-    "test_replica_identity_unique_defer" UNIQUE CONSTRAINT, btree (keya, keyb) DEFERRABLE
-    "test_replica_identity_unique_nondefer" UNIQUE CONSTRAINT, btree (keya, keyb)
+dyld: lazy symbol binding failed: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
+
+dyld: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
 
--- succeed, nondeferrable unique constraint over nonnullable cols
-ALTER TABLE test_replica_identity REPLICA IDENTITY USING INDEX test_replica_identity_unique_nondefer;
--- succeed unique index over nonnullable cols
-ALTER TABLE test_replica_identity REPLICA IDENTITY USING INDEX test_replica_identity_keyab_key;
-ALTER TABLE test_replica_identity REPLICA IDENTITY USING INDEX test_replica_identity_keyab_key;
-SELECT relreplident FROM pg_class WHERE oid = 'test_replica_identity'::regclass;
- relreplident 
---------------
- i
-(1 row)
-
-\d test_replica_identity
-                            Table "public.test_replica_identity"
- Column |  Type   | Collation | Nullable |                      Default                      
---------+---------+-----------+----------+---------------------------------------------------
- id     | integer |           | not null | nextval('test_replica_identity_id_seq'::regclass)
- keya   | text    |           | not null | 
- keyb   | text    |           | not null | 
- nonkey | text    |           |          | 
-Indexes:
-    "test_replica_identity_pkey" PRIMARY KEY, btree (id)
-    "test_replica_identity_expr" UNIQUE, btree (keya, keyb, (3))
-    "test_replica_identity_hash" hash (nonkey)
-    "test_replica_identity_keyab" btree (keya, keyb)
-    "test_replica_identity_keyab_key" UNIQUE, btree (keya, keyb) REPLICA IDENTITY
-    "test_replica_identity_nonkey" UNIQUE, btree (keya, nonkey)
-    "test_replica_identity_partial" UNIQUE, btree (keya, keyb) WHERE keyb <> '3'::text
-    "test_replica_identity_unique_defer" UNIQUE CONSTRAINT, btree (keya, keyb) DEFERRABLE
-    "test_replica_identity_unique_nondefer" UNIQUE CONSTRAINT, btree (keya, keyb)
-
-SELECT count(*) FROM pg_index WHERE indrelid = 'test_replica_identity'::regclass AND indisreplident;
- count 
--------
-     1
-(1 row)
-
-----
--- Make sure non index cases work
-----
-ALTER TABLE test_replica_identity REPLICA IDENTITY DEFAULT;
-SELECT relreplident FROM pg_class WHERE oid = 'test_replica_identity'::regclass;
- relreplident 
---------------
- d
-(1 row)
-
-SELECT count(*) FROM pg_index WHERE indrelid = 'test_replica_identity'::regclass AND indisreplident;
- count 
--------
-     0
-(1 row)
-
-ALTER TABLE test_replica_identity REPLICA IDENTITY FULL;
-SELECT relreplident FROM pg_class WHERE oid = 'test_replica_identity'::regclass;
- relreplident 
---------------
- f
-(1 row)
-
-\d+ test_replica_identity
-                                                Table "public.test_replica_identity"
- Column |  Type   | Collation | Nullable |                      Default                      | Storage  | Stats target | Description 
---------+---------+-----------+----------+---------------------------------------------------+----------+--------------+-------------
- id     | integer |           | not null | nextval('test_replica_identity_id_seq'::regclass) | plain    |              | 
- keya   | text    |           | not null |                                                   | extended |              | 
- keyb   | text    |           | not null |                                                   | extended |              | 
- nonkey | text    |           |          |                                                   | extended |              | 
-Indexes:
-    "test_replica_identity_pkey" PRIMARY KEY, btree (id)
-    "test_replica_identity_expr" UNIQUE, btree (keya, keyb, (3))
-    "test_replica_identity_hash" hash (nonkey)
-    "test_replica_identity_keyab" btree (keya, keyb)
-    "test_replica_identity_keyab_key" UNIQUE, btree (keya, keyb)
-    "test_replica_identity_nonkey" UNIQUE, btree (keya, nonkey)
-    "test_replica_identity_partial" UNIQUE, btree (keya, keyb) WHERE keyb <> '3'::text
-    "test_replica_identity_unique_defer" UNIQUE CONSTRAINT, btree (keya, keyb) DEFERRABLE
-    "test_replica_identity_unique_nondefer" UNIQUE CONSTRAINT, btree (keya, keyb)
-Replica Identity: FULL
-
-ALTER TABLE test_replica_identity REPLICA IDENTITY NOTHING;
-SELECT relreplident FROM pg_class WHERE oid = 'test_replica_identity'::regclass;
- relreplident 
---------------
- n
-(1 row)
-
----
--- Test that ALTER TABLE rewrite preserves nondefault replica identity
----
--- constraint variant
-CREATE TABLE test_replica_identity2 (id int UNIQUE NOT NULL);
-ALTER TABLE test_replica_identity2 REPLICA IDENTITY USING INDEX test_replica_identity2_id_key;
-\d test_replica_identity2
-       Table "public.test_replica_identity2"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- id     | integer |           | not null | 
-Indexes:
-    "test_replica_identity2_id_key" UNIQUE CONSTRAINT, btree (id) REPLICA IDENTITY
-
-ALTER TABLE test_replica_identity2 ALTER COLUMN id TYPE bigint;
-\d test_replica_identity2
-      Table "public.test_replica_identity2"
- Column |  Type  | Collation | Nullable | Default 
---------+--------+-----------+----------+---------
- id     | bigint |           | not null | 
-Indexes:
-    "test_replica_identity2_id_key" UNIQUE CONSTRAINT, btree (id) REPLICA IDENTITY
-
--- straight index variant
-CREATE TABLE test_replica_identity3 (id int NOT NULL);
-CREATE UNIQUE INDEX test_replica_identity3_id_key ON test_replica_identity3 (id);
-ALTER TABLE test_replica_identity3 REPLICA IDENTITY USING INDEX test_replica_identity3_id_key;
-\d test_replica_identity3
-       Table "public.test_replica_identity3"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- id     | integer |           | not null | 
-Indexes:
-    "test_replica_identity3_id_key" UNIQUE, btree (id) REPLICA IDENTITY
-
-ALTER TABLE test_replica_identity3 ALTER COLUMN id TYPE bigint;
-\d test_replica_identity3
-      Table "public.test_replica_identity3"
- Column |  Type  | Collation | Nullable | Default 
---------+--------+-----------+----------+---------
- id     | bigint |           | not null | 
-Indexes:
-    "test_replica_identity3_id_key" UNIQUE, btree (id) REPLICA IDENTITY
-
-DROP TABLE test_replica_identity;
-DROP TABLE test_replica_identity2;
-DROP TABLE test_replica_identity3;
-DROP TABLE test_replica_identity_othertable;
diff -U3 /Users/kenaniah/workspace/postgres/src/test/regress/expected/rowsecurity.out /Users/kenaniah/workspace/postgres/src/test/regress/results/rowsecurity.out
--- /Users/kenaniah/workspace/postgres/src/test/regress/expected/rowsecurity.out	2021-10-03 17:41:49.000000000 -0700
+++ /Users/kenaniah/workspace/postgres/src/test/regress/results/rowsecurity.out	2021-10-03 20:08:17.000000000 -0700
@@ -113,3930 +113,11 @@
 (3 rows)
 
 \d document
-        Table "regress_rls_schema.document"
- Column  |  Type   | Collation | Nullable | Default 
----------+---------+-----------+----------+---------
- did     | integer |           | not null | 
- cid     | integer |           |          | 
- dlevel  | integer |           | not null | 
- dauthor | name    |           |          | 
- dtitle  | text    |           |          | 
-Indexes:
-    "document_pkey" PRIMARY KEY, btree (did)
-Foreign-key constraints:
-    "document_cid_fkey" FOREIGN KEY (cid) REFERENCES category(cid)
-Policies:
-    POLICY "p1"
-      USING ((dlevel <= ( SELECT uaccount.seclv
-   FROM uaccount
-  WHERE (uaccount.pguser = CURRENT_USER))))
-    POLICY "p1r" AS RESTRICTIVE
-      TO regress_rls_dave
-      USING ((cid <> 44))
-    POLICY "p2r" AS RESTRICTIVE
-      TO regress_rls_dave
-      USING (((cid <> 44) AND (cid < 50)))
+dyld: lazy symbol binding failed: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
+
+dyld: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
 
-SELECT * FROM pg_policies WHERE schemaname = 'regress_rls_schema' AND tablename = 'document' ORDER BY policyname;
-     schemaname     | tablename | policyname | permissive  |       roles        | cmd |                    qual                    | with_check 
---------------------+-----------+------------+-------------+--------------------+-----+--------------------------------------------+------------
- regress_rls_schema | document  | p1         | PERMISSIVE  | {public}           | ALL | (dlevel <= ( SELECT uaccount.seclv        +| 
-                    |           |            |             |                    |     |    FROM uaccount                          +| 
-                    |           |            |             |                    |     |   WHERE (uaccount.pguser = CURRENT_USER))) | 
- regress_rls_schema | document  | p1r        | RESTRICTIVE | {regress_rls_dave} | ALL | (cid <> 44)                                | 
- regress_rls_schema | document  | p2r        | RESTRICTIVE | {regress_rls_dave} | ALL | ((cid <> 44) AND (cid < 50))               | 
-(3 rows)
-
--- viewpoint from regress_rls_bob
-SET SESSION AUTHORIZATION regress_rls_bob;
-SET row_security TO ON;
-SELECT * FROM document WHERE f_leak(dtitle) ORDER BY did;
-NOTICE:  f_leak => my first novel
-NOTICE:  f_leak => my first manga
-NOTICE:  f_leak => great science fiction
-NOTICE:  f_leak => great manga
-NOTICE:  f_leak => awesome science fiction
- did | cid | dlevel |      dauthor      |         dtitle          
------+-----+--------+-------------------+-------------------------
-   1 |  11 |      1 | regress_rls_bob   | my first novel
-   4 |  44 |      1 | regress_rls_bob   | my first manga
-   6 |  22 |      1 | regress_rls_carol | great science fiction
-   8 |  44 |      1 | regress_rls_carol | great manga
-   9 |  22 |      1 | regress_rls_dave  | awesome science fiction
-(5 rows)
-
-SELECT * FROM document NATURAL JOIN category WHERE f_leak(dtitle) ORDER BY did;
-NOTICE:  f_leak => my first novel
-NOTICE:  f_leak => my first manga
-NOTICE:  f_leak => great science fiction
-NOTICE:  f_leak => great manga
-NOTICE:  f_leak => awesome science fiction
- cid | did | dlevel |      dauthor      |         dtitle          |      cname      
------+-----+--------+-------------------+-------------------------+-----------------
-  11 |   1 |      1 | regress_rls_bob   | my first novel          | novel
-  44 |   4 |      1 | regress_rls_bob   | my first manga          | manga
-  22 |   6 |      1 | regress_rls_carol | great science fiction   | science fiction
-  44 |   8 |      1 | regress_rls_carol | great manga             | manga
-  22 |   9 |      1 | regress_rls_dave  | awesome science fiction | science fiction
-(5 rows)
-
--- try a sampled version
-SELECT * FROM document TABLESAMPLE BERNOULLI(50) REPEATABLE(0)
-  WHERE f_leak(dtitle) ORDER BY did;
-NOTICE:  f_leak => my first manga
-NOTICE:  f_leak => great science fiction
-NOTICE:  f_leak => great manga
-NOTICE:  f_leak => awesome science fiction
- did | cid | dlevel |      dauthor      |         dtitle          
------+-----+--------+-------------------+-------------------------
-   4 |  44 |      1 | regress_rls_bob   | my first manga
-   6 |  22 |      1 | regress_rls_carol | great science fiction
-   8 |  44 |      1 | regress_rls_carol | great manga
-   9 |  22 |      1 | regress_rls_dave  | awesome science fiction
-(4 rows)
-
--- viewpoint from regress_rls_carol
-SET SESSION AUTHORIZATION regress_rls_carol;
-SELECT * FROM document WHERE f_leak(dtitle) ORDER BY did;
-NOTICE:  f_leak => my first novel
-NOTICE:  f_leak => my second novel
-NOTICE:  f_leak => my science fiction
-NOTICE:  f_leak => my first manga
-NOTICE:  f_leak => my second manga
-NOTICE:  f_leak => great science fiction
-NOTICE:  f_leak => great technology book
-NOTICE:  f_leak => great manga
-NOTICE:  f_leak => awesome science fiction
-NOTICE:  f_leak => awesome technology book
- did | cid | dlevel |      dauthor      |         dtitle          
------+-----+--------+-------------------+-------------------------
-   1 |  11 |      1 | regress_rls_bob   | my first novel
-   2 |  11 |      2 | regress_rls_bob   | my second novel
-   3 |  22 |      2 | regress_rls_bob   | my science fiction
-   4 |  44 |      1 | regress_rls_bob   | my first manga
-   5 |  44 |      2 | regress_rls_bob   | my second manga
-   6 |  22 |      1 | regress_rls_carol | great science fiction
-   7 |  33 |      2 | regress_rls_carol | great technology book
-   8 |  44 |      1 | regress_rls_carol | great manga
-   9 |  22 |      1 | regress_rls_dave  | awesome science fiction
-  10 |  33 |      2 | regress_rls_dave  | awesome technology book
-(10 rows)
-
-SELECT * FROM document NATURAL JOIN category WHERE f_leak(dtitle) ORDER BY did;
-NOTICE:  f_leak => my first novel
-NOTICE:  f_leak => my second novel
-NOTICE:  f_leak => my science fiction
-NOTICE:  f_leak => my first manga
-NOTICE:  f_leak => my second manga
-NOTICE:  f_leak => great science fiction
-NOTICE:  f_leak => great technology book
-NOTICE:  f_leak => great manga
-NOTICE:  f_leak => awesome science fiction
-NOTICE:  f_leak => awesome technology book
- cid | did | dlevel |      dauthor      |         dtitle          |      cname      
------+-----+--------+-------------------+-------------------------+-----------------
-  11 |   1 |      1 | regress_rls_bob   | my first novel          | novel
-  11 |   2 |      2 | regress_rls_bob   | my second novel         | novel
-  22 |   3 |      2 | regress_rls_bob   | my science fiction      | science fiction
-  44 |   4 |      1 | regress_rls_bob   | my first manga          | manga
-  44 |   5 |      2 | regress_rls_bob   | my second manga         | manga
-  22 |   6 |      1 | regress_rls_carol | great science fiction   | science fiction
-  33 |   7 |      2 | regress_rls_carol | great technology book   | technology
-  44 |   8 |      1 | regress_rls_carol | great manga             | manga
-  22 |   9 |      1 | regress_rls_dave  | awesome science fiction | science fiction
-  33 |  10 |      2 | regress_rls_dave  | awesome technology book | technology
-(10 rows)
-
--- try a sampled version
-SELECT * FROM document TABLESAMPLE BERNOULLI(50) REPEATABLE(0)
-  WHERE f_leak(dtitle) ORDER BY did;
-NOTICE:  f_leak => my first manga
-NOTICE:  f_leak => my second manga
-NOTICE:  f_leak => great science fiction
-NOTICE:  f_leak => great manga
-NOTICE:  f_leak => awesome science fiction
- did | cid | dlevel |      dauthor      |         dtitle          
------+-----+--------+-------------------+-------------------------
-   4 |  44 |      1 | regress_rls_bob   | my first manga
-   5 |  44 |      2 | regress_rls_bob   | my second manga
-   6 |  22 |      1 | regress_rls_carol | great science fiction
-   8 |  44 |      1 | regress_rls_carol | great manga
-   9 |  22 |      1 | regress_rls_dave  | awesome science fiction
-(5 rows)
-
-EXPLAIN (COSTS OFF) SELECT * FROM document WHERE f_leak(dtitle);
-                     QUERY PLAN                     
-----------------------------------------------------
- Seq Scan on document
-   Filter: ((dlevel <= $0) AND f_leak(dtitle))
-   InitPlan 1 (returns $0)
-     ->  Index Scan using uaccount_pkey on uaccount
-           Index Cond: (pguser = CURRENT_USER)
-(5 rows)
-
-EXPLAIN (COSTS OFF) SELECT * FROM document NATURAL JOIN category WHERE f_leak(dtitle);
-                        QUERY PLAN                         
------------------------------------------------------------
- Hash Join
-   Hash Cond: (category.cid = document.cid)
-   InitPlan 1 (returns $0)
-     ->  Index Scan using uaccount_pkey on uaccount
-           Index Cond: (pguser = CURRENT_USER)
-   ->  Seq Scan on category
-   ->  Hash
-         ->  Seq Scan on document
-               Filter: ((dlevel <= $0) AND f_leak(dtitle))
-(9 rows)
-
--- viewpoint from regress_rls_dave
-SET SESSION AUTHORIZATION regress_rls_dave;
-SELECT * FROM document WHERE f_leak(dtitle) ORDER BY did;
-NOTICE:  f_leak => my first novel
-NOTICE:  f_leak => my second novel
-NOTICE:  f_leak => my science fiction
-NOTICE:  f_leak => great science fiction
-NOTICE:  f_leak => great technology book
-NOTICE:  f_leak => awesome science fiction
-NOTICE:  f_leak => awesome technology book
- did | cid | dlevel |      dauthor      |         dtitle          
------+-----+--------+-------------------+-------------------------
-   1 |  11 |      1 | regress_rls_bob   | my first novel
-   2 |  11 |      2 | regress_rls_bob   | my second novel
-   3 |  22 |      2 | regress_rls_bob   | my science fiction
-   6 |  22 |      1 | regress_rls_carol | great science fiction
-   7 |  33 |      2 | regress_rls_carol | great technology book
-   9 |  22 |      1 | regress_rls_dave  | awesome science fiction
-  10 |  33 |      2 | regress_rls_dave  | awesome technology book
-(7 rows)
-
-SELECT * FROM document NATURAL JOIN category WHERE f_leak(dtitle) ORDER BY did;
-NOTICE:  f_leak => my first novel
-NOTICE:  f_leak => my second novel
-NOTICE:  f_leak => my science fiction
-NOTICE:  f_leak => great science fiction
-NOTICE:  f_leak => great technology book
-NOTICE:  f_leak => awesome science fiction
-NOTICE:  f_leak => awesome technology book
- cid | did | dlevel |      dauthor      |         dtitle          |      cname      
------+-----+--------+-------------------+-------------------------+-----------------
-  11 |   1 |      1 | regress_rls_bob   | my first novel          | novel
-  11 |   2 |      2 | regress_rls_bob   | my second novel         | novel
-  22 |   3 |      2 | regress_rls_bob   | my science fiction      | science fiction
-  22 |   6 |      1 | regress_rls_carol | great science fiction   | science fiction
-  33 |   7 |      2 | regress_rls_carol | great technology book   | technology
-  22 |   9 |      1 | regress_rls_dave  | awesome science fiction | science fiction
-  33 |  10 |      2 | regress_rls_dave  | awesome technology book | technology
-(7 rows)
-
-EXPLAIN (COSTS OFF) SELECT * FROM document WHERE f_leak(dtitle);
-                                          QUERY PLAN                                          
-----------------------------------------------------------------------------------------------
- Seq Scan on document
-   Filter: ((cid <> 44) AND (cid <> 44) AND (cid < 50) AND (dlevel <= $0) AND f_leak(dtitle))
-   InitPlan 1 (returns $0)
-     ->  Index Scan using uaccount_pkey on uaccount
-           Index Cond: (pguser = CURRENT_USER)
-(5 rows)
-
-EXPLAIN (COSTS OFF) SELECT * FROM document NATURAL JOIN category WHERE f_leak(dtitle);
-                                                QUERY PLAN                                                
-----------------------------------------------------------------------------------------------------------
- Hash Join
-   Hash Cond: (category.cid = document.cid)
-   InitPlan 1 (returns $0)
-     ->  Index Scan using uaccount_pkey on uaccount
-           Index Cond: (pguser = CURRENT_USER)
-   ->  Seq Scan on category
-   ->  Hash
-         ->  Seq Scan on document
-               Filter: ((cid <> 44) AND (cid <> 44) AND (cid < 50) AND (dlevel <= $0) AND f_leak(dtitle))
-(9 rows)
-
--- 44 would technically fail for both p2r and p1r, but we should get an error
--- back from p1r for this because it sorts first
-INSERT INTO document VALUES (100, 44, 1, 'regress_rls_dave', 'testing sorting of policies'); -- fail
-ERROR:  new row violates row-level security policy "p1r" for table "document"
--- Just to see a p2r error
-INSERT INTO document VALUES (100, 55, 1, 'regress_rls_dave', 'testing sorting of policies'); -- fail
-ERROR:  new row violates row-level security policy "p2r" for table "document"
--- only owner can change policies
-ALTER POLICY p1 ON document USING (true);    --fail
-ERROR:  must be owner of table document
-DROP POLICY p1 ON document;                  --fail
-ERROR:  must be owner of relation document
-SET SESSION AUTHORIZATION regress_rls_alice;
-ALTER POLICY p1 ON document USING (dauthor = current_user);
--- viewpoint from regress_rls_bob again
-SET SESSION AUTHORIZATION regress_rls_bob;
-SELECT * FROM document WHERE f_leak(dtitle) ORDER BY did;
-NOTICE:  f_leak => my first novel
-NOTICE:  f_leak => my second novel
-NOTICE:  f_leak => my science fiction
-NOTICE:  f_leak => my first manga
-NOTICE:  f_leak => my second manga
- did | cid | dlevel |     dauthor     |       dtitle       
------+-----+--------+-----------------+--------------------
-   1 |  11 |      1 | regress_rls_bob | my first novel
-   2 |  11 |      2 | regress_rls_bob | my second novel
-   3 |  22 |      2 | regress_rls_bob | my science fiction
-   4 |  44 |      1 | regress_rls_bob | my first manga
-   5 |  44 |      2 | regress_rls_bob | my second manga
-(5 rows)
-
-SELECT * FROM document NATURAL JOIN category WHERE f_leak(dtitle) ORDER by did;
-NOTICE:  f_leak => my first novel
-NOTICE:  f_leak => my second novel
-NOTICE:  f_leak => my science fiction
-NOTICE:  f_leak => my first manga
-NOTICE:  f_leak => my second manga
- cid | did | dlevel |     dauthor     |       dtitle       |      cname      
------+-----+--------+-----------------+--------------------+-----------------
-  11 |   1 |      1 | regress_rls_bob | my first novel     | novel
-  11 |   2 |      2 | regress_rls_bob | my second novel    | novel
-  22 |   3 |      2 | regress_rls_bob | my science fiction | science fiction
-  44 |   4 |      1 | regress_rls_bob | my first manga     | manga
-  44 |   5 |      2 | regress_rls_bob | my second manga    | manga
-(5 rows)
-
--- viewpoint from rls_regres_carol again
-SET SESSION AUTHORIZATION regress_rls_carol;
-SELECT * FROM document WHERE f_leak(dtitle) ORDER BY did;
-NOTICE:  f_leak => great science fiction
-NOTICE:  f_leak => great technology book
-NOTICE:  f_leak => great manga
- did | cid | dlevel |      dauthor      |        dtitle         
------+-----+--------+-------------------+-----------------------
-   6 |  22 |      1 | regress_rls_carol | great science fiction
-   7 |  33 |      2 | regress_rls_carol | great technology book
-   8 |  44 |      1 | regress_rls_carol | great manga
-(3 rows)
-
-SELECT * FROM document NATURAL JOIN category WHERE f_leak(dtitle) ORDER by did;
-NOTICE:  f_leak => great science fiction
-NOTICE:  f_leak => great technology book
-NOTICE:  f_leak => great manga
- cid | did | dlevel |      dauthor      |        dtitle         |      cname      
------+-----+--------+-------------------+-----------------------+-----------------
-  22 |   6 |      1 | regress_rls_carol | great science fiction | science fiction
-  33 |   7 |      2 | regress_rls_carol | great technology book | technology
-  44 |   8 |      1 | regress_rls_carol | great manga           | manga
-(3 rows)
-
-EXPLAIN (COSTS OFF) SELECT * FROM document WHERE f_leak(dtitle);
-                       QUERY PLAN                        
----------------------------------------------------------
- Seq Scan on document
-   Filter: ((dauthor = CURRENT_USER) AND f_leak(dtitle))
-(2 rows)
-
-EXPLAIN (COSTS OFF) SELECT * FROM document NATURAL JOIN category WHERE f_leak(dtitle);
-                          QUERY PLAN                           
----------------------------------------------------------------
- Nested Loop
-   ->  Seq Scan on document
-         Filter: ((dauthor = CURRENT_USER) AND f_leak(dtitle))
-   ->  Index Scan using category_pkey on category
-         Index Cond: (cid = document.cid)
-(5 rows)
-
--- interaction of FK/PK constraints
-SET SESSION AUTHORIZATION regress_rls_alice;
-CREATE POLICY p2 ON category
-    USING (CASE WHEN current_user = 'regress_rls_bob' THEN cid IN (11, 33)
-           WHEN current_user = 'regress_rls_carol' THEN cid IN (22, 44)
-           ELSE false END);
-ALTER TABLE category ENABLE ROW LEVEL SECURITY;
--- cannot delete PK referenced by invisible FK
-SET SESSION AUTHORIZATION regress_rls_bob;
-SELECT * FROM document d FULL OUTER JOIN category c on d.cid = c.cid ORDER BY d.did, c.cid;
- did | cid | dlevel |     dauthor     |       dtitle       | cid |   cname    
------+-----+--------+-----------------+--------------------+-----+------------
-   1 |  11 |      1 | regress_rls_bob | my first novel     |  11 | novel
-   2 |  11 |      2 | regress_rls_bob | my second novel    |  11 | novel
-   3 |  22 |      2 | regress_rls_bob | my science fiction |     | 
-   4 |  44 |      1 | regress_rls_bob | my first manga     |     | 
-   5 |  44 |      2 | regress_rls_bob | my second manga    |     | 
-     |     |        |                 |                    |  33 | technology
-(6 rows)
-
-DELETE FROM category WHERE cid = 33;    -- fails with FK violation
-ERROR:  update or delete on table "category" violates foreign key constraint "document_cid_fkey" on table "document"
-DETAIL:  Key is still referenced from table "document".
--- can insert FK referencing invisible PK
-SET SESSION AUTHORIZATION regress_rls_carol;
-SELECT * FROM document d FULL OUTER JOIN category c on d.cid = c.cid ORDER BY d.did, c.cid;
- did | cid | dlevel |      dauthor      |        dtitle         | cid |      cname      
------+-----+--------+-------------------+-----------------------+-----+-----------------
-   6 |  22 |      1 | regress_rls_carol | great science fiction |  22 | science fiction
-   7 |  33 |      2 | regress_rls_carol | great technology book |     | 
-   8 |  44 |      1 | regress_rls_carol | great manga           |  44 | manga
-(3 rows)
-
-INSERT INTO document VALUES (11, 33, 1, current_user, 'hoge');
--- UNIQUE or PRIMARY KEY constraint violation DOES reveal presence of row
-SET SESSION AUTHORIZATION regress_rls_bob;
-INSERT INTO document VALUES (8, 44, 1, 'regress_rls_bob', 'my third manga'); -- Must fail with unique violation, revealing presence of did we can't see
-ERROR:  duplicate key value violates unique constraint "document_pkey"
-SELECT * FROM document WHERE did = 8; -- and confirm we can't see it
- did | cid | dlevel | dauthor | dtitle 
------+-----+--------+---------+--------
-(0 rows)
-
--- RLS policies are checked before constraints
-INSERT INTO document VALUES (8, 44, 1, 'regress_rls_carol', 'my third manga'); -- Should fail with RLS check violation, not duplicate key violation
-ERROR:  new row violates row-level security policy for table "document"
-UPDATE document SET did = 8, dauthor = 'regress_rls_carol' WHERE did = 5; -- Should fail with RLS check violation, not duplicate key violation
-ERROR:  new row violates row-level security policy for table "document"
--- database superuser does bypass RLS policy when enabled
-RESET SESSION AUTHORIZATION;
-SET row_security TO ON;
-SELECT * FROM document;
- did | cid | dlevel |      dauthor      |         dtitle          
------+-----+--------+-------------------+-------------------------
-   1 |  11 |      1 | regress_rls_bob   | my first novel
-   2 |  11 |      2 | regress_rls_bob   | my second novel
-   3 |  22 |      2 | regress_rls_bob   | my science fiction
-   4 |  44 |      1 | regress_rls_bob   | my first manga
-   5 |  44 |      2 | regress_rls_bob   | my second manga
-   6 |  22 |      1 | regress_rls_carol | great science fiction
-   7 |  33 |      2 | regress_rls_carol | great technology book
-   8 |  44 |      1 | regress_rls_carol | great manga
-   9 |  22 |      1 | regress_rls_dave  | awesome science fiction
-  10 |  33 |      2 | regress_rls_dave  | awesome technology book
-  11 |  33 |      1 | regress_rls_carol | hoge
-(11 rows)
-
-SELECT * FROM category;
- cid |      cname      
------+-----------------
-  11 | novel
-  22 | science fiction
-  33 | technology
-  44 | manga
-(4 rows)
-
--- database superuser does bypass RLS policy when disabled
-RESET SESSION AUTHORIZATION;
-SET row_security TO OFF;
-SELECT * FROM document;
- did | cid | dlevel |      dauthor      |         dtitle          
------+-----+--------+-------------------+-------------------------
-   1 |  11 |      1 | regress_rls_bob   | my first novel
-   2 |  11 |      2 | regress_rls_bob   | my second novel
-   3 |  22 |      2 | regress_rls_bob   | my science fiction
-   4 |  44 |      1 | regress_rls_bob   | my first manga
-   5 |  44 |      2 | regress_rls_bob   | my second manga
-   6 |  22 |      1 | regress_rls_carol | great science fiction
-   7 |  33 |      2 | regress_rls_carol | great technology book
-   8 |  44 |      1 | regress_rls_carol | great manga
-   9 |  22 |      1 | regress_rls_dave  | awesome science fiction
-  10 |  33 |      2 | regress_rls_dave  | awesome technology book
-  11 |  33 |      1 | regress_rls_carol | hoge
-(11 rows)
-
-SELECT * FROM category;
- cid |      cname      
------+-----------------
-  11 | novel
-  22 | science fiction
-  33 | technology
-  44 | manga
-(4 rows)
-
--- database non-superuser with bypass privilege can bypass RLS policy when disabled
-SET SESSION AUTHORIZATION regress_rls_exempt_user;
-SET row_security TO OFF;
-SELECT * FROM document;
- did | cid | dlevel |      dauthor      |         dtitle          
------+-----+--------+-------------------+-------------------------
-   1 |  11 |      1 | regress_rls_bob   | my first novel
-   2 |  11 |      2 | regress_rls_bob   | my second novel
-   3 |  22 |      2 | regress_rls_bob   | my science fiction
-   4 |  44 |      1 | regress_rls_bob   | my first manga
-   5 |  44 |      2 | regress_rls_bob   | my second manga
-   6 |  22 |      1 | regress_rls_carol | great science fiction
-   7 |  33 |      2 | regress_rls_carol | great technology book
-   8 |  44 |      1 | regress_rls_carol | great manga
-   9 |  22 |      1 | regress_rls_dave  | awesome science fiction
-  10 |  33 |      2 | regress_rls_dave  | awesome technology book
-  11 |  33 |      1 | regress_rls_carol | hoge
-(11 rows)
-
-SELECT * FROM category;
- cid |      cname      
------+-----------------
-  11 | novel
-  22 | science fiction
-  33 | technology
-  44 | manga
-(4 rows)
-
--- RLS policy does not apply to table owner when RLS enabled.
-SET SESSION AUTHORIZATION regress_rls_alice;
-SET row_security TO ON;
-SELECT * FROM document;
- did | cid | dlevel |      dauthor      |         dtitle          
------+-----+--------+-------------------+-------------------------
-   1 |  11 |      1 | regress_rls_bob   | my first novel
-   2 |  11 |      2 | regress_rls_bob   | my second novel
-   3 |  22 |      2 | regress_rls_bob   | my science fiction
-   4 |  44 |      1 | regress_rls_bob   | my first manga
-   5 |  44 |      2 | regress_rls_bob   | my second manga
-   6 |  22 |      1 | regress_rls_carol | great science fiction
-   7 |  33 |      2 | regress_rls_carol | great technology book
-   8 |  44 |      1 | regress_rls_carol | great manga
-   9 |  22 |      1 | regress_rls_dave  | awesome science fiction
-  10 |  33 |      2 | regress_rls_dave  | awesome technology book
-  11 |  33 |      1 | regress_rls_carol | hoge
-(11 rows)
-
-SELECT * FROM category;
- cid |      cname      
------+-----------------
-  11 | novel
-  22 | science fiction
-  33 | technology
-  44 | manga
-(4 rows)
-
--- RLS policy does not apply to table owner when RLS disabled.
-SET SESSION AUTHORIZATION regress_rls_alice;
-SET row_security TO OFF;
-SELECT * FROM document;
- did | cid | dlevel |      dauthor      |         dtitle          
------+-----+--------+-------------------+-------------------------
-   1 |  11 |      1 | regress_rls_bob   | my first novel
-   2 |  11 |      2 | regress_rls_bob   | my second novel
-   3 |  22 |      2 | regress_rls_bob   | my science fiction
-   4 |  44 |      1 | regress_rls_bob   | my first manga
-   5 |  44 |      2 | regress_rls_bob   | my second manga
-   6 |  22 |      1 | regress_rls_carol | great science fiction
-   7 |  33 |      2 | regress_rls_carol | great technology book
-   8 |  44 |      1 | regress_rls_carol | great manga
-   9 |  22 |      1 | regress_rls_dave  | awesome science fiction
-  10 |  33 |      2 | regress_rls_dave  | awesome technology book
-  11 |  33 |      1 | regress_rls_carol | hoge
-(11 rows)
-
-SELECT * FROM category;
- cid |      cname      
------+-----------------
-  11 | novel
-  22 | science fiction
-  33 | technology
-  44 | manga
-(4 rows)
-
---
--- Table inheritance and RLS policy
---
-SET SESSION AUTHORIZATION regress_rls_alice;
-SET row_security TO ON;
-CREATE TABLE t1 (id int not null primary key, a int, junk1 text, b text);
-ALTER TABLE t1 DROP COLUMN junk1;    -- just a disturbing factor
-GRANT ALL ON t1 TO public;
-COPY t1 FROM stdin WITH ;
-CREATE TABLE t2 (c float) INHERITS (t1);
-GRANT ALL ON t2 TO public;
-COPY t2 FROM stdin;
-CREATE TABLE t3 (id int not null primary key, c text, b text, a int);
-ALTER TABLE t3 INHERIT t1;
-GRANT ALL ON t3 TO public;
-COPY t3(id, a,b,c) FROM stdin;
-CREATE POLICY p1 ON t1 FOR ALL TO PUBLIC USING (a % 2 = 0); -- be even number
-CREATE POLICY p2 ON t2 FOR ALL TO PUBLIC USING (a % 2 = 1); -- be odd number
-ALTER TABLE t1 ENABLE ROW LEVEL SECURITY;
-ALTER TABLE t2 ENABLE ROW LEVEL SECURITY;
-SET SESSION AUTHORIZATION regress_rls_bob;
-SELECT * FROM t1;
- id  | a |  b  
------+---+-----
- 102 | 2 | bbb
- 104 | 4 | dad
- 202 | 2 | bcd
- 204 | 4 | def
- 302 | 2 | yyy
-(5 rows)
-
-EXPLAIN (COSTS OFF) SELECT * FROM t1;
-          QUERY PLAN           
--------------------------------
- Append
-   ->  Seq Scan on t1 t1_1
-         Filter: ((a % 2) = 0)
-   ->  Seq Scan on t2 t1_2
-         Filter: ((a % 2) = 0)
-   ->  Seq Scan on t3 t1_3
-         Filter: ((a % 2) = 0)
-(7 rows)
-
-SELECT * FROM t1 WHERE f_leak(b);
-NOTICE:  f_leak => bbb
-NOTICE:  f_leak => dad
-NOTICE:  f_leak => bcd
-NOTICE:  f_leak => def
-NOTICE:  f_leak => yyy
- id  | a |  b  
------+---+-----
- 102 | 2 | bbb
- 104 | 4 | dad
- 202 | 2 | bcd
- 204 | 4 | def
- 302 | 2 | yyy
-(5 rows)
-
-EXPLAIN (COSTS OFF) SELECT * FROM t1 WHERE f_leak(b);
-                  QUERY PLAN                   
------------------------------------------------
- Append
-   ->  Seq Scan on t1 t1_1
-         Filter: (((a % 2) = 0) AND f_leak(b))
-   ->  Seq Scan on t2 t1_2
-         Filter: (((a % 2) = 0) AND f_leak(b))
-   ->  Seq Scan on t3 t1_3
-         Filter: (((a % 2) = 0) AND f_leak(b))
-(7 rows)
-
--- reference to system column
-SELECT tableoid::regclass, * FROM t1;
- tableoid | id  | a |  b  
-----------+-----+---+-----
- t1       | 102 | 2 | bbb
- t1       | 104 | 4 | dad
- t2       | 202 | 2 | bcd
- t2       | 204 | 4 | def
- t3       | 302 | 2 | yyy
-(5 rows)
-
-EXPLAIN (COSTS OFF) SELECT *, t1 FROM t1;
-          QUERY PLAN           
--------------------------------
- Append
-   ->  Seq Scan on t1 t1_1
-         Filter: ((a % 2) = 0)
-   ->  Seq Scan on t2 t1_2
-         Filter: ((a % 2) = 0)
-   ->  Seq Scan on t3 t1_3
-         Filter: ((a % 2) = 0)
-(7 rows)
-
--- reference to whole-row reference
-SELECT *, t1 FROM t1;
- id  | a |  b  |     t1      
------+---+-----+-------------
- 102 | 2 | bbb | (102,2,bbb)
- 104 | 4 | dad | (104,4,dad)
- 202 | 2 | bcd | (202,2,bcd)
- 204 | 4 | def | (204,4,def)
- 302 | 2 | yyy | (302,2,yyy)
-(5 rows)
-
-EXPLAIN (COSTS OFF) SELECT *, t1 FROM t1;
-          QUERY PLAN           
--------------------------------
- Append
-   ->  Seq Scan on t1 t1_1
-         Filter: ((a % 2) = 0)
-   ->  Seq Scan on t2 t1_2
-         Filter: ((a % 2) = 0)
-   ->  Seq Scan on t3 t1_3
-         Filter: ((a % 2) = 0)
-(7 rows)
-
--- for share/update lock
-SELECT * FROM t1 FOR SHARE;
- id  | a |  b  
------+---+-----
- 102 | 2 | bbb
- 104 | 4 | dad
- 202 | 2 | bcd
- 204 | 4 | def
- 302 | 2 | yyy
-(5 rows)
-
-EXPLAIN (COSTS OFF) SELECT * FROM t1 FOR SHARE;
-             QUERY PLAN              
--------------------------------------
- LockRows
-   ->  Append
-         ->  Seq Scan on t1 t1_1
-               Filter: ((a % 2) = 0)
-         ->  Seq Scan on t2 t1_2
-               Filter: ((a % 2) = 0)
-         ->  Seq Scan on t3 t1_3
-               Filter: ((a % 2) = 0)
-(8 rows)
-
-SELECT * FROM t1 WHERE f_leak(b) FOR SHARE;
-NOTICE:  f_leak => bbb
-NOTICE:  f_leak => dad
-NOTICE:  f_leak => bcd
-NOTICE:  f_leak => def
-NOTICE:  f_leak => yyy
- id  | a |  b  
------+---+-----
- 102 | 2 | bbb
- 104 | 4 | dad
- 202 | 2 | bcd
- 204 | 4 | def
- 302 | 2 | yyy
-(5 rows)
-
-EXPLAIN (COSTS OFF) SELECT * FROM t1 WHERE f_leak(b) FOR SHARE;
-                     QUERY PLAN                      
------------------------------------------------------
- LockRows
-   ->  Append
-         ->  Seq Scan on t1 t1_1
-               Filter: (((a % 2) = 0) AND f_leak(b))
-         ->  Seq Scan on t2 t1_2
-               Filter: (((a % 2) = 0) AND f_leak(b))
-         ->  Seq Scan on t3 t1_3
-               Filter: (((a % 2) = 0) AND f_leak(b))
-(8 rows)
-
--- union all query
-SELECT a, b, tableoid::regclass FROM t2 UNION ALL SELECT a, b, tableoid::regclass FROM t3;
- a |  b  | tableoid 
----+-----+----------
- 1 | abc | t2
- 3 | cde | t2
- 1 | xxx | t3
- 2 | yyy | t3
- 3 | zzz | t3
-(5 rows)
-
-EXPLAIN (COSTS OFF) SELECT a, b, tableoid::regclass FROM t2 UNION ALL SELECT a, b, tableoid::regclass FROM t3;
-          QUERY PLAN           
--------------------------------
- Append
-   ->  Seq Scan on t2
-         Filter: ((a % 2) = 1)
-   ->  Seq Scan on t3
-(4 rows)
-
--- superuser is allowed to bypass RLS checks
-RESET SESSION AUTHORIZATION;
-SET row_security TO OFF;
-SELECT * FROM t1 WHERE f_leak(b);
-NOTICE:  f_leak => aba
-NOTICE:  f_leak => bbb
-NOTICE:  f_leak => ccc
-NOTICE:  f_leak => dad
-NOTICE:  f_leak => abc
-NOTICE:  f_leak => bcd
-NOTICE:  f_leak => cde
-NOTICE:  f_leak => def
-NOTICE:  f_leak => xxx
-NOTICE:  f_leak => yyy
-NOTICE:  f_leak => zzz
- id  | a |  b  
------+---+-----
- 101 | 1 | aba
- 102 | 2 | bbb
- 103 | 3 | ccc
- 104 | 4 | dad
- 201 | 1 | abc
- 202 | 2 | bcd
- 203 | 3 | cde
- 204 | 4 | def
- 301 | 1 | xxx
- 302 | 2 | yyy
- 303 | 3 | zzz
-(11 rows)
-
-EXPLAIN (COSTS OFF) SELECT * FROM t1 WHERE f_leak(b);
-        QUERY PLAN         
----------------------------
- Append
-   ->  Seq Scan on t1 t1_1
-         Filter: f_leak(b)
-   ->  Seq Scan on t2 t1_2
-         Filter: f_leak(b)
-   ->  Seq Scan on t3 t1_3
-         Filter: f_leak(b)
-(7 rows)
-
--- non-superuser with bypass privilege can bypass RLS policy when disabled
-SET SESSION AUTHORIZATION regress_rls_exempt_user;
-SET row_security TO OFF;
-SELECT * FROM t1 WHERE f_leak(b);
-NOTICE:  f_leak => aba
-NOTICE:  f_leak => bbb
-NOTICE:  f_leak => ccc
-NOTICE:  f_leak => dad
-NOTICE:  f_leak => abc
-NOTICE:  f_leak => bcd
-NOTICE:  f_leak => cde
-NOTICE:  f_leak => def
-NOTICE:  f_leak => xxx
-NOTICE:  f_leak => yyy
-NOTICE:  f_leak => zzz
- id  | a |  b  
------+---+-----
- 101 | 1 | aba
- 102 | 2 | bbb
- 103 | 3 | ccc
- 104 | 4 | dad
- 201 | 1 | abc
- 202 | 2 | bcd
- 203 | 3 | cde
- 204 | 4 | def
- 301 | 1 | xxx
- 302 | 2 | yyy
- 303 | 3 | zzz
-(11 rows)
-
-EXPLAIN (COSTS OFF) SELECT * FROM t1 WHERE f_leak(b);
-        QUERY PLAN         
----------------------------
- Append
-   ->  Seq Scan on t1 t1_1
-         Filter: f_leak(b)
-   ->  Seq Scan on t2 t1_2
-         Filter: f_leak(b)
-   ->  Seq Scan on t3 t1_3
-         Filter: f_leak(b)
-(7 rows)
-
---
--- Partitioned Tables
---
-SET SESSION AUTHORIZATION regress_rls_alice;
-CREATE TABLE part_document (
-    did         int,
-    cid         int,
-    dlevel      int not null,
-    dauthor     name,
-    dtitle      text
-) PARTITION BY RANGE (cid);
-GRANT ALL ON part_document TO public;
--- Create partitions for document categories
-CREATE TABLE part_document_fiction PARTITION OF part_document FOR VALUES FROM (11) to (12);
-CREATE TABLE part_document_satire PARTITION OF part_document FOR VALUES FROM (55) to (56);
-CREATE TABLE part_document_nonfiction PARTITION OF part_document FOR VALUES FROM (99) to (100);
-GRANT ALL ON part_document_fiction TO public;
-GRANT ALL ON part_document_satire TO public;
-GRANT ALL ON part_document_nonfiction TO public;
-INSERT INTO part_document VALUES
-    ( 1, 11, 1, 'regress_rls_bob', 'my first novel'),
-    ( 2, 11, 2, 'regress_rls_bob', 'my second novel'),
-    ( 3, 99, 2, 'regress_rls_bob', 'my science textbook'),
-    ( 4, 55, 1, 'regress_rls_bob', 'my first satire'),
-    ( 5, 99, 2, 'regress_rls_bob', 'my history book'),
-    ( 6, 11, 1, 'regress_rls_carol', 'great science fiction'),
-    ( 7, 99, 2, 'regress_rls_carol', 'great technology book'),
-    ( 8, 55, 2, 'regress_rls_carol', 'great satire'),
-    ( 9, 11, 1, 'regress_rls_dave', 'awesome science fiction'),
-    (10, 99, 2, 'regress_rls_dave', 'awesome technology book');
-ALTER TABLE part_document ENABLE ROW LEVEL SECURITY;
--- Create policy on parent
--- user's security level must be higher than or equal to document's
-CREATE POLICY pp1 ON part_document AS PERMISSIVE
-    USING (dlevel <= (SELECT seclv FROM uaccount WHERE pguser = current_user));
--- Dave is only allowed to see cid < 55
-CREATE POLICY pp1r ON part_document AS RESTRICTIVE TO regress_rls_dave
-    USING (cid < 55);
-\d+ part_document
-                    Partitioned table "regress_rls_schema.part_document"
- Column  |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
----------+---------+-----------+----------+---------+----------+--------------+-------------
- did     | integer |           |          |         | plain    |              | 
- cid     | integer |           |          |         | plain    |              | 
- dlevel  | integer |           | not null |         | plain    |              | 
- dauthor | name    |           |          |         | plain    |              | 
- dtitle  | text    |           |          |         | extended |              | 
-Partition key: RANGE (cid)
-Policies:
-    POLICY "pp1"
-      USING ((dlevel <= ( SELECT uaccount.seclv
-   FROM uaccount
-  WHERE (uaccount.pguser = CURRENT_USER))))
-    POLICY "pp1r" AS RESTRICTIVE
-      TO regress_rls_dave
-      USING ((cid < 55))
-Partitions: part_document_fiction FOR VALUES FROM (11) TO (12),
-            part_document_nonfiction FOR VALUES FROM (99) TO (100),
-            part_document_satire FOR VALUES FROM (55) TO (56)
-
-SELECT * FROM pg_policies WHERE schemaname = 'regress_rls_schema' AND tablename like '%part_document%' ORDER BY policyname;
-     schemaname     |   tablename   | policyname | permissive  |       roles        | cmd |                    qual                    | with_check 
---------------------+---------------+------------+-------------+--------------------+-----+--------------------------------------------+------------
- regress_rls_schema | part_document | pp1        | PERMISSIVE  | {public}           | ALL | (dlevel <= ( SELECT uaccount.seclv        +| 
-                    |               |            |             |                    |     |    FROM uaccount                          +| 
-                    |               |            |             |                    |     |   WHERE (uaccount.pguser = CURRENT_USER))) | 
- regress_rls_schema | part_document | pp1r       | RESTRICTIVE | {regress_rls_dave} | ALL | (cid < 55)                                 | 
-(2 rows)
-
--- viewpoint from regress_rls_bob
-SET SESSION AUTHORIZATION regress_rls_bob;
-SET row_security TO ON;
-SELECT * FROM part_document WHERE f_leak(dtitle) ORDER BY did;
-NOTICE:  f_leak => my first novel
-NOTICE:  f_leak => great science fiction
-NOTICE:  f_leak => awesome science fiction
-NOTICE:  f_leak => my first satire
- did | cid | dlevel |      dauthor      |         dtitle          
------+-----+--------+-------------------+-------------------------
-   1 |  11 |      1 | regress_rls_bob   | my first novel
-   4 |  55 |      1 | regress_rls_bob   | my first satire
-   6 |  11 |      1 | regress_rls_carol | great science fiction
-   9 |  11 |      1 | regress_rls_dave  | awesome science fiction
-(4 rows)
-
-EXPLAIN (COSTS OFF) SELECT * FROM part_document WHERE f_leak(dtitle);
-                         QUERY PLAN                         
-------------------------------------------------------------
- Append
-   InitPlan 1 (returns $0)
-     ->  Index Scan using uaccount_pkey on uaccount
-           Index Cond: (pguser = CURRENT_USER)
-   ->  Seq Scan on part_document_fiction part_document_1
-         Filter: ((dlevel <= $0) AND f_leak(dtitle))
-   ->  Seq Scan on part_document_satire part_document_2
-         Filter: ((dlevel <= $0) AND f_leak(dtitle))
-   ->  Seq Scan on part_document_nonfiction part_document_3
-         Filter: ((dlevel <= $0) AND f_leak(dtitle))
-(10 rows)
-
--- viewpoint from regress_rls_carol
-SET SESSION AUTHORIZATION regress_rls_carol;
-SELECT * FROM part_document WHERE f_leak(dtitle) ORDER BY did;
-NOTICE:  f_leak => my first novel
-NOTICE:  f_leak => my second novel
-NOTICE:  f_leak => great science fiction
-NOTICE:  f_leak => awesome science fiction
-NOTICE:  f_leak => my first satire
-NOTICE:  f_leak => great satire
-NOTICE:  f_leak => my science textbook
-NOTICE:  f_leak => my history book
-NOTICE:  f_leak => great technology book
-NOTICE:  f_leak => awesome technology book
- did | cid | dlevel |      dauthor      |         dtitle          
------+-----+--------+-------------------+-------------------------
-   1 |  11 |      1 | regress_rls_bob   | my first novel
-   2 |  11 |      2 | regress_rls_bob   | my second novel
-   3 |  99 |      2 | regress_rls_bob   | my science textbook
-   4 |  55 |      1 | regress_rls_bob   | my first satire
-   5 |  99 |      2 | regress_rls_bob   | my history book
-   6 |  11 |      1 | regress_rls_carol | great science fiction
-   7 |  99 |      2 | regress_rls_carol | great technology book
-   8 |  55 |      2 | regress_rls_carol | great satire
-   9 |  11 |      1 | regress_rls_dave  | awesome science fiction
-  10 |  99 |      2 | regress_rls_dave  | awesome technology book
-(10 rows)
-
-EXPLAIN (COSTS OFF) SELECT * FROM part_document WHERE f_leak(dtitle);
-                         QUERY PLAN                         
-------------------------------------------------------------
- Append
-   InitPlan 1 (returns $0)
-     ->  Index Scan using uaccount_pkey on uaccount
-           Index Cond: (pguser = CURRENT_USER)
-   ->  Seq Scan on part_document_fiction part_document_1
-         Filter: ((dlevel <= $0) AND f_leak(dtitle))
-   ->  Seq Scan on part_document_satire part_document_2
-         Filter: ((dlevel <= $0) AND f_leak(dtitle))
-   ->  Seq Scan on part_document_nonfiction part_document_3
-         Filter: ((dlevel <= $0) AND f_leak(dtitle))
-(10 rows)
-
--- viewpoint from regress_rls_dave
-SET SESSION AUTHORIZATION regress_rls_dave;
-SELECT * FROM part_document WHERE f_leak(dtitle) ORDER BY did;
-NOTICE:  f_leak => my first novel
-NOTICE:  f_leak => my second novel
-NOTICE:  f_leak => great science fiction
-NOTICE:  f_leak => awesome science fiction
- did | cid | dlevel |      dauthor      |         dtitle          
------+-----+--------+-------------------+-------------------------
-   1 |  11 |      1 | regress_rls_bob   | my first novel
-   2 |  11 |      2 | regress_rls_bob   | my second novel
-   6 |  11 |      1 | regress_rls_carol | great science fiction
-   9 |  11 |      1 | regress_rls_dave  | awesome science fiction
-(4 rows)
-
-EXPLAIN (COSTS OFF) SELECT * FROM part_document WHERE f_leak(dtitle);
-                          QUERY PLAN                          
---------------------------------------------------------------
- Seq Scan on part_document_fiction part_document
-   Filter: ((cid < 55) AND (dlevel <= $0) AND f_leak(dtitle))
-   InitPlan 1 (returns $0)
-     ->  Index Scan using uaccount_pkey on uaccount
-           Index Cond: (pguser = CURRENT_USER)
-(5 rows)
-
--- pp1 ERROR
-INSERT INTO part_document VALUES (100, 11, 5, 'regress_rls_dave', 'testing pp1'); -- fail
-ERROR:  new row violates row-level security policy for table "part_document"
--- pp1r ERROR
-INSERT INTO part_document VALUES (100, 99, 1, 'regress_rls_dave', 'testing pp1r'); -- fail
-ERROR:  new row violates row-level security policy "pp1r" for table "part_document"
--- Show that RLS policy does not apply for direct inserts to children
--- This should fail with RLS POLICY pp1r violation.
-INSERT INTO part_document VALUES (100, 55, 1, 'regress_rls_dave', 'testing RLS with partitions'); -- fail
-ERROR:  new row violates row-level security policy "pp1r" for table "part_document"
--- But this should succeed.
-INSERT INTO part_document_satire VALUES (100, 55, 1, 'regress_rls_dave', 'testing RLS with partitions'); -- success
--- We still cannot see the row using the parent
-SELECT * FROM part_document WHERE f_leak(dtitle) ORDER BY did;
-NOTICE:  f_leak => my first novel
-NOTICE:  f_leak => my second novel
-NOTICE:  f_leak => great science fiction
-NOTICE:  f_leak => awesome science fiction
- did | cid | dlevel |      dauthor      |         dtitle          
------+-----+--------+-------------------+-------------------------
-   1 |  11 |      1 | regress_rls_bob   | my first novel
-   2 |  11 |      2 | regress_rls_bob   | my second novel
-   6 |  11 |      1 | regress_rls_carol | great science fiction
-   9 |  11 |      1 | regress_rls_dave  | awesome science fiction
-(4 rows)
-
--- But we can if we look directly
-SELECT * FROM part_document_satire WHERE f_leak(dtitle) ORDER BY did;
-NOTICE:  f_leak => my first satire
-NOTICE:  f_leak => great satire
-NOTICE:  f_leak => testing RLS with partitions
- did | cid | dlevel |      dauthor      |           dtitle            
------+-----+--------+-------------------+-----------------------------
-   4 |  55 |      1 | regress_rls_bob   | my first satire
-   8 |  55 |      2 | regress_rls_carol | great satire
- 100 |  55 |      1 | regress_rls_dave  | testing RLS with partitions
-(3 rows)
-
--- Turn on RLS and create policy on child to show RLS is checked before constraints
-SET SESSION AUTHORIZATION regress_rls_alice;
-ALTER TABLE part_document_satire ENABLE ROW LEVEL SECURITY;
-CREATE POLICY pp3 ON part_document_satire AS RESTRICTIVE
-    USING (cid < 55);
--- This should fail with RLS violation now.
-SET SESSION AUTHORIZATION regress_rls_dave;
-INSERT INTO part_document_satire VALUES (101, 55, 1, 'regress_rls_dave', 'testing RLS with partitions'); -- fail
-ERROR:  new row violates row-level security policy for table "part_document_satire"
--- And now we cannot see directly into the partition either, due to RLS
-SELECT * FROM part_document_satire WHERE f_leak(dtitle) ORDER BY did;
- did | cid | dlevel | dauthor | dtitle 
------+-----+--------+---------+--------
-(0 rows)
-
--- The parent looks same as before
--- viewpoint from regress_rls_dave
-SELECT * FROM part_document WHERE f_leak(dtitle) ORDER BY did;
-NOTICE:  f_leak => my first novel
-NOTICE:  f_leak => my second novel
-NOTICE:  f_leak => great science fiction
-NOTICE:  f_leak => awesome science fiction
- did | cid | dlevel |      dauthor      |         dtitle          
------+-----+--------+-------------------+-------------------------
-   1 |  11 |      1 | regress_rls_bob   | my first novel
-   2 |  11 |      2 | regress_rls_bob   | my second novel
-   6 |  11 |      1 | regress_rls_carol | great science fiction
-   9 |  11 |      1 | regress_rls_dave  | awesome science fiction
-(4 rows)
-
-EXPLAIN (COSTS OFF) SELECT * FROM part_document WHERE f_leak(dtitle);
-                          QUERY PLAN                          
---------------------------------------------------------------
- Seq Scan on part_document_fiction part_document
-   Filter: ((cid < 55) AND (dlevel <= $0) AND f_leak(dtitle))
-   InitPlan 1 (returns $0)
-     ->  Index Scan using uaccount_pkey on uaccount
-           Index Cond: (pguser = CURRENT_USER)
-(5 rows)
-
--- viewpoint from regress_rls_carol
-SET SESSION AUTHORIZATION regress_rls_carol;
-SELECT * FROM part_document WHERE f_leak(dtitle) ORDER BY did;
-NOTICE:  f_leak => my first novel
-NOTICE:  f_leak => my second novel
-NOTICE:  f_leak => great science fiction
-NOTICE:  f_leak => awesome science fiction
-NOTICE:  f_leak => my first satire
-NOTICE:  f_leak => great satire
-NOTICE:  f_leak => testing RLS with partitions
-NOTICE:  f_leak => my science textbook
-NOTICE:  f_leak => my history book
-NOTICE:  f_leak => great technology book
-NOTICE:  f_leak => awesome technology book
- did | cid | dlevel |      dauthor      |           dtitle            
------+-----+--------+-------------------+-----------------------------
-   1 |  11 |      1 | regress_rls_bob   | my first novel
-   2 |  11 |      2 | regress_rls_bob   | my second novel
-   3 |  99 |      2 | regress_rls_bob   | my science textbook
-   4 |  55 |      1 | regress_rls_bob   | my first satire
-   5 |  99 |      2 | regress_rls_bob   | my history book
-   6 |  11 |      1 | regress_rls_carol | great science fiction
-   7 |  99 |      2 | regress_rls_carol | great technology book
-   8 |  55 |      2 | regress_rls_carol | great satire
-   9 |  11 |      1 | regress_rls_dave  | awesome science fiction
-  10 |  99 |      2 | regress_rls_dave  | awesome technology book
- 100 |  55 |      1 | regress_rls_dave  | testing RLS with partitions
-(11 rows)
-
-EXPLAIN (COSTS OFF) SELECT * FROM part_document WHERE f_leak(dtitle);
-                         QUERY PLAN                         
-------------------------------------------------------------
- Append
-   InitPlan 1 (returns $0)
-     ->  Index Scan using uaccount_pkey on uaccount
-           Index Cond: (pguser = CURRENT_USER)
-   ->  Seq Scan on part_document_fiction part_document_1
-         Filter: ((dlevel <= $0) AND f_leak(dtitle))
-   ->  Seq Scan on part_document_satire part_document_2
-         Filter: ((dlevel <= $0) AND f_leak(dtitle))
-   ->  Seq Scan on part_document_nonfiction part_document_3
-         Filter: ((dlevel <= $0) AND f_leak(dtitle))
-(10 rows)
-
--- only owner can change policies
-ALTER POLICY pp1 ON part_document USING (true);    --fail
-ERROR:  must be owner of table part_document
-DROP POLICY pp1 ON part_document;                  --fail
-ERROR:  must be owner of relation part_document
-SET SESSION AUTHORIZATION regress_rls_alice;
-ALTER POLICY pp1 ON part_document USING (dauthor = current_user);
--- viewpoint from regress_rls_bob again
-SET SESSION AUTHORIZATION regress_rls_bob;
-SELECT * FROM part_document WHERE f_leak(dtitle) ORDER BY did;
-NOTICE:  f_leak => my first novel
-NOTICE:  f_leak => my second novel
-NOTICE:  f_leak => my first satire
-NOTICE:  f_leak => my science textbook
-NOTICE:  f_leak => my history book
- did | cid | dlevel |     dauthor     |       dtitle        
------+-----+--------+-----------------+---------------------
-   1 |  11 |      1 | regress_rls_bob | my first novel
-   2 |  11 |      2 | regress_rls_bob | my second novel
-   3 |  99 |      2 | regress_rls_bob | my science textbook
-   4 |  55 |      1 | regress_rls_bob | my first satire
-   5 |  99 |      2 | regress_rls_bob | my history book
-(5 rows)
-
--- viewpoint from rls_regres_carol again
-SET SESSION AUTHORIZATION regress_rls_carol;
-SELECT * FROM part_document WHERE f_leak(dtitle) ORDER BY did;
-NOTICE:  f_leak => great science fiction
-NOTICE:  f_leak => great satire
-NOTICE:  f_leak => great technology book
- did | cid | dlevel |      dauthor      |        dtitle         
------+-----+--------+-------------------+-----------------------
-   6 |  11 |      1 | regress_rls_carol | great science fiction
-   7 |  99 |      2 | regress_rls_carol | great technology book
-   8 |  55 |      2 | regress_rls_carol | great satire
-(3 rows)
-
-EXPLAIN (COSTS OFF) SELECT * FROM part_document WHERE f_leak(dtitle);
-                          QUERY PLAN                           
----------------------------------------------------------------
- Append
-   ->  Seq Scan on part_document_fiction part_document_1
-         Filter: ((dauthor = CURRENT_USER) AND f_leak(dtitle))
-   ->  Seq Scan on part_document_satire part_document_2
-         Filter: ((dauthor = CURRENT_USER) AND f_leak(dtitle))
-   ->  Seq Scan on part_document_nonfiction part_document_3
-         Filter: ((dauthor = CURRENT_USER) AND f_leak(dtitle))
-(7 rows)
-
--- database superuser does bypass RLS policy when enabled
-RESET SESSION AUTHORIZATION;
-SET row_security TO ON;
-SELECT * FROM part_document ORDER BY did;
- did | cid | dlevel |      dauthor      |           dtitle            
------+-----+--------+-------------------+-----------------------------
-   1 |  11 |      1 | regress_rls_bob   | my first novel
-   2 |  11 |      2 | regress_rls_bob   | my second novel
-   3 |  99 |      2 | regress_rls_bob   | my science textbook
-   4 |  55 |      1 | regress_rls_bob   | my first satire
-   5 |  99 |      2 | regress_rls_bob   | my history book
-   6 |  11 |      1 | regress_rls_carol | great science fiction
-   7 |  99 |      2 | regress_rls_carol | great technology book
-   8 |  55 |      2 | regress_rls_carol | great satire
-   9 |  11 |      1 | regress_rls_dave  | awesome science fiction
-  10 |  99 |      2 | regress_rls_dave  | awesome technology book
- 100 |  55 |      1 | regress_rls_dave  | testing RLS with partitions
-(11 rows)
-
-SELECT * FROM part_document_satire ORDER by did;
- did | cid | dlevel |      dauthor      |           dtitle            
------+-----+--------+-------------------+-----------------------------
-   4 |  55 |      1 | regress_rls_bob   | my first satire
-   8 |  55 |      2 | regress_rls_carol | great satire
- 100 |  55 |      1 | regress_rls_dave  | testing RLS with partitions
-(3 rows)
-
--- database non-superuser with bypass privilege can bypass RLS policy when disabled
-SET SESSION AUTHORIZATION regress_rls_exempt_user;
-SET row_security TO OFF;
-SELECT * FROM part_document ORDER BY did;
- did | cid | dlevel |      dauthor      |           dtitle            
------+-----+--------+-------------------+-----------------------------
-   1 |  11 |      1 | regress_rls_bob   | my first novel
-   2 |  11 |      2 | regress_rls_bob   | my second novel
-   3 |  99 |      2 | regress_rls_bob   | my science textbook
-   4 |  55 |      1 | regress_rls_bob   | my first satire
-   5 |  99 |      2 | regress_rls_bob   | my history book
-   6 |  11 |      1 | regress_rls_carol | great science fiction
-   7 |  99 |      2 | regress_rls_carol | great technology book
-   8 |  55 |      2 | regress_rls_carol | great satire
-   9 |  11 |      1 | regress_rls_dave  | awesome science fiction
-  10 |  99 |      2 | regress_rls_dave  | awesome technology book
- 100 |  55 |      1 | regress_rls_dave  | testing RLS with partitions
-(11 rows)
-
-SELECT * FROM part_document_satire ORDER by did;
- did | cid | dlevel |      dauthor      |           dtitle            
------+-----+--------+-------------------+-----------------------------
-   4 |  55 |      1 | regress_rls_bob   | my first satire
-   8 |  55 |      2 | regress_rls_carol | great satire
- 100 |  55 |      1 | regress_rls_dave  | testing RLS with partitions
-(3 rows)
-
--- RLS policy does not apply to table owner when RLS enabled.
-SET SESSION AUTHORIZATION regress_rls_alice;
-SET row_security TO ON;
-SELECT * FROM part_document ORDER by did;
- did | cid | dlevel |      dauthor      |           dtitle            
------+-----+--------+-------------------+-----------------------------
-   1 |  11 |      1 | regress_rls_bob   | my first novel
-   2 |  11 |      2 | regress_rls_bob   | my second novel
-   3 |  99 |      2 | regress_rls_bob   | my science textbook
-   4 |  55 |      1 | regress_rls_bob   | my first satire
-   5 |  99 |      2 | regress_rls_bob   | my history book
-   6 |  11 |      1 | regress_rls_carol | great science fiction
-   7 |  99 |      2 | regress_rls_carol | great technology book
-   8 |  55 |      2 | regress_rls_carol | great satire
-   9 |  11 |      1 | regress_rls_dave  | awesome science fiction
-  10 |  99 |      2 | regress_rls_dave  | awesome technology book
- 100 |  55 |      1 | regress_rls_dave  | testing RLS with partitions
-(11 rows)
-
-SELECT * FROM part_document_satire ORDER by did;
- did | cid | dlevel |      dauthor      |           dtitle            
------+-----+--------+-------------------+-----------------------------
-   4 |  55 |      1 | regress_rls_bob   | my first satire
-   8 |  55 |      2 | regress_rls_carol | great satire
- 100 |  55 |      1 | regress_rls_dave  | testing RLS with partitions
-(3 rows)
-
--- When RLS disabled, other users get ERROR.
-SET SESSION AUTHORIZATION regress_rls_dave;
-SET row_security TO OFF;
-SELECT * FROM part_document ORDER by did;
-ERROR:  query would be affected by row-level security policy for table "part_document"
-SELECT * FROM part_document_satire ORDER by did;
-ERROR:  query would be affected by row-level security policy for table "part_document_satire"
--- Check behavior with a policy that uses a SubPlan not an InitPlan.
-SET SESSION AUTHORIZATION regress_rls_alice;
-SET row_security TO ON;
-CREATE POLICY pp3 ON part_document AS RESTRICTIVE
-    USING ((SELECT dlevel <= seclv FROM uaccount WHERE pguser = current_user));
-SET SESSION AUTHORIZATION regress_rls_carol;
-INSERT INTO part_document VALUES (100, 11, 5, 'regress_rls_carol', 'testing pp3'); -- fail
-ERROR:  new row violates row-level security policy "pp3" for table "part_document"
------ Dependencies -----
-SET SESSION AUTHORIZATION regress_rls_alice;
-SET row_security TO ON;
-CREATE TABLE dependee (x integer, y integer);
-CREATE TABLE dependent (x integer, y integer);
-CREATE POLICY d1 ON dependent FOR ALL
-    TO PUBLIC
-    USING (x = (SELECT d.x FROM dependee d WHERE d.y = y));
-DROP TABLE dependee; -- Should fail without CASCADE due to dependency on row security qual?
-ERROR:  cannot drop table dependee because other objects depend on it
-DETAIL:  policy d1 on table dependent depends on table dependee
-HINT:  Use DROP ... CASCADE to drop the dependent objects too.
-DROP TABLE dependee CASCADE;
-NOTICE:  drop cascades to policy d1 on table dependent
-EXPLAIN (COSTS OFF) SELECT * FROM dependent; -- After drop, should be unqualified
-      QUERY PLAN       
------------------------
- Seq Scan on dependent
-(1 row)
-
------   RECURSION    ----
---
--- Simple recursion
---
-SET SESSION AUTHORIZATION regress_rls_alice;
-CREATE TABLE rec1 (x integer, y integer);
-CREATE POLICY r1 ON rec1 USING (x = (SELECT r.x FROM rec1 r WHERE y = r.y));
-ALTER TABLE rec1 ENABLE ROW LEVEL SECURITY;
-SET SESSION AUTHORIZATION regress_rls_bob;
-SELECT * FROM rec1; -- fail, direct recursion
-ERROR:  infinite recursion detected in policy for relation "rec1"
---
--- Mutual recursion
---
-SET SESSION AUTHORIZATION regress_rls_alice;
-CREATE TABLE rec2 (a integer, b integer);
-ALTER POLICY r1 ON rec1 USING (x = (SELECT a FROM rec2 WHERE b = y));
-CREATE POLICY r2 ON rec2 USING (a = (SELECT x FROM rec1 WHERE y = b));
-ALTER TABLE rec2 ENABLE ROW LEVEL SECURITY;
-SET SESSION AUTHORIZATION regress_rls_bob;
-SELECT * FROM rec1;    -- fail, mutual recursion
-ERROR:  infinite recursion detected in policy for relation "rec1"
---
--- Mutual recursion via views
---
-SET SESSION AUTHORIZATION regress_rls_bob;
-CREATE VIEW rec1v AS SELECT * FROM rec1;
-CREATE VIEW rec2v AS SELECT * FROM rec2;
-SET SESSION AUTHORIZATION regress_rls_alice;
-ALTER POLICY r1 ON rec1 USING (x = (SELECT a FROM rec2v WHERE b = y));
-ALTER POLICY r2 ON rec2 USING (a = (SELECT x FROM rec1v WHERE y = b));
-SET SESSION AUTHORIZATION regress_rls_bob;
-SELECT * FROM rec1;    -- fail, mutual recursion via views
-ERROR:  infinite recursion detected in policy for relation "rec1"
---
--- Mutual recursion via .s.b views
---
-SET SESSION AUTHORIZATION regress_rls_bob;
-DROP VIEW rec1v, rec2v CASCADE;
-NOTICE:  drop cascades to 2 other objects
-DETAIL:  drop cascades to policy r1 on table rec1
-drop cascades to policy r2 on table rec2
-CREATE VIEW rec1v WITH (security_barrier) AS SELECT * FROM rec1;
-CREATE VIEW rec2v WITH (security_barrier) AS SELECT * FROM rec2;
-SET SESSION AUTHORIZATION regress_rls_alice;
-CREATE POLICY r1 ON rec1 USING (x = (SELECT a FROM rec2v WHERE b = y));
-CREATE POLICY r2 ON rec2 USING (a = (SELECT x FROM rec1v WHERE y = b));
-SET SESSION AUTHORIZATION regress_rls_bob;
-SELECT * FROM rec1;    -- fail, mutual recursion via s.b. views
-ERROR:  infinite recursion detected in policy for relation "rec1"
---
--- recursive RLS and VIEWs in policy
---
-SET SESSION AUTHORIZATION regress_rls_alice;
-CREATE TABLE s1 (a int, b text);
-INSERT INTO s1 (SELECT x, md5(x::text) FROM generate_series(-10,10) x);
-CREATE TABLE s2 (x int, y text);
-INSERT INTO s2 (SELECT x, md5(x::text) FROM generate_series(-6,6) x);
-GRANT SELECT ON s1, s2 TO regress_rls_bob;
-CREATE POLICY p1 ON s1 USING (a in (select x from s2 where y like '%2f%'));
-CREATE POLICY p2 ON s2 USING (x in (select a from s1 where b like '%22%'));
-CREATE POLICY p3 ON s1 FOR INSERT WITH CHECK (a = (SELECT a FROM s1));
-ALTER TABLE s1 ENABLE ROW LEVEL SECURITY;
-ALTER TABLE s2 ENABLE ROW LEVEL SECURITY;
-SET SESSION AUTHORIZATION regress_rls_bob;
-CREATE VIEW v2 AS SELECT * FROM s2 WHERE y like '%af%';
-SELECT * FROM s1 WHERE f_leak(b); -- fail (infinite recursion)
-ERROR:  infinite recursion detected in policy for relation "s1"
-INSERT INTO s1 VALUES (1, 'foo'); -- fail (infinite recursion)
-ERROR:  infinite recursion detected in policy for relation "s1"
-SET SESSION AUTHORIZATION regress_rls_alice;
-DROP POLICY p3 on s1;
-ALTER POLICY p2 ON s2 USING (x % 2 = 0);
-SET SESSION AUTHORIZATION regress_rls_bob;
-SELECT * FROM s1 WHERE f_leak(b);	-- OK
-NOTICE:  f_leak => c81e728d9d4c2f636f067f89cc14862c
-NOTICE:  f_leak => a87ff679a2f3e71d9181a67b7542122c
- a |                b                 
----+----------------------------------
- 2 | c81e728d9d4c2f636f067f89cc14862c
- 4 | a87ff679a2f3e71d9181a67b7542122c
-(2 rows)
-
-EXPLAIN (COSTS OFF) SELECT * FROM only s1 WHERE f_leak(b);
-                        QUERY PLAN                         
------------------------------------------------------------
- Seq Scan on s1
-   Filter: ((hashed SubPlan 1) AND f_leak(b))
-   SubPlan 1
-     ->  Seq Scan on s2
-           Filter: (((x % 2) = 0) AND (y ~~ '%2f%'::text))
-(5 rows)
-
-SET SESSION AUTHORIZATION regress_rls_alice;
-ALTER POLICY p1 ON s1 USING (a in (select x from v2)); -- using VIEW in RLS policy
-SET SESSION AUTHORIZATION regress_rls_bob;
-SELECT * FROM s1 WHERE f_leak(b);	-- OK
-NOTICE:  f_leak => 0267aaf632e87a63288a08331f22c7c3
-NOTICE:  f_leak => 1679091c5a880faf6fb5e6087eb1b2dc
- a  |                b                 
-----+----------------------------------
- -4 | 0267aaf632e87a63288a08331f22c7c3
-  6 | 1679091c5a880faf6fb5e6087eb1b2dc
-(2 rows)
-
-EXPLAIN (COSTS OFF) SELECT * FROM s1 WHERE f_leak(b);
-                        QUERY PLAN                         
------------------------------------------------------------
- Seq Scan on s1
-   Filter: ((hashed SubPlan 1) AND f_leak(b))
-   SubPlan 1
-     ->  Seq Scan on s2
-           Filter: (((x % 2) = 0) AND (y ~~ '%af%'::text))
-(5 rows)
-
-SELECT (SELECT x FROM s1 LIMIT 1) xx, * FROM s2 WHERE y like '%28%';
- xx | x  |                y                 
-----+----+----------------------------------
- -6 | -6 | 596a3d04481816330f07e4f97510c28f
- -4 | -4 | 0267aaf632e87a63288a08331f22c7c3
-  2 |  2 | c81e728d9d4c2f636f067f89cc14862c
-(3 rows)
-
-EXPLAIN (COSTS OFF) SELECT (SELECT x FROM s1 LIMIT 1) xx, * FROM s2 WHERE y like '%28%';
-                               QUERY PLAN                                
--------------------------------------------------------------------------
- Seq Scan on s2
-   Filter: (((x % 2) = 0) AND (y ~~ '%28%'::text))
-   SubPlan 2
-     ->  Limit
-           ->  Seq Scan on s1
-                 Filter: (hashed SubPlan 1)
-                 SubPlan 1
-                   ->  Seq Scan on s2 s2_1
-                         Filter: (((x % 2) = 0) AND (y ~~ '%af%'::text))
-(9 rows)
-
-SET SESSION AUTHORIZATION regress_rls_alice;
-ALTER POLICY p2 ON s2 USING (x in (select a from s1 where b like '%d2%'));
-SET SESSION AUTHORIZATION regress_rls_bob;
-SELECT * FROM s1 WHERE f_leak(b);	-- fail (infinite recursion via view)
-ERROR:  infinite recursion detected in policy for relation "s1"
--- prepared statement with regress_rls_alice privilege
-PREPARE p1(int) AS SELECT * FROM t1 WHERE a <= $1;
-EXECUTE p1(2);
- id  | a |  b  
------+---+-----
- 102 | 2 | bbb
- 202 | 2 | bcd
- 302 | 2 | yyy
-(3 rows)
-
-EXPLAIN (COSTS OFF) EXECUTE p1(2);
-                  QUERY PLAN                  
-----------------------------------------------
- Append
-   ->  Seq Scan on t1 t1_1
-         Filter: ((a <= 2) AND ((a % 2) = 0))
-   ->  Seq Scan on t2 t1_2
-         Filter: ((a <= 2) AND ((a % 2) = 0))
-   ->  Seq Scan on t3 t1_3
-         Filter: ((a <= 2) AND ((a % 2) = 0))
-(7 rows)
-
--- superuser is allowed to bypass RLS checks
-RESET SESSION AUTHORIZATION;
-SET row_security TO OFF;
-SELECT * FROM t1 WHERE f_leak(b);
-NOTICE:  f_leak => aba
-NOTICE:  f_leak => bbb
-NOTICE:  f_leak => ccc
-NOTICE:  f_leak => dad
-NOTICE:  f_leak => abc
-NOTICE:  f_leak => bcd
-NOTICE:  f_leak => cde
-NOTICE:  f_leak => def
-NOTICE:  f_leak => xxx
-NOTICE:  f_leak => yyy
-NOTICE:  f_leak => zzz
- id  | a |  b  
------+---+-----
- 101 | 1 | aba
- 102 | 2 | bbb
- 103 | 3 | ccc
- 104 | 4 | dad
- 201 | 1 | abc
- 202 | 2 | bcd
- 203 | 3 | cde
- 204 | 4 | def
- 301 | 1 | xxx
- 302 | 2 | yyy
- 303 | 3 | zzz
-(11 rows)
-
-EXPLAIN (COSTS OFF) SELECT * FROM t1 WHERE f_leak(b);
-        QUERY PLAN         
----------------------------
- Append
-   ->  Seq Scan on t1 t1_1
-         Filter: f_leak(b)
-   ->  Seq Scan on t2 t1_2
-         Filter: f_leak(b)
-   ->  Seq Scan on t3 t1_3
-         Filter: f_leak(b)
-(7 rows)
-
--- plan cache should be invalidated
-EXECUTE p1(2);
- id  | a |  b  
------+---+-----
- 101 | 1 | aba
- 102 | 2 | bbb
- 201 | 1 | abc
- 202 | 2 | bcd
- 301 | 1 | xxx
- 302 | 2 | yyy
-(6 rows)
-
-EXPLAIN (COSTS OFF) EXECUTE p1(2);
-        QUERY PLAN         
----------------------------
- Append
-   ->  Seq Scan on t1 t1_1
-         Filter: (a <= 2)
-   ->  Seq Scan on t2 t1_2
-         Filter: (a <= 2)
-   ->  Seq Scan on t3 t1_3
-         Filter: (a <= 2)
-(7 rows)
-
-PREPARE p2(int) AS SELECT * FROM t1 WHERE a = $1;
-EXECUTE p2(2);
- id  | a |  b  
------+---+-----
- 102 | 2 | bbb
- 202 | 2 | bcd
- 302 | 2 | yyy
-(3 rows)
-
-EXPLAIN (COSTS OFF) EXECUTE p2(2);
-        QUERY PLAN         
----------------------------
- Append
-   ->  Seq Scan on t1 t1_1
-         Filter: (a = 2)
-   ->  Seq Scan on t2 t1_2
-         Filter: (a = 2)
-   ->  Seq Scan on t3 t1_3
-         Filter: (a = 2)
-(7 rows)
-
--- also, case when privilege switch from superuser
-SET SESSION AUTHORIZATION regress_rls_bob;
-SET row_security TO ON;
-EXECUTE p2(2);
- id  | a |  b  
------+---+-----
- 102 | 2 | bbb
- 202 | 2 | bcd
- 302 | 2 | yyy
-(3 rows)
-
-EXPLAIN (COSTS OFF) EXECUTE p2(2);
-                 QUERY PLAN                  
----------------------------------------------
- Append
-   ->  Seq Scan on t1 t1_1
-         Filter: ((a = 2) AND ((a % 2) = 0))
-   ->  Seq Scan on t2 t1_2
-         Filter: ((a = 2) AND ((a % 2) = 0))
-   ->  Seq Scan on t3 t1_3
-         Filter: ((a = 2) AND ((a % 2) = 0))
-(7 rows)
-
---
--- UPDATE / DELETE and Row-level security
---
-SET SESSION AUTHORIZATION regress_rls_bob;
-EXPLAIN (COSTS OFF) UPDATE t1 SET b = b || b WHERE f_leak(b);
-                        QUERY PLAN                         
------------------------------------------------------------
- Update on t1
-   Update on t1 t1_1
-   Update on t2 t1_2
-   Update on t3 t1_3
-   ->  Result
-         ->  Append
-               ->  Seq Scan on t1 t1_1
-                     Filter: (((a % 2) = 0) AND f_leak(b))
-               ->  Seq Scan on t2 t1_2
-                     Filter: (((a % 2) = 0) AND f_leak(b))
-               ->  Seq Scan on t3 t1_3
-                     Filter: (((a % 2) = 0) AND f_leak(b))
-(12 rows)
-
-UPDATE t1 SET b = b || b WHERE f_leak(b);
-NOTICE:  f_leak => bbb
-NOTICE:  f_leak => dad
-NOTICE:  f_leak => bcd
-NOTICE:  f_leak => def
-NOTICE:  f_leak => yyy
-EXPLAIN (COSTS OFF) UPDATE only t1 SET b = b || '_updt' WHERE f_leak(b);
-                  QUERY PLAN                   
------------------------------------------------
- Update on t1
-   ->  Seq Scan on t1
-         Filter: (((a % 2) = 0) AND f_leak(b))
-(3 rows)
-
-UPDATE only t1 SET b = b || '_updt' WHERE f_leak(b);
-NOTICE:  f_leak => bbbbbb
-NOTICE:  f_leak => daddad
--- returning clause with system column
-UPDATE only t1 SET b = b WHERE f_leak(b) RETURNING tableoid::regclass, *, t1;
-NOTICE:  f_leak => bbbbbb_updt
-NOTICE:  f_leak => daddad_updt
- tableoid | id  | a |      b      |         t1          
-----------+-----+---+-------------+---------------------
- t1       | 102 | 2 | bbbbbb_updt | (102,2,bbbbbb_updt)
- t1       | 104 | 4 | daddad_updt | (104,4,daddad_updt)
-(2 rows)
-
-UPDATE t1 SET b = b WHERE f_leak(b) RETURNING *;
-NOTICE:  f_leak => bbbbbb_updt
-NOTICE:  f_leak => daddad_updt
-NOTICE:  f_leak => bcdbcd
-NOTICE:  f_leak => defdef
-NOTICE:  f_leak => yyyyyy
- id  | a |      b      
------+---+-------------
- 102 | 2 | bbbbbb_updt
- 104 | 4 | daddad_updt
- 202 | 2 | bcdbcd
- 204 | 4 | defdef
- 302 | 2 | yyyyyy
-(5 rows)
-
-UPDATE t1 SET b = b WHERE f_leak(b) RETURNING tableoid::regclass, *, t1;
-NOTICE:  f_leak => bbbbbb_updt
-NOTICE:  f_leak => daddad_updt
-NOTICE:  f_leak => bcdbcd
-NOTICE:  f_leak => defdef
-NOTICE:  f_leak => yyyyyy
- tableoid | id  | a |      b      |         t1          
-----------+-----+---+-------------+---------------------
- t1       | 102 | 2 | bbbbbb_updt | (102,2,bbbbbb_updt)
- t1       | 104 | 4 | daddad_updt | (104,4,daddad_updt)
- t2       | 202 | 2 | bcdbcd      | (202,2,bcdbcd)
- t2       | 204 | 4 | defdef      | (204,4,defdef)
- t3       | 302 | 2 | yyyyyy      | (302,2,yyyyyy)
-(5 rows)
-
--- updates with from clause
-EXPLAIN (COSTS OFF) UPDATE t2 SET b=t2.b FROM t3
-WHERE t2.a = 3 and t3.a = 2 AND f_leak(t2.b) AND f_leak(t3.b);
-                           QUERY PLAN                            
------------------------------------------------------------------
- Update on t2
-   ->  Nested Loop
-         ->  Seq Scan on t2
-               Filter: ((a = 3) AND ((a % 2) = 1) AND f_leak(b))
-         ->  Seq Scan on t3
-               Filter: ((a = 2) AND f_leak(b))
-(6 rows)
-
-UPDATE t2 SET b=t2.b FROM t3
-WHERE t2.a = 3 and t3.a = 2 AND f_leak(t2.b) AND f_leak(t3.b);
-NOTICE:  f_leak => cde
-NOTICE:  f_leak => yyyyyy
-EXPLAIN (COSTS OFF) UPDATE t1 SET b=t1.b FROM t2
-WHERE t1.a = 3 and t2.a = 3 AND f_leak(t1.b) AND f_leak(t2.b);
-                              QUERY PLAN                               
------------------------------------------------------------------------
- Update on t1
-   Update on t1 t1_1
-   Update on t2 t1_2
-   Update on t3 t1_3
-   ->  Nested Loop
-         ->  Seq Scan on t2
-               Filter: ((a = 3) AND ((a % 2) = 1) AND f_leak(b))
-         ->  Append
-               ->  Seq Scan on t1 t1_1
-                     Filter: ((a = 3) AND ((a % 2) = 0) AND f_leak(b))
-               ->  Seq Scan on t2 t1_2
-                     Filter: ((a = 3) AND ((a % 2) = 0) AND f_leak(b))
-               ->  Seq Scan on t3 t1_3
-                     Filter: ((a = 3) AND ((a % 2) = 0) AND f_leak(b))
-(14 rows)
-
-UPDATE t1 SET b=t1.b FROM t2
-WHERE t1.a = 3 and t2.a = 3 AND f_leak(t1.b) AND f_leak(t2.b);
-NOTICE:  f_leak => cde
-EXPLAIN (COSTS OFF) UPDATE t2 SET b=t2.b FROM t1
-WHERE t1.a = 3 and t2.a = 3 AND f_leak(t1.b) AND f_leak(t2.b);
-                              QUERY PLAN                               
------------------------------------------------------------------------
- Update on t2
-   ->  Nested Loop
-         ->  Seq Scan on t2
-               Filter: ((a = 3) AND ((a % 2) = 1) AND f_leak(b))
-         ->  Append
-               ->  Seq Scan on t1 t1_1
-                     Filter: ((a = 3) AND ((a % 2) = 0) AND f_leak(b))
-               ->  Seq Scan on t2 t1_2
-                     Filter: ((a = 3) AND ((a % 2) = 0) AND f_leak(b))
-               ->  Seq Scan on t3 t1_3
-                     Filter: ((a = 3) AND ((a % 2) = 0) AND f_leak(b))
-(11 rows)
-
-UPDATE t2 SET b=t2.b FROM t1
-WHERE t1.a = 3 and t2.a = 3 AND f_leak(t1.b) AND f_leak(t2.b);
-NOTICE:  f_leak => cde
--- updates with from clause self join
-EXPLAIN (COSTS OFF) UPDATE t2 t2_1 SET b = t2_2.b FROM t2 t2_2
-WHERE t2_1.a = 3 AND t2_2.a = t2_1.a AND t2_2.b = t2_1.b
-AND f_leak(t2_1.b) AND f_leak(t2_2.b) RETURNING *, t2_1, t2_2;
-                           QUERY PLAN                            
------------------------------------------------------------------
- Update on t2 t2_1
-   ->  Nested Loop
-         Join Filter: (t2_1.b = t2_2.b)
-         ->  Seq Scan on t2 t2_1
-               Filter: ((a = 3) AND ((a % 2) = 1) AND f_leak(b))
-         ->  Seq Scan on t2 t2_2
-               Filter: ((a = 3) AND ((a % 2) = 1) AND f_leak(b))
-(7 rows)
-
-UPDATE t2 t2_1 SET b = t2_2.b FROM t2 t2_2
-WHERE t2_1.a = 3 AND t2_2.a = t2_1.a AND t2_2.b = t2_1.b
-AND f_leak(t2_1.b) AND f_leak(t2_2.b) RETURNING *, t2_1, t2_2;
-NOTICE:  f_leak => cde
-NOTICE:  f_leak => cde
- id  | a |  b  |  c  | id  | a |  b  |  c  |      t2_1       |      t2_2       
------+---+-----+-----+-----+---+-----+-----+-----------------+-----------------
- 203 | 3 | cde | 3.3 | 203 | 3 | cde | 3.3 | (203,3,cde,3.3) | (203,3,cde,3.3)
-(1 row)
-
-EXPLAIN (COSTS OFF) UPDATE t1 t1_1 SET b = t1_2.b FROM t1 t1_2
-WHERE t1_1.a = 4 AND t1_2.a = t1_1.a AND t1_2.b = t1_1.b
-AND f_leak(t1_1.b) AND f_leak(t1_2.b) RETURNING *, t1_1, t1_2;
-                                 QUERY PLAN                                  
------------------------------------------------------------------------------
- Update on t1 t1_1
-   Update on t1 t1_1_1
-   Update on t2 t1_1_2
-   Update on t3 t1_1_3
-   ->  Nested Loop
-         Join Filter: (t1_1.b = t1_2.b)
-         ->  Append
-               ->  Seq Scan on t1 t1_1_1
-                     Filter: ((a = 4) AND ((a % 2) = 0) AND f_leak(b))
-               ->  Seq Scan on t2 t1_1_2
-                     Filter: ((a = 4) AND ((a % 2) = 0) AND f_leak(b))
-               ->  Seq Scan on t3 t1_1_3
-                     Filter: ((a = 4) AND ((a % 2) = 0) AND f_leak(b))
-         ->  Materialize
-               ->  Append
-                     ->  Seq Scan on t1 t1_2_1
-                           Filter: ((a = 4) AND ((a % 2) = 0) AND f_leak(b))
-                     ->  Seq Scan on t2 t1_2_2
-                           Filter: ((a = 4) AND ((a % 2) = 0) AND f_leak(b))
-                     ->  Seq Scan on t3 t1_2_3
-                           Filter: ((a = 4) AND ((a % 2) = 0) AND f_leak(b))
-(21 rows)
-
-UPDATE t1 t1_1 SET b = t1_2.b FROM t1 t1_2
-WHERE t1_1.a = 4 AND t1_2.a = t1_1.a AND t1_2.b = t1_1.b
-AND f_leak(t1_1.b) AND f_leak(t1_2.b) RETURNING *, t1_1, t1_2;
-NOTICE:  f_leak => daddad_updt
-NOTICE:  f_leak => daddad_updt
-NOTICE:  f_leak => defdef
-NOTICE:  f_leak => defdef
- id  | a |      b      | id  | a |      b      |        t1_1         |        t1_2         
------+---+-------------+-----+---+-------------+---------------------+---------------------
- 104 | 4 | daddad_updt | 104 | 4 | daddad_updt | (104,4,daddad_updt) | (104,4,daddad_updt)
- 204 | 4 | defdef      | 204 | 4 | defdef      | (204,4,defdef)      | (204,4,defdef)
-(2 rows)
-
-RESET SESSION AUTHORIZATION;
-SET row_security TO OFF;
-SELECT * FROM t1 ORDER BY a,b;
- id  | a |      b      
------+---+-------------
- 101 | 1 | aba
- 201 | 1 | abc
- 301 | 1 | xxx
- 102 | 2 | bbbbbb_updt
- 202 | 2 | bcdbcd
- 302 | 2 | yyyyyy
- 103 | 3 | ccc
- 203 | 3 | cde
- 303 | 3 | zzz
- 104 | 4 | daddad_updt
- 204 | 4 | defdef
-(11 rows)
-
-SET SESSION AUTHORIZATION regress_rls_bob;
-SET row_security TO ON;
-EXPLAIN (COSTS OFF) DELETE FROM only t1 WHERE f_leak(b);
-                  QUERY PLAN                   
------------------------------------------------
- Delete on t1
-   ->  Seq Scan on t1
-         Filter: (((a % 2) = 0) AND f_leak(b))
-(3 rows)
-
-EXPLAIN (COSTS OFF) DELETE FROM t1 WHERE f_leak(b);
-                     QUERY PLAN                      
------------------------------------------------------
- Delete on t1
-   Delete on t1 t1_1
-   Delete on t2 t1_2
-   Delete on t3 t1_3
-   ->  Append
-         ->  Seq Scan on t1 t1_1
-               Filter: (((a % 2) = 0) AND f_leak(b))
-         ->  Seq Scan on t2 t1_2
-               Filter: (((a % 2) = 0) AND f_leak(b))
-         ->  Seq Scan on t3 t1_3
-               Filter: (((a % 2) = 0) AND f_leak(b))
-(11 rows)
-
-DELETE FROM only t1 WHERE f_leak(b) RETURNING tableoid::regclass, *, t1;
-NOTICE:  f_leak => bbbbbb_updt
-NOTICE:  f_leak => daddad_updt
- tableoid | id  | a |      b      |         t1          
-----------+-----+---+-------------+---------------------
- t1       | 102 | 2 | bbbbbb_updt | (102,2,bbbbbb_updt)
- t1       | 104 | 4 | daddad_updt | (104,4,daddad_updt)
-(2 rows)
-
-DELETE FROM t1 WHERE f_leak(b) RETURNING tableoid::regclass, *, t1;
-NOTICE:  f_leak => bcdbcd
-NOTICE:  f_leak => defdef
-NOTICE:  f_leak => yyyyyy
- tableoid | id  | a |   b    |       t1       
-----------+-----+---+--------+----------------
- t2       | 202 | 2 | bcdbcd | (202,2,bcdbcd)
- t2       | 204 | 4 | defdef | (204,4,defdef)
- t3       | 302 | 2 | yyyyyy | (302,2,yyyyyy)
-(3 rows)
-
---
--- S.b. view on top of Row-level security
---
-SET SESSION AUTHORIZATION regress_rls_alice;
-CREATE TABLE b1 (a int, b text);
-INSERT INTO b1 (SELECT x, md5(x::text) FROM generate_series(-10,10) x);
-CREATE POLICY p1 ON b1 USING (a % 2 = 0);
-ALTER TABLE b1 ENABLE ROW LEVEL SECURITY;
-GRANT ALL ON b1 TO regress_rls_bob;
-SET SESSION AUTHORIZATION regress_rls_bob;
-CREATE VIEW bv1 WITH (security_barrier) AS SELECT * FROM b1 WHERE a > 0 WITH CHECK OPTION;
-GRANT ALL ON bv1 TO regress_rls_carol;
-SET SESSION AUTHORIZATION regress_rls_carol;
-EXPLAIN (COSTS OFF) SELECT * FROM bv1 WHERE f_leak(b);
-                 QUERY PLAN                  
----------------------------------------------
- Subquery Scan on bv1
-   Filter: f_leak(bv1.b)
-   ->  Seq Scan on b1
-         Filter: ((a > 0) AND ((a % 2) = 0))
-(4 rows)
-
-SELECT * FROM bv1 WHERE f_leak(b);
-NOTICE:  f_leak => c81e728d9d4c2f636f067f89cc14862c
-NOTICE:  f_leak => a87ff679a2f3e71d9181a67b7542122c
-NOTICE:  f_leak => 1679091c5a880faf6fb5e6087eb1b2dc
-NOTICE:  f_leak => c9f0f895fb98ab9159f51fd0297e236d
-NOTICE:  f_leak => d3d9446802a44259755d38e6d163e820
- a  |                b                 
-----+----------------------------------
-  2 | c81e728d9d4c2f636f067f89cc14862c
-  4 | a87ff679a2f3e71d9181a67b7542122c
-  6 | 1679091c5a880faf6fb5e6087eb1b2dc
-  8 | c9f0f895fb98ab9159f51fd0297e236d
- 10 | d3d9446802a44259755d38e6d163e820
-(5 rows)
-
-INSERT INTO bv1 VALUES (-1, 'xxx'); -- should fail view WCO
-ERROR:  new row violates row-level security policy for table "b1"
-INSERT INTO bv1 VALUES (11, 'xxx'); -- should fail RLS check
-ERROR:  new row violates row-level security policy for table "b1"
-INSERT INTO bv1 VALUES (12, 'xxx'); -- ok
-EXPLAIN (COSTS OFF) UPDATE bv1 SET b = 'yyy' WHERE a = 4 AND f_leak(b);
-                              QUERY PLAN                               
------------------------------------------------------------------------
- Update on b1
-   ->  Seq Scan on b1
-         Filter: ((a > 0) AND (a = 4) AND ((a % 2) = 0) AND f_leak(b))
-(3 rows)
-
-UPDATE bv1 SET b = 'yyy' WHERE a = 4 AND f_leak(b);
-NOTICE:  f_leak => a87ff679a2f3e71d9181a67b7542122c
-EXPLAIN (COSTS OFF) DELETE FROM bv1 WHERE a = 6 AND f_leak(b);
-                              QUERY PLAN                               
------------------------------------------------------------------------
- Delete on b1
-   ->  Seq Scan on b1
-         Filter: ((a > 0) AND (a = 6) AND ((a % 2) = 0) AND f_leak(b))
-(3 rows)
-
-DELETE FROM bv1 WHERE a = 6 AND f_leak(b);
-NOTICE:  f_leak => 1679091c5a880faf6fb5e6087eb1b2dc
-SET SESSION AUTHORIZATION regress_rls_alice;
-SELECT * FROM b1;
-  a  |                b                 
------+----------------------------------
- -10 | 1b0fd9efa5279c4203b7c70233f86dbf
-  -9 | 252e691406782824eec43d7eadc3d256
-  -8 | a8d2ec85eaf98407310b72eb73dda247
-  -7 | 74687a12d3915d3c4d83f1af7b3683d5
-  -6 | 596a3d04481816330f07e4f97510c28f
-  -5 | 47c1b025fa18ea96c33fbb6718688c0f
-  -4 | 0267aaf632e87a63288a08331f22c7c3
-  -3 | b3149ecea4628efd23d2f86e5a723472
-  -2 | 5d7b9adcbe1c629ec722529dd12e5129
-  -1 | 6bb61e3b7bce0931da574d19d1d82c88
-   0 | cfcd208495d565ef66e7dff9f98764da
-   1 | c4ca4238a0b923820dcc509a6f75849b
-   2 | c81e728d9d4c2f636f067f89cc14862c
-   3 | eccbc87e4b5ce2fe28308fd9f2a7baf3
-   5 | e4da3b7fbbce2345d7772b0674a318d5
-   7 | 8f14e45fceea167a5a36dedd4bea2543
-   8 | c9f0f895fb98ab9159f51fd0297e236d
-   9 | 45c48cce2e2d7fbdea1afc51c7c6ad26
-  10 | d3d9446802a44259755d38e6d163e820
-  12 | xxx
-   4 | yyy
-(21 rows)
-
---
--- INSERT ... ON CONFLICT DO UPDATE and Row-level security
---
-SET SESSION AUTHORIZATION regress_rls_alice;
-DROP POLICY p1 ON document;
-DROP POLICY p1r ON document;
-CREATE POLICY p1 ON document FOR SELECT USING (true);
-CREATE POLICY p2 ON document FOR INSERT WITH CHECK (dauthor = current_user);
-CREATE POLICY p3 ON document FOR UPDATE
-  USING (cid = (SELECT cid from category WHERE cname = 'novel'))
-  WITH CHECK (dauthor = current_user);
-SET SESSION AUTHORIZATION regress_rls_bob;
--- Exists...
-SELECT * FROM document WHERE did = 2;
- did | cid | dlevel |     dauthor     |     dtitle      
------+-----+--------+-----------------+-----------------
-   2 |  11 |      2 | regress_rls_bob | my second novel
-(1 row)
-
--- ...so violates actual WITH CHECK OPTION within UPDATE (not INSERT, since
--- alternative UPDATE path happens to be taken):
-INSERT INTO document VALUES (2, (SELECT cid from category WHERE cname = 'novel'), 1, 'regress_rls_carol', 'my first novel')
-    ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle, dauthor = EXCLUDED.dauthor;
-ERROR:  new row violates row-level security policy for table "document"
--- Violates USING qual for UPDATE policy p3.
---
--- UPDATE path is taken, but UPDATE fails purely because *existing* row to be
--- updated is not a "novel"/cid 11 (row is not leaked, even though we have
--- SELECT privileges sufficient to see the row in this instance):
-INSERT INTO document VALUES (33, 22, 1, 'regress_rls_bob', 'okay science fiction'); -- preparation for next statement
-INSERT INTO document VALUES (33, (SELECT cid from category WHERE cname = 'novel'), 1, 'regress_rls_bob', 'Some novel, replaces sci-fi') -- takes UPDATE path
-    ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle;
-ERROR:  new row violates row-level security policy (USING expression) for table "document"
--- Fine (we UPDATE, since INSERT WCOs and UPDATE security barrier quals + WCOs
--- not violated):
-INSERT INTO document VALUES (2, (SELECT cid from category WHERE cname = 'novel'), 1, 'regress_rls_bob', 'my first novel')
-    ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle RETURNING *;
- did | cid | dlevel |     dauthor     |     dtitle     
------+-----+--------+-----------------+----------------
-   2 |  11 |      2 | regress_rls_bob | my first novel
-(1 row)
-
--- Fine (we INSERT, so "cid = 33" ("technology") isn't evaluated):
-INSERT INTO document VALUES (78, (SELECT cid from category WHERE cname = 'novel'), 1, 'regress_rls_bob', 'some technology novel')
-    ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle, cid = 33 RETURNING *;
- did | cid | dlevel |     dauthor     |        dtitle         
------+-----+--------+-----------------+-----------------------
-  78 |  11 |      1 | regress_rls_bob | some technology novel
-(1 row)
-
--- Fine (same query, but we UPDATE, so "cid = 33", ("technology") is not the
--- case in respect of *existing* tuple):
-INSERT INTO document VALUES (78, (SELECT cid from category WHERE cname = 'novel'), 1, 'regress_rls_bob', 'some technology novel')
-    ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle, cid = 33 RETURNING *;
- did | cid | dlevel |     dauthor     |        dtitle         
------+-----+--------+-----------------+-----------------------
-  78 |  33 |      1 | regress_rls_bob | some technology novel
-(1 row)
-
--- Same query a third time, but now fails due to existing tuple finally not
--- passing quals:
-INSERT INTO document VALUES (78, (SELECT cid from category WHERE cname = 'novel'), 1, 'regress_rls_bob', 'some technology novel')
-    ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle, cid = 33 RETURNING *;
-ERROR:  new row violates row-level security policy (USING expression) for table "document"
--- Don't fail just because INSERT doesn't satisfy WITH CHECK option that
--- originated as a barrier/USING() qual from the UPDATE.  Note that the UPDATE
--- path *isn't* taken, and so UPDATE-related policy does not apply:
-INSERT INTO document VALUES (79, (SELECT cid from category WHERE cname = 'technology'), 1, 'regress_rls_bob', 'technology book, can only insert')
-    ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle RETURNING *;
- did | cid | dlevel |     dauthor     |              dtitle              
------+-----+--------+-----------------+----------------------------------
-  79 |  33 |      1 | regress_rls_bob | technology book, can only insert
-(1 row)
-
--- But this time, the same statement fails, because the UPDATE path is taken,
--- and updating the row just inserted falls afoul of security barrier qual
--- (enforced as WCO) -- what we might have updated target tuple to is
--- irrelevant, in fact.
-INSERT INTO document VALUES (79, (SELECT cid from category WHERE cname = 'technology'), 1, 'regress_rls_bob', 'technology book, can only insert')
-    ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle RETURNING *;
-ERROR:  new row violates row-level security policy (USING expression) for table "document"
--- Test default USING qual enforced as WCO
-SET SESSION AUTHORIZATION regress_rls_alice;
-DROP POLICY p1 ON document;
-DROP POLICY p2 ON document;
-DROP POLICY p3 ON document;
-CREATE POLICY p3_with_default ON document FOR UPDATE
-  USING (cid = (SELECT cid from category WHERE cname = 'novel'));
-SET SESSION AUTHORIZATION regress_rls_bob;
--- Just because WCO-style enforcement of USING quals occurs with
--- existing/target tuple does not mean that the implementation can be allowed
--- to fail to also enforce this qual against the final tuple appended to
--- relation (since in the absence of an explicit WCO, this is also interpreted
--- as an UPDATE/ALL WCO in general).
---
--- UPDATE path is taken here (fails due to existing tuple).  Note that this is
--- not reported as a "USING expression", because it's an RLS UPDATE check that originated as
--- a USING qual for the purposes of RLS in general, as opposed to an explicit
--- USING qual that is ordinarily a security barrier.  We leave it up to the
--- UPDATE to make this fail:
-INSERT INTO document VALUES (79, (SELECT cid from category WHERE cname = 'technology'), 1, 'regress_rls_bob', 'technology book, can only insert')
-    ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle RETURNING *;
-ERROR:  new row violates row-level security policy for table "document"
--- UPDATE path is taken here.  Existing tuple passes, since its cid
--- corresponds to "novel", but default USING qual is enforced against
--- post-UPDATE tuple too (as always when updating with a policy that lacks an
--- explicit WCO), and so this fails:
-INSERT INTO document VALUES (2, (SELECT cid from category WHERE cname = 'technology'), 1, 'regress_rls_bob', 'my first novel')
-    ON CONFLICT (did) DO UPDATE SET cid = EXCLUDED.cid, dtitle = EXCLUDED.dtitle RETURNING *;
-ERROR:  new row violates row-level security policy for table "document"
-SET SESSION AUTHORIZATION regress_rls_alice;
-DROP POLICY p3_with_default ON document;
---
--- Test ALL policies with ON CONFLICT DO UPDATE (much the same as existing UPDATE
--- tests)
---
-CREATE POLICY p3_with_all ON document FOR ALL
-  USING (cid = (SELECT cid from category WHERE cname = 'novel'))
-  WITH CHECK (dauthor = current_user);
-SET SESSION AUTHORIZATION regress_rls_bob;
--- Fails, since ALL WCO is enforced in insert path:
-INSERT INTO document VALUES (80, (SELECT cid from category WHERE cname = 'novel'), 1, 'regress_rls_carol', 'my first novel')
-    ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle, cid = 33;
-ERROR:  new row violates row-level security policy for table "document"
--- Fails, since ALL policy USING qual is enforced (existing, target tuple is in
--- violation, since it has the "manga" cid):
-INSERT INTO document VALUES (4, (SELECT cid from category WHERE cname = 'novel'), 1, 'regress_rls_bob', 'my first novel')
-    ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle;
-ERROR:  new row violates row-level security policy (USING expression) for table "document"
--- Fails, since ALL WCO are enforced:
-INSERT INTO document VALUES (1, (SELECT cid from category WHERE cname = 'novel'), 1, 'regress_rls_bob', 'my first novel')
-    ON CONFLICT (did) DO UPDATE SET dauthor = 'regress_rls_carol';
-ERROR:  new row violates row-level security policy for table "document"
---
--- ROLE/GROUP
---
-SET SESSION AUTHORIZATION regress_rls_alice;
-CREATE TABLE z1 (a int, b text);
-CREATE TABLE z2 (a int, b text);
-GRANT SELECT ON z1,z2 TO regress_rls_group1, regress_rls_group2,
-    regress_rls_bob, regress_rls_carol;
-INSERT INTO z1 VALUES
-    (1, 'aba'),
-    (2, 'bbb'),
-    (3, 'ccc'),
-    (4, 'dad');
-CREATE POLICY p1 ON z1 TO regress_rls_group1 USING (a % 2 = 0);
-CREATE POLICY p2 ON z1 TO regress_rls_group2 USING (a % 2 = 1);
-ALTER TABLE z1 ENABLE ROW LEVEL SECURITY;
-SET SESSION AUTHORIZATION regress_rls_bob;
-SELECT * FROM z1 WHERE f_leak(b);
-NOTICE:  f_leak => bbb
-NOTICE:  f_leak => dad
- a |  b  
----+-----
- 2 | bbb
- 4 | dad
-(2 rows)
-
-EXPLAIN (COSTS OFF) SELECT * FROM z1 WHERE f_leak(b);
-               QUERY PLAN                
------------------------------------------
- Seq Scan on z1
-   Filter: (((a % 2) = 0) AND f_leak(b))
-(2 rows)
-
-PREPARE plancache_test AS SELECT * FROM z1 WHERE f_leak(b);
-EXPLAIN (COSTS OFF) EXECUTE plancache_test;
-               QUERY PLAN                
------------------------------------------
- Seq Scan on z1
-   Filter: (((a % 2) = 0) AND f_leak(b))
-(2 rows)
-
-PREPARE plancache_test2 AS WITH q AS MATERIALIZED (SELECT * FROM z1 WHERE f_leak(b)) SELECT * FROM q,z2;
-EXPLAIN (COSTS OFF) EXECUTE plancache_test2;
-                   QUERY PLAN                    
--------------------------------------------------
- Nested Loop
-   CTE q
-     ->  Seq Scan on z1
-           Filter: (((a % 2) = 0) AND f_leak(b))
-   ->  CTE Scan on q
-   ->  Materialize
-         ->  Seq Scan on z2
-(7 rows)
-
-PREPARE plancache_test3 AS WITH q AS MATERIALIZED (SELECT * FROM z2) SELECT * FROM q,z1 WHERE f_leak(z1.b);
-EXPLAIN (COSTS OFF) EXECUTE plancache_test3;
-                     QUERY PLAN                      
------------------------------------------------------
- Nested Loop
-   CTE q
-     ->  Seq Scan on z2
-   ->  CTE Scan on q
-   ->  Materialize
-         ->  Seq Scan on z1
-               Filter: (((a % 2) = 0) AND f_leak(b))
-(7 rows)
-
-SET ROLE regress_rls_group1;
-SELECT * FROM z1 WHERE f_leak(b);
-NOTICE:  f_leak => bbb
-NOTICE:  f_leak => dad
- a |  b  
----+-----
- 2 | bbb
- 4 | dad
-(2 rows)
-
-EXPLAIN (COSTS OFF) SELECT * FROM z1 WHERE f_leak(b);
-               QUERY PLAN                
------------------------------------------
- Seq Scan on z1
-   Filter: (((a % 2) = 0) AND f_leak(b))
-(2 rows)
-
-EXPLAIN (COSTS OFF) EXECUTE plancache_test;
-               QUERY PLAN                
------------------------------------------
- Seq Scan on z1
-   Filter: (((a % 2) = 0) AND f_leak(b))
-(2 rows)
-
-EXPLAIN (COSTS OFF) EXECUTE plancache_test2;
-                   QUERY PLAN                    
--------------------------------------------------
- Nested Loop
-   CTE q
-     ->  Seq Scan on z1
-           Filter: (((a % 2) = 0) AND f_leak(b))
-   ->  CTE Scan on q
-   ->  Materialize
-         ->  Seq Scan on z2
-(7 rows)
-
-EXPLAIN (COSTS OFF) EXECUTE plancache_test3;
-                     QUERY PLAN                      
------------------------------------------------------
- Nested Loop
-   CTE q
-     ->  Seq Scan on z2
-   ->  CTE Scan on q
-   ->  Materialize
-         ->  Seq Scan on z1
-               Filter: (((a % 2) = 0) AND f_leak(b))
-(7 rows)
-
-SET SESSION AUTHORIZATION regress_rls_carol;
-SELECT * FROM z1 WHERE f_leak(b);
-NOTICE:  f_leak => aba
-NOTICE:  f_leak => ccc
- a |  b  
----+-----
- 1 | aba
- 3 | ccc
-(2 rows)
-
-EXPLAIN (COSTS OFF) SELECT * FROM z1 WHERE f_leak(b);
-               QUERY PLAN                
------------------------------------------
- Seq Scan on z1
-   Filter: (((a % 2) = 1) AND f_leak(b))
-(2 rows)
-
-EXPLAIN (COSTS OFF) EXECUTE plancache_test;
-               QUERY PLAN                
------------------------------------------
- Seq Scan on z1
-   Filter: (((a % 2) = 1) AND f_leak(b))
-(2 rows)
-
-EXPLAIN (COSTS OFF) EXECUTE plancache_test2;
-                   QUERY PLAN                    
--------------------------------------------------
- Nested Loop
-   CTE q
-     ->  Seq Scan on z1
-           Filter: (((a % 2) = 1) AND f_leak(b))
-   ->  CTE Scan on q
-   ->  Materialize
-         ->  Seq Scan on z2
-(7 rows)
-
-EXPLAIN (COSTS OFF) EXECUTE plancache_test3;
-                     QUERY PLAN                      
------------------------------------------------------
- Nested Loop
-   CTE q
-     ->  Seq Scan on z2
-   ->  CTE Scan on q
-   ->  Materialize
-         ->  Seq Scan on z1
-               Filter: (((a % 2) = 1) AND f_leak(b))
-(7 rows)
-
-SET ROLE regress_rls_group2;
-SELECT * FROM z1 WHERE f_leak(b);
-NOTICE:  f_leak => aba
-NOTICE:  f_leak => ccc
- a |  b  
----+-----
- 1 | aba
- 3 | ccc
-(2 rows)
-
-EXPLAIN (COSTS OFF) SELECT * FROM z1 WHERE f_leak(b);
-               QUERY PLAN                
------------------------------------------
- Seq Scan on z1
-   Filter: (((a % 2) = 1) AND f_leak(b))
-(2 rows)
-
-EXPLAIN (COSTS OFF) EXECUTE plancache_test;
-               QUERY PLAN                
------------------------------------------
- Seq Scan on z1
-   Filter: (((a % 2) = 1) AND f_leak(b))
-(2 rows)
-
-EXPLAIN (COSTS OFF) EXECUTE plancache_test2;
-                   QUERY PLAN                    
--------------------------------------------------
- Nested Loop
-   CTE q
-     ->  Seq Scan on z1
-           Filter: (((a % 2) = 1) AND f_leak(b))
-   ->  CTE Scan on q
-   ->  Materialize
-         ->  Seq Scan on z2
-(7 rows)
-
-EXPLAIN (COSTS OFF) EXECUTE plancache_test3;
-                     QUERY PLAN                      
------------------------------------------------------
- Nested Loop
-   CTE q
-     ->  Seq Scan on z2
-   ->  CTE Scan on q
-   ->  Materialize
-         ->  Seq Scan on z1
-               Filter: (((a % 2) = 1) AND f_leak(b))
-(7 rows)
-
---
--- Views should follow policy for view owner.
---
--- View and Table owner are the same.
-SET SESSION AUTHORIZATION regress_rls_alice;
-CREATE VIEW rls_view AS SELECT * FROM z1 WHERE f_leak(b);
-GRANT SELECT ON rls_view TO regress_rls_bob;
--- Query as role that is not owner of view or table.  Should return all records.
-SET SESSION AUTHORIZATION regress_rls_bob;
-SELECT * FROM rls_view;
-NOTICE:  f_leak => aba
-NOTICE:  f_leak => bbb
-NOTICE:  f_leak => ccc
-NOTICE:  f_leak => dad
- a |  b  
----+-----
- 1 | aba
- 2 | bbb
- 3 | ccc
- 4 | dad
-(4 rows)
-
-EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
-     QUERY PLAN      
----------------------
- Seq Scan on z1
-   Filter: f_leak(b)
-(2 rows)
-
--- Query as view/table owner.  Should return all records.
-SET SESSION AUTHORIZATION regress_rls_alice;
-SELECT * FROM rls_view;
-NOTICE:  f_leak => aba
-NOTICE:  f_leak => bbb
-NOTICE:  f_leak => ccc
-NOTICE:  f_leak => dad
- a |  b  
----+-----
- 1 | aba
- 2 | bbb
- 3 | ccc
- 4 | dad
-(4 rows)
-
-EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
-     QUERY PLAN      
----------------------
- Seq Scan on z1
-   Filter: f_leak(b)
-(2 rows)
-
-DROP VIEW rls_view;
--- View and Table owners are different.
-SET SESSION AUTHORIZATION regress_rls_bob;
-CREATE VIEW rls_view AS SELECT * FROM z1 WHERE f_leak(b);
-GRANT SELECT ON rls_view TO regress_rls_alice;
--- Query as role that is not owner of view but is owner of table.
--- Should return records based on view owner policies.
-SET SESSION AUTHORIZATION regress_rls_alice;
-SELECT * FROM rls_view;
-NOTICE:  f_leak => bbb
-NOTICE:  f_leak => dad
- a |  b  
----+-----
- 2 | bbb
- 4 | dad
-(2 rows)
-
-EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
-               QUERY PLAN                
------------------------------------------
- Seq Scan on z1
-   Filter: (((a % 2) = 0) AND f_leak(b))
-(2 rows)
-
--- Query as role that is not owner of table but is owner of view.
--- Should return records based on view owner policies.
-SET SESSION AUTHORIZATION regress_rls_bob;
-SELECT * FROM rls_view;
-NOTICE:  f_leak => bbb
-NOTICE:  f_leak => dad
- a |  b  
----+-----
- 2 | bbb
- 4 | dad
-(2 rows)
-
-EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
-               QUERY PLAN                
------------------------------------------
- Seq Scan on z1
-   Filter: (((a % 2) = 0) AND f_leak(b))
-(2 rows)
-
--- Query as role that is not the owner of the table or view without permissions.
-SET SESSION AUTHORIZATION regress_rls_carol;
-SELECT * FROM rls_view; --fail - permission denied.
-ERROR:  permission denied for view rls_view
-EXPLAIN (COSTS OFF) SELECT * FROM rls_view; --fail - permission denied.
-ERROR:  permission denied for view rls_view
--- Query as role that is not the owner of the table or view with permissions.
-SET SESSION AUTHORIZATION regress_rls_bob;
-GRANT SELECT ON rls_view TO regress_rls_carol;
-SELECT * FROM rls_view;
-NOTICE:  f_leak => bbb
-NOTICE:  f_leak => dad
- a |  b  
----+-----
- 2 | bbb
- 4 | dad
-(2 rows)
-
-EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
-               QUERY PLAN                
------------------------------------------
- Seq Scan on z1
-   Filter: (((a % 2) = 0) AND f_leak(b))
-(2 rows)
-
-SET SESSION AUTHORIZATION regress_rls_bob;
-DROP VIEW rls_view;
---
--- Command specific
---
-SET SESSION AUTHORIZATION regress_rls_alice;
-CREATE TABLE x1 (a int, b text, c text);
-GRANT ALL ON x1 TO PUBLIC;
-INSERT INTO x1 VALUES
-    (1, 'abc', 'regress_rls_bob'),
-    (2, 'bcd', 'regress_rls_bob'),
-    (3, 'cde', 'regress_rls_carol'),
-    (4, 'def', 'regress_rls_carol'),
-    (5, 'efg', 'regress_rls_bob'),
-    (6, 'fgh', 'regress_rls_bob'),
-    (7, 'fgh', 'regress_rls_carol'),
-    (8, 'fgh', 'regress_rls_carol');
-CREATE POLICY p0 ON x1 FOR ALL USING (c = current_user);
-CREATE POLICY p1 ON x1 FOR SELECT USING (a % 2 = 0);
-CREATE POLICY p2 ON x1 FOR INSERT WITH CHECK (a % 2 = 1);
-CREATE POLICY p3 ON x1 FOR UPDATE USING (a % 2 = 0);
-CREATE POLICY p4 ON x1 FOR DELETE USING (a < 8);
-ALTER TABLE x1 ENABLE ROW LEVEL SECURITY;
-SET SESSION AUTHORIZATION regress_rls_bob;
-SELECT * FROM x1 WHERE f_leak(b) ORDER BY a ASC;
-NOTICE:  f_leak => abc
-NOTICE:  f_leak => bcd
-NOTICE:  f_leak => def
-NOTICE:  f_leak => efg
-NOTICE:  f_leak => fgh
-NOTICE:  f_leak => fgh
- a |  b  |         c         
----+-----+-------------------
- 1 | abc | regress_rls_bob
- 2 | bcd | regress_rls_bob
- 4 | def | regress_rls_carol
- 5 | efg | regress_rls_bob
- 6 | fgh | regress_rls_bob
- 8 | fgh | regress_rls_carol
-(6 rows)
-
-UPDATE x1 SET b = b || '_updt' WHERE f_leak(b) RETURNING *;
-NOTICE:  f_leak => abc
-NOTICE:  f_leak => bcd
-NOTICE:  f_leak => def
-NOTICE:  f_leak => efg
-NOTICE:  f_leak => fgh
-NOTICE:  f_leak => fgh
- a |    b     |         c         
----+----------+-------------------
- 1 | abc_updt | regress_rls_bob
- 2 | bcd_updt | regress_rls_bob
- 4 | def_updt | regress_rls_carol
- 5 | efg_updt | regress_rls_bob
- 6 | fgh_updt | regress_rls_bob
- 8 | fgh_updt | regress_rls_carol
-(6 rows)
-
-SET SESSION AUTHORIZATION regress_rls_carol;
-SELECT * FROM x1 WHERE f_leak(b) ORDER BY a ASC;
-NOTICE:  f_leak => cde
-NOTICE:  f_leak => fgh
-NOTICE:  f_leak => bcd_updt
-NOTICE:  f_leak => def_updt
-NOTICE:  f_leak => fgh_updt
-NOTICE:  f_leak => fgh_updt
- a |    b     |         c         
----+----------+-------------------
- 2 | bcd_updt | regress_rls_bob
- 3 | cde      | regress_rls_carol
- 4 | def_updt | regress_rls_carol
- 6 | fgh_updt | regress_rls_bob
- 7 | fgh      | regress_rls_carol
- 8 | fgh_updt | regress_rls_carol
-(6 rows)
-
-UPDATE x1 SET b = b || '_updt' WHERE f_leak(b) RETURNING *;
-NOTICE:  f_leak => cde
-NOTICE:  f_leak => fgh
-NOTICE:  f_leak => bcd_updt
-NOTICE:  f_leak => def_updt
-NOTICE:  f_leak => fgh_updt
-NOTICE:  f_leak => fgh_updt
- a |       b       |         c         
----+---------------+-------------------
- 3 | cde_updt      | regress_rls_carol
- 7 | fgh_updt      | regress_rls_carol
- 2 | bcd_updt_updt | regress_rls_bob
- 4 | def_updt_updt | regress_rls_carol
- 6 | fgh_updt_updt | regress_rls_bob
- 8 | fgh_updt_updt | regress_rls_carol
-(6 rows)
-
-DELETE FROM x1 WHERE f_leak(b) RETURNING *;
-NOTICE:  f_leak => cde_updt
-NOTICE:  f_leak => fgh_updt
-NOTICE:  f_leak => bcd_updt_updt
-NOTICE:  f_leak => def_updt_updt
-NOTICE:  f_leak => fgh_updt_updt
-NOTICE:  f_leak => fgh_updt_updt
- a |       b       |         c         
----+---------------+-------------------
- 3 | cde_updt      | regress_rls_carol
- 7 | fgh_updt      | regress_rls_carol
- 2 | bcd_updt_updt | regress_rls_bob
- 4 | def_updt_updt | regress_rls_carol
- 6 | fgh_updt_updt | regress_rls_bob
- 8 | fgh_updt_updt | regress_rls_carol
-(6 rows)
-
---
--- Duplicate Policy Names
---
-SET SESSION AUTHORIZATION regress_rls_alice;
-CREATE TABLE y1 (a int, b text);
-CREATE TABLE y2 (a int, b text);
-GRANT ALL ON y1, y2 TO regress_rls_bob;
-CREATE POLICY p1 ON y1 FOR ALL USING (a % 2 = 0);
-CREATE POLICY p2 ON y1 FOR SELECT USING (a > 2);
-CREATE POLICY p1 ON y1 FOR SELECT USING (a % 2 = 1);  --fail
-ERROR:  policy "p1" for table "y1" already exists
-CREATE POLICY p1 ON y2 FOR ALL USING (a % 2 = 0);  --OK
-ALTER TABLE y1 ENABLE ROW LEVEL SECURITY;
-ALTER TABLE y2 ENABLE ROW LEVEL SECURITY;
---
--- Expression structure with SBV
---
--- Create view as table owner.  RLS should NOT be applied.
-SET SESSION AUTHORIZATION regress_rls_alice;
-CREATE VIEW rls_sbv WITH (security_barrier) AS
-    SELECT * FROM y1 WHERE f_leak(b);
-EXPLAIN (COSTS OFF) SELECT * FROM rls_sbv WHERE (a = 1);
-            QUERY PLAN             
------------------------------------
- Seq Scan on y1
-   Filter: (f_leak(b) AND (a = 1))
-(2 rows)
-
-DROP VIEW rls_sbv;
--- Create view as role that does not own table.  RLS should be applied.
-SET SESSION AUTHORIZATION regress_rls_bob;
-CREATE VIEW rls_sbv WITH (security_barrier) AS
-    SELECT * FROM y1 WHERE f_leak(b);
-EXPLAIN (COSTS OFF) SELECT * FROM rls_sbv WHERE (a = 1);
-                            QUERY PLAN                            
-------------------------------------------------------------------
- Seq Scan on y1
-   Filter: ((a = 1) AND ((a > 2) OR ((a % 2) = 0)) AND f_leak(b))
-(2 rows)
-
-DROP VIEW rls_sbv;
---
--- Expression structure
---
-SET SESSION AUTHORIZATION regress_rls_alice;
-INSERT INTO y2 (SELECT x, md5(x::text) FROM generate_series(0,20) x);
-CREATE POLICY p2 ON y2 USING (a % 3 = 0);
-CREATE POLICY p3 ON y2 USING (a % 4 = 0);
-SET SESSION AUTHORIZATION regress_rls_bob;
-SELECT * FROM y2 WHERE f_leak(b);
-NOTICE:  f_leak => cfcd208495d565ef66e7dff9f98764da
-NOTICE:  f_leak => c81e728d9d4c2f636f067f89cc14862c
-NOTICE:  f_leak => eccbc87e4b5ce2fe28308fd9f2a7baf3
-NOTICE:  f_leak => a87ff679a2f3e71d9181a67b7542122c
-NOTICE:  f_leak => 1679091c5a880faf6fb5e6087eb1b2dc
-NOTICE:  f_leak => c9f0f895fb98ab9159f51fd0297e236d
-NOTICE:  f_leak => 45c48cce2e2d7fbdea1afc51c7c6ad26
-NOTICE:  f_leak => d3d9446802a44259755d38e6d163e820
-NOTICE:  f_leak => c20ad4d76fe97759aa27a0c99bff6710
-NOTICE:  f_leak => aab3238922bcc25a6f606eb525ffdc56
-NOTICE:  f_leak => 9bf31c7ff062936a96d3c8bd1f8f2ff3
-NOTICE:  f_leak => c74d97b01eae257e44aa9d5bade97baf
-NOTICE:  f_leak => 6f4922f45568161a8cdf4ad2299f6d23
-NOTICE:  f_leak => 98f13708210194c475687be6106a3b84
- a  |                b                 
-----+----------------------------------
-  0 | cfcd208495d565ef66e7dff9f98764da
-  2 | c81e728d9d4c2f636f067f89cc14862c
-  3 | eccbc87e4b5ce2fe28308fd9f2a7baf3
-  4 | a87ff679a2f3e71d9181a67b7542122c
-  6 | 1679091c5a880faf6fb5e6087eb1b2dc
-  8 | c9f0f895fb98ab9159f51fd0297e236d
-  9 | 45c48cce2e2d7fbdea1afc51c7c6ad26
- 10 | d3d9446802a44259755d38e6d163e820
- 12 | c20ad4d76fe97759aa27a0c99bff6710
- 14 | aab3238922bcc25a6f606eb525ffdc56
- 15 | 9bf31c7ff062936a96d3c8bd1f8f2ff3
- 16 | c74d97b01eae257e44aa9d5bade97baf
- 18 | 6f4922f45568161a8cdf4ad2299f6d23
- 20 | 98f13708210194c475687be6106a3b84
-(14 rows)
-
-EXPLAIN (COSTS OFF) SELECT * FROM y2 WHERE f_leak(b);
-                                 QUERY PLAN                                  
------------------------------------------------------------------------------
- Seq Scan on y2
-   Filter: ((((a % 4) = 0) OR ((a % 3) = 0) OR ((a % 2) = 0)) AND f_leak(b))
-(2 rows)
-
---
--- Qual push-down of leaky functions, when not referring to table
---
-SELECT * FROM y2 WHERE f_leak('abc');
-NOTICE:  f_leak => abc
-NOTICE:  f_leak => abc
-NOTICE:  f_leak => abc
-NOTICE:  f_leak => abc
-NOTICE:  f_leak => abc
-NOTICE:  f_leak => abc
-NOTICE:  f_leak => abc
-NOTICE:  f_leak => abc
-NOTICE:  f_leak => abc
-NOTICE:  f_leak => abc
-NOTICE:  f_leak => abc
-NOTICE:  f_leak => abc
-NOTICE:  f_leak => abc
-NOTICE:  f_leak => abc
-NOTICE:  f_leak => abc
-NOTICE:  f_leak => abc
-NOTICE:  f_leak => abc
-NOTICE:  f_leak => abc
-NOTICE:  f_leak => abc
-NOTICE:  f_leak => abc
-NOTICE:  f_leak => abc
- a  |                b                 
-----+----------------------------------
-  0 | cfcd208495d565ef66e7dff9f98764da
-  2 | c81e728d9d4c2f636f067f89cc14862c
-  3 | eccbc87e4b5ce2fe28308fd9f2a7baf3
-  4 | a87ff679a2f3e71d9181a67b7542122c
-  6 | 1679091c5a880faf6fb5e6087eb1b2dc
-  8 | c9f0f895fb98ab9159f51fd0297e236d
-  9 | 45c48cce2e2d7fbdea1afc51c7c6ad26
- 10 | d3d9446802a44259755d38e6d163e820
- 12 | c20ad4d76fe97759aa27a0c99bff6710
- 14 | aab3238922bcc25a6f606eb525ffdc56
- 15 | 9bf31c7ff062936a96d3c8bd1f8f2ff3
- 16 | c74d97b01eae257e44aa9d5bade97baf
- 18 | 6f4922f45568161a8cdf4ad2299f6d23
- 20 | 98f13708210194c475687be6106a3b84
-(14 rows)
-
-EXPLAIN (COSTS OFF) SELECT * FROM y2 WHERE f_leak('abc');
-                                      QUERY PLAN                                       
----------------------------------------------------------------------------------------
- Seq Scan on y2
-   Filter: (f_leak('abc'::text) AND (((a % 4) = 0) OR ((a % 3) = 0) OR ((a % 2) = 0)))
-(2 rows)
-
-CREATE TABLE test_qual_pushdown (
-    abc text
-);
-INSERT INTO test_qual_pushdown VALUES ('abc'),('def');
-SELECT * FROM y2 JOIN test_qual_pushdown ON (b = abc) WHERE f_leak(abc);
-NOTICE:  f_leak => abc
-NOTICE:  f_leak => def
- a | b | abc 
----+---+-----
-(0 rows)
-
-EXPLAIN (COSTS OFF) SELECT * FROM y2 JOIN test_qual_pushdown ON (b = abc) WHERE f_leak(abc);
-                               QUERY PLAN                                
--------------------------------------------------------------------------
- Hash Join
-   Hash Cond: (test_qual_pushdown.abc = y2.b)
-   ->  Seq Scan on test_qual_pushdown
-         Filter: f_leak(abc)
-   ->  Hash
-         ->  Seq Scan on y2
-               Filter: (((a % 4) = 0) OR ((a % 3) = 0) OR ((a % 2) = 0))
-(7 rows)
-
-SELECT * FROM y2 JOIN test_qual_pushdown ON (b = abc) WHERE f_leak(b);
-NOTICE:  f_leak => cfcd208495d565ef66e7dff9f98764da
-NOTICE:  f_leak => c81e728d9d4c2f636f067f89cc14862c
-NOTICE:  f_leak => eccbc87e4b5ce2fe28308fd9f2a7baf3
-NOTICE:  f_leak => a87ff679a2f3e71d9181a67b7542122c
-NOTICE:  f_leak => 1679091c5a880faf6fb5e6087eb1b2dc
-NOTICE:  f_leak => c9f0f895fb98ab9159f51fd0297e236d
-NOTICE:  f_leak => 45c48cce2e2d7fbdea1afc51c7c6ad26
-NOTICE:  f_leak => d3d9446802a44259755d38e6d163e820
-NOTICE:  f_leak => c20ad4d76fe97759aa27a0c99bff6710
-NOTICE:  f_leak => aab3238922bcc25a6f606eb525ffdc56
-NOTICE:  f_leak => 9bf31c7ff062936a96d3c8bd1f8f2ff3
-NOTICE:  f_leak => c74d97b01eae257e44aa9d5bade97baf
-NOTICE:  f_leak => 6f4922f45568161a8cdf4ad2299f6d23
-NOTICE:  f_leak => 98f13708210194c475687be6106a3b84
- a | b | abc 
----+---+-----
-(0 rows)
-
-EXPLAIN (COSTS OFF) SELECT * FROM y2 JOIN test_qual_pushdown ON (b = abc) WHERE f_leak(b);
-                                       QUERY PLAN                                        
------------------------------------------------------------------------------------------
- Hash Join
-   Hash Cond: (test_qual_pushdown.abc = y2.b)
-   ->  Seq Scan on test_qual_pushdown
-   ->  Hash
-         ->  Seq Scan on y2
-               Filter: ((((a % 4) = 0) OR ((a % 3) = 0) OR ((a % 2) = 0)) AND f_leak(b))
-(6 rows)
-
-DROP TABLE test_qual_pushdown;
---
--- Plancache invalidate on user change.
---
-RESET SESSION AUTHORIZATION;
-DROP TABLE t1 CASCADE;
-NOTICE:  drop cascades to 2 other objects
-DETAIL:  drop cascades to table t2
-drop cascades to table t3
-CREATE TABLE t1 (a integer);
-GRANT SELECT ON t1 TO regress_rls_bob, regress_rls_carol;
-CREATE POLICY p1 ON t1 TO regress_rls_bob USING ((a % 2) = 0);
-CREATE POLICY p2 ON t1 TO regress_rls_carol USING ((a % 4) = 0);
-ALTER TABLE t1 ENABLE ROW LEVEL SECURITY;
--- Prepare as regress_rls_bob
-SET ROLE regress_rls_bob;
-PREPARE role_inval AS SELECT * FROM t1;
--- Check plan
-EXPLAIN (COSTS OFF) EXECUTE role_inval;
-       QUERY PLAN        
--------------------------
- Seq Scan on t1
-   Filter: ((a % 2) = 0)
-(2 rows)
-
--- Change to regress_rls_carol
-SET ROLE regress_rls_carol;
--- Check plan- should be different
-EXPLAIN (COSTS OFF) EXECUTE role_inval;
-       QUERY PLAN        
--------------------------
- Seq Scan on t1
-   Filter: ((a % 4) = 0)
-(2 rows)
-
--- Change back to regress_rls_bob
-SET ROLE regress_rls_bob;
--- Check plan- should be back to original
-EXPLAIN (COSTS OFF) EXECUTE role_inval;
-       QUERY PLAN        
--------------------------
- Seq Scan on t1
-   Filter: ((a % 2) = 0)
-(2 rows)
-
---
--- CTE and RLS
---
-RESET SESSION AUTHORIZATION;
-DROP TABLE t1 CASCADE;
-CREATE TABLE t1 (a integer, b text);
-CREATE POLICY p1 ON t1 USING (a % 2 = 0);
-ALTER TABLE t1 ENABLE ROW LEVEL SECURITY;
-GRANT ALL ON t1 TO regress_rls_bob;
-INSERT INTO t1 (SELECT x, md5(x::text) FROM generate_series(0,20) x);
-SET SESSION AUTHORIZATION regress_rls_bob;
-WITH cte1 AS MATERIALIZED (SELECT * FROM t1 WHERE f_leak(b)) SELECT * FROM cte1;
-NOTICE:  f_leak => cfcd208495d565ef66e7dff9f98764da
-NOTICE:  f_leak => c81e728d9d4c2f636f067f89cc14862c
-NOTICE:  f_leak => a87ff679a2f3e71d9181a67b7542122c
-NOTICE:  f_leak => 1679091c5a880faf6fb5e6087eb1b2dc
-NOTICE:  f_leak => c9f0f895fb98ab9159f51fd0297e236d
-NOTICE:  f_leak => d3d9446802a44259755d38e6d163e820
-NOTICE:  f_leak => c20ad4d76fe97759aa27a0c99bff6710
-NOTICE:  f_leak => aab3238922bcc25a6f606eb525ffdc56
-NOTICE:  f_leak => c74d97b01eae257e44aa9d5bade97baf
-NOTICE:  f_leak => 6f4922f45568161a8cdf4ad2299f6d23
-NOTICE:  f_leak => 98f13708210194c475687be6106a3b84
- a  |                b                 
-----+----------------------------------
-  0 | cfcd208495d565ef66e7dff9f98764da
-  2 | c81e728d9d4c2f636f067f89cc14862c
-  4 | a87ff679a2f3e71d9181a67b7542122c
-  6 | 1679091c5a880faf6fb5e6087eb1b2dc
-  8 | c9f0f895fb98ab9159f51fd0297e236d
- 10 | d3d9446802a44259755d38e6d163e820
- 12 | c20ad4d76fe97759aa27a0c99bff6710
- 14 | aab3238922bcc25a6f606eb525ffdc56
- 16 | c74d97b01eae257e44aa9d5bade97baf
- 18 | 6f4922f45568161a8cdf4ad2299f6d23
- 20 | 98f13708210194c475687be6106a3b84
-(11 rows)
-
-EXPLAIN (COSTS OFF)
-WITH cte1 AS MATERIALIZED (SELECT * FROM t1 WHERE f_leak(b)) SELECT * FROM cte1;
-                   QUERY PLAN                    
--------------------------------------------------
- CTE Scan on cte1
-   CTE cte1
-     ->  Seq Scan on t1
-           Filter: (((a % 2) = 0) AND f_leak(b))
-(4 rows)
-
-WITH cte1 AS (UPDATE t1 SET a = a + 1 RETURNING *) SELECT * FROM cte1; --fail
-ERROR:  new row violates row-level security policy for table "t1"
-WITH cte1 AS (UPDATE t1 SET a = a RETURNING *) SELECT * FROM cte1; --ok
- a  |                b                 
-----+----------------------------------
-  0 | cfcd208495d565ef66e7dff9f98764da
-  2 | c81e728d9d4c2f636f067f89cc14862c
-  4 | a87ff679a2f3e71d9181a67b7542122c
-  6 | 1679091c5a880faf6fb5e6087eb1b2dc
-  8 | c9f0f895fb98ab9159f51fd0297e236d
- 10 | d3d9446802a44259755d38e6d163e820
- 12 | c20ad4d76fe97759aa27a0c99bff6710
- 14 | aab3238922bcc25a6f606eb525ffdc56
- 16 | c74d97b01eae257e44aa9d5bade97baf
- 18 | 6f4922f45568161a8cdf4ad2299f6d23
- 20 | 98f13708210194c475687be6106a3b84
-(11 rows)
-
-WITH cte1 AS (INSERT INTO t1 VALUES (21, 'Fail') RETURNING *) SELECT * FROM cte1; --fail
-ERROR:  new row violates row-level security policy for table "t1"
-WITH cte1 AS (INSERT INTO t1 VALUES (20, 'Success') RETURNING *) SELECT * FROM cte1; --ok
- a  |    b    
-----+---------
- 20 | Success
-(1 row)
-
---
--- Rename Policy
---
-RESET SESSION AUTHORIZATION;
-ALTER POLICY p1 ON t1 RENAME TO p1; --fail
-ERROR:  policy "p1" for table "t1" already exists
-SELECT polname, relname
-    FROM pg_policy pol
-    JOIN pg_class pc ON (pc.oid = pol.polrelid)
-    WHERE relname = 't1';
- polname | relname 
----------+---------
- p1      | t1
-(1 row)
-
-ALTER POLICY p1 ON t1 RENAME TO p2; --ok
-SELECT polname, relname
-    FROM pg_policy pol
-    JOIN pg_class pc ON (pc.oid = pol.polrelid)
-    WHERE relname = 't1';
- polname | relname 
----------+---------
- p2      | t1
-(1 row)
-
---
--- Check INSERT SELECT
---
-SET SESSION AUTHORIZATION regress_rls_bob;
-CREATE TABLE t2 (a integer, b text);
-INSERT INTO t2 (SELECT * FROM t1);
-EXPLAIN (COSTS OFF) INSERT INTO t2 (SELECT * FROM t1);
-          QUERY PLAN           
--------------------------------
- Insert on t2
-   ->  Seq Scan on t1
-         Filter: ((a % 2) = 0)
-(3 rows)
-
-SELECT * FROM t2;
- a  |                b                 
-----+----------------------------------
-  0 | cfcd208495d565ef66e7dff9f98764da
-  2 | c81e728d9d4c2f636f067f89cc14862c
-  4 | a87ff679a2f3e71d9181a67b7542122c
-  6 | 1679091c5a880faf6fb5e6087eb1b2dc
-  8 | c9f0f895fb98ab9159f51fd0297e236d
- 10 | d3d9446802a44259755d38e6d163e820
- 12 | c20ad4d76fe97759aa27a0c99bff6710
- 14 | aab3238922bcc25a6f606eb525ffdc56
- 16 | c74d97b01eae257e44aa9d5bade97baf
- 18 | 6f4922f45568161a8cdf4ad2299f6d23
- 20 | 98f13708210194c475687be6106a3b84
- 20 | Success
-(12 rows)
-
-EXPLAIN (COSTS OFF) SELECT * FROM t2;
-   QUERY PLAN   
-----------------
- Seq Scan on t2
-(1 row)
-
-CREATE TABLE t3 AS SELECT * FROM t1;
-SELECT * FROM t3;
- a  |                b                 
-----+----------------------------------
-  0 | cfcd208495d565ef66e7dff9f98764da
-  2 | c81e728d9d4c2f636f067f89cc14862c
-  4 | a87ff679a2f3e71d9181a67b7542122c
-  6 | 1679091c5a880faf6fb5e6087eb1b2dc
-  8 | c9f0f895fb98ab9159f51fd0297e236d
- 10 | d3d9446802a44259755d38e6d163e820
- 12 | c20ad4d76fe97759aa27a0c99bff6710
- 14 | aab3238922bcc25a6f606eb525ffdc56
- 16 | c74d97b01eae257e44aa9d5bade97baf
- 18 | 6f4922f45568161a8cdf4ad2299f6d23
- 20 | 98f13708210194c475687be6106a3b84
- 20 | Success
-(12 rows)
-
-SELECT * INTO t4 FROM t1;
-SELECT * FROM t4;
- a  |                b                 
-----+----------------------------------
-  0 | cfcd208495d565ef66e7dff9f98764da
-  2 | c81e728d9d4c2f636f067f89cc14862c
-  4 | a87ff679a2f3e71d9181a67b7542122c
-  6 | 1679091c5a880faf6fb5e6087eb1b2dc
-  8 | c9f0f895fb98ab9159f51fd0297e236d
- 10 | d3d9446802a44259755d38e6d163e820
- 12 | c20ad4d76fe97759aa27a0c99bff6710
- 14 | aab3238922bcc25a6f606eb525ffdc56
- 16 | c74d97b01eae257e44aa9d5bade97baf
- 18 | 6f4922f45568161a8cdf4ad2299f6d23
- 20 | 98f13708210194c475687be6106a3b84
- 20 | Success
-(12 rows)
-
---
--- RLS with JOIN
---
-SET SESSION AUTHORIZATION regress_rls_alice;
-CREATE TABLE blog (id integer, author text, post text);
-CREATE TABLE comment (blog_id integer, message text);
-GRANT ALL ON blog, comment TO regress_rls_bob;
-CREATE POLICY blog_1 ON blog USING (id % 2 = 0);
-ALTER TABLE blog ENABLE ROW LEVEL SECURITY;
-INSERT INTO blog VALUES
-    (1, 'alice', 'blog #1'),
-    (2, 'bob', 'blog #1'),
-    (3, 'alice', 'blog #2'),
-    (4, 'alice', 'blog #3'),
-    (5, 'john', 'blog #1');
-INSERT INTO comment VALUES
-    (1, 'cool blog'),
-    (1, 'fun blog'),
-    (3, 'crazy blog'),
-    (5, 'what?'),
-    (4, 'insane!'),
-    (2, 'who did it?');
-SET SESSION AUTHORIZATION regress_rls_bob;
--- Check RLS JOIN with Non-RLS.
-SELECT id, author, message FROM blog JOIN comment ON id = blog_id;
- id | author |   message   
-----+--------+-------------
-  4 | alice  | insane!
-  2 | bob    | who did it?
-(2 rows)
-
--- Check Non-RLS JOIN with RLS.
-SELECT id, author, message FROM comment JOIN blog ON id = blog_id;
- id | author |   message   
-----+--------+-------------
-  4 | alice  | insane!
-  2 | bob    | who did it?
-(2 rows)
-
-SET SESSION AUTHORIZATION regress_rls_alice;
-CREATE POLICY comment_1 ON comment USING (blog_id < 4);
-ALTER TABLE comment ENABLE ROW LEVEL SECURITY;
-SET SESSION AUTHORIZATION regress_rls_bob;
--- Check RLS JOIN RLS
-SELECT id, author, message FROM blog JOIN comment ON id = blog_id;
- id | author |   message   
-----+--------+-------------
-  2 | bob    | who did it?
-(1 row)
-
-SELECT id, author, message FROM comment JOIN blog ON id = blog_id;
- id | author |   message   
-----+--------+-------------
-  2 | bob    | who did it?
-(1 row)
-
-SET SESSION AUTHORIZATION regress_rls_alice;
-DROP TABLE blog, comment;
---
--- Default Deny Policy
---
-RESET SESSION AUTHORIZATION;
-DROP POLICY p2 ON t1;
-ALTER TABLE t1 OWNER TO regress_rls_alice;
--- Check that default deny does not apply to superuser.
-RESET SESSION AUTHORIZATION;
-SELECT * FROM t1;
- a  |                b                 
-----+----------------------------------
-  1 | c4ca4238a0b923820dcc509a6f75849b
-  3 | eccbc87e4b5ce2fe28308fd9f2a7baf3
-  5 | e4da3b7fbbce2345d7772b0674a318d5
-  7 | 8f14e45fceea167a5a36dedd4bea2543
-  9 | 45c48cce2e2d7fbdea1afc51c7c6ad26
- 11 | 6512bd43d9caa6e02c990b0a82652dca
- 13 | c51ce410c124a10e0db5e4b97fc2af39
- 15 | 9bf31c7ff062936a96d3c8bd1f8f2ff3
- 17 | 70efdf2ec9b086079795c442636b55fb
- 19 | 1f0e3dad99908345f7439f8ffabdffc4
-  0 | cfcd208495d565ef66e7dff9f98764da
-  2 | c81e728d9d4c2f636f067f89cc14862c
-  4 | a87ff679a2f3e71d9181a67b7542122c
-  6 | 1679091c5a880faf6fb5e6087eb1b2dc
-  8 | c9f0f895fb98ab9159f51fd0297e236d
- 10 | d3d9446802a44259755d38e6d163e820
- 12 | c20ad4d76fe97759aa27a0c99bff6710
- 14 | aab3238922bcc25a6f606eb525ffdc56
- 16 | c74d97b01eae257e44aa9d5bade97baf
- 18 | 6f4922f45568161a8cdf4ad2299f6d23
- 20 | 98f13708210194c475687be6106a3b84
- 20 | Success
-(22 rows)
-
-EXPLAIN (COSTS OFF) SELECT * FROM t1;
-   QUERY PLAN   
-----------------
- Seq Scan on t1
-(1 row)
-
--- Check that default deny does not apply to table owner.
-SET SESSION AUTHORIZATION regress_rls_alice;
-SELECT * FROM t1;
- a  |                b                 
-----+----------------------------------
-  1 | c4ca4238a0b923820dcc509a6f75849b
-  3 | eccbc87e4b5ce2fe28308fd9f2a7baf3
-  5 | e4da3b7fbbce2345d7772b0674a318d5
-  7 | 8f14e45fceea167a5a36dedd4bea2543
-  9 | 45c48cce2e2d7fbdea1afc51c7c6ad26
- 11 | 6512bd43d9caa6e02c990b0a82652dca
- 13 | c51ce410c124a10e0db5e4b97fc2af39
- 15 | 9bf31c7ff062936a96d3c8bd1f8f2ff3
- 17 | 70efdf2ec9b086079795c442636b55fb
- 19 | 1f0e3dad99908345f7439f8ffabdffc4
-  0 | cfcd208495d565ef66e7dff9f98764da
-  2 | c81e728d9d4c2f636f067f89cc14862c
-  4 | a87ff679a2f3e71d9181a67b7542122c
-  6 | 1679091c5a880faf6fb5e6087eb1b2dc
-  8 | c9f0f895fb98ab9159f51fd0297e236d
- 10 | d3d9446802a44259755d38e6d163e820
- 12 | c20ad4d76fe97759aa27a0c99bff6710
- 14 | aab3238922bcc25a6f606eb525ffdc56
- 16 | c74d97b01eae257e44aa9d5bade97baf
- 18 | 6f4922f45568161a8cdf4ad2299f6d23
- 20 | 98f13708210194c475687be6106a3b84
- 20 | Success
-(22 rows)
-
-EXPLAIN (COSTS OFF) SELECT * FROM t1;
-   QUERY PLAN   
-----------------
- Seq Scan on t1
-(1 row)
-
--- Check that default deny applies to non-owner/non-superuser when RLS on.
-SET SESSION AUTHORIZATION regress_rls_bob;
-SET row_security TO ON;
-SELECT * FROM t1;
- a | b 
----+---
-(0 rows)
-
-EXPLAIN (COSTS OFF) SELECT * FROM t1;
-        QUERY PLAN        
---------------------------
- Result
-   One-Time Filter: false
-(2 rows)
-
-SET SESSION AUTHORIZATION regress_rls_bob;
-SELECT * FROM t1;
- a | b 
----+---
-(0 rows)
-
-EXPLAIN (COSTS OFF) SELECT * FROM t1;
-        QUERY PLAN        
---------------------------
- Result
-   One-Time Filter: false
-(2 rows)
-
---
--- COPY TO/FROM
---
-RESET SESSION AUTHORIZATION;
-DROP TABLE copy_t CASCADE;
-ERROR:  table "copy_t" does not exist
-CREATE TABLE copy_t (a integer, b text);
-CREATE POLICY p1 ON copy_t USING (a % 2 = 0);
-ALTER TABLE copy_t ENABLE ROW LEVEL SECURITY;
-GRANT ALL ON copy_t TO regress_rls_bob, regress_rls_exempt_user;
-INSERT INTO copy_t (SELECT x, md5(x::text) FROM generate_series(0,10) x);
--- Check COPY TO as Superuser/owner.
-RESET SESSION AUTHORIZATION;
-SET row_security TO OFF;
-COPY (SELECT * FROM copy_t ORDER BY a ASC) TO STDOUT WITH DELIMITER ',';
-0,cfcd208495d565ef66e7dff9f98764da
-1,c4ca4238a0b923820dcc509a6f75849b
-2,c81e728d9d4c2f636f067f89cc14862c
-3,eccbc87e4b5ce2fe28308fd9f2a7baf3
-4,a87ff679a2f3e71d9181a67b7542122c
-5,e4da3b7fbbce2345d7772b0674a318d5
-6,1679091c5a880faf6fb5e6087eb1b2dc
-7,8f14e45fceea167a5a36dedd4bea2543
-8,c9f0f895fb98ab9159f51fd0297e236d
-9,45c48cce2e2d7fbdea1afc51c7c6ad26
-10,d3d9446802a44259755d38e6d163e820
-SET row_security TO ON;
-COPY (SELECT * FROM copy_t ORDER BY a ASC) TO STDOUT WITH DELIMITER ',';
-0,cfcd208495d565ef66e7dff9f98764da
-1,c4ca4238a0b923820dcc509a6f75849b
-2,c81e728d9d4c2f636f067f89cc14862c
-3,eccbc87e4b5ce2fe28308fd9f2a7baf3
-4,a87ff679a2f3e71d9181a67b7542122c
-5,e4da3b7fbbce2345d7772b0674a318d5
-6,1679091c5a880faf6fb5e6087eb1b2dc
-7,8f14e45fceea167a5a36dedd4bea2543
-8,c9f0f895fb98ab9159f51fd0297e236d
-9,45c48cce2e2d7fbdea1afc51c7c6ad26
-10,d3d9446802a44259755d38e6d163e820
--- Check COPY TO as user with permissions.
-SET SESSION AUTHORIZATION regress_rls_bob;
-SET row_security TO OFF;
-COPY (SELECT * FROM copy_t ORDER BY a ASC) TO STDOUT WITH DELIMITER ','; --fail - would be affected by RLS
-ERROR:  query would be affected by row-level security policy for table "copy_t"
-SET row_security TO ON;
-COPY (SELECT * FROM copy_t ORDER BY a ASC) TO STDOUT WITH DELIMITER ','; --ok
-0,cfcd208495d565ef66e7dff9f98764da
-2,c81e728d9d4c2f636f067f89cc14862c
-4,a87ff679a2f3e71d9181a67b7542122c
-6,1679091c5a880faf6fb5e6087eb1b2dc
-8,c9f0f895fb98ab9159f51fd0297e236d
-10,d3d9446802a44259755d38e6d163e820
--- Check COPY TO as user with permissions and BYPASSRLS
-SET SESSION AUTHORIZATION regress_rls_exempt_user;
-SET row_security TO OFF;
-COPY (SELECT * FROM copy_t ORDER BY a ASC) TO STDOUT WITH DELIMITER ','; --ok
-0,cfcd208495d565ef66e7dff9f98764da
-1,c4ca4238a0b923820dcc509a6f75849b
-2,c81e728d9d4c2f636f067f89cc14862c
-3,eccbc87e4b5ce2fe28308fd9f2a7baf3
-4,a87ff679a2f3e71d9181a67b7542122c
-5,e4da3b7fbbce2345d7772b0674a318d5
-6,1679091c5a880faf6fb5e6087eb1b2dc
-7,8f14e45fceea167a5a36dedd4bea2543
-8,c9f0f895fb98ab9159f51fd0297e236d
-9,45c48cce2e2d7fbdea1afc51c7c6ad26
-10,d3d9446802a44259755d38e6d163e820
-SET row_security TO ON;
-COPY (SELECT * FROM copy_t ORDER BY a ASC) TO STDOUT WITH DELIMITER ','; --ok
-0,cfcd208495d565ef66e7dff9f98764da
-1,c4ca4238a0b923820dcc509a6f75849b
-2,c81e728d9d4c2f636f067f89cc14862c
-3,eccbc87e4b5ce2fe28308fd9f2a7baf3
-4,a87ff679a2f3e71d9181a67b7542122c
-5,e4da3b7fbbce2345d7772b0674a318d5
-6,1679091c5a880faf6fb5e6087eb1b2dc
-7,8f14e45fceea167a5a36dedd4bea2543
-8,c9f0f895fb98ab9159f51fd0297e236d
-9,45c48cce2e2d7fbdea1afc51c7c6ad26
-10,d3d9446802a44259755d38e6d163e820
--- Check COPY TO as user without permissions. SET row_security TO OFF;
-SET SESSION AUTHORIZATION regress_rls_carol;
-SET row_security TO OFF;
-COPY (SELECT * FROM copy_t ORDER BY a ASC) TO STDOUT WITH DELIMITER ','; --fail - would be affected by RLS
-ERROR:  query would be affected by row-level security policy for table "copy_t"
-SET row_security TO ON;
-COPY (SELECT * FROM copy_t ORDER BY a ASC) TO STDOUT WITH DELIMITER ','; --fail - permission denied
-ERROR:  permission denied for table copy_t
--- Check COPY relation TO; keep it just one row to avoid reordering issues
-RESET SESSION AUTHORIZATION;
-SET row_security TO ON;
-CREATE TABLE copy_rel_to (a integer, b text);
-CREATE POLICY p1 ON copy_rel_to USING (a % 2 = 0);
-ALTER TABLE copy_rel_to ENABLE ROW LEVEL SECURITY;
-GRANT ALL ON copy_rel_to TO regress_rls_bob, regress_rls_exempt_user;
-INSERT INTO copy_rel_to VALUES (1, md5('1'));
--- Check COPY TO as Superuser/owner.
-RESET SESSION AUTHORIZATION;
-SET row_security TO OFF;
-COPY copy_rel_to TO STDOUT WITH DELIMITER ',';
-1,c4ca4238a0b923820dcc509a6f75849b
-SET row_security TO ON;
-COPY copy_rel_to TO STDOUT WITH DELIMITER ',';
-1,c4ca4238a0b923820dcc509a6f75849b
--- Check COPY TO as user with permissions.
-SET SESSION AUTHORIZATION regress_rls_bob;
-SET row_security TO OFF;
-COPY copy_rel_to TO STDOUT WITH DELIMITER ','; --fail - would be affected by RLS
-ERROR:  query would be affected by row-level security policy for table "copy_rel_to"
-SET row_security TO ON;
-COPY copy_rel_to TO STDOUT WITH DELIMITER ','; --ok
--- Check COPY TO as user with permissions and BYPASSRLS
-SET SESSION AUTHORIZATION regress_rls_exempt_user;
-SET row_security TO OFF;
-COPY copy_rel_to TO STDOUT WITH DELIMITER ','; --ok
-1,c4ca4238a0b923820dcc509a6f75849b
-SET row_security TO ON;
-COPY copy_rel_to TO STDOUT WITH DELIMITER ','; --ok
-1,c4ca4238a0b923820dcc509a6f75849b
--- Check COPY TO as user without permissions. SET row_security TO OFF;
-SET SESSION AUTHORIZATION regress_rls_carol;
-SET row_security TO OFF;
-COPY copy_rel_to TO STDOUT WITH DELIMITER ','; --fail - permission denied
-ERROR:  permission denied for table copy_rel_to
-SET row_security TO ON;
-COPY copy_rel_to TO STDOUT WITH DELIMITER ','; --fail - permission denied
-ERROR:  permission denied for table copy_rel_to
--- Check COPY FROM as Superuser/owner.
-RESET SESSION AUTHORIZATION;
-SET row_security TO OFF;
-COPY copy_t FROM STDIN; --ok
-SET row_security TO ON;
-COPY copy_t FROM STDIN; --ok
--- Check COPY FROM as user with permissions.
-SET SESSION AUTHORIZATION regress_rls_bob;
-SET row_security TO OFF;
-COPY copy_t FROM STDIN; --fail - would be affected by RLS.
-ERROR:  query would be affected by row-level security policy for table "copy_t"
-SET row_security TO ON;
-COPY copy_t FROM STDIN; --fail - COPY FROM not supported by RLS.
-ERROR:  COPY FROM not supported with row-level security
-HINT:  Use INSERT statements instead.
--- Check COPY FROM as user with permissions and BYPASSRLS
-SET SESSION AUTHORIZATION regress_rls_exempt_user;
-SET row_security TO ON;
-COPY copy_t FROM STDIN; --ok
--- Check COPY FROM as user without permissions.
-SET SESSION AUTHORIZATION regress_rls_carol;
-SET row_security TO OFF;
-COPY copy_t FROM STDIN; --fail - permission denied.
-ERROR:  permission denied for table copy_t
-SET row_security TO ON;
-COPY copy_t FROM STDIN; --fail - permission denied.
-ERROR:  permission denied for table copy_t
-RESET SESSION AUTHORIZATION;
-DROP TABLE copy_t;
-DROP TABLE copy_rel_to CASCADE;
--- Check WHERE CURRENT OF
-SET SESSION AUTHORIZATION regress_rls_alice;
-CREATE TABLE current_check (currentid int, payload text, rlsuser text);
-GRANT ALL ON current_check TO PUBLIC;
-INSERT INTO current_check VALUES
-    (1, 'abc', 'regress_rls_bob'),
-    (2, 'bcd', 'regress_rls_bob'),
-    (3, 'cde', 'regress_rls_bob'),
-    (4, 'def', 'regress_rls_bob');
-CREATE POLICY p1 ON current_check FOR SELECT USING (currentid % 2 = 0);
-CREATE POLICY p2 ON current_check FOR DELETE USING (currentid = 4 AND rlsuser = current_user);
-CREATE POLICY p3 ON current_check FOR UPDATE USING (currentid = 4) WITH CHECK (rlsuser = current_user);
-ALTER TABLE current_check ENABLE ROW LEVEL SECURITY;
-SET SESSION AUTHORIZATION regress_rls_bob;
--- Can SELECT even rows
-SELECT * FROM current_check;
- currentid | payload |     rlsuser     
------------+---------+-----------------
-         2 | bcd     | regress_rls_bob
-         4 | def     | regress_rls_bob
-(2 rows)
-
--- Cannot UPDATE row 2
-UPDATE current_check SET payload = payload || '_new' WHERE currentid = 2 RETURNING *;
- currentid | payload | rlsuser 
------------+---------+---------
-(0 rows)
-
-BEGIN;
-DECLARE current_check_cursor SCROLL CURSOR FOR SELECT * FROM current_check;
--- Returns rows that can be seen according to SELECT policy, like plain SELECT
--- above (even rows)
-FETCH ABSOLUTE 1 FROM current_check_cursor;
- currentid | payload |     rlsuser     
------------+---------+-----------------
-         2 | bcd     | regress_rls_bob
-(1 row)
-
--- Still cannot UPDATE row 2 through cursor
-UPDATE current_check SET payload = payload || '_new' WHERE CURRENT OF current_check_cursor RETURNING *;
- currentid | payload | rlsuser 
------------+---------+---------
-(0 rows)
-
--- Can update row 4 through cursor, which is the next visible row
-FETCH RELATIVE 1 FROM current_check_cursor;
- currentid | payload |     rlsuser     
------------+---------+-----------------
-         4 | def     | regress_rls_bob
-(1 row)
-
-UPDATE current_check SET payload = payload || '_new' WHERE CURRENT OF current_check_cursor RETURNING *;
- currentid | payload |     rlsuser     
------------+---------+-----------------
-         4 | def_new | regress_rls_bob
-(1 row)
-
-SELECT * FROM current_check;
- currentid | payload |     rlsuser     
------------+---------+-----------------
-         2 | bcd     | regress_rls_bob
-         4 | def_new | regress_rls_bob
-(2 rows)
-
--- Plan should be a subquery TID scan
-EXPLAIN (COSTS OFF) UPDATE current_check SET payload = payload WHERE CURRENT OF current_check_cursor;
-                         QUERY PLAN                          
--------------------------------------------------------------
- Update on current_check
-   ->  Tid Scan on current_check
-         TID Cond: CURRENT OF current_check_cursor
-         Filter: ((currentid = 4) AND ((currentid % 2) = 0))
-(4 rows)
-
--- Similarly can only delete row 4
-FETCH ABSOLUTE 1 FROM current_check_cursor;
- currentid | payload |     rlsuser     
------------+---------+-----------------
-         2 | bcd     | regress_rls_bob
-(1 row)
-
-DELETE FROM current_check WHERE CURRENT OF current_check_cursor RETURNING *;
- currentid | payload | rlsuser 
------------+---------+---------
-(0 rows)
-
-FETCH RELATIVE 1 FROM current_check_cursor;
- currentid | payload |     rlsuser     
------------+---------+-----------------
-         4 | def     | regress_rls_bob
-(1 row)
-
-DELETE FROM current_check WHERE CURRENT OF current_check_cursor RETURNING *;
- currentid | payload |     rlsuser     
------------+---------+-----------------
-         4 | def_new | regress_rls_bob
-(1 row)
-
-SELECT * FROM current_check;
- currentid | payload |     rlsuser     
------------+---------+-----------------
-         2 | bcd     | regress_rls_bob
-(1 row)
-
-COMMIT;
---
--- check pg_stats view filtering
---
-SET row_security TO ON;
-SET SESSION AUTHORIZATION regress_rls_alice;
-ANALYZE current_check;
--- Stats visible
-SELECT row_security_active('current_check');
- row_security_active 
----------------------
- f
-(1 row)
-
-SELECT attname, most_common_vals FROM pg_stats
-  WHERE tablename = 'current_check'
-  ORDER BY 1;
-  attname  | most_common_vals  
------------+-------------------
- currentid | 
- payload   | 
- rlsuser   | {regress_rls_bob}
-(3 rows)
-
-SET SESSION AUTHORIZATION regress_rls_bob;
--- Stats not visible
-SELECT row_security_active('current_check');
- row_security_active 
----------------------
- t
-(1 row)
-
-SELECT attname, most_common_vals FROM pg_stats
-  WHERE tablename = 'current_check'
-  ORDER BY 1;
- attname | most_common_vals 
----------+------------------
-(0 rows)
-
---
--- Collation support
---
-BEGIN;
-CREATE TABLE coll_t (c) AS VALUES ('bar'::text);
-CREATE POLICY coll_p ON coll_t USING (c < ('foo'::text COLLATE "C"));
-ALTER TABLE coll_t ENABLE ROW LEVEL SECURITY;
-GRANT SELECT ON coll_t TO regress_rls_alice;
-SELECT (string_to_array(polqual, ':'))[7] AS inputcollid FROM pg_policy WHERE polrelid = 'coll_t'::regclass;
-   inputcollid    
-------------------
- inputcollid 950 
-(1 row)
-
-SET SESSION AUTHORIZATION regress_rls_alice;
-SELECT * FROM coll_t;
-  c  
------
- bar
-(1 row)
-
-ROLLBACK;
---
--- Shared Object Dependencies
---
-RESET SESSION AUTHORIZATION;
-BEGIN;
-CREATE ROLE regress_rls_eve;
-CREATE ROLE regress_rls_frank;
-CREATE TABLE tbl1 (c) AS VALUES ('bar'::text);
-GRANT SELECT ON TABLE tbl1 TO regress_rls_eve;
-CREATE POLICY P ON tbl1 TO regress_rls_eve, regress_rls_frank USING (true);
-SELECT refclassid::regclass, deptype
-  FROM pg_depend
-  WHERE classid = 'pg_policy'::regclass
-  AND refobjid = 'tbl1'::regclass;
- refclassid | deptype 
-------------+---------
- pg_class   | a
-(1 row)
-
-SELECT refclassid::regclass, deptype
-  FROM pg_shdepend
-  WHERE classid = 'pg_policy'::regclass
-  AND refobjid IN ('regress_rls_eve'::regrole, 'regress_rls_frank'::regrole);
- refclassid | deptype 
-------------+---------
- pg_authid  | r
- pg_authid  | r
-(2 rows)
-
-SAVEPOINT q;
-DROP ROLE regress_rls_eve; --fails due to dependency on POLICY p
-ERROR:  role "regress_rls_eve" cannot be dropped because some objects depend on it
-DETAIL:  privileges for table tbl1
-target of policy p on table tbl1
-ROLLBACK TO q;
-ALTER POLICY p ON tbl1 TO regress_rls_frank USING (true);
-SAVEPOINT q;
-DROP ROLE regress_rls_eve; --fails due to dependency on GRANT SELECT
-ERROR:  role "regress_rls_eve" cannot be dropped because some objects depend on it
-DETAIL:  privileges for table tbl1
-ROLLBACK TO q;
-REVOKE ALL ON TABLE tbl1 FROM regress_rls_eve;
-SAVEPOINT q;
-DROP ROLE regress_rls_eve; --succeeds
-ROLLBACK TO q;
-SAVEPOINT q;
-DROP ROLE regress_rls_frank; --fails due to dependency on POLICY p
-ERROR:  role "regress_rls_frank" cannot be dropped because some objects depend on it
-DETAIL:  target of policy p on table tbl1
-ROLLBACK TO q;
-DROP POLICY p ON tbl1;
-SAVEPOINT q;
-DROP ROLE regress_rls_frank; -- succeeds
-ROLLBACK TO q;
-ROLLBACK; -- cleanup
---
--- Converting table to view
---
-BEGIN;
-CREATE TABLE t (c int);
-CREATE POLICY p ON t USING (c % 2 = 1);
-ALTER TABLE t ENABLE ROW LEVEL SECURITY;
-SAVEPOINT q;
-CREATE RULE "_RETURN" AS ON SELECT TO t DO INSTEAD
-  SELECT * FROM generate_series(1,5) t0(c); -- fails due to row-level security enabled
-ERROR:  could not convert table "t" to a view because it has row security enabled
-ROLLBACK TO q;
-ALTER TABLE t DISABLE ROW LEVEL SECURITY;
-SAVEPOINT q;
-CREATE RULE "_RETURN" AS ON SELECT TO t DO INSTEAD
-  SELECT * FROM generate_series(1,5) t0(c); -- fails due to policy p on t
-ERROR:  could not convert table "t" to a view because it has row security policies
-ROLLBACK TO q;
-DROP POLICY p ON t;
-CREATE RULE "_RETURN" AS ON SELECT TO t DO INSTEAD
-  SELECT * FROM generate_series(1,5) t0(c); -- succeeds
-ROLLBACK;
---
--- Policy expression handling
---
-BEGIN;
-CREATE TABLE t (c) AS VALUES ('bar'::text);
-CREATE POLICY p ON t USING (max(c)); -- fails: aggregate functions are not allowed in policy expressions
-ERROR:  aggregate functions are not allowed in policy expressions
-ROLLBACK;
---
--- Non-target relations are only subject to SELECT policies
---
-SET SESSION AUTHORIZATION regress_rls_alice;
-CREATE TABLE r1 (a int);
-CREATE TABLE r2 (a int);
-INSERT INTO r1 VALUES (10), (20);
-INSERT INTO r2 VALUES (10), (20);
-GRANT ALL ON r1, r2 TO regress_rls_bob;
-CREATE POLICY p1 ON r1 USING (true);
-ALTER TABLE r1 ENABLE ROW LEVEL SECURITY;
-CREATE POLICY p1 ON r2 FOR SELECT USING (true);
-CREATE POLICY p2 ON r2 FOR INSERT WITH CHECK (false);
-CREATE POLICY p3 ON r2 FOR UPDATE USING (false);
-CREATE POLICY p4 ON r2 FOR DELETE USING (false);
-ALTER TABLE r2 ENABLE ROW LEVEL SECURITY;
-SET SESSION AUTHORIZATION regress_rls_bob;
-SELECT * FROM r1;
- a  
-----
- 10
- 20
-(2 rows)
-
-SELECT * FROM r2;
- a  
-----
- 10
- 20
-(2 rows)
-
--- r2 is read-only
-INSERT INTO r2 VALUES (2); -- Not allowed
-ERROR:  new row violates row-level security policy for table "r2"
-UPDATE r2 SET a = 2 RETURNING *; -- Updates nothing
- a 
----
-(0 rows)
-
-DELETE FROM r2 RETURNING *; -- Deletes nothing
- a 
----
-(0 rows)
-
--- r2 can be used as a non-target relation in DML
-INSERT INTO r1 SELECT a + 1 FROM r2 RETURNING *; -- OK
- a  
-----
- 11
- 21
-(2 rows)
-
-UPDATE r1 SET a = r2.a + 2 FROM r2 WHERE r1.a = r2.a RETURNING *; -- OK
- a  | a  
-----+----
- 12 | 10
- 22 | 20
-(2 rows)
-
-DELETE FROM r1 USING r2 WHERE r1.a = r2.a + 2 RETURNING *; -- OK
- a  | a  
-----+----
- 12 | 10
- 22 | 20
-(2 rows)
-
-SELECT * FROM r1;
- a  
-----
- 11
- 21
-(2 rows)
-
-SELECT * FROM r2;
- a  
-----
- 10
- 20
-(2 rows)
-
-SET SESSION AUTHORIZATION regress_rls_alice;
-DROP TABLE r1;
-DROP TABLE r2;
---
--- FORCE ROW LEVEL SECURITY applies RLS to owners too
---
-SET SESSION AUTHORIZATION regress_rls_alice;
-SET row_security = on;
-CREATE TABLE r1 (a int);
-INSERT INTO r1 VALUES (10), (20);
-CREATE POLICY p1 ON r1 USING (false);
-ALTER TABLE r1 ENABLE ROW LEVEL SECURITY;
-ALTER TABLE r1 FORCE ROW LEVEL SECURITY;
--- No error, but no rows
-TABLE r1;
- a 
----
-(0 rows)
-
--- RLS error
-INSERT INTO r1 VALUES (1);
-ERROR:  new row violates row-level security policy for table "r1"
--- No error (unable to see any rows to update)
-UPDATE r1 SET a = 1;
-TABLE r1;
- a 
----
-(0 rows)
-
--- No error (unable to see any rows to delete)
-DELETE FROM r1;
-TABLE r1;
- a 
----
-(0 rows)
-
-SET row_security = off;
--- these all fail, would be affected by RLS
-TABLE r1;
-ERROR:  query would be affected by row-level security policy for table "r1"
-HINT:  To disable the policy for the table's owner, use ALTER TABLE NO FORCE ROW LEVEL SECURITY.
-UPDATE r1 SET a = 1;
-ERROR:  query would be affected by row-level security policy for table "r1"
-HINT:  To disable the policy for the table's owner, use ALTER TABLE NO FORCE ROW LEVEL SECURITY.
-DELETE FROM r1;
-ERROR:  query would be affected by row-level security policy for table "r1"
-HINT:  To disable the policy for the table's owner, use ALTER TABLE NO FORCE ROW LEVEL SECURITY.
-DROP TABLE r1;
---
--- FORCE ROW LEVEL SECURITY does not break RI
---
-SET SESSION AUTHORIZATION regress_rls_alice;
-SET row_security = on;
-CREATE TABLE r1 (a int PRIMARY KEY);
-CREATE TABLE r2 (a int REFERENCES r1);
-INSERT INTO r1 VALUES (10), (20);
-INSERT INTO r2 VALUES (10), (20);
--- Create policies on r2 which prevent the
--- owner from seeing any rows, but RI should
--- still see them.
-CREATE POLICY p1 ON r2 USING (false);
-ALTER TABLE r2 ENABLE ROW LEVEL SECURITY;
-ALTER TABLE r2 FORCE ROW LEVEL SECURITY;
--- Errors due to rows in r2
-DELETE FROM r1;
-ERROR:  update or delete on table "r1" violates foreign key constraint "r2_a_fkey" on table "r2"
-DETAIL:  Key (a)=(10) is still referenced from table "r2".
--- Reset r2 to no-RLS
-DROP POLICY p1 ON r2;
-ALTER TABLE r2 NO FORCE ROW LEVEL SECURITY;
-ALTER TABLE r2 DISABLE ROW LEVEL SECURITY;
--- clean out r2 for INSERT test below
-DELETE FROM r2;
--- Change r1 to not allow rows to be seen
-CREATE POLICY p1 ON r1 USING (false);
-ALTER TABLE r1 ENABLE ROW LEVEL SECURITY;
-ALTER TABLE r1 FORCE ROW LEVEL SECURITY;
--- No rows seen
-TABLE r1;
- a 
----
-(0 rows)
-
--- No error, RI still sees that row exists in r1
-INSERT INTO r2 VALUES (10);
-DROP TABLE r2;
-DROP TABLE r1;
--- Ensure cascaded DELETE works
-CREATE TABLE r1 (a int PRIMARY KEY);
-CREATE TABLE r2 (a int REFERENCES r1 ON DELETE CASCADE);
-INSERT INTO r1 VALUES (10), (20);
-INSERT INTO r2 VALUES (10), (20);
--- Create policies on r2 which prevent the
--- owner from seeing any rows, but RI should
--- still see them.
-CREATE POLICY p1 ON r2 USING (false);
-ALTER TABLE r2 ENABLE ROW LEVEL SECURITY;
-ALTER TABLE r2 FORCE ROW LEVEL SECURITY;
--- Deletes all records from both
-DELETE FROM r1;
--- Remove FORCE from r2
-ALTER TABLE r2 NO FORCE ROW LEVEL SECURITY;
--- As owner, we now bypass RLS
--- verify no rows in r2 now
-TABLE r2;
- a 
----
-(0 rows)
-
-DROP TABLE r2;
-DROP TABLE r1;
--- Ensure cascaded UPDATE works
-CREATE TABLE r1 (a int PRIMARY KEY);
-CREATE TABLE r2 (a int REFERENCES r1 ON UPDATE CASCADE);
-INSERT INTO r1 VALUES (10), (20);
-INSERT INTO r2 VALUES (10), (20);
--- Create policies on r2 which prevent the
--- owner from seeing any rows, but RI should
--- still see them.
-CREATE POLICY p1 ON r2 USING (false);
-ALTER TABLE r2 ENABLE ROW LEVEL SECURITY;
-ALTER TABLE r2 FORCE ROW LEVEL SECURITY;
--- Updates records in both
-UPDATE r1 SET a = a+5;
--- Remove FORCE from r2
-ALTER TABLE r2 NO FORCE ROW LEVEL SECURITY;
--- As owner, we now bypass RLS
--- verify records in r2 updated
-TABLE r2;
- a  
-----
- 15
- 25
-(2 rows)
-
-DROP TABLE r2;
-DROP TABLE r1;
---
--- Test INSERT+RETURNING applies SELECT policies as
--- WithCheckOptions (meaning an error is thrown)
---
-SET SESSION AUTHORIZATION regress_rls_alice;
-SET row_security = on;
-CREATE TABLE r1 (a int);
-CREATE POLICY p1 ON r1 FOR SELECT USING (false);
-CREATE POLICY p2 ON r1 FOR INSERT WITH CHECK (true);
-ALTER TABLE r1 ENABLE ROW LEVEL SECURITY;
-ALTER TABLE r1 FORCE ROW LEVEL SECURITY;
--- Works fine
-INSERT INTO r1 VALUES (10), (20);
--- No error, but no rows
-TABLE r1;
- a 
----
-(0 rows)
-
-SET row_security = off;
--- fail, would be affected by RLS
-TABLE r1;
-ERROR:  query would be affected by row-level security policy for table "r1"
-HINT:  To disable the policy for the table's owner, use ALTER TABLE NO FORCE ROW LEVEL SECURITY.
-SET row_security = on;
--- Error
-INSERT INTO r1 VALUES (10), (20) RETURNING *;
-ERROR:  new row violates row-level security policy for table "r1"
-DROP TABLE r1;
---
--- Test UPDATE+RETURNING applies SELECT policies as
--- WithCheckOptions (meaning an error is thrown)
---
-SET SESSION AUTHORIZATION regress_rls_alice;
-SET row_security = on;
-CREATE TABLE r1 (a int PRIMARY KEY);
-CREATE POLICY p1 ON r1 FOR SELECT USING (a < 20);
-CREATE POLICY p2 ON r1 FOR UPDATE USING (a < 20) WITH CHECK (true);
-CREATE POLICY p3 ON r1 FOR INSERT WITH CHECK (true);
-INSERT INTO r1 VALUES (10);
-ALTER TABLE r1 ENABLE ROW LEVEL SECURITY;
-ALTER TABLE r1 FORCE ROW LEVEL SECURITY;
--- Works fine
-UPDATE r1 SET a = 30;
--- Show updated rows
-ALTER TABLE r1 NO FORCE ROW LEVEL SECURITY;
-TABLE r1;
- a  
-----
- 30
-(1 row)
-
--- reset value in r1 for test with RETURNING
-UPDATE r1 SET a = 10;
--- Verify row reset
-TABLE r1;
- a  
-----
- 10
-(1 row)
-
-ALTER TABLE r1 FORCE ROW LEVEL SECURITY;
--- Error
-UPDATE r1 SET a = 30 RETURNING *;
-ERROR:  new row violates row-level security policy for table "r1"
--- UPDATE path of INSERT ... ON CONFLICT DO UPDATE should also error out
-INSERT INTO r1 VALUES (10)
-    ON CONFLICT (a) DO UPDATE SET a = 30 RETURNING *;
-ERROR:  new row violates row-level security policy for table "r1"
--- Should still error out without RETURNING (use of arbiter always requires
--- SELECT permissions)
-INSERT INTO r1 VALUES (10)
-    ON CONFLICT (a) DO UPDATE SET a = 30;
-ERROR:  new row violates row-level security policy for table "r1"
-INSERT INTO r1 VALUES (10)
-    ON CONFLICT ON CONSTRAINT r1_pkey DO UPDATE SET a = 30;
-ERROR:  new row violates row-level security policy for table "r1"
-DROP TABLE r1;
--- Check dependency handling
-RESET SESSION AUTHORIZATION;
-CREATE TABLE dep1 (c1 int);
-CREATE TABLE dep2 (c1 int);
-CREATE POLICY dep_p1 ON dep1 TO regress_rls_bob USING (c1 > (select max(dep2.c1) from dep2));
-ALTER POLICY dep_p1 ON dep1 TO regress_rls_bob,regress_rls_carol;
--- Should return one
-SELECT count(*) = 1 FROM pg_depend
-				   WHERE objid = (SELECT oid FROM pg_policy WHERE polname = 'dep_p1')
-					 AND refobjid = (SELECT oid FROM pg_class WHERE relname = 'dep2');
- ?column? 
-----------
- t
-(1 row)
-
-ALTER POLICY dep_p1 ON dep1 USING (true);
--- Should return one
-SELECT count(*) = 1 FROM pg_shdepend
-				   WHERE objid = (SELECT oid FROM pg_policy WHERE polname = 'dep_p1')
-					 AND refobjid = (SELECT oid FROM pg_authid WHERE rolname = 'regress_rls_bob');
- ?column? 
-----------
- t
-(1 row)
-
--- Should return one
-SELECT count(*) = 1 FROM pg_shdepend
-				   WHERE objid = (SELECT oid FROM pg_policy WHERE polname = 'dep_p1')
-					 AND refobjid = (SELECT oid FROM pg_authid WHERE rolname = 'regress_rls_carol');
- ?column? 
-----------
- t
-(1 row)
-
--- Should return zero
-SELECT count(*) = 0 FROM pg_depend
-				   WHERE objid = (SELECT oid FROM pg_policy WHERE polname = 'dep_p1')
-					 AND refobjid = (SELECT oid FROM pg_class WHERE relname = 'dep2');
- ?column? 
-----------
- t
-(1 row)
-
--- DROP OWNED BY testing
-RESET SESSION AUTHORIZATION;
-CREATE ROLE regress_rls_dob_role1;
-CREATE ROLE regress_rls_dob_role2;
-CREATE TABLE dob_t1 (c1 int);
-CREATE TABLE dob_t2 (c1 int) PARTITION BY RANGE (c1);
-CREATE POLICY p1 ON dob_t1 TO regress_rls_dob_role1 USING (true);
-DROP OWNED BY regress_rls_dob_role1;
-DROP POLICY p1 ON dob_t1; -- should fail, already gone
-ERROR:  policy "p1" for table "dob_t1" does not exist
-CREATE POLICY p1 ON dob_t1 TO regress_rls_dob_role1,regress_rls_dob_role2 USING (true);
-DROP OWNED BY regress_rls_dob_role1;
-DROP POLICY p1 ON dob_t1; -- should succeed
--- same cases with duplicate polroles entries
-CREATE POLICY p1 ON dob_t1 TO regress_rls_dob_role1,regress_rls_dob_role1 USING (true);
-DROP OWNED BY regress_rls_dob_role1;
-DROP POLICY p1 ON dob_t1; -- should fail, already gone
-ERROR:  policy "p1" for table "dob_t1" does not exist
-CREATE POLICY p1 ON dob_t1 TO regress_rls_dob_role1,regress_rls_dob_role1,regress_rls_dob_role2 USING (true);
-DROP OWNED BY regress_rls_dob_role1;
-DROP POLICY p1 ON dob_t1; -- should succeed
--- partitioned target
-CREATE POLICY p1 ON dob_t2 TO regress_rls_dob_role1,regress_rls_dob_role2 USING (true);
-DROP OWNED BY regress_rls_dob_role1;
-DROP POLICY p1 ON dob_t2; -- should succeed
-DROP USER regress_rls_dob_role1;
-DROP USER regress_rls_dob_role2;
--- Bug #15708: view + table with RLS should check policies as view owner
-CREATE TABLE ref_tbl (a int);
-INSERT INTO ref_tbl VALUES (1);
-CREATE TABLE rls_tbl (a int);
-INSERT INTO rls_tbl VALUES (10);
-ALTER TABLE rls_tbl ENABLE ROW LEVEL SECURITY;
-CREATE POLICY p1 ON rls_tbl USING (EXISTS (SELECT 1 FROM ref_tbl));
-GRANT SELECT ON ref_tbl TO regress_rls_bob;
-GRANT SELECT ON rls_tbl TO regress_rls_bob;
-CREATE VIEW rls_view AS SELECT * FROM rls_tbl;
-ALTER VIEW rls_view OWNER TO regress_rls_bob;
-GRANT SELECT ON rls_view TO regress_rls_alice;
-SET SESSION AUTHORIZATION regress_rls_alice;
-SELECT * FROM ref_tbl; -- Permission denied
-ERROR:  permission denied for table ref_tbl
-SELECT * FROM rls_tbl; -- Permission denied
-ERROR:  permission denied for table rls_tbl
-SELECT * FROM rls_view; -- OK
- a  
-----
- 10
-(1 row)
-
-RESET SESSION AUTHORIZATION;
-DROP VIEW rls_view;
-DROP TABLE rls_tbl;
-DROP TABLE ref_tbl;
--- Leaky operator test
-CREATE TABLE rls_tbl (a int);
-INSERT INTO rls_tbl SELECT x/10 FROM generate_series(1, 100) x;
-ANALYZE rls_tbl;
-ALTER TABLE rls_tbl ENABLE ROW LEVEL SECURITY;
-GRANT SELECT ON rls_tbl TO regress_rls_alice;
-SET SESSION AUTHORIZATION regress_rls_alice;
-CREATE FUNCTION op_leak(int, int) RETURNS bool
-    AS 'BEGIN RAISE NOTICE ''op_leak => %, %'', $1, $2; RETURN $1 < $2; END'
-    LANGUAGE plpgsql;
-CREATE OPERATOR <<< (procedure = op_leak, leftarg = int, rightarg = int,
-                     restrict = scalarltsel);
-SELECT * FROM rls_tbl WHERE a <<< 1000;
- a 
----
-(0 rows)
-
-DROP OPERATOR <<< (int, int);
-DROP FUNCTION op_leak(int, int);
-RESET SESSION AUTHORIZATION;
-DROP TABLE rls_tbl;
--- Bug #16006: whole-row Vars in a policy don't play nice with sub-selects
-SET SESSION AUTHORIZATION regress_rls_alice;
-CREATE TABLE rls_tbl (a int, b int, c int);
-CREATE POLICY p1 ON rls_tbl USING (rls_tbl >= ROW(1,1,1));
-ALTER TABLE rls_tbl ENABLE ROW LEVEL SECURITY;
-ALTER TABLE rls_tbl FORCE ROW LEVEL SECURITY;
-INSERT INTO rls_tbl SELECT 10, 20, 30;
-EXPLAIN (VERBOSE, COSTS OFF)
-INSERT INTO rls_tbl
-  SELECT * FROM (SELECT b, c FROM rls_tbl ORDER BY a) ss;
-                             QUERY PLAN                             
---------------------------------------------------------------------
- Insert on regress_rls_schema.rls_tbl
-   ->  Subquery Scan on ss
-         Output: ss.b, ss.c, NULL::integer
-         ->  Sort
-               Output: rls_tbl_1.b, rls_tbl_1.c, rls_tbl_1.a
-               Sort Key: rls_tbl_1.a
-               ->  Seq Scan on regress_rls_schema.rls_tbl rls_tbl_1
-                     Output: rls_tbl_1.b, rls_tbl_1.c, rls_tbl_1.a
-                     Filter: (rls_tbl_1.* >= '(1,1,1)'::record)
-(9 rows)
-
-INSERT INTO rls_tbl
-  SELECT * FROM (SELECT b, c FROM rls_tbl ORDER BY a) ss;
-SELECT * FROM rls_tbl;
- a  | b  | c  
-----+----+----
- 10 | 20 | 30
- 20 | 30 |   
-(2 rows)
-
-DROP TABLE rls_tbl;
-RESET SESSION AUTHORIZATION;
---
--- Clean up objects
---
-RESET SESSION AUTHORIZATION;
-DROP SCHEMA regress_rls_schema CASCADE;
-NOTICE:  drop cascades to 29 other objects
-DETAIL:  drop cascades to function f_leak(text)
-drop cascades to table uaccount
-drop cascades to table category
-drop cascades to table document
-drop cascades to table part_document
-drop cascades to table dependent
-drop cascades to table rec1
-drop cascades to table rec2
-drop cascades to view rec1v
-drop cascades to view rec2v
-drop cascades to table s1
-drop cascades to table s2
-drop cascades to view v2
-drop cascades to table b1
-drop cascades to view bv1
-drop cascades to table z1
-drop cascades to table z2
-drop cascades to table x1
-drop cascades to table y1
-drop cascades to table y2
-drop cascades to table t1
-drop cascades to table t2
-drop cascades to table t3
-drop cascades to table t4
-drop cascades to table current_check
-drop cascades to table dep1
-drop cascades to table dep2
-drop cascades to table dob_t1
-drop cascades to table dob_t2
-DROP USER regress_rls_alice;
-DROP USER regress_rls_bob;
-DROP USER regress_rls_carol;
-DROP USER regress_rls_dave;
-DROP USER regress_rls_exempt_user;
-DROP ROLE regress_rls_group1;
-DROP ROLE regress_rls_group2;
--- Arrange to have a few policies left over, for testing
--- pg_dump/pg_restore
-CREATE SCHEMA regress_rls_schema;
-CREATE TABLE rls_tbl (c1 int);
-ALTER TABLE rls_tbl ENABLE ROW LEVEL SECURITY;
-CREATE POLICY p1 ON rls_tbl USING (c1 > 5);
-CREATE POLICY p2 ON rls_tbl FOR SELECT USING (c1 <= 3);
-CREATE POLICY p3 ON rls_tbl FOR UPDATE USING (c1 <= 3) WITH CHECK (c1 > 5);
-CREATE POLICY p4 ON rls_tbl FOR DELETE USING (c1 <= 3);
-CREATE TABLE rls_tbl_force (c1 int);
-ALTER TABLE rls_tbl_force ENABLE ROW LEVEL SECURITY;
-ALTER TABLE rls_tbl_force FORCE ROW LEVEL SECURITY;
-CREATE POLICY p1 ON rls_tbl_force USING (c1 = 5) WITH CHECK (c1 < 5);
-CREATE POLICY p2 ON rls_tbl_force FOR SELECT USING (c1 = 8);
-CREATE POLICY p3 ON rls_tbl_force FOR UPDATE USING (c1 = 8) WITH CHECK (c1 >= 5);
-CREATE POLICY p4 ON rls_tbl_force FOR DELETE USING (c1 = 8);
diff -U3 /Users/kenaniah/workspace/postgres/src/test/regress/expected/tablesample.out /Users/kenaniah/workspace/postgres/src/test/regress/results/tablesample.out
--- /Users/kenaniah/workspace/postgres/src/test/regress/expected/tablesample.out	2021-10-03 18:09:17.000000000 -0700
+++ /Users/kenaniah/workspace/postgres/src/test/regress/results/tablesample.out	2021-10-03 20:08:17.000000000 -0700
@@ -69,263 +69,11 @@
 CREATE VIEW test_tablesample_v2 AS
   SELECT id FROM test_tablesample TABLESAMPLE SYSTEM (99);
 \d+ test_tablesample_v1
-                     View "public.test_tablesample_v1"
- Column |  Type   | Collation | Nullable | Default | Storage | Description 
---------+---------+-----------+----------+---------+---------+-------------
- id     | integer |           |          |         | plain   | 
-View definition:
- SELECT test_tablesample.id
-   FROM test_tablesample TABLESAMPLE system ((10 * 2)) REPEATABLE (2);
+dyld: lazy symbol binding failed: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
+
+dyld: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
 
-\d+ test_tablesample_v2
-                     View "public.test_tablesample_v2"
- Column |  Type   | Collation | Nullable | Default | Storage | Description 
---------+---------+-----------+----------+---------+---------+-------------
- id     | integer |           |          |         | plain   | 
-View definition:
- SELECT test_tablesample.id
-   FROM test_tablesample TABLESAMPLE system (99);
-
--- check a sampled query doesn't affect cursor in progress
-BEGIN;
-DECLARE tablesample_cur SCROLL CURSOR FOR
-  SELECT id FROM test_tablesample TABLESAMPLE SYSTEM (50) REPEATABLE (0);
-FETCH FIRST FROM tablesample_cur;
- id 
-----
-  3
-(1 row)
-
-FETCH NEXT FROM tablesample_cur;
- id 
-----
-  4
-(1 row)
-
-FETCH NEXT FROM tablesample_cur;
- id 
-----
-  5
-(1 row)
-
-SELECT id FROM test_tablesample TABLESAMPLE SYSTEM (50) REPEATABLE (0);
- id 
-----
-  3
-  4
-  5
-  6
-  7
-  8
-(6 rows)
-
-FETCH NEXT FROM tablesample_cur;
- id 
-----
-  6
-(1 row)
-
-FETCH NEXT FROM tablesample_cur;
- id 
-----
-  7
-(1 row)
-
-FETCH NEXT FROM tablesample_cur;
- id 
-----
-  8
-(1 row)
-
-FETCH FIRST FROM tablesample_cur;
- id 
-----
-  3
-(1 row)
-
-FETCH NEXT FROM tablesample_cur;
- id 
-----
-  4
-(1 row)
-
-FETCH NEXT FROM tablesample_cur;
- id 
-----
-  5
-(1 row)
-
-FETCH NEXT FROM tablesample_cur;
- id 
-----
-  6
-(1 row)
-
-FETCH NEXT FROM tablesample_cur;
- id 
-----
-  7
-(1 row)
-
-FETCH NEXT FROM tablesample_cur;
- id 
-----
-  8
-(1 row)
-
-CLOSE tablesample_cur;
-END;
-EXPLAIN (COSTS OFF)
-  SELECT id FROM test_tablesample TABLESAMPLE SYSTEM (50) REPEATABLE (2);
-                             QUERY PLAN                             
---------------------------------------------------------------------
- Sample Scan on test_tablesample
-   Sampling: system ('50'::real) REPEATABLE ('2'::double precision)
-(2 rows)
-
-EXPLAIN (COSTS OFF)
-  SELECT * FROM test_tablesample_v1;
-                             QUERY PLAN                             
---------------------------------------------------------------------
- Sample Scan on test_tablesample
-   Sampling: system ('20'::real) REPEATABLE ('2'::double precision)
-(2 rows)
-
--- check inheritance behavior
-explain (costs off)
-  select count(*) from person tablesample bernoulli (100);
-                   QUERY PLAN                    
--------------------------------------------------
- Aggregate
-   ->  Append
-         ->  Sample Scan on person person_1
-               Sampling: bernoulli ('100'::real)
-         ->  Sample Scan on emp person_2
-               Sampling: bernoulli ('100'::real)
-         ->  Sample Scan on student person_3
-               Sampling: bernoulli ('100'::real)
-         ->  Sample Scan on stud_emp person_4
-               Sampling: bernoulli ('100'::real)
-(10 rows)
-
-select count(*) from person tablesample bernoulli (100);
- count 
--------
-    58
-(1 row)
-
-select count(*) from person;
- count 
--------
-    58
-(1 row)
-
--- check that collations get assigned within the tablesample arguments
-SELECT count(*) FROM test_tablesample TABLESAMPLE bernoulli (('1'::text < '0'::text)::int);
- count 
--------
-     0
-(1 row)
-
--- check behavior during rescans, as well as correct handling of min/max pct
-select * from
-  (values (0),(100)) v(pct),
-  lateral (select count(*) from tenk1 tablesample bernoulli (pct)) ss;
- pct | count 
------+-------
-   0 |     0
- 100 | 10000
-(2 rows)
-
-select * from
-  (values (0),(100)) v(pct),
-  lateral (select count(*) from tenk1 tablesample system (pct)) ss;
- pct | count 
------+-------
-   0 |     0
- 100 | 10000
-(2 rows)
-
-explain (costs off)
-select pct, count(unique1) from
-  (values (0),(100)) v(pct),
-  lateral (select * from tenk1 tablesample bernoulli (pct)) ss
-  group by pct;
-                       QUERY PLAN                       
---------------------------------------------------------
- HashAggregate
-   Group Key: "*VALUES*".column1
-   ->  Nested Loop
-         ->  Values Scan on "*VALUES*"
-         ->  Sample Scan on tenk1
-               Sampling: bernoulli ("*VALUES*".column1)
-(6 rows)
-
-select pct, count(unique1) from
-  (values (0),(100)) v(pct),
-  lateral (select * from tenk1 tablesample bernoulli (pct)) ss
-  group by pct;
- pct | count 
------+-------
- 100 | 10000
-(1 row)
-
-select pct, count(unique1) from
-  (values (0),(100)) v(pct),
-  lateral (select * from tenk1 tablesample system (pct)) ss
-  group by pct;
- pct | count 
------+-------
- 100 | 10000
-(1 row)
-
--- errors
-SELECT id FROM test_tablesample TABLESAMPLE FOOBAR (1);
-ERROR:  tablesample method foobar does not exist
-LINE 1: SELECT id FROM test_tablesample TABLESAMPLE FOOBAR (1);
-                                                    ^
-SELECT id FROM test_tablesample TABLESAMPLE SYSTEM (NULL);
-ERROR:  TABLESAMPLE parameter cannot be null
-SELECT id FROM test_tablesample TABLESAMPLE SYSTEM (50) REPEATABLE (NULL);
-ERROR:  TABLESAMPLE REPEATABLE parameter cannot be null
-SELECT id FROM test_tablesample TABLESAMPLE BERNOULLI (-1);
-ERROR:  sample percentage must be between 0 and 100
-SELECT id FROM test_tablesample TABLESAMPLE BERNOULLI (200);
-ERROR:  sample percentage must be between 0 and 100
-SELECT id FROM test_tablesample TABLESAMPLE SYSTEM (-1);
-ERROR:  sample percentage must be between 0 and 100
-SELECT id FROM test_tablesample TABLESAMPLE SYSTEM (200);
-ERROR:  sample percentage must be between 0 and 100
-SELECT id FROM test_tablesample_v1 TABLESAMPLE BERNOULLI (1);
-ERROR:  TABLESAMPLE clause can only be applied to tables and materialized views
-LINE 1: SELECT id FROM test_tablesample_v1 TABLESAMPLE BERNOULLI (1)...
-                       ^
-INSERT INTO test_tablesample_v1 VALUES(1);
-ERROR:  cannot insert into view "test_tablesample_v1"
-DETAIL:  Views containing TABLESAMPLE are not automatically updatable.
-HINT:  To enable inserting into the view, provide an INSTEAD OF INSERT trigger or an unconditional ON INSERT DO INSTEAD rule.
-WITH query_select AS (SELECT * FROM test_tablesample)
-SELECT * FROM query_select TABLESAMPLE BERNOULLI (5.5) REPEATABLE (1);
-ERROR:  TABLESAMPLE clause can only be applied to tables and materialized views
-LINE 2: SELECT * FROM query_select TABLESAMPLE BERNOULLI (5.5) REPEA...
-                      ^
-SELECT q.* FROM (SELECT * FROM test_tablesample) as q TABLESAMPLE BERNOULLI (5);
-ERROR:  syntax error at or near "TABLESAMPLE"
-LINE 1: ...CT q.* FROM (SELECT * FROM test_tablesample) as q TABLESAMPL...
-                                                             ^
--- check partitioned tables support tablesample
-create table parted_sample (a int) partition by list (a);
-create table parted_sample_1 partition of parted_sample for values in (1);
-create table parted_sample_2 partition of parted_sample for values in (2);
-explain (costs off)
-  select * from parted_sample tablesample bernoulli (100);
-                QUERY PLAN                 
--------------------------------------------
- Append
-   ->  Sample Scan on parted_sample_1
-         Sampling: bernoulli ('100'::real)
-   ->  Sample Scan on parted_sample_2
-         Sampling: bernoulli ('100'::real)
-(5 rows)
-
-drop table parted_sample, parted_sample_1, parted_sample_2;
diff -U3 /Users/kenaniah/workspace/postgres/src/test/regress/expected/identity.out /Users/kenaniah/workspace/postgres/src/test/regress/results/identity.out
--- /Users/kenaniah/workspace/postgres/src/test/regress/expected/identity.out	2021-10-03 17:41:49.000000000 -0700
+++ /Users/kenaniah/workspace/postgres/src/test/regress/results/identity.out	2021-10-03 20:08:17.000000000 -0700
@@ -33,530 +33,11 @@
 (1 row)
 
 \d itest1_a_seq
-                    Sequence "public.itest1_a_seq"
-  Type   | Start | Minimum |  Maximum   | Increment | Cycles? | Cache 
----------+-------+---------+------------+-----------+---------+-------
- integer |     1 |       1 | 2147483647 |         1 | no      |     1
-Sequence for identity column: public.itest1.a
+dyld: lazy symbol binding failed: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
+
+dyld: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
 
-CREATE TABLE itest4 (a int, b text);
-ALTER TABLE itest4 ALTER COLUMN a ADD GENERATED ALWAYS AS IDENTITY;  -- error, requires NOT NULL
-ERROR:  column "a" of relation "itest4" must be declared NOT NULL before identity can be added
-ALTER TABLE itest4 ALTER COLUMN a SET NOT NULL;
-ALTER TABLE itest4 ALTER COLUMN a ADD GENERATED ALWAYS AS IDENTITY;  -- ok
-ALTER TABLE itest4 ALTER COLUMN a DROP NOT NULL;  -- error, disallowed
-ERROR:  column "a" of relation "itest4" is an identity column
-ALTER TABLE itest4 ALTER COLUMN a ADD GENERATED ALWAYS AS IDENTITY;  -- error, already set
-ERROR:  column "a" of relation "itest4" is already an identity column
-ALTER TABLE itest4 ALTER COLUMN b ADD GENERATED ALWAYS AS IDENTITY;  -- error, wrong data type
-ERROR:  identity column type must be smallint, integer, or bigint
--- for later
-ALTER TABLE itest4 ALTER COLUMN b SET DEFAULT '';
--- invalid column type
-CREATE TABLE itest_err_1 (a text generated by default as identity);
-ERROR:  identity column type must be smallint, integer, or bigint
--- duplicate identity
-CREATE TABLE itest_err_2 (a int generated always as identity generated by default as identity);
-ERROR:  multiple identity specifications for column "a" of table "itest_err_2"
-LINE 1: ...E itest_err_2 (a int generated always as identity generated ...
-                                                             ^
--- cannot have default and identity
-CREATE TABLE itest_err_3 (a int default 5 generated by default as identity);
-ERROR:  both default and identity specified for column "a" of table "itest_err_3"
-LINE 1: CREATE TABLE itest_err_3 (a int default 5 generated by defau...
-                                                  ^
--- cannot combine serial and identity
-CREATE TABLE itest_err_4 (a serial generated by default as identity);
-ERROR:  both default and identity specified for column "a" of table "itest_err_4"
-INSERT INTO itest1 DEFAULT VALUES;
-INSERT INTO itest1 DEFAULT VALUES;
-INSERT INTO itest2 DEFAULT VALUES;
-INSERT INTO itest2 DEFAULT VALUES;
-INSERT INTO itest3 DEFAULT VALUES;
-INSERT INTO itest3 DEFAULT VALUES;
-INSERT INTO itest4 DEFAULT VALUES;
-INSERT INTO itest4 DEFAULT VALUES;
-SELECT * FROM itest1;
- a | b 
----+---
- 1 | 
- 2 | 
-(2 rows)
-
-SELECT * FROM itest2;
- a | b 
----+---
- 1 | 
- 2 | 
-(2 rows)
-
-SELECT * FROM itest3;
- a  | b 
-----+---
-  7 | 
- 12 | 
-(2 rows)
-
-SELECT * FROM itest4;
- a | b 
----+---
- 1 | 
- 2 | 
-(2 rows)
-
--- VALUES RTEs
-CREATE TABLE itest5 (a int generated always as identity, b text);
-INSERT INTO itest5 VALUES (1, 'a');  -- error
-ERROR:  cannot insert a non-DEFAULT value into column "a"
-DETAIL:  Column "a" is an identity column defined as GENERATED ALWAYS.
-HINT:  Use OVERRIDING SYSTEM VALUE to override.
-INSERT INTO itest5 VALUES (DEFAULT, 'a');  -- ok
-INSERT INTO itest5 VALUES (2, 'b'), (3, 'c');  -- error
-ERROR:  cannot insert a non-DEFAULT value into column "a"
-DETAIL:  Column "a" is an identity column defined as GENERATED ALWAYS.
-HINT:  Use OVERRIDING SYSTEM VALUE to override.
-INSERT INTO itest5 VALUES (DEFAULT, 'b'), (3, 'c');  -- error
-ERROR:  cannot insert a non-DEFAULT value into column "a"
-DETAIL:  Column "a" is an identity column defined as GENERATED ALWAYS.
-HINT:  Use OVERRIDING SYSTEM VALUE to override.
-INSERT INTO itest5 VALUES (2, 'b'), (DEFAULT, 'c');  -- error
-ERROR:  cannot insert a non-DEFAULT value into column "a"
-DETAIL:  Column "a" is an identity column defined as GENERATED ALWAYS.
-HINT:  Use OVERRIDING SYSTEM VALUE to override.
-INSERT INTO itest5 VALUES (DEFAULT, 'b'), (DEFAULT, 'c');  -- ok
-INSERT INTO itest5 OVERRIDING SYSTEM VALUE VALUES (-1, 'aa');
-INSERT INTO itest5 OVERRIDING SYSTEM VALUE VALUES (-2, 'bb'), (-3, 'cc');
-INSERT INTO itest5 OVERRIDING SYSTEM VALUE VALUES (DEFAULT, 'dd'), (-4, 'ee');
-INSERT INTO itest5 OVERRIDING SYSTEM VALUE VALUES (-5, 'ff'), (DEFAULT, 'gg');
-INSERT INTO itest5 OVERRIDING SYSTEM VALUE VALUES (DEFAULT, 'hh'), (DEFAULT, 'ii');
-INSERT INTO itest5 OVERRIDING USER VALUE VALUES (-1, 'aaa');
-INSERT INTO itest5 OVERRIDING USER VALUE VALUES (-2, 'bbb'), (-3, 'ccc');
-INSERT INTO itest5 OVERRIDING USER VALUE VALUES (DEFAULT, 'ddd'), (-4, 'eee');
-INSERT INTO itest5 OVERRIDING USER VALUE VALUES (-5, 'fff'), (DEFAULT, 'ggg');
-INSERT INTO itest5 OVERRIDING USER VALUE VALUES (DEFAULT, 'hhh'), (DEFAULT, 'iii');
-SELECT * FROM itest5;
- a  |  b  
-----+-----
-  1 | a
-  2 | b
-  3 | c
- -1 | aa
- -2 | bb
- -3 | cc
-  4 | dd
- -4 | ee
- -5 | ff
-  5 | gg
-  6 | hh
-  7 | ii
-  8 | aaa
-  9 | bbb
- 10 | ccc
- 11 | ddd
- 12 | eee
- 13 | fff
- 14 | ggg
- 15 | hhh
- 16 | iii
-(21 rows)
-
-DROP TABLE itest5;
-INSERT INTO itest3 VALUES (DEFAULT, 'a');
-INSERT INTO itest3 VALUES (DEFAULT, 'b'), (DEFAULT, 'c');
-SELECT * FROM itest3;
- a  | b 
-----+---
-  7 | 
- 12 | 
- 17 | a
- 22 | b
- 27 | c
-(5 rows)
-
--- OVERRIDING tests
--- GENERATED BY DEFAULT
--- This inserts the row as presented:
-INSERT INTO itest1 VALUES (10, 'xyz');
--- With GENERATED BY DEFAULT, OVERRIDING SYSTEM VALUE is not allowed
--- by the standard, but we allow it as a no-op, since it is of use if
--- there are multiple identity columns in a table, which is also an
--- extension.
-INSERT INTO itest1 OVERRIDING SYSTEM VALUE VALUES (20, 'xyz');
--- This ignores the 30 and uses the sequence value instead:
-INSERT INTO itest1 OVERRIDING USER VALUE VALUES (30, 'xyz');
-SELECT * FROM itest1;
- a  |  b  
-----+-----
-  1 | 
-  2 | 
- 10 | xyz
- 20 | xyz
-  3 | xyz
-(5 rows)
-
--- GENERATED ALWAYS
--- This is an error:
-INSERT INTO itest2 VALUES (10, 'xyz');
-ERROR:  cannot insert a non-DEFAULT value into column "a"
-DETAIL:  Column "a" is an identity column defined as GENERATED ALWAYS.
-HINT:  Use OVERRIDING SYSTEM VALUE to override.
--- This inserts the row as presented:
-INSERT INTO itest2 OVERRIDING SYSTEM VALUE VALUES (20, 'xyz');
--- This ignores the 30 and uses the sequence value instead:
-INSERT INTO itest2 OVERRIDING USER VALUE VALUES (30, 'xyz');
-SELECT * FROM itest2;
- a  |  b  
-----+-----
-  1 | 
-  2 | 
- 20 | xyz
-  3 | xyz
-(4 rows)
-
--- UPDATE tests
--- GENERATED BY DEFAULT is not restricted.
-UPDATE itest1 SET a = 101 WHERE a = 1;
-UPDATE itest1 SET a = DEFAULT WHERE a = 2;
-SELECT * FROM itest1;
-  a  |  b  
------+-----
-  10 | xyz
-  20 | xyz
-   3 | xyz
- 101 | 
-   4 | 
-(5 rows)
-
--- GENERATED ALWAYS allows only DEFAULT.
-UPDATE itest2 SET a = 101 WHERE a = 1;  -- error
-ERROR:  column "a" can only be updated to DEFAULT
-DETAIL:  Column "a" is an identity column defined as GENERATED ALWAYS.
-UPDATE itest2 SET a = DEFAULT WHERE a = 2;  -- ok
-SELECT * FROM itest2;
- a  |  b  
-----+-----
-  1 | 
- 20 | xyz
-  3 | xyz
-  4 | 
-(4 rows)
-
--- COPY tests
-CREATE TABLE itest9 (a int GENERATED ALWAYS AS IDENTITY, b text, c bigint);
-COPY itest9 FROM stdin;
-COPY itest9 (b, c) FROM stdin;
-SELECT * FROM itest9 ORDER BY c;
-  a  |  b   |  c  
------+------+-----
- 100 | foo  | 200
- 101 | bar  | 201
-   1 | foo2 | 202
-   2 | bar2 | 203
-(4 rows)
-
--- DROP IDENTITY tests
-ALTER TABLE itest4 ALTER COLUMN a DROP IDENTITY;
-ALTER TABLE itest4 ALTER COLUMN a DROP IDENTITY;  -- error
-ERROR:  column "a" of relation "itest4" is not an identity column
-ALTER TABLE itest4 ALTER COLUMN a DROP IDENTITY IF EXISTS;  -- noop
-NOTICE:  column "a" of relation "itest4" is not an identity column, skipping
-INSERT INTO itest4 DEFAULT VALUES;  -- fails because NOT NULL is not dropped
-ERROR:  null value in column "a" of relation "itest4" violates not-null constraint
-DETAIL:  Failing row contains (null, ).
-ALTER TABLE itest4 ALTER COLUMN a DROP NOT NULL;
-INSERT INTO itest4 DEFAULT VALUES;
-SELECT * FROM itest4;
- a | b 
----+---
- 1 | 
- 2 | 
-   | 
-(3 rows)
-
--- check that sequence is removed
-SELECT sequence_name FROM itest4_a_seq;
-ERROR:  relation "itest4_a_seq" does not exist
-LINE 1: SELECT sequence_name FROM itest4_a_seq;
-                                  ^
--- test views
-CREATE TABLE itest10 (a int generated by default as identity, b text);
-CREATE TABLE itest11 (a int generated always as identity, b text);
-CREATE VIEW itestv10 AS SELECT * FROM itest10;
-CREATE VIEW itestv11 AS SELECT * FROM itest11;
-INSERT INTO itestv10 DEFAULT VALUES;
-INSERT INTO itestv10 DEFAULT VALUES;
-INSERT INTO itestv11 DEFAULT VALUES;
-INSERT INTO itestv11 DEFAULT VALUES;
-SELECT * FROM itestv10;
- a | b 
----+---
- 1 | 
- 2 | 
-(2 rows)
-
-SELECT * FROM itestv11;
- a | b 
----+---
- 1 | 
- 2 | 
-(2 rows)
-
-INSERT INTO itestv10 VALUES (10, 'xyz');
-INSERT INTO itestv10 OVERRIDING USER VALUE VALUES (11, 'xyz');
-SELECT * FROM itestv10;
- a  |  b  
-----+-----
-  1 | 
-  2 | 
- 10 | xyz
-  3 | xyz
-(4 rows)
-
-INSERT INTO itestv11 VALUES (10, 'xyz');
-ERROR:  cannot insert a non-DEFAULT value into column "a"
-DETAIL:  Column "a" is an identity column defined as GENERATED ALWAYS.
-HINT:  Use OVERRIDING SYSTEM VALUE to override.
-INSERT INTO itestv11 OVERRIDING SYSTEM VALUE VALUES (11, 'xyz');
-SELECT * FROM itestv11;
- a  |  b  
-----+-----
-  1 | 
-  2 | 
- 11 | xyz
-(3 rows)
-
-DROP VIEW itestv10, itestv11;
--- ADD COLUMN
-CREATE TABLE itest13 (a int);
--- add column to empty table
-ALTER TABLE itest13 ADD COLUMN b int GENERATED BY DEFAULT AS IDENTITY;
-INSERT INTO itest13 VALUES (1), (2), (3);
--- add column to populated table
-ALTER TABLE itest13 ADD COLUMN c int GENERATED BY DEFAULT AS IDENTITY;
-SELECT * FROM itest13;
- a | b | c 
----+---+---
- 1 | 1 | 1
- 2 | 2 | 2
- 3 | 3 | 3
-(3 rows)
-
--- various ALTER COLUMN tests
--- fail, not allowed for identity columns
-ALTER TABLE itest1 ALTER COLUMN a SET DEFAULT 1;
-ERROR:  column "a" of relation "itest1" is an identity column
--- fail, not allowed, already has a default
-CREATE TABLE itest5 (a serial, b text);
-ALTER TABLE itest5 ALTER COLUMN a ADD GENERATED ALWAYS AS IDENTITY;
-ERROR:  column "a" of relation "itest5" already has a default value
-ALTER TABLE itest3 ALTER COLUMN a TYPE int;
-SELECT seqtypid::regtype FROM pg_sequence WHERE seqrelid = 'itest3_a_seq'::regclass;
- seqtypid 
-----------
- integer
-(1 row)
-
-\d itest3
-                           Table "public.itest3"
- Column |  Type   | Collation | Nullable |             Default              
---------+---------+-----------+----------+----------------------------------
- a      | integer |           | not null | generated by default as identity
- b      | text    |           |          | 
-
-ALTER TABLE itest3 ALTER COLUMN a TYPE text;  -- error
-ERROR:  identity column type must be smallint, integer, or bigint
--- kinda silly to change property in the same command, but it should work
-ALTER TABLE itest3
-  ADD COLUMN c int GENERATED BY DEFAULT AS IDENTITY,
-  ALTER COLUMN c SET GENERATED ALWAYS;
-\d itest3
-                           Table "public.itest3"
- Column |  Type   | Collation | Nullable |             Default              
---------+---------+-----------+----------+----------------------------------
- a      | integer |           | not null | generated by default as identity
- b      | text    |           |          | 
- c      | integer |           | not null | generated always as identity
-
--- ALTER COLUMN ... SET
-CREATE TABLE itest6 (a int GENERATED ALWAYS AS IDENTITY, b text);
-INSERT INTO itest6 DEFAULT VALUES;
-ALTER TABLE itest6 ALTER COLUMN a SET GENERATED BY DEFAULT SET INCREMENT BY 2 SET START WITH 100 RESTART;
-INSERT INTO itest6 DEFAULT VALUES;
-INSERT INTO itest6 DEFAULT VALUES;
-SELECT * FROM itest6;
-  a  | b 
------+---
-   1 | 
- 100 | 
- 102 | 
-(3 rows)
-
-SELECT table_name, column_name, is_identity, identity_generation FROM information_schema.columns WHERE table_name = 'itest6' ORDER BY 1, 2;
- table_name | column_name | is_identity | identity_generation 
-------------+-------------+-------------+---------------------
- itest6     | a           | YES         | BY DEFAULT
- itest6     | b           | NO          | 
-(2 rows)
-
-ALTER TABLE itest6 ALTER COLUMN b SET INCREMENT BY 2;  -- fail, not identity
-ERROR:  column "b" of relation "itest6" is not an identity column
--- prohibited direct modification of sequence
-ALTER SEQUENCE itest6_a_seq OWNED BY NONE;
-ERROR:  cannot change ownership of identity sequence
-DETAIL:  Sequence "itest6_a_seq" is linked to table "itest6".
--- inheritance
-CREATE TABLE itest7 (a int GENERATED ALWAYS AS IDENTITY);
-INSERT INTO itest7 DEFAULT VALUES;
-SELECT * FROM itest7;
- a 
----
- 1
-(1 row)
-
--- identity property is not inherited
-CREATE TABLE itest7a (b text) INHERITS (itest7);
--- make column identity in child table
-CREATE TABLE itest7b (a int);
-CREATE TABLE itest7c (a int GENERATED ALWAYS AS IDENTITY) INHERITS (itest7b);
-NOTICE:  merging column "a" with inherited definition
-INSERT INTO itest7c DEFAULT VALUES;
-SELECT * FROM itest7c;
- a 
----
- 1
-(1 row)
-
-CREATE TABLE itest7d (a int not null);
-CREATE TABLE itest7e () INHERITS (itest7d);
-ALTER TABLE itest7d ALTER COLUMN a ADD GENERATED ALWAYS AS IDENTITY;
-ALTER TABLE itest7d ADD COLUMN b int GENERATED ALWAYS AS IDENTITY;  -- error
-ERROR:  cannot recursively add identity column to table that has child tables
-SELECT table_name, column_name, is_nullable, is_identity, identity_generation FROM information_schema.columns WHERE table_name LIKE 'itest7%' ORDER BY 1, 2;
- table_name | column_name | is_nullable | is_identity | identity_generation 
-------------+-------------+-------------+-------------+---------------------
- itest7     | a           | NO          | YES         | ALWAYS
- itest7a    | a           | NO          | NO          | 
- itest7a    | b           | YES         | NO          | 
- itest7b    | a           | YES         | NO          | 
- itest7c    | a           | NO          | YES         | ALWAYS
- itest7d    | a           | NO          | YES         | ALWAYS
- itest7e    | a           | NO          | NO          | 
-(7 rows)
-
--- These ALTER TABLE variants will not recurse.
-ALTER TABLE itest7 ALTER COLUMN a SET GENERATED BY DEFAULT;
-ALTER TABLE itest7 ALTER COLUMN a RESTART;
-ALTER TABLE itest7 ALTER COLUMN a DROP IDENTITY;
--- privileges
-CREATE USER regress_identity_user1;
-CREATE TABLE itest8 (a int GENERATED ALWAYS AS IDENTITY, b text);
-GRANT SELECT, INSERT ON itest8 TO regress_identity_user1;
-SET ROLE regress_identity_user1;
-INSERT INTO itest8 DEFAULT VALUES;
-SELECT * FROM itest8;
- a | b 
----+---
- 1 | 
-(1 row)
-
-RESET ROLE;
-DROP TABLE itest8;
-DROP USER regress_identity_user1;
--- multiple steps in ALTER TABLE
-CREATE TABLE itest8 (f1 int);
-ALTER TABLE itest8
-  ADD COLUMN f2 int NOT NULL,
-  ALTER COLUMN f2 ADD GENERATED ALWAYS AS IDENTITY;
-ALTER TABLE itest8
-  ADD COLUMN f3 int NOT NULL,
-  ALTER COLUMN f3 ADD GENERATED ALWAYS AS IDENTITY,
-  ALTER COLUMN f3 SET GENERATED BY DEFAULT SET INCREMENT 10;
-ALTER TABLE itest8
-  ADD COLUMN f4 int;
-ALTER TABLE itest8
-  ALTER COLUMN f4 SET NOT NULL,
-  ALTER COLUMN f4 ADD GENERATED ALWAYS AS IDENTITY,
-  ALTER COLUMN f4 SET DATA TYPE bigint;
-ALTER TABLE itest8
-  ADD COLUMN f5 int GENERATED ALWAYS AS IDENTITY;
-ALTER TABLE itest8
-  ALTER COLUMN f5 DROP IDENTITY,
-  ALTER COLUMN f5 DROP NOT NULL,
-  ALTER COLUMN f5 SET DATA TYPE bigint;
-INSERT INTO itest8 VALUES(0), (1);
--- This does not work when the table isn't empty.  That's intentional,
--- since ADD GENERATED should only affect later insertions:
-ALTER TABLE itest8
-  ADD COLUMN f22 int NOT NULL,
-  ALTER COLUMN f22 ADD GENERATED ALWAYS AS IDENTITY;
-ERROR:  column "f22" of relation "itest8" contains null values
-TABLE itest8;
- f1 | f2 | f3 | f4 | f5 
-----+----+----+----+----
-  0 |  1 |  1 |  1 |   
-  1 |  2 | 11 |  2 |   
-(2 rows)
-
-\d+ itest8
-                                               Table "public.itest8"
- Column |  Type   | Collation | Nullable |             Default              | Storage | Stats target | Description 
---------+---------+-----------+----------+----------------------------------+---------+--------------+-------------
- f1     | integer |           |          |                                  | plain   |              | 
- f2     | integer |           | not null | generated always as identity     | plain   |              | 
- f3     | integer |           | not null | generated by default as identity | plain   |              | 
- f4     | bigint  |           | not null | generated always as identity     | plain   |              | 
- f5     | bigint  |           |          |                                  | plain   |              | 
-
-\d itest8_f2_seq
-                   Sequence "public.itest8_f2_seq"
-  Type   | Start | Minimum |  Maximum   | Increment | Cycles? | Cache 
----------+-------+---------+------------+-----------+---------+-------
- integer |     1 |       1 | 2147483647 |         1 | no      |     1
-Sequence for identity column: public.itest8.f2
-
-\d itest8_f3_seq
-                   Sequence "public.itest8_f3_seq"
-  Type   | Start | Minimum |  Maximum   | Increment | Cycles? | Cache 
----------+-------+---------+------------+-----------+---------+-------
- integer |     1 |       1 | 2147483647 |        10 | no      |     1
-Sequence for identity column: public.itest8.f3
-
-\d itest8_f4_seq
-                       Sequence "public.itest8_f4_seq"
-  Type  | Start | Minimum |       Maximum       | Increment | Cycles? | Cache 
---------+-------+---------+---------------------+-----------+---------+-------
- bigint |     1 |       1 | 9223372036854775807 |         1 | no      |     1
-Sequence for identity column: public.itest8.f4
-
-\d itest8_f5_seq
-DROP TABLE itest8;
--- typed tables (currently not supported)
-CREATE TYPE itest_type AS (f1 integer, f2 text, f3 bigint);
-CREATE TABLE itest12 OF itest_type (f1 WITH OPTIONS GENERATED ALWAYS AS IDENTITY); -- error
-ERROR:  identity columns are not supported on typed tables
-DROP TYPE itest_type CASCADE;
--- table partitions (currently not supported)
-CREATE TABLE itest_parent (f1 date NOT NULL, f2 text, f3 bigint) PARTITION BY RANGE (f1);
-CREATE TABLE itest_child PARTITION OF itest_parent (
-    f3 WITH OPTIONS GENERATED ALWAYS AS IDENTITY
-) FOR VALUES FROM ('2016-07-01') TO ('2016-08-01'); -- error
-ERROR:  identity columns are not supported on partitions
-DROP TABLE itest_parent;
--- test that sequence of half-dropped serial column is properly ignored
-CREATE TABLE itest14 (id serial);
-ALTER TABLE itest14 ALTER id DROP DEFAULT;
-ALTER TABLE itest14 ALTER id ADD GENERATED BY DEFAULT AS IDENTITY;
-INSERT INTO itest14 (id) VALUES (DEFAULT);
--- Identity columns must be NOT NULL (cf bug #16913)
-CREATE TABLE itest15 (id integer GENERATED ALWAYS AS IDENTITY NULL); -- fail
-ERROR:  conflicting NULL/NOT NULL declarations for column "id" of table "itest15"
-LINE 1: ...ABLE itest15 (id integer GENERATED ALWAYS AS IDENTITY NULL);
-                                                                 ^
-CREATE TABLE itest15 (id integer NULL GENERATED ALWAYS AS IDENTITY); -- fail
-ERROR:  conflicting NULL/NOT NULL declarations for column "id" of table "itest15"
-LINE 1: CREATE TABLE itest15 (id integer NULL GENERATED ALWAYS AS ID...
-                                              ^
-CREATE TABLE itest15 (id integer GENERATED ALWAYS AS IDENTITY NOT NULL);
-DROP TABLE itest15;
-CREATE TABLE itest15 (id integer NOT NULL GENERATED ALWAYS AS IDENTITY);
-DROP TABLE itest15;
diff -U3 /Users/kenaniah/workspace/postgres/src/test/regress/expected/generated.out /Users/kenaniah/workspace/postgres/src/test/regress/results/generated.out
--- /Users/kenaniah/workspace/postgres/src/test/regress/expected/generated.out	2021-10-03 17:41:49.000000000 -0700
+++ /Users/kenaniah/workspace/postgres/src/test/regress/results/generated.out	2021-10-03 20:08:17.000000000 -0700
@@ -22,1044 +22,11 @@
 (1 row)
 
 \d gtest1
-                            Table "public.gtest1"
- Column |  Type   | Collation | Nullable |              Default               
---------+---------+-----------+----------+------------------------------------
- a      | integer |           | not null | 
- b      | integer |           |          | generated always as (a * 2) stored
-Indexes:
-    "gtest1_pkey" PRIMARY KEY, btree (a)
-
--- duplicate generated
-CREATE TABLE gtest_err_1 (a int PRIMARY KEY, b int GENERATED ALWAYS AS (a * 2) STORED GENERATED ALWAYS AS (a * 3) STORED);
-ERROR:  multiple generation clauses specified for column "b" of table "gtest_err_1"
-LINE 1: ...ARY KEY, b int GENERATED ALWAYS AS (a * 2) STORED GENERATED ...
-                                                             ^
--- references to other generated columns, including self-references
-CREATE TABLE gtest_err_2a (a int PRIMARY KEY, b int GENERATED ALWAYS AS (b * 2) STORED);
-ERROR:  cannot use generated column "b" in column generation expression
-LINE 1: ...2a (a int PRIMARY KEY, b int GENERATED ALWAYS AS (b * 2) STO...
-                                                             ^
-DETAIL:  A generated column cannot reference another generated column.
-CREATE TABLE gtest_err_2b (a int PRIMARY KEY, b int GENERATED ALWAYS AS (a * 2) STORED, c int GENERATED ALWAYS AS (b * 3) STORED);
-ERROR:  cannot use generated column "b" in column generation expression
-LINE 1: ...AYS AS (a * 2) STORED, c int GENERATED ALWAYS AS (b * 3) STO...
-                                                             ^
-DETAIL:  A generated column cannot reference another generated column.
--- a whole-row var is a self-reference on steroids, so disallow that too
-CREATE TABLE gtest_err_2c (a int PRIMARY KEY,
-    b int GENERATED ALWAYS AS (num_nulls(gtest_err_2c)) STORED);
-ERROR:  cannot use whole-row variable in column generation expression
-LINE 2:     b int GENERATED ALWAYS AS (num_nulls(gtest_err_2c)) STOR...
-                                                 ^
-DETAIL:  This would cause the generated column to depend on its own value.
--- invalid reference
-CREATE TABLE gtest_err_3 (a int PRIMARY KEY, b int GENERATED ALWAYS AS (c * 2) STORED);
-ERROR:  column "c" does not exist
-LINE 1: ..._3 (a int PRIMARY KEY, b int GENERATED ALWAYS AS (c * 2) STO...
-                                                             ^
--- generation expression must be immutable
-CREATE TABLE gtest_err_4 (a int PRIMARY KEY, b double precision GENERATED ALWAYS AS (random()) STORED);
-ERROR:  generation expression is not immutable
--- cannot have default/identity and generated
-CREATE TABLE gtest_err_5a (a int PRIMARY KEY, b int DEFAULT 5 GENERATED ALWAYS AS (a * 2) STORED);
-ERROR:  both default and generation expression specified for column "b" of table "gtest_err_5a"
-LINE 1: ... gtest_err_5a (a int PRIMARY KEY, b int DEFAULT 5 GENERATED ...
-                                                             ^
-CREATE TABLE gtest_err_5b (a int PRIMARY KEY, b int GENERATED ALWAYS AS identity GENERATED ALWAYS AS (a * 2) STORED);
-ERROR:  both identity and generation expression specified for column "b" of table "gtest_err_5b"
-LINE 1: ...t PRIMARY KEY, b int GENERATED ALWAYS AS identity GENERATED ...
-                                                             ^
--- reference to system column not allowed in generated column
--- (except tableoid, which we test below)
-CREATE TABLE gtest_err_6a (a int PRIMARY KEY, b bool GENERATED ALWAYS AS (xmin <> 37) STORED);
-ERROR:  cannot use system column "xmin" in column generation expression
-LINE 1: ...a (a int PRIMARY KEY, b bool GENERATED ALWAYS AS (xmin <> 37...
-                                                             ^
--- various prohibited constructs
-CREATE TABLE gtest_err_7a (a int PRIMARY KEY, b int GENERATED ALWAYS AS (avg(a)) STORED);
-ERROR:  aggregate functions are not allowed in column generation expressions
-LINE 1: ...7a (a int PRIMARY KEY, b int GENERATED ALWAYS AS (avg(a)) ST...
-                                                             ^
-CREATE TABLE gtest_err_7b (a int PRIMARY KEY, b int GENERATED ALWAYS AS (row_number() OVER (ORDER BY a)) STORED);
-ERROR:  window functions are not allowed in column generation expressions
-LINE 1: ...7b (a int PRIMARY KEY, b int GENERATED ALWAYS AS (row_number...
-                                                             ^
-CREATE TABLE gtest_err_7c (a int PRIMARY KEY, b int GENERATED ALWAYS AS ((SELECT a)) STORED);
-ERROR:  cannot use subquery in column generation expression
-LINE 1: ...7c (a int PRIMARY KEY, b int GENERATED ALWAYS AS ((SELECT a)...
-                                                             ^
-CREATE TABLE gtest_err_7d (a int PRIMARY KEY, b int GENERATED ALWAYS AS (generate_series(1, a)) STORED);
-ERROR:  set-returning functions are not allowed in column generation expressions
-LINE 1: ...7d (a int PRIMARY KEY, b int GENERATED ALWAYS AS (generate_s...
-                                                             ^
--- GENERATED BY DEFAULT not allowed
-CREATE TABLE gtest_err_8 (a int PRIMARY KEY, b int GENERATED BY DEFAULT AS (a * 2) STORED);
-ERROR:  for a generated column, GENERATED ALWAYS must be specified
-LINE 1: ...E gtest_err_8 (a int PRIMARY KEY, b int GENERATED BY DEFAULT...
-                                                             ^
-INSERT INTO gtest1 VALUES (1);
-INSERT INTO gtest1 VALUES (2, DEFAULT);  -- ok
-INSERT INTO gtest1 VALUES (3, 33);  -- error
-ERROR:  cannot insert a non-DEFAULT value into column "b"
-DETAIL:  Column "b" is a generated column.
-INSERT INTO gtest1 VALUES (3, 33), (4, 44);  -- error
-ERROR:  cannot insert a non-DEFAULT value into column "b"
-DETAIL:  Column "b" is a generated column.
-INSERT INTO gtest1 VALUES (3, DEFAULT), (4, 44);  -- error
-ERROR:  cannot insert a non-DEFAULT value into column "b"
-DETAIL:  Column "b" is a generated column.
-INSERT INTO gtest1 VALUES (3, 33), (4, DEFAULT);  -- error
-ERROR:  cannot insert a non-DEFAULT value into column "b"
-DETAIL:  Column "b" is a generated column.
-INSERT INTO gtest1 VALUES (3, DEFAULT), (4, DEFAULT);  -- ok
-SELECT * FROM gtest1 ORDER BY a;
- a | b 
----+---
- 1 | 2
- 2 | 4
- 3 | 6
- 4 | 8
-(4 rows)
-
-DELETE FROM gtest1 WHERE a >= 3;
-UPDATE gtest1 SET b = DEFAULT WHERE a = 1;
-UPDATE gtest1 SET b = 11 WHERE a = 1;  -- error
-ERROR:  column "b" can only be updated to DEFAULT
-DETAIL:  Column "b" is a generated column.
-SELECT * FROM gtest1 ORDER BY a;
- a | b 
----+---
- 1 | 2
- 2 | 4
-(2 rows)
-
-SELECT a, b, b * 2 AS b2 FROM gtest1 ORDER BY a;
- a | b | b2 
----+---+----
- 1 | 2 |  4
- 2 | 4 |  8
-(2 rows)
-
-SELECT a, b FROM gtest1 WHERE b = 4 ORDER BY a;
- a | b 
----+---
- 2 | 4
-(1 row)
-
--- test that overflow error happens on write
-INSERT INTO gtest1 VALUES (2000000000);
-ERROR:  integer out of range
-SELECT * FROM gtest1;
- a | b 
----+---
- 2 | 4
- 1 | 2
-(2 rows)
-
-DELETE FROM gtest1 WHERE a = 2000000000;
--- test with joins
-CREATE TABLE gtestx (x int, y int);
-INSERT INTO gtestx VALUES (11, 1), (22, 2), (33, 3);
-SELECT * FROM gtestx, gtest1 WHERE gtestx.y = gtest1.a;
- x  | y | a | b 
-----+---+---+---
- 11 | 1 | 1 | 2
- 22 | 2 | 2 | 4
-(2 rows)
-
-DROP TABLE gtestx;
--- test UPDATE/DELETE quals
-SELECT * FROM gtest1 ORDER BY a;
- a | b 
----+---
- 1 | 2
- 2 | 4
-(2 rows)
-
-UPDATE gtest1 SET a = 3 WHERE b = 4;
-SELECT * FROM gtest1 ORDER BY a;
- a | b 
----+---
- 1 | 2
- 3 | 6
-(2 rows)
-
-DELETE FROM gtest1 WHERE b = 2;
-SELECT * FROM gtest1 ORDER BY a;
- a | b 
----+---
- 3 | 6
-(1 row)
-
--- views
-CREATE VIEW gtest1v AS SELECT * FROM gtest1;
-SELECT * FROM gtest1v;
- a | b 
----+---
- 3 | 6
-(1 row)
-
-INSERT INTO gtest1v VALUES (4, 8);  -- error
-ERROR:  cannot insert a non-DEFAULT value into column "b"
-DETAIL:  Column "b" is a generated column.
-INSERT INTO gtest1v VALUES (5, DEFAULT);  -- ok
-INSERT INTO gtest1v VALUES (6, 66), (7, 77);  -- error
-ERROR:  cannot insert a non-DEFAULT value into column "b"
-DETAIL:  Column "b" is a generated column.
-INSERT INTO gtest1v VALUES (6, DEFAULT), (7, 77);  -- error
-ERROR:  cannot insert a non-DEFAULT value into column "b"
-DETAIL:  Column "b" is a generated column.
-INSERT INTO gtest1v VALUES (6, 66), (7, DEFAULT);  -- error
-ERROR:  cannot insert a non-DEFAULT value into column "b"
-DETAIL:  Column "b" is a generated column.
-INSERT INTO gtest1v VALUES (6, DEFAULT), (7, DEFAULT);  -- ok
-ALTER VIEW gtest1v ALTER COLUMN b SET DEFAULT 100;
-INSERT INTO gtest1v VALUES (8, DEFAULT);  -- error
-ERROR:  cannot insert a non-DEFAULT value into column "b"
-DETAIL:  Column "b" is a generated column.
-INSERT INTO gtest1v VALUES (8, DEFAULT), (9, DEFAULT);  -- error
-ERROR:  cannot insert a non-DEFAULT value into column "b"
-DETAIL:  Column "b" is a generated column.
-SELECT * FROM gtest1v;
- a | b  
----+----
- 3 |  6
- 5 | 10
- 6 | 12
- 7 | 14
-(4 rows)
-
-DELETE FROM gtest1v WHERE a >= 5;
-DROP VIEW gtest1v;
--- CTEs
-WITH foo AS (SELECT * FROM gtest1) SELECT * FROM foo;
- a | b 
----+---
- 3 | 6
-(1 row)
-
--- inheritance
-CREATE TABLE gtest1_1 () INHERITS (gtest1);
-SELECT * FROM gtest1_1;
- a | b 
----+---
-(0 rows)
-
-\d gtest1_1
-                           Table "public.gtest1_1"
- Column |  Type   | Collation | Nullable |              Default               
---------+---------+-----------+----------+------------------------------------
- a      | integer |           | not null | 
- b      | integer |           |          | generated always as (a * 2) stored
-Inherits: gtest1
-
-INSERT INTO gtest1_1 VALUES (4);
-SELECT * FROM gtest1_1;
- a | b 
----+---
- 4 | 8
-(1 row)
-
-SELECT * FROM gtest1;
- a | b 
----+---
- 3 | 6
- 4 | 8
-(2 rows)
-
-CREATE TABLE gtest_normal (a int, b int);
-CREATE TABLE gtest_normal_child (a int, b int GENERATED ALWAYS AS (a * 2) STORED) INHERITS (gtest_normal);
-NOTICE:  merging column "a" with inherited definition
-NOTICE:  merging column "b" with inherited definition
-\d gtest_normal_child
-                      Table "public.gtest_normal_child"
- Column |  Type   | Collation | Nullable |              Default               
---------+---------+-----------+----------+------------------------------------
- a      | integer |           |          | 
- b      | integer |           |          | generated always as (a * 2) stored
-Inherits: gtest_normal
-
-INSERT INTO gtest_normal (a) VALUES (1);
-INSERT INTO gtest_normal_child (a) VALUES (2);
-SELECT * FROM gtest_normal;
- a | b 
----+---
- 1 |  
- 2 | 4
-(2 rows)
-
-CREATE TABLE gtest_normal_child2 (a int, b int GENERATED ALWAYS AS (a * 3) STORED);
-ALTER TABLE gtest_normal_child2 INHERIT gtest_normal;
-INSERT INTO gtest_normal_child2 (a) VALUES (3);
-SELECT * FROM gtest_normal;
- a | b 
----+---
- 1 |  
- 2 | 4
- 3 | 9
-(3 rows)
-
--- test inheritance mismatches between parent and child
-CREATE TABLE gtestx (x int, b int GENERATED ALWAYS AS (a * 22) STORED) INHERITS (gtest1);  -- error
-NOTICE:  merging column "b" with inherited definition
-ERROR:  child column "b" specifies generation expression
-HINT:  Omit the generation expression in the definition of the child table column to inherit the generation expression from the parent table.
-CREATE TABLE gtestx (x int, b int DEFAULT 10) INHERITS (gtest1);  -- error
-NOTICE:  merging column "b" with inherited definition
-ERROR:  column "b" inherits from generated column but specifies default
-CREATE TABLE gtestx (x int, b int GENERATED ALWAYS AS IDENTITY) INHERITS (gtest1);  -- error
-NOTICE:  merging column "b" with inherited definition
-ERROR:  column "b" inherits from generated column but specifies identity
-CREATE TABLE gtestxx_1 (a int NOT NULL, b int);
-ALTER TABLE gtestxx_1 INHERIT gtest1;  -- error
-ERROR:  column "b" in child table must be a generated column
-CREATE TABLE gtestxx_2 (a int NOT NULL, b int GENERATED ALWAYS AS (a * 22) STORED);
-ALTER TABLE gtestxx_2 INHERIT gtest1;  -- error
-ERROR:  column "b" in child table has a conflicting generation expression
-CREATE TABLE gtestxx_3 (a int NOT NULL, b int GENERATED ALWAYS AS (a * 2) STORED);
-ALTER TABLE gtestxx_3 INHERIT gtest1;  -- ok
-CREATE TABLE gtestxx_4 (b int GENERATED ALWAYS AS (a * 2) STORED, a int NOT NULL);
-ALTER TABLE gtestxx_4 INHERIT gtest1;  -- ok
--- test multiple inheritance mismatches
-CREATE TABLE gtesty (x int, b int);
-CREATE TABLE gtest1_2 () INHERITS (gtest1, gtesty);  -- error
-NOTICE:  merging multiple inherited definitions of column "b"
-ERROR:  inherited column "b" has a generation conflict
-DROP TABLE gtesty;
-CREATE TABLE gtesty (x int, b int GENERATED ALWAYS AS (x * 22) STORED);
-CREATE TABLE gtest1_2 () INHERITS (gtest1, gtesty);  -- error
-NOTICE:  merging multiple inherited definitions of column "b"
-ERROR:  column "b" inherits conflicting generation expressions
-DROP TABLE gtesty;
-CREATE TABLE gtesty (x int, b int DEFAULT 55);
-CREATE TABLE gtest1_2 () INHERITS (gtest0, gtesty);  -- error
-NOTICE:  merging multiple inherited definitions of column "b"
-ERROR:  inherited column "b" has a generation conflict
-DROP TABLE gtesty;
--- test stored update
-CREATE TABLE gtest3 (a int, b int GENERATED ALWAYS AS (a * 3) STORED);
-INSERT INTO gtest3 (a) VALUES (1), (2), (3), (NULL);
-SELECT * FROM gtest3 ORDER BY a;
- a | b 
----+---
- 1 | 3
- 2 | 6
- 3 | 9
-   |  
-(4 rows)
-
-UPDATE gtest3 SET a = 22 WHERE a = 2;
-SELECT * FROM gtest3 ORDER BY a;
- a  | b  
-----+----
-  1 |  3
-  3 |  9
- 22 | 66
-    |   
-(4 rows)
-
-CREATE TABLE gtest3a (a text, b text GENERATED ALWAYS AS (a || '+' || a) STORED);
-INSERT INTO gtest3a (a) VALUES ('a'), ('b'), ('c'), (NULL);
-SELECT * FROM gtest3a ORDER BY a;
- a |  b  
----+-----
- a | a+a
- b | b+b
- c | c+c
-   | 
-(4 rows)
-
-UPDATE gtest3a SET a = 'bb' WHERE a = 'b';
-SELECT * FROM gtest3a ORDER BY a;
- a  |   b   
-----+-------
- a  | a+a
- bb | bb+bb
- c  | c+c
-    | 
-(4 rows)
-
--- COPY
-TRUNCATE gtest1;
-INSERT INTO gtest1 (a) VALUES (1), (2);
-COPY gtest1 TO stdout;
-1
-2
-COPY gtest1 (a, b) TO stdout;
-ERROR:  column "b" is a generated column
-DETAIL:  Generated columns cannot be used in COPY.
-COPY gtest1 FROM stdin;
-COPY gtest1 (a, b) FROM stdin;
-ERROR:  column "b" is a generated column
-DETAIL:  Generated columns cannot be used in COPY.
-SELECT * FROM gtest1 ORDER BY a;
- a | b 
----+---
- 1 | 2
- 2 | 4
- 3 | 6
- 4 | 8
-(4 rows)
-
-TRUNCATE gtest3;
-INSERT INTO gtest3 (a) VALUES (1), (2);
-COPY gtest3 TO stdout;
-1
-2
-COPY gtest3 (a, b) TO stdout;
-ERROR:  column "b" is a generated column
-DETAIL:  Generated columns cannot be used in COPY.
-COPY gtest3 FROM stdin;
-COPY gtest3 (a, b) FROM stdin;
-ERROR:  column "b" is a generated column
-DETAIL:  Generated columns cannot be used in COPY.
-SELECT * FROM gtest3 ORDER BY a;
- a | b  
----+----
- 1 |  3
- 2 |  6
- 3 |  9
- 4 | 12
-(4 rows)
-
--- null values
-CREATE TABLE gtest2 (a int PRIMARY KEY, b int GENERATED ALWAYS AS (NULL) STORED);
-INSERT INTO gtest2 VALUES (1);
-SELECT * FROM gtest2;
- a | b 
----+---
- 1 |  
-(1 row)
-
--- simple column reference for varlena types
-CREATE TABLE gtest_varlena (a varchar, b varchar GENERATED ALWAYS AS (a) STORED);
-INSERT INTO gtest_varlena (a) VALUES('01234567890123456789');
-INSERT INTO gtest_varlena (a) VALUES(NULL);
-SELECT * FROM gtest_varlena ORDER BY a;
-          a           |          b           
-----------------------+----------------------
- 01234567890123456789 | 01234567890123456789
-                      | 
-(2 rows)
-
-DROP TABLE gtest_varlena;
--- composite types
-CREATE TYPE double_int as (a int, b int);
-CREATE TABLE gtest4 (
-    a int,
-    b double_int GENERATED ALWAYS AS ((a * 2, a * 3)) STORED
-);
-INSERT INTO gtest4 VALUES (1), (6);
-SELECT * FROM gtest4;
- a |    b    
----+---------
- 1 | (2,3)
- 6 | (12,18)
-(2 rows)
-
-DROP TABLE gtest4;
-DROP TYPE double_int;
--- using tableoid is allowed
-CREATE TABLE gtest_tableoid (
-  a int PRIMARY KEY,
-  b bool GENERATED ALWAYS AS (tableoid = 'gtest_tableoid'::regclass) STORED
-);
-INSERT INTO gtest_tableoid VALUES (1), (2);
-ALTER TABLE gtest_tableoid ADD COLUMN
-  c regclass GENERATED ALWAYS AS (tableoid) STORED;
-SELECT * FROM gtest_tableoid;
- a | b |       c        
----+---+----------------
- 1 | t | gtest_tableoid
- 2 | t | gtest_tableoid
-(2 rows)
-
--- drop column behavior
-CREATE TABLE gtest10 (a int PRIMARY KEY, b int, c int GENERATED ALWAYS AS (b * 2) STORED);
-ALTER TABLE gtest10 DROP COLUMN b;
-\d gtest10
-              Table "public.gtest10"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           | not null | 
-Indexes:
-    "gtest10_pkey" PRIMARY KEY, btree (a)
-
-CREATE TABLE gtest10a (a int PRIMARY KEY, b int GENERATED ALWAYS AS (a * 2) STORED);
-ALTER TABLE gtest10a DROP COLUMN b;
-INSERT INTO gtest10a (a) VALUES (1);
--- privileges
-CREATE USER regress_user11;
-CREATE TABLE gtest11s (a int PRIMARY KEY, b int, c int GENERATED ALWAYS AS (b * 2) STORED);
-INSERT INTO gtest11s VALUES (1, 10), (2, 20);
-GRANT SELECT (a, c) ON gtest11s TO regress_user11;
-CREATE FUNCTION gf1(a int) RETURNS int AS $$ SELECT a * 3 $$ IMMUTABLE LANGUAGE SQL;
-REVOKE ALL ON FUNCTION gf1(int) FROM PUBLIC;
-CREATE TABLE gtest12s (a int PRIMARY KEY, b int, c int GENERATED ALWAYS AS (gf1(b)) STORED);
-INSERT INTO gtest12s VALUES (1, 10), (2, 20);
-GRANT SELECT (a, c) ON gtest12s TO regress_user11;
-SET ROLE regress_user11;
-SELECT a, b FROM gtest11s;  -- not allowed
-ERROR:  permission denied for table gtest11s
-SELECT a, c FROM gtest11s;  -- allowed
- a | c  
----+----
- 1 | 20
- 2 | 40
-(2 rows)
-
-SELECT gf1(10);  -- not allowed
-ERROR:  permission denied for function gf1
-SELECT a, c FROM gtest12s;  -- allowed
- a | c  
----+----
- 1 | 30
- 2 | 60
-(2 rows)
-
-RESET ROLE;
-DROP TABLE gtest11s, gtest12s;
-DROP FUNCTION gf1(int);
-DROP USER regress_user11;
--- check constraints
-CREATE TABLE gtest20 (a int PRIMARY KEY, b int GENERATED ALWAYS AS (a * 2) STORED CHECK (b < 50));
-INSERT INTO gtest20 (a) VALUES (10);  -- ok
-INSERT INTO gtest20 (a) VALUES (30);  -- violates constraint
-ERROR:  new row for relation "gtest20" violates check constraint "gtest20_b_check"
-DETAIL:  Failing row contains (30, 60).
-CREATE TABLE gtest20a (a int PRIMARY KEY, b int GENERATED ALWAYS AS (a * 2) STORED);
-INSERT INTO gtest20a (a) VALUES (10);
-INSERT INTO gtest20a (a) VALUES (30);
-ALTER TABLE gtest20a ADD CHECK (b < 50);  -- fails on existing row
-ERROR:  check constraint "gtest20a_b_check" of relation "gtest20a" is violated by some row
-CREATE TABLE gtest20b (a int PRIMARY KEY, b int GENERATED ALWAYS AS (a * 2) STORED);
-INSERT INTO gtest20b (a) VALUES (10);
-INSERT INTO gtest20b (a) VALUES (30);
-ALTER TABLE gtest20b ADD CONSTRAINT chk CHECK (b < 50) NOT VALID;
-ALTER TABLE gtest20b VALIDATE CONSTRAINT chk;  -- fails on existing row
-ERROR:  check constraint "chk" of relation "gtest20b" is violated by some row
--- not-null constraints
-CREATE TABLE gtest21a (a int PRIMARY KEY, b int GENERATED ALWAYS AS (nullif(a, 0)) STORED NOT NULL);
-INSERT INTO gtest21a (a) VALUES (1);  -- ok
-INSERT INTO gtest21a (a) VALUES (0);  -- violates constraint
-ERROR:  null value in column "b" of relation "gtest21a" violates not-null constraint
-DETAIL:  Failing row contains (0, null).
-CREATE TABLE gtest21b (a int PRIMARY KEY, b int GENERATED ALWAYS AS (nullif(a, 0)) STORED);
-ALTER TABLE gtest21b ALTER COLUMN b SET NOT NULL;
-INSERT INTO gtest21b (a) VALUES (1);  -- ok
-INSERT INTO gtest21b (a) VALUES (0);  -- violates constraint
-ERROR:  null value in column "b" of relation "gtest21b" violates not-null constraint
-DETAIL:  Failing row contains (0, null).
-ALTER TABLE gtest21b ALTER COLUMN b DROP NOT NULL;
-INSERT INTO gtest21b (a) VALUES (0);  -- ok now
--- index constraints
-CREATE TABLE gtest22a (a int PRIMARY KEY, b int GENERATED ALWAYS AS (a / 2) STORED UNIQUE);
-INSERT INTO gtest22a VALUES (2);
-INSERT INTO gtest22a VALUES (3);
-ERROR:  duplicate key value violates unique constraint "gtest22a_b_key"
-DETAIL:  Key (b)=(1) already exists.
-INSERT INTO gtest22a VALUES (4);
-CREATE TABLE gtest22b (a int, b int GENERATED ALWAYS AS (a / 2) STORED, PRIMARY KEY (a, b));
-INSERT INTO gtest22b VALUES (2);
-INSERT INTO gtest22b VALUES (2);
-ERROR:  duplicate key value violates unique constraint "gtest22b_pkey"
-DETAIL:  Key (a, b)=(2, 1) already exists.
--- indexes
-CREATE TABLE gtest22c (a int, b int GENERATED ALWAYS AS (a * 2) STORED);
-CREATE INDEX gtest22c_b_idx ON gtest22c (b);
-CREATE INDEX gtest22c_expr_idx ON gtest22c ((b * 3));
-CREATE INDEX gtest22c_pred_idx ON gtest22c (a) WHERE b > 0;
-\d gtest22c
-                           Table "public.gtest22c"
- Column |  Type   | Collation | Nullable |              Default               
---------+---------+-----------+----------+------------------------------------
- a      | integer |           |          | 
- b      | integer |           |          | generated always as (a * 2) stored
-Indexes:
-    "gtest22c_b_idx" btree (b)
-    "gtest22c_expr_idx" btree ((b * 3))
-    "gtest22c_pred_idx" btree (a) WHERE b > 0
-
-INSERT INTO gtest22c VALUES (1), (2), (3);
-SET enable_seqscan TO off;
-SET enable_bitmapscan TO off;
-EXPLAIN (COSTS OFF) SELECT * FROM gtest22c WHERE b = 4;
-                 QUERY PLAN                  
----------------------------------------------
- Index Scan using gtest22c_b_idx on gtest22c
-   Index Cond: (b = 4)
-(2 rows)
-
-SELECT * FROM gtest22c WHERE b = 4;
- a | b 
----+---
- 2 | 4
-(1 row)
-
-EXPLAIN (COSTS OFF) SELECT * FROM gtest22c WHERE b * 3 = 6;
-                   QUERY PLAN                   
-------------------------------------------------
- Index Scan using gtest22c_expr_idx on gtest22c
-   Index Cond: ((b * 3) = 6)
-(2 rows)
-
-SELECT * FROM gtest22c WHERE b * 3 = 6;
- a | b 
----+---
- 1 | 2
-(1 row)
-
-EXPLAIN (COSTS OFF) SELECT * FROM gtest22c WHERE a = 1 AND b > 0;
-                   QUERY PLAN                   
-------------------------------------------------
- Index Scan using gtest22c_pred_idx on gtest22c
-   Index Cond: (a = 1)
-(2 rows)
-
-SELECT * FROM gtest22c WHERE a = 1 AND b > 0;
- a | b 
----+---
- 1 | 2
-(1 row)
-
-RESET enable_seqscan;
-RESET enable_bitmapscan;
--- foreign keys
-CREATE TABLE gtest23a (x int PRIMARY KEY, y int);
-INSERT INTO gtest23a VALUES (1, 11), (2, 22), (3, 33);
-CREATE TABLE gtest23x (a int PRIMARY KEY, b int GENERATED ALWAYS AS (a * 2) STORED REFERENCES gtest23a (x) ON UPDATE CASCADE);  -- error
-ERROR:  invalid ON UPDATE action for foreign key constraint containing generated column
-CREATE TABLE gtest23x (a int PRIMARY KEY, b int GENERATED ALWAYS AS (a * 2) STORED REFERENCES gtest23a (x) ON DELETE SET NULL);  -- error
-ERROR:  invalid ON DELETE action for foreign key constraint containing generated column
-CREATE TABLE gtest23b (a int PRIMARY KEY, b int GENERATED ALWAYS AS (a * 2) STORED REFERENCES gtest23a (x));
-\d gtest23b
-                           Table "public.gtest23b"
- Column |  Type   | Collation | Nullable |              Default               
---------+---------+-----------+----------+------------------------------------
- a      | integer |           | not null | 
- b      | integer |           |          | generated always as (a * 2) stored
-Indexes:
-    "gtest23b_pkey" PRIMARY KEY, btree (a)
-Foreign-key constraints:
-    "gtest23b_b_fkey" FOREIGN KEY (b) REFERENCES gtest23a(x)
-
-INSERT INTO gtest23b VALUES (1);  -- ok
-INSERT INTO gtest23b VALUES (5);  -- error
-ERROR:  insert or update on table "gtest23b" violates foreign key constraint "gtest23b_b_fkey"
-DETAIL:  Key (b)=(10) is not present in table "gtest23a".
-DROP TABLE gtest23b;
-DROP TABLE gtest23a;
-CREATE TABLE gtest23p (x int, y int GENERATED ALWAYS AS (x * 2) STORED, PRIMARY KEY (y));
-INSERT INTO gtest23p VALUES (1), (2), (3);
-CREATE TABLE gtest23q (a int PRIMARY KEY, b int REFERENCES gtest23p (y));
-INSERT INTO gtest23q VALUES (1, 2);  -- ok
-INSERT INTO gtest23q VALUES (2, 5);  -- error
-ERROR:  insert or update on table "gtest23q" violates foreign key constraint "gtest23q_b_fkey"
-DETAIL:  Key (b)=(5) is not present in table "gtest23p".
--- domains
-CREATE DOMAIN gtestdomain1 AS int CHECK (VALUE < 10);
-CREATE TABLE gtest24 (a int PRIMARY KEY, b gtestdomain1 GENERATED ALWAYS AS (a * 2) STORED);
-INSERT INTO gtest24 (a) VALUES (4);  -- ok
-INSERT INTO gtest24 (a) VALUES (6);  -- error
-ERROR:  value for domain gtestdomain1 violates check constraint "gtestdomain1_check"
--- typed tables (currently not supported)
-CREATE TYPE gtest_type AS (f1 integer, f2 text, f3 bigint);
-CREATE TABLE gtest28 OF gtest_type (f1 WITH OPTIONS GENERATED ALWAYS AS (f2 *2) STORED);
-ERROR:  generated columns are not supported on typed tables
-DROP TYPE gtest_type CASCADE;
--- table partitions (currently not supported)
-CREATE TABLE gtest_parent (f1 date NOT NULL, f2 text, f3 bigint) PARTITION BY RANGE (f1);
-CREATE TABLE gtest_child PARTITION OF gtest_parent (
-    f3 WITH OPTIONS GENERATED ALWAYS AS (f2 * 2) STORED
-) FOR VALUES FROM ('2016-07-01') TO ('2016-08-01'); -- error
-ERROR:  generated columns are not supported on partitions
-DROP TABLE gtest_parent;
--- partitioned table
-CREATE TABLE gtest_parent (f1 date NOT NULL, f2 bigint, f3 bigint GENERATED ALWAYS AS (f2 * 2) STORED) PARTITION BY RANGE (f1);
-CREATE TABLE gtest_child PARTITION OF gtest_parent FOR VALUES FROM ('2016-07-01') TO ('2016-08-01');
-INSERT INTO gtest_parent (f1, f2) VALUES ('2016-07-15', 1);
-SELECT * FROM gtest_parent;
-     f1     | f2 | f3 
-------------+----+----
- 07-15-2016 |  1 |  2
-(1 row)
-
-SELECT * FROM gtest_child;
-     f1     | f2 | f3 
-------------+----+----
- 07-15-2016 |  1 |  2
-(1 row)
-
-DROP TABLE gtest_parent;
--- generated columns in partition key (not allowed)
-CREATE TABLE gtest_parent (f1 date NOT NULL, f2 bigint, f3 bigint GENERATED ALWAYS AS (f2 * 2) STORED) PARTITION BY RANGE (f3);
-ERROR:  cannot use generated column in partition key
-LINE 1: ...ENERATED ALWAYS AS (f2 * 2) STORED) PARTITION BY RANGE (f3);
-                                                                   ^
-DETAIL:  Column "f3" is a generated column.
-CREATE TABLE gtest_parent (f1 date NOT NULL, f2 bigint, f3 bigint GENERATED ALWAYS AS (f2 * 2) STORED) PARTITION BY RANGE ((f3 * 3));
-ERROR:  cannot use generated column in partition key
-LINE 1: ...ED ALWAYS AS (f2 * 2) STORED) PARTITION BY RANGE ((f3 * 3));
-                                                             ^
-DETAIL:  Column "f3" is a generated column.
--- ALTER TABLE ... ADD COLUMN
-CREATE TABLE gtest25 (a int PRIMARY KEY);
-INSERT INTO gtest25 VALUES (3), (4);
-ALTER TABLE gtest25 ADD COLUMN b int GENERATED ALWAYS AS (a * 3) STORED;
-SELECT * FROM gtest25 ORDER BY a;
- a | b  
----+----
- 3 |  9
- 4 | 12
-(2 rows)
-
-ALTER TABLE gtest25 ADD COLUMN x int GENERATED ALWAYS AS (b * 4) STORED;  -- error
-ERROR:  cannot use generated column "b" in column generation expression
-DETAIL:  A generated column cannot reference another generated column.
-ALTER TABLE gtest25 ADD COLUMN x int GENERATED ALWAYS AS (z * 4) STORED;  -- error
-ERROR:  column "z" does not exist
-ALTER TABLE gtest25 ADD COLUMN c int DEFAULT 42,
-  ADD COLUMN x int GENERATED ALWAYS AS (c * 4) STORED;
-ALTER TABLE gtest25 ADD COLUMN d int DEFAULT 101;
-ALTER TABLE gtest25 ALTER COLUMN d SET DATA TYPE float8,
-  ADD COLUMN y float8 GENERATED ALWAYS AS (d * 4) STORED;
-SELECT * FROM gtest25 ORDER BY a;
- a | b  | c  |  x  |  d  |  y  
----+----+----+-----+-----+-----
- 3 |  9 | 42 | 168 | 101 | 404
- 4 | 12 | 42 | 168 | 101 | 404
-(2 rows)
-
-\d gtest25
-                                         Table "public.gtest25"
- Column |       Type       | Collation | Nullable |                       Default                        
---------+------------------+-----------+----------+------------------------------------------------------
- a      | integer          |           | not null | 
- b      | integer          |           |          | generated always as (a * 3) stored
- c      | integer          |           |          | 42
- x      | integer          |           |          | generated always as (c * 4) stored
- d      | double precision |           |          | 101
- y      | double precision |           |          | generated always as (d * 4::double precision) stored
-Indexes:
-    "gtest25_pkey" PRIMARY KEY, btree (a)
-
--- ALTER TABLE ... ALTER COLUMN
-CREATE TABLE gtest27 (
-    a int,
-    b int,
-    x int GENERATED ALWAYS AS ((a + b) * 2) STORED
-);
-INSERT INTO gtest27 (a, b) VALUES (3, 7), (4, 11);
-ALTER TABLE gtest27 ALTER COLUMN a TYPE text;  -- error
-ERROR:  cannot alter type of a column used by a generated column
-DETAIL:  Column "a" is used by generated column "x".
-ALTER TABLE gtest27 ALTER COLUMN x TYPE numeric;
-\d gtest27
-                                Table "public.gtest27"
- Column |  Type   | Collation | Nullable |                  Default                   
---------+---------+-----------+----------+--------------------------------------------
- a      | integer |           |          | 
- b      | integer |           |          | 
- x      | numeric |           |          | generated always as (((a + b) * 2)) stored
-
-SELECT * FROM gtest27;
- a | b  | x  
----+----+----
- 3 |  7 | 20
- 4 | 11 | 30
-(2 rows)
-
-ALTER TABLE gtest27 ALTER COLUMN x TYPE boolean USING x <> 0;  -- error
-ERROR:  generation expression for column "x" cannot be cast automatically to type boolean
-ALTER TABLE gtest27 ALTER COLUMN x DROP DEFAULT;  -- error
-ERROR:  column "x" of relation "gtest27" is a generated column
-HINT:  Use ALTER TABLE ... ALTER COLUMN ... DROP EXPRESSION instead.
--- It's possible to alter the column types this way:
-ALTER TABLE gtest27
-  DROP COLUMN x,
-  ALTER COLUMN a TYPE bigint,
-  ALTER COLUMN b TYPE bigint,
-  ADD COLUMN x bigint GENERATED ALWAYS AS ((a + b) * 2) STORED;
-\d gtest27
-                              Table "public.gtest27"
- Column |  Type  | Collation | Nullable |                 Default                  
---------+--------+-----------+----------+------------------------------------------
- a      | bigint |           |          | 
- b      | bigint |           |          | 
- x      | bigint |           |          | generated always as ((a + b) * 2) stored
-
--- Ideally you could just do this, but not today (and should x change type?):
-ALTER TABLE gtest27
-  ALTER COLUMN a TYPE float8,
-  ALTER COLUMN b TYPE float8;  -- error
-ERROR:  cannot alter type of a column used by a generated column
-DETAIL:  Column "a" is used by generated column "x".
-\d gtest27
-                              Table "public.gtest27"
- Column |  Type  | Collation | Nullable |                 Default                  
---------+--------+-----------+----------+------------------------------------------
- a      | bigint |           |          | 
- b      | bigint |           |          | 
- x      | bigint |           |          | generated always as ((a + b) * 2) stored
-
-SELECT * FROM gtest27;
- a | b  | x  
----+----+----
- 3 |  7 | 20
- 4 | 11 | 30
-(2 rows)
-
--- ALTER TABLE ... ALTER COLUMN ... DROP EXPRESSION
-CREATE TABLE gtest29 (
-    a int,
-    b int GENERATED ALWAYS AS (a * 2) STORED
-);
-INSERT INTO gtest29 (a) VALUES (3), (4);
-ALTER TABLE gtest29 ALTER COLUMN a DROP EXPRESSION;  -- error
-ERROR:  column "a" of relation "gtest29" is not a stored generated column
-ALTER TABLE gtest29 ALTER COLUMN a DROP EXPRESSION IF EXISTS;  -- notice
-NOTICE:  column "a" of relation "gtest29" is not a stored generated column, skipping
-ALTER TABLE gtest29 ALTER COLUMN b DROP EXPRESSION;
-INSERT INTO gtest29 (a) VALUES (5);
-INSERT INTO gtest29 (a, b) VALUES (6, 66);
-SELECT * FROM gtest29;
- a | b  
----+----
- 3 |  6
- 4 |  8
- 5 |   
- 6 | 66
-(4 rows)
-
-\d gtest29
-              Table "public.gtest29"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
- b      | integer |           |          | 
-
--- check that dependencies between columns have also been removed
-ALTER TABLE gtest29 DROP COLUMN a;  -- should not drop b
-\d gtest29
-              Table "public.gtest29"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- b      | integer |           |          | 
-
--- with inheritance
-CREATE TABLE gtest30 (
-    a int,
-    b int GENERATED ALWAYS AS (a * 2) STORED
-);
-CREATE TABLE gtest30_1 () INHERITS (gtest30);
-ALTER TABLE gtest30 ALTER COLUMN b DROP EXPRESSION;
-\d gtest30
-              Table "public.gtest30"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
- b      | integer |           |          | 
-Number of child tables: 1 (Use \d+ to list them.)
-
-\d gtest30_1
-             Table "public.gtest30_1"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
- b      | integer |           |          | 
-Inherits: gtest30
-
-DROP TABLE gtest30 CASCADE;
-NOTICE:  drop cascades to table gtest30_1
-CREATE TABLE gtest30 (
-    a int,
-    b int GENERATED ALWAYS AS (a * 2) STORED
-);
-CREATE TABLE gtest30_1 () INHERITS (gtest30);
-ALTER TABLE ONLY gtest30 ALTER COLUMN b DROP EXPRESSION;  -- error
-ERROR:  ALTER TABLE / DROP EXPRESSION must be applied to child tables too
-\d gtest30
-                            Table "public.gtest30"
- Column |  Type   | Collation | Nullable |              Default               
---------+---------+-----------+----------+------------------------------------
- a      | integer |           |          | 
- b      | integer |           |          | generated always as (a * 2) stored
-Number of child tables: 1 (Use \d+ to list them.)
-
-\d gtest30_1
-                           Table "public.gtest30_1"
- Column |  Type   | Collation | Nullable |              Default               
---------+---------+-----------+----------+------------------------------------
- a      | integer |           |          | 
- b      | integer |           |          | generated always as (a * 2) stored
-Inherits: gtest30
-
-ALTER TABLE gtest30_1 ALTER COLUMN b DROP EXPRESSION;  -- error
-ERROR:  cannot drop generation expression from inherited column
--- triggers
-CREATE TABLE gtest26 (
-    a int PRIMARY KEY,
-    b int GENERATED ALWAYS AS (a * 2) STORED
-);
-CREATE FUNCTION gtest_trigger_func() RETURNS trigger
-  LANGUAGE plpgsql
-AS $$
-BEGIN
-  IF tg_op IN ('DELETE', 'UPDATE') THEN
-    RAISE INFO '%: %: old = %', TG_NAME, TG_WHEN, OLD;
-  END IF;
-  IF tg_op IN ('INSERT', 'UPDATE') THEN
-    RAISE INFO '%: %: new = %', TG_NAME, TG_WHEN, NEW;
-  END IF;
-  IF tg_op = 'DELETE' THEN
-    RETURN OLD;
-  ELSE
-    RETURN NEW;
-  END IF;
-END
-$$;
-CREATE TRIGGER gtest1 BEFORE DELETE OR UPDATE ON gtest26
-  FOR EACH ROW
-  WHEN (OLD.b < 0)  -- ok
-  EXECUTE PROCEDURE gtest_trigger_func();
-CREATE TRIGGER gtest2a BEFORE INSERT OR UPDATE ON gtest26
-  FOR EACH ROW
-  WHEN (NEW.b < 0)  -- error
-  EXECUTE PROCEDURE gtest_trigger_func();
-ERROR:  BEFORE trigger's WHEN condition cannot reference NEW generated columns
-LINE 3:   WHEN (NEW.b < 0)  
-                ^
-DETAIL:  Column "b" is a generated column.
-CREATE TRIGGER gtest2b BEFORE INSERT OR UPDATE ON gtest26
-  FOR EACH ROW
-  WHEN (NEW.* IS NOT NULL)  -- error
-  EXECUTE PROCEDURE gtest_trigger_func();
-ERROR:  BEFORE trigger's WHEN condition cannot reference NEW generated columns
-LINE 3:   WHEN (NEW.* IS NOT NULL)  
-                ^
-DETAIL:  A whole-row reference is used and the table contains generated columns.
-CREATE TRIGGER gtest2 BEFORE INSERT ON gtest26
-  FOR EACH ROW
-  WHEN (NEW.a < 0)
-  EXECUTE PROCEDURE gtest_trigger_func();
-CREATE TRIGGER gtest3 AFTER DELETE OR UPDATE ON gtest26
-  FOR EACH ROW
-  WHEN (OLD.b < 0)  -- ok
-  EXECUTE PROCEDURE gtest_trigger_func();
-CREATE TRIGGER gtest4 AFTER INSERT OR UPDATE ON gtest26
-  FOR EACH ROW
-  WHEN (NEW.b < 0)  -- ok
-  EXECUTE PROCEDURE gtest_trigger_func();
-INSERT INTO gtest26 (a) VALUES (-2), (0), (3);
-INFO:  gtest2: BEFORE: new = (-2,)
-INFO:  gtest4: AFTER: new = (-2,-4)
-SELECT * FROM gtest26 ORDER BY a;
- a  | b  
-----+----
- -2 | -4
-  0 |  0
-  3 |  6
-(3 rows)
-
-UPDATE gtest26 SET a = a * -2;
-INFO:  gtest1: BEFORE: old = (-2,-4)
-INFO:  gtest1: BEFORE: new = (4,)
-INFO:  gtest3: AFTER: old = (-2,-4)
-INFO:  gtest3: AFTER: new = (4,8)
-INFO:  gtest4: AFTER: old = (3,6)
-INFO:  gtest4: AFTER: new = (-6,-12)
-SELECT * FROM gtest26 ORDER BY a;
- a  |  b  
-----+-----
- -6 | -12
-  0 |   0
-  4 |   8
-(3 rows)
-
-DELETE FROM gtest26 WHERE a = -6;
-INFO:  gtest1: BEFORE: old = (-6,-12)
-INFO:  gtest3: AFTER: old = (-6,-12)
-SELECT * FROM gtest26 ORDER BY a;
- a | b 
----+---
- 0 | 0
- 4 | 8
-(2 rows)
-
-DROP TRIGGER gtest1 ON gtest26;
-DROP TRIGGER gtest2 ON gtest26;
-DROP TRIGGER gtest3 ON gtest26;
--- Check that an UPDATE of "a" fires the trigger for UPDATE OF b, per
--- SQL standard.
-CREATE FUNCTION gtest_trigger_func3() RETURNS trigger
-  LANGUAGE plpgsql
-AS $$
-BEGIN
-  RAISE NOTICE 'OK';
-  RETURN NEW;
-END
-$$;
-CREATE TRIGGER gtest11 BEFORE UPDATE OF b ON gtest26
-  FOR EACH ROW
-  EXECUTE PROCEDURE gtest_trigger_func3();
-UPDATE gtest26 SET a = 1 WHERE a = 0;
-NOTICE:  OK
-DROP TRIGGER gtest11 ON gtest26;
-TRUNCATE gtest26;
--- check that modifications of stored generated columns in triggers do
--- not get propagated
-CREATE FUNCTION gtest_trigger_func4() RETURNS trigger
-  LANGUAGE plpgsql
-AS $$
-BEGIN
-  NEW.a = 10;
-  NEW.b = 300;
-  RETURN NEW;
-END;
-$$;
-CREATE TRIGGER gtest12_01 BEFORE UPDATE ON gtest26
-  FOR EACH ROW
-  EXECUTE PROCEDURE gtest_trigger_func();
-CREATE TRIGGER gtest12_02 BEFORE UPDATE ON gtest26
-  FOR EACH ROW
-  EXECUTE PROCEDURE gtest_trigger_func4();
-CREATE TRIGGER gtest12_03 BEFORE UPDATE ON gtest26
-  FOR EACH ROW
-  EXECUTE PROCEDURE gtest_trigger_func();
-INSERT INTO gtest26 (a) VALUES (1);
-UPDATE gtest26 SET a = 11 WHERE a = 1;
-INFO:  gtest12_01: BEFORE: old = (1,2)
-INFO:  gtest12_01: BEFORE: new = (11,)
-INFO:  gtest12_03: BEFORE: old = (1,2)
-INFO:  gtest12_03: BEFORE: new = (10,)
-SELECT * FROM gtest26 ORDER BY a;
- a  | b  
-----+----
- 10 | 20
-(1 row)
-
--- LIKE INCLUDING GENERATED and dropped column handling
-CREATE TABLE gtest28a (
-  a int,
-  b int,
-  c int,
-  x int GENERATED ALWAYS AS (b * 2) STORED
-);
-ALTER TABLE gtest28a DROP COLUMN a;
-CREATE TABLE gtest28b (LIKE gtest28a INCLUDING GENERATED);
-\d gtest28*
-                           Table "public.gtest28a"
- Column |  Type   | Collation | Nullable |              Default               
---------+---------+-----------+----------+------------------------------------
- b      | integer |           |          | 
- c      | integer |           |          | 
- x      | integer |           |          | generated always as (b * 2) stored
-
-                           Table "public.gtest28b"
- Column |  Type   | Collation | Nullable |              Default               
---------+---------+-----------+----------+------------------------------------
- b      | integer |           |          | 
- c      | integer |           |          | 
- x      | integer |           |          | generated always as (b * 2) stored
+dyld: lazy symbol binding failed: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
+
+dyld: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
 
diff -U3 /Users/kenaniah/workspace/postgres/src/test/regress/expected/create_table_like.out /Users/kenaniah/workspace/postgres/src/test/regress/results/create_table_like.out
--- /Users/kenaniah/workspace/postgres/src/test/regress/expected/create_table_like.out	2021-10-03 18:09:17.000000000 -0700
+++ /Users/kenaniah/workspace/postgres/src/test/regress/results/create_table_like.out	2021-10-03 20:08:19.000000000 -0700
@@ -68,453 +68,11 @@
 DROP TABLE inhg;
 CREATE TABLE test_like_id_1 (a bigint GENERATED ALWAYS AS IDENTITY, b text);
 \d test_like_id_1
-                     Table "public.test_like_id_1"
- Column |  Type  | Collation | Nullable |           Default            
---------+--------+-----------+----------+------------------------------
- a      | bigint |           | not null | generated always as identity
- b      | text   |           |          | 
+dyld: lazy symbol binding failed: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
+
+dyld: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
 
-INSERT INTO test_like_id_1 (b) VALUES ('b1');
-SELECT * FROM test_like_id_1;
- a | b  
----+----
- 1 | b1
-(1 row)
-
-CREATE TABLE test_like_id_2 (LIKE test_like_id_1);
-\d test_like_id_2
-          Table "public.test_like_id_2"
- Column |  Type  | Collation | Nullable | Default 
---------+--------+-----------+----------+---------
- a      | bigint |           | not null | 
- b      | text   |           |          | 
-
-INSERT INTO test_like_id_2 (b) VALUES ('b2');
-ERROR:  null value in column "a" of relation "test_like_id_2" violates not-null constraint
-DETAIL:  Failing row contains (null, b2).
-SELECT * FROM test_like_id_2;  -- identity was not copied
- a | b 
----+---
-(0 rows)
-
-CREATE TABLE test_like_id_3 (LIKE test_like_id_1 INCLUDING IDENTITY);
-\d test_like_id_3
-                     Table "public.test_like_id_3"
- Column |  Type  | Collation | Nullable |           Default            
---------+--------+-----------+----------+------------------------------
- a      | bigint |           | not null | generated always as identity
- b      | text   |           |          | 
-
-INSERT INTO test_like_id_3 (b) VALUES ('b3');
-SELECT * FROM test_like_id_3;  -- identity was copied and applied
- a | b  
----+----
- 1 | b3
-(1 row)
-
-DROP TABLE test_like_id_1, test_like_id_2, test_like_id_3;
-CREATE TABLE test_like_gen_1 (a int, b int GENERATED ALWAYS AS (a * 2) STORED);
-\d test_like_gen_1
-                        Table "public.test_like_gen_1"
- Column |  Type   | Collation | Nullable |              Default               
---------+---------+-----------+----------+------------------------------------
- a      | integer |           |          | 
- b      | integer |           |          | generated always as (a * 2) stored
-
-INSERT INTO test_like_gen_1 (a) VALUES (1);
-SELECT * FROM test_like_gen_1;
- a | b 
----+---
- 1 | 2
-(1 row)
-
-CREATE TABLE test_like_gen_2 (LIKE test_like_gen_1);
-\d test_like_gen_2
-          Table "public.test_like_gen_2"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
- b      | integer |           |          | 
-
-INSERT INTO test_like_gen_2 (a) VALUES (1);
-SELECT * FROM test_like_gen_2;
- a | b 
----+---
- 1 |  
-(1 row)
-
-CREATE TABLE test_like_gen_3 (LIKE test_like_gen_1 INCLUDING GENERATED);
-\d test_like_gen_3
-                        Table "public.test_like_gen_3"
- Column |  Type   | Collation | Nullable |              Default               
---------+---------+-----------+----------+------------------------------------
- a      | integer |           |          | 
- b      | integer |           |          | generated always as (a * 2) stored
-
-INSERT INTO test_like_gen_3 (a) VALUES (1);
-SELECT * FROM test_like_gen_3;
- a | b 
----+---
- 1 | 2
-(1 row)
-
-DROP TABLE test_like_gen_1, test_like_gen_2, test_like_gen_3;
--- also test generated column with a "forward" reference (bug #16342)
-CREATE TABLE test_like_4 (b int DEFAULT 42,
-  c int GENERATED ALWAYS AS (a * 2) STORED,
-  a int CHECK (a > 0));
-\d test_like_4
-                          Table "public.test_like_4"
- Column |  Type   | Collation | Nullable |              Default               
---------+---------+-----------+----------+------------------------------------
- b      | integer |           |          | 42
- c      | integer |           |          | generated always as (a * 2) stored
- a      | integer |           |          | 
-Check constraints:
-    "test_like_4_a_check" CHECK (a > 0)
-
-CREATE TABLE test_like_4a (LIKE test_like_4);
-CREATE TABLE test_like_4b (LIKE test_like_4 INCLUDING DEFAULTS);
-CREATE TABLE test_like_4c (LIKE test_like_4 INCLUDING GENERATED);
-CREATE TABLE test_like_4d (LIKE test_like_4 INCLUDING DEFAULTS INCLUDING GENERATED);
-\d test_like_4a
-            Table "public.test_like_4a"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- b      | integer |           |          | 
- c      | integer |           |          | 
- a      | integer |           |          | 
-
-INSERT INTO test_like_4a (a) VALUES(11);
-SELECT a, b, c FROM test_like_4a;
- a  | b | c 
-----+---+---
- 11 |   |  
-(1 row)
-
-\d test_like_4b
-            Table "public.test_like_4b"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- b      | integer |           |          | 42
- c      | integer |           |          | 
- a      | integer |           |          | 
-
-INSERT INTO test_like_4b (a) VALUES(11);
-SELECT a, b, c FROM test_like_4b;
- a  | b  | c 
-----+----+---
- 11 | 42 |  
-(1 row)
-
-\d test_like_4c
-                         Table "public.test_like_4c"
- Column |  Type   | Collation | Nullable |              Default               
---------+---------+-----------+----------+------------------------------------
- b      | integer |           |          | 
- c      | integer |           |          | generated always as (a * 2) stored
- a      | integer |           |          | 
-
-INSERT INTO test_like_4c (a) VALUES(11);
-SELECT a, b, c FROM test_like_4c;
- a  | b | c  
-----+---+----
- 11 |   | 22
-(1 row)
-
-\d test_like_4d
-                         Table "public.test_like_4d"
- Column |  Type   | Collation | Nullable |              Default               
---------+---------+-----------+----------+------------------------------------
- b      | integer |           |          | 42
- c      | integer |           |          | generated always as (a * 2) stored
- a      | integer |           |          | 
-
-INSERT INTO test_like_4d (a) VALUES(11);
-SELECT a, b, c FROM test_like_4d;
- a  | b  | c  
-----+----+----
- 11 | 42 | 22
-(1 row)
-
--- Test renumbering of Vars when combining LIKE with inheritance
-CREATE TABLE test_like_5 (x point, y point, z point);
-CREATE TABLE test_like_5x (p int CHECK (p > 0),
-   q int GENERATED ALWAYS AS (p * 2) STORED);
-CREATE TABLE test_like_5c (LIKE test_like_4 INCLUDING ALL)
-  INHERITS (test_like_5, test_like_5x);
-\d test_like_5c
-                         Table "public.test_like_5c"
- Column |  Type   | Collation | Nullable |              Default               
---------+---------+-----------+----------+------------------------------------
- x      | point   |           |          | 
- y      | point   |           |          | 
- z      | point   |           |          | 
- p      | integer |           |          | 
- q      | integer |           |          | generated always as (p * 2) stored
- b      | integer |           |          | 42
- c      | integer |           |          | generated always as (a * 2) stored
- a      | integer |           |          | 
-Check constraints:
-    "test_like_4_a_check" CHECK (a > 0)
-    "test_like_5x_p_check" CHECK (p > 0)
-Inherits: test_like_5,
-          test_like_5x
-
-DROP TABLE test_like_4, test_like_4a, test_like_4b, test_like_4c, test_like_4d;
-DROP TABLE test_like_5, test_like_5x, test_like_5c;
-CREATE TABLE inhg (x text, LIKE inhx INCLUDING INDEXES, y text); /* copies indexes */
-INSERT INTO inhg VALUES (5, 10);
-INSERT INTO inhg VALUES (20, 10); -- should fail
-ERROR:  duplicate key value violates unique constraint "inhg_pkey"
-DETAIL:  Key (xx)=(10) already exists.
-DROP TABLE inhg;
-/* Multiple primary keys creation should fail */
-CREATE TABLE inhg (x text, LIKE inhx INCLUDING INDEXES, PRIMARY KEY(x)); /* fails */
-ERROR:  multiple primary keys for table "inhg" are not allowed
-CREATE TABLE inhz (xx text DEFAULT 'text', yy int UNIQUE);
-CREATE UNIQUE INDEX inhz_xx_idx on inhz (xx) WHERE xx <> 'test';
-/* Ok to create multiple unique indexes */
-CREATE TABLE inhg (x text UNIQUE, LIKE inhz INCLUDING INDEXES);
-INSERT INTO inhg (xx, yy, x) VALUES ('test', 5, 10);
-INSERT INTO inhg (xx, yy, x) VALUES ('test', 10, 15);
-INSERT INTO inhg (xx, yy, x) VALUES ('foo', 10, 15); -- should fail
-ERROR:  duplicate key value violates unique constraint "inhg_x_key"
-DETAIL:  Key (x)=(15) already exists.
-DROP TABLE inhg;
-DROP TABLE inhz;
-/* Use primary key imported by LIKE for self-referential FK constraint */
-CREATE TABLE inhz (x text REFERENCES inhz, LIKE inhx INCLUDING INDEXES);
-\d inhz
-              Table "public.inhz"
- Column | Type | Collation | Nullable | Default 
---------+------+-----------+----------+---------
- x      | text |           |          | 
- xx     | text |           | not null | 
-Indexes:
-    "inhz_pkey" PRIMARY KEY, btree (xx)
-Foreign-key constraints:
-    "inhz_x_fkey" FOREIGN KEY (x) REFERENCES inhz(xx)
-Referenced by:
-    TABLE "inhz" CONSTRAINT "inhz_x_fkey" FOREIGN KEY (x) REFERENCES inhz(xx)
-
-DROP TABLE inhz;
--- including storage and comments
-CREATE TABLE ctlt1 (a text CHECK (length(a) > 2) PRIMARY KEY, b text);
-CREATE INDEX ctlt1_b_key ON ctlt1 (b);
-CREATE INDEX ctlt1_fnidx ON ctlt1 ((a || b));
-CREATE STATISTICS ctlt1_a_b_stat ON a,b FROM ctlt1;
-CREATE STATISTICS ctlt1_expr_stat ON (a || b) FROM ctlt1;
-COMMENT ON STATISTICS ctlt1_a_b_stat IS 'ab stats';
-COMMENT ON STATISTICS ctlt1_expr_stat IS 'ab expr stats';
-COMMENT ON COLUMN ctlt1.a IS 'A';
-COMMENT ON COLUMN ctlt1.b IS 'B';
-COMMENT ON CONSTRAINT ctlt1_a_check ON ctlt1 IS 't1_a_check';
-COMMENT ON INDEX ctlt1_pkey IS 'index pkey';
-COMMENT ON INDEX ctlt1_b_key IS 'index b_key';
-ALTER TABLE ctlt1 ALTER COLUMN a SET STORAGE MAIN;
-CREATE TABLE ctlt2 (c text);
-ALTER TABLE ctlt2 ALTER COLUMN c SET STORAGE EXTERNAL;
-COMMENT ON COLUMN ctlt2.c IS 'C';
-CREATE TABLE ctlt3 (a text CHECK (length(a) < 5), c text CHECK (length(c) < 7));
-ALTER TABLE ctlt3 ALTER COLUMN c SET STORAGE EXTERNAL;
-ALTER TABLE ctlt3 ALTER COLUMN a SET STORAGE MAIN;
-CREATE INDEX ctlt3_fnidx ON ctlt3 ((a || c));
-COMMENT ON COLUMN ctlt3.a IS 'A3';
-COMMENT ON COLUMN ctlt3.c IS 'C';
-COMMENT ON CONSTRAINT ctlt3_a_check ON ctlt3 IS 't3_a_check';
-CREATE TABLE ctlt4 (a text, c text);
-ALTER TABLE ctlt4 ALTER COLUMN c SET STORAGE EXTERNAL;
-CREATE TABLE ctlt12_storage (LIKE ctlt1 INCLUDING STORAGE, LIKE ctlt2 INCLUDING STORAGE);
-\d+ ctlt12_storage
-                             Table "public.ctlt12_storage"
- Column | Type | Collation | Nullable | Default | Storage  | Stats target | Description 
---------+------+-----------+----------+---------+----------+--------------+-------------
- a      | text |           | not null |         | main     |              | 
- b      | text |           |          |         | extended |              | 
- c      | text |           |          |         | external |              | 
-
-CREATE TABLE ctlt12_comments (LIKE ctlt1 INCLUDING COMMENTS, LIKE ctlt2 INCLUDING COMMENTS);
-\d+ ctlt12_comments
-                             Table "public.ctlt12_comments"
- Column | Type | Collation | Nullable | Default | Storage  | Stats target | Description 
---------+------+-----------+----------+---------+----------+--------------+-------------
- a      | text |           | not null |         | extended |              | A
- b      | text |           |          |         | extended |              | B
- c      | text |           |          |         | extended |              | C
-
-CREATE TABLE ctlt1_inh (LIKE ctlt1 INCLUDING CONSTRAINTS INCLUDING COMMENTS) INHERITS (ctlt1);
-NOTICE:  merging column "a" with inherited definition
-NOTICE:  merging column "b" with inherited definition
-NOTICE:  merging constraint "ctlt1_a_check" with inherited definition
-\d+ ctlt1_inh
-                                Table "public.ctlt1_inh"
- Column | Type | Collation | Nullable | Default | Storage  | Stats target | Description 
---------+------+-----------+----------+---------+----------+--------------+-------------
- a      | text |           | not null |         | main     |              | A
- b      | text |           |          |         | extended |              | B
-Check constraints:
-    "ctlt1_a_check" CHECK (length(a) > 2)
-Inherits: ctlt1
-
-SELECT description FROM pg_description, pg_constraint c WHERE classoid = 'pg_constraint'::regclass AND objoid = c.oid AND c.conrelid = 'ctlt1_inh'::regclass;
- description 
--------------
- t1_a_check
-(1 row)
-
-CREATE TABLE ctlt13_inh () INHERITS (ctlt1, ctlt3);
-NOTICE:  merging multiple inherited definitions of column "a"
-\d+ ctlt13_inh
-                               Table "public.ctlt13_inh"
- Column | Type | Collation | Nullable | Default | Storage  | Stats target | Description 
---------+------+-----------+----------+---------+----------+--------------+-------------
- a      | text |           | not null |         | main     |              | 
- b      | text |           |          |         | extended |              | 
- c      | text |           |          |         | external |              | 
-Check constraints:
-    "ctlt1_a_check" CHECK (length(a) > 2)
-    "ctlt3_a_check" CHECK (length(a) < 5)
-    "ctlt3_c_check" CHECK (length(c) < 7)
-Inherits: ctlt1,
-          ctlt3
-
-CREATE TABLE ctlt13_like (LIKE ctlt3 INCLUDING CONSTRAINTS INCLUDING INDEXES INCLUDING COMMENTS INCLUDING STORAGE) INHERITS (ctlt1);
-NOTICE:  merging column "a" with inherited definition
-\d+ ctlt13_like
-                               Table "public.ctlt13_like"
- Column | Type | Collation | Nullable | Default | Storage  | Stats target | Description 
---------+------+-----------+----------+---------+----------+--------------+-------------
- a      | text |           | not null |         | main     |              | A3
- b      | text |           |          |         | extended |              | 
- c      | text |           |          |         | external |              | C
-Indexes:
-    "ctlt13_like_expr_idx" btree ((a || c))
-Check constraints:
-    "ctlt1_a_check" CHECK (length(a) > 2)
-    "ctlt3_a_check" CHECK (length(a) < 5)
-    "ctlt3_c_check" CHECK (length(c) < 7)
-Inherits: ctlt1
-
-SELECT description FROM pg_description, pg_constraint c WHERE classoid = 'pg_constraint'::regclass AND objoid = c.oid AND c.conrelid = 'ctlt13_like'::regclass;
- description 
--------------
- t3_a_check
-(1 row)
-
-CREATE TABLE ctlt_all (LIKE ctlt1 INCLUDING ALL);
-\d+ ctlt_all
-                                Table "public.ctlt_all"
- Column | Type | Collation | Nullable | Default | Storage  | Stats target | Description 
---------+------+-----------+----------+---------+----------+--------------+-------------
- a      | text |           | not null |         | main     |              | A
- b      | text |           |          |         | extended |              | B
-Indexes:
-    "ctlt_all_pkey" PRIMARY KEY, btree (a)
-    "ctlt_all_b_idx" btree (b)
-    "ctlt_all_expr_idx" btree ((a || b))
-Check constraints:
-    "ctlt1_a_check" CHECK (length(a) > 2)
-Statistics objects:
-    "public.ctlt_all_a_b_stat" ON a, b FROM ctlt_all
-    "public.ctlt_all_expr_stat" ON (a || b) FROM ctlt_all
-
-SELECT c.relname, objsubid, description FROM pg_description, pg_index i, pg_class c WHERE classoid = 'pg_class'::regclass AND objoid = i.indexrelid AND c.oid = i.indexrelid AND i.indrelid = 'ctlt_all'::regclass ORDER BY c.relname, objsubid;
-    relname     | objsubid | description 
-----------------+----------+-------------
- ctlt_all_b_idx |        0 | index b_key
- ctlt_all_pkey  |        0 | index pkey
-(2 rows)
-
-SELECT s.stxname, objsubid, description FROM pg_description, pg_statistic_ext s WHERE classoid = 'pg_statistic_ext'::regclass AND objoid = s.oid AND s.stxrelid = 'ctlt_all'::regclass ORDER BY s.stxname, objsubid;
-      stxname       | objsubid |  description  
---------------------+----------+---------------
- ctlt_all_a_b_stat  |        0 | ab stats
- ctlt_all_expr_stat |        0 | ab expr stats
-(2 rows)
-
-CREATE TABLE inh_error1 () INHERITS (ctlt1, ctlt4);
-NOTICE:  merging multiple inherited definitions of column "a"
-ERROR:  inherited column "a" has a storage parameter conflict
-DETAIL:  MAIN versus EXTENDED
-CREATE TABLE inh_error2 (LIKE ctlt4 INCLUDING STORAGE) INHERITS (ctlt1);
-NOTICE:  merging column "a" with inherited definition
-ERROR:  column "a" has a storage parameter conflict
-DETAIL:  MAIN versus EXTENDED
--- Check that LIKE isn't confused by a system catalog of the same name
-CREATE TABLE pg_attrdef (LIKE ctlt1 INCLUDING ALL);
-\d+ public.pg_attrdef
-                               Table "public.pg_attrdef"
- Column | Type | Collation | Nullable | Default | Storage  | Stats target | Description 
---------+------+-----------+----------+---------+----------+--------------+-------------
- a      | text |           | not null |         | main     |              | A
- b      | text |           |          |         | extended |              | B
-Indexes:
-    "pg_attrdef_pkey" PRIMARY KEY, btree (a)
-    "pg_attrdef_b_idx" btree (b)
-    "pg_attrdef_expr_idx" btree ((a || b))
-Check constraints:
-    "ctlt1_a_check" CHECK (length(a) > 2)
-Statistics objects:
-    "public.pg_attrdef_a_b_stat" ON a, b FROM public.pg_attrdef
-    "public.pg_attrdef_expr_stat" ON (a || b) FROM public.pg_attrdef
-
-DROP TABLE public.pg_attrdef;
--- Check that LIKE isn't confused when new table masks the old, either
-BEGIN;
-CREATE SCHEMA ctl_schema;
-SET LOCAL search_path = ctl_schema, public;
-CREATE TABLE ctlt1 (LIKE ctlt1 INCLUDING ALL);
-\d+ ctlt1
-                                Table "ctl_schema.ctlt1"
- Column | Type | Collation | Nullable | Default | Storage  | Stats target | Description 
---------+------+-----------+----------+---------+----------+--------------+-------------
- a      | text |           | not null |         | main     |              | A
- b      | text |           |          |         | extended |              | B
-Indexes:
-    "ctlt1_pkey" PRIMARY KEY, btree (a)
-    "ctlt1_b_idx" btree (b)
-    "ctlt1_expr_idx" btree ((a || b))
-Check constraints:
-    "ctlt1_a_check" CHECK (length(a) > 2)
-Statistics objects:
-    "ctl_schema.ctlt1_a_b_stat" ON a, b FROM ctlt1
-    "ctl_schema.ctlt1_expr_stat" ON (a || b) FROM ctlt1
-
-ROLLBACK;
-DROP TABLE ctlt1, ctlt2, ctlt3, ctlt4, ctlt12_storage, ctlt12_comments, ctlt1_inh, ctlt13_inh, ctlt13_like, ctlt_all, ctla, ctlb CASCADE;
-NOTICE:  drop cascades to table inhe
--- LIKE must respect NO INHERIT property of constraints
-CREATE TABLE noinh_con_copy (a int CHECK (a > 0) NO INHERIT);
-CREATE TABLE noinh_con_copy1 (LIKE noinh_con_copy INCLUDING CONSTRAINTS);
-\d noinh_con_copy1
-          Table "public.noinh_con_copy1"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
-Check constraints:
-    "noinh_con_copy_a_check" CHECK (a > 0) NO INHERIT
-
--- fail, as partitioned tables don't allow NO INHERIT constraints
-CREATE TABLE noinh_con_copy1_parted (LIKE noinh_con_copy INCLUDING ALL)
-  PARTITION BY LIST (a);
-ERROR:  cannot add NO INHERIT constraint to partitioned table "noinh_con_copy1_parted"
-DROP TABLE noinh_con_copy, noinh_con_copy1;
-/* LIKE with other relation kinds */
-CREATE TABLE ctlt4 (a int, b text);
-CREATE SEQUENCE ctlseq1;
-CREATE TABLE ctlt10 (LIKE ctlseq1);  -- fail
-ERROR:  relation "ctlseq1" is invalid in LIKE clause
-LINE 1: CREATE TABLE ctlt10 (LIKE ctlseq1);
-                                  ^
-DETAIL:  This operation is not supported for sequences.
-CREATE VIEW ctlv1 AS SELECT * FROM ctlt4;
-CREATE TABLE ctlt11 (LIKE ctlv1);
-CREATE TABLE ctlt11a (LIKE ctlv1 INCLUDING ALL);
-CREATE TYPE ctlty1 AS (a int, b text);
-CREATE TABLE ctlt12 (LIKE ctlty1);
-DROP SEQUENCE ctlseq1;
-DROP TYPE ctlty1;
-DROP VIEW ctlv1;
-DROP TABLE IF EXISTS ctlt4, ctlt10, ctlt11, ctlt11a, ctlt12;
-NOTICE:  table "ctlt10" does not exist, skipping
diff -U3 /Users/kenaniah/workspace/postgres/src/test/regress/expected/rules.out /Users/kenaniah/workspace/postgres/src/test/regress/results/rules.out
--- /Users/kenaniah/workspace/postgres/src/test/regress/expected/rules.out	2021-10-03 17:41:49.000000000 -0700
+++ /Users/kenaniah/workspace/postgres/src/test/regress/results/rules.out	2021-10-03 20:08:20.000000000 -0700
@@ -1299,6 +1299,9 @@
    FROM view_base_table
   GROUP BY view_base_table.key
  HAVING (length((view_base_table.data)::text) > 0);
+main_view| SELECT main_table.a,
+    main_table.b
+   FROM main_table;
 mvtest_tv| SELECT mvtest_t.type,
     sum(mvtest_t.amt) AS totamt
    FROM mvtest_t
@@ -2607,6 +2610,10 @@
     rtest_view1.b,
     rtest_viewfunc1(rtest_view1.a) AS refcount
    FROM rtest_view1;
+rw_view1| SELECT base_tbl.a,
+    base_tbl.b
+   FROM base_tbl
+  WHERE (base_tbl.a < base_tbl.b);
 shoe| SELECT sh.shoename,
     sh.sh_avail,
     sh.slcolor,
@@ -2668,9 +2675,19 @@
     emp.location,
     (12 * emp.salary) AS annualsal
    FROM emp;
+v_test1| SELECT ('v_'::text || test1.t)
+   FROM test1;
 SELECT tablename, rulename, definition FROM pg_rules
 WHERE schemaname IN ('pg_catalog', 'public')
 ORDER BY tablename, rulename;
+inserttest2|irule1|CREATE RULE irule1 AS
+    ON INSERT TO public.inserttest2 DO  INSERT INTO inserttest (f3.if2[1], f3.if2[2])
+  VALUES (new.f1, new.f2);
+inserttest2|irule2|CREATE RULE irule2 AS
+    ON INSERT TO public.inserttest2 DO  INSERT INTO inserttest (f4[1].if1, f4[1].if2[2]) VALUES (1,'fool'::text), (new.f1,new.f2);
+inserttest2|irule3|CREATE RULE irule3 AS
+    ON INSERT TO public.inserttest2 DO  INSERT INTO inserttest (f4[1].if1, f4[1].if2[2])  SELECT new.f1,
+            new.f2;
 pg_settings|pg_settings_n|CREATE RULE pg_settings_n AS
     ON UPDATE TO pg_catalog.pg_settings DO INSTEAD NOTHING;
 pg_settings|pg_settings_u|CREATE RULE pg_settings_u AS
@@ -3167,535 +3184,11 @@
 
 create rule r3 as on delete to rules_src do notify rules_src_deletion;
 \d+ rules_src
-                                 Table "public.rules_src"
- Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
---------+---------+-----------+----------+---------+---------+--------------+-------------
- f1     | integer |           |          |         | plain   |              | 
- f2     | integer |           |          |         | plain   |              | 
-Rules:
-    r1 AS
-    ON UPDATE TO rules_src DO  INSERT INTO rules_log (f1, f2, tag) VALUES (old.f1,old.f2,'old'::text), (new.f1,new.f2,'new'::text)
-    r2 AS
-    ON UPDATE TO rules_src DO  VALUES (old.f1,old.f2,'old'::text), (new.f1,new.f2,'new'::text)
-    r3 AS
-    ON DELETE TO rules_src DO
- NOTIFY rules_src_deletion
+dyld: lazy symbol binding failed: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
+
+dyld: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
 
---
--- Ensure an aliased target relation for insert is correctly deparsed.
---
-create rule r4 as on insert to rules_src do instead insert into rules_log AS trgt SELECT NEW.* RETURNING trgt.f1, trgt.f2;
-create rule r5 as on update to rules_src do instead UPDATE rules_log AS trgt SET tag = 'updated' WHERE trgt.f1 = new.f1;
-\d+ rules_src
-                                 Table "public.rules_src"
- Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
---------+---------+-----------+----------+---------+---------+--------------+-------------
- f1     | integer |           |          |         | plain   |              | 
- f2     | integer |           |          |         | plain   |              | 
-Rules:
-    r1 AS
-    ON UPDATE TO rules_src DO  INSERT INTO rules_log (f1, f2, tag) VALUES (old.f1,old.f2,'old'::text), (new.f1,new.f2,'new'::text)
-    r2 AS
-    ON UPDATE TO rules_src DO  VALUES (old.f1,old.f2,'old'::text), (new.f1,new.f2,'new'::text)
-    r3 AS
-    ON DELETE TO rules_src DO
- NOTIFY rules_src_deletion
-    r4 AS
-    ON INSERT TO rules_src DO INSTEAD  INSERT INTO rules_log AS trgt (f1, f2)  SELECT new.f1,
-            new.f2
-  RETURNING trgt.f1,
-    trgt.f2
-    r5 AS
-    ON UPDATE TO rules_src DO INSTEAD  UPDATE rules_log trgt SET tag = 'updated'::text
-  WHERE trgt.f1 = new.f1
-
---
--- Also check multiassignment deparsing.
---
-create table rule_t1(f1 int, f2 int);
-create table rule_dest(f1 int, f2 int[], tag text);
-create rule rr as on update to rule_t1 do instead UPDATE rule_dest trgt
-  SET (f2[1], f1, tag) = (SELECT new.f2, new.f1, 'updated'::varchar)
-  WHERE trgt.f1 = new.f1 RETURNING new.*;
-\d+ rule_t1
-                                  Table "public.rule_t1"
- Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
---------+---------+-----------+----------+---------+---------+--------------+-------------
- f1     | integer |           |          |         | plain   |              | 
- f2     | integer |           |          |         | plain   |              | 
-Rules:
-    rr AS
-    ON UPDATE TO rule_t1 DO INSTEAD  UPDATE rule_dest trgt SET (f2[1], f1, tag) = ( SELECT new.f2,
-            new.f1,
-            'updated'::character varying AS "varchar")
-  WHERE trgt.f1 = new.f1
-  RETURNING new.f1,
-    new.f2
-
-drop table rule_t1, rule_dest;
---
--- check alter rename rule
---
-CREATE TABLE rule_t1 (a INT);
-CREATE VIEW rule_v1 AS SELECT * FROM rule_t1;
-CREATE RULE InsertRule AS
-    ON INSERT TO rule_v1
-    DO INSTEAD
-        INSERT INTO rule_t1 VALUES(new.a);
-ALTER RULE InsertRule ON rule_v1 RENAME to NewInsertRule;
-INSERT INTO rule_v1 VALUES(1);
-SELECT * FROM rule_v1;
- a 
----
- 1
-(1 row)
-
-\d+ rule_v1
-                           View "public.rule_v1"
- Column |  Type   | Collation | Nullable | Default | Storage | Description 
---------+---------+-----------+----------+---------+---------+-------------
- a      | integer |           |          |         | plain   | 
-View definition:
- SELECT rule_t1.a
-   FROM rule_t1;
-Rules:
- newinsertrule AS
-    ON INSERT TO rule_v1 DO INSTEAD  INSERT INTO rule_t1 (a)
-  VALUES (new.a)
-
---
--- error conditions for alter rename rule
---
-ALTER RULE InsertRule ON rule_v1 RENAME TO NewInsertRule; -- doesn't exist
-ERROR:  rule "insertrule" for relation "rule_v1" does not exist
-ALTER RULE NewInsertRule ON rule_v1 RENAME TO "_RETURN"; -- already exists
-ERROR:  rule "_RETURN" for relation "rule_v1" already exists
-ALTER RULE "_RETURN" ON rule_v1 RENAME TO abc; -- ON SELECT rule cannot be renamed
-ERROR:  renaming an ON SELECT rule is not allowed
-DROP VIEW rule_v1;
-DROP TABLE rule_t1;
---
--- check display of VALUES in view definitions
---
-create view rule_v1 as values(1,2);
-\d+ rule_v1
-                           View "public.rule_v1"
- Column  |  Type   | Collation | Nullable | Default | Storage | Description 
----------+---------+-----------+----------+---------+---------+-------------
- column1 | integer |           |          |         | plain   | 
- column2 | integer |           |          |         | plain   | 
-View definition:
- VALUES (1,2);
-
-alter table rule_v1 rename column column2 to q2;
-\d+ rule_v1
-                           View "public.rule_v1"
- Column  |  Type   | Collation | Nullable | Default | Storage | Description 
----------+---------+-----------+----------+---------+---------+-------------
- column1 | integer |           |          |         | plain   | 
- q2      | integer |           |          |         | plain   | 
-View definition:
- SELECT "*VALUES*".column1,
-    "*VALUES*".column2 AS q2
-   FROM (VALUES (1,2)) "*VALUES*";
-
-drop view rule_v1;
-create view rule_v1(x) as values(1,2);
-\d+ rule_v1
-                           View "public.rule_v1"
- Column  |  Type   | Collation | Nullable | Default | Storage | Description 
----------+---------+-----------+----------+---------+---------+-------------
- x       | integer |           |          |         | plain   | 
- column2 | integer |           |          |         | plain   | 
-View definition:
- SELECT "*VALUES*".column1 AS x,
-    "*VALUES*".column2
-   FROM (VALUES (1,2)) "*VALUES*";
-
-drop view rule_v1;
-create view rule_v1(x) as select * from (values(1,2)) v;
-\d+ rule_v1
-                           View "public.rule_v1"
- Column  |  Type   | Collation | Nullable | Default | Storage | Description 
----------+---------+-----------+----------+---------+---------+-------------
- x       | integer |           |          |         | plain   | 
- column2 | integer |           |          |         | plain   | 
-View definition:
- SELECT v.column1 AS x,
-    v.column2
-   FROM ( VALUES (1,2)) v;
-
-drop view rule_v1;
-create view rule_v1(x) as select * from (values(1,2)) v(q,w);
-\d+ rule_v1
-                           View "public.rule_v1"
- Column |  Type   | Collation | Nullable | Default | Storage | Description 
---------+---------+-----------+----------+---------+---------+-------------
- x      | integer |           |          |         | plain   | 
- w      | integer |           |          |         | plain   | 
-View definition:
- SELECT v.q AS x,
-    v.w
-   FROM ( VALUES (1,2)) v(q, w);
-
-drop view rule_v1;
---
--- Check DO INSTEAD rules with ON CONFLICT
---
-CREATE TABLE hats (
-	hat_name    char(10) primary key,
-	hat_color   char(10)      -- hat color
-);
-CREATE TABLE hat_data (
-	hat_name    char(10),
-	hat_color   char(10)      -- hat color
-);
-create unique index hat_data_unique_idx
-  on hat_data (hat_name COLLATE "C" bpchar_pattern_ops);
--- DO NOTHING with ON CONFLICT
-CREATE RULE hat_nosert AS ON INSERT TO hats
-    DO INSTEAD
-    INSERT INTO hat_data VALUES (
-           NEW.hat_name,
-           NEW.hat_color)
-        ON CONFLICT (hat_name COLLATE "C" bpchar_pattern_ops) WHERE hat_color = 'green'
-        DO NOTHING
-        RETURNING *;
-SELECT definition FROM pg_rules WHERE tablename = 'hats' ORDER BY rulename;
-                                         definition                                          
----------------------------------------------------------------------------------------------
- CREATE RULE hat_nosert AS                                                                  +
-     ON INSERT TO public.hats DO INSTEAD  INSERT INTO hat_data (hat_name, hat_color)        +
-   VALUES (new.hat_name, new.hat_color) ON CONFLICT(hat_name COLLATE "C" bpchar_pattern_ops)+
-   WHERE (hat_color = 'green'::bpchar) DO NOTHING                                           +
-   RETURNING hat_data.hat_name,                                                             +
-     hat_data.hat_color;
-(1 row)
-
--- Works (projects row)
-INSERT INTO hats VALUES ('h7', 'black') RETURNING *;
-  hat_name  | hat_color  
-------------+------------
- h7         | black     
-(1 row)
-
--- Works (does nothing)
-INSERT INTO hats VALUES ('h7', 'black') RETURNING *;
- hat_name | hat_color 
-----------+-----------
-(0 rows)
-
-SELECT tablename, rulename, definition FROM pg_rules
-	WHERE tablename = 'hats';
- tablename |  rulename  |                                         definition                                          
------------+------------+---------------------------------------------------------------------------------------------
- hats      | hat_nosert | CREATE RULE hat_nosert AS                                                                  +
-           |            |     ON INSERT TO public.hats DO INSTEAD  INSERT INTO hat_data (hat_name, hat_color)        +
-           |            |   VALUES (new.hat_name, new.hat_color) ON CONFLICT(hat_name COLLATE "C" bpchar_pattern_ops)+
-           |            |   WHERE (hat_color = 'green'::bpchar) DO NOTHING                                           +
-           |            |   RETURNING hat_data.hat_name,                                                             +
-           |            |     hat_data.hat_color;
-(1 row)
-
-DROP RULE hat_nosert ON hats;
--- DO NOTHING without ON CONFLICT
-CREATE RULE hat_nosert_all AS ON INSERT TO hats
-    DO INSTEAD
-    INSERT INTO hat_data VALUES (
-           NEW.hat_name,
-           NEW.hat_color)
-        ON CONFLICT
-        DO NOTHING
-        RETURNING *;
-SELECT definition FROM pg_rules WHERE tablename = 'hats' ORDER BY rulename;
-                                     definition                                      
--------------------------------------------------------------------------------------
- CREATE RULE hat_nosert_all AS                                                      +
-     ON INSERT TO public.hats DO INSTEAD  INSERT INTO hat_data (hat_name, hat_color)+
-   VALUES (new.hat_name, new.hat_color) ON CONFLICT DO NOTHING                      +
-   RETURNING hat_data.hat_name,                                                     +
-     hat_data.hat_color;
-(1 row)
-
-DROP RULE hat_nosert_all ON hats;
--- Works (does nothing)
-INSERT INTO hats VALUES ('h7', 'black') RETURNING *;
-  hat_name  | hat_color  
-------------+------------
- h7         | black     
-(1 row)
-
--- DO UPDATE with a WHERE clause
-CREATE RULE hat_upsert AS ON INSERT TO hats
-    DO INSTEAD
-    INSERT INTO hat_data VALUES (
-           NEW.hat_name,
-           NEW.hat_color)
-        ON CONFLICT (hat_name)
-        DO UPDATE
-           SET hat_name = hat_data.hat_name, hat_color = excluded.hat_color
-           WHERE excluded.hat_color <>  'forbidden' AND hat_data.* != excluded.*
-        RETURNING *;
-SELECT definition FROM pg_rules WHERE tablename = 'hats' ORDER BY rulename;
-                                                               definition                                                                
------------------------------------------------------------------------------------------------------------------------------------------
- CREATE RULE hat_upsert AS                                                                                                              +
-     ON INSERT TO public.hats DO INSTEAD  INSERT INTO hat_data (hat_name, hat_color)                                                    +
-   VALUES (new.hat_name, new.hat_color) ON CONFLICT(hat_name) DO UPDATE SET hat_name = hat_data.hat_name, hat_color = excluded.hat_color+
-   WHERE ((excluded.hat_color <> 'forbidden'::bpchar) AND (hat_data.* <> excluded.*))                                                   +
-   RETURNING hat_data.hat_name,                                                                                                         +
-     hat_data.hat_color;
-(1 row)
-
--- Works (does upsert)
-INSERT INTO hats VALUES ('h8', 'black') RETURNING *;
-  hat_name  | hat_color  
-------------+------------
- h8         | black     
-(1 row)
-
-SELECT * FROM hat_data WHERE hat_name = 'h8';
-  hat_name  | hat_color  
-------------+------------
- h8         | black     
-(1 row)
-
-INSERT INTO hats VALUES ('h8', 'white') RETURNING *;
-  hat_name  | hat_color  
-------------+------------
- h8         | white     
-(1 row)
-
-SELECT * FROM hat_data WHERE hat_name = 'h8';
-  hat_name  | hat_color  
-------------+------------
- h8         | white     
-(1 row)
-
-INSERT INTO hats VALUES ('h8', 'forbidden') RETURNING *;
- hat_name | hat_color 
-----------+-----------
-(0 rows)
-
-SELECT * FROM hat_data WHERE hat_name = 'h8';
-  hat_name  | hat_color  
-------------+------------
- h8         | white     
-(1 row)
-
-SELECT tablename, rulename, definition FROM pg_rules
-	WHERE tablename = 'hats';
- tablename |  rulename  |                                                               definition                                                                
------------+------------+-----------------------------------------------------------------------------------------------------------------------------------------
- hats      | hat_upsert | CREATE RULE hat_upsert AS                                                                                                              +
-           |            |     ON INSERT TO public.hats DO INSTEAD  INSERT INTO hat_data (hat_name, hat_color)                                                    +
-           |            |   VALUES (new.hat_name, new.hat_color) ON CONFLICT(hat_name) DO UPDATE SET hat_name = hat_data.hat_name, hat_color = excluded.hat_color+
-           |            |   WHERE ((excluded.hat_color <> 'forbidden'::bpchar) AND (hat_data.* <> excluded.*))                                                   +
-           |            |   RETURNING hat_data.hat_name,                                                                                                         +
-           |            |     hat_data.hat_color;
-(1 row)
-
--- ensure explain works for on insert conflict rules
-explain (costs off) INSERT INTO hats VALUES ('h8', 'forbidden') RETURNING *;
-                                           QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
- Insert on hat_data
-   Conflict Resolution: UPDATE
-   Conflict Arbiter Indexes: hat_data_unique_idx
-   Conflict Filter: ((excluded.hat_color <> 'forbidden'::bpchar) AND (hat_data.* <> excluded.*))
-   ->  Result
-(5 rows)
-
--- ensure upserting into a rule, with a CTE (different offsets!) works
-WITH data(hat_name, hat_color) AS MATERIALIZED (
-    VALUES ('h8', 'green'),
-        ('h9', 'blue'),
-        ('h7', 'forbidden')
-)
-INSERT INTO hats
-    SELECT * FROM data
-RETURNING *;
-  hat_name  | hat_color  
-------------+------------
- h8         | green     
- h9         | blue      
-(2 rows)
-
-EXPLAIN (costs off)
-WITH data(hat_name, hat_color) AS MATERIALIZED (
-    VALUES ('h8', 'green'),
-        ('h9', 'blue'),
-        ('h7', 'forbidden')
-)
-INSERT INTO hats
-    SELECT * FROM data
-RETURNING *;
-                                           QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
- Insert on hat_data
-   Conflict Resolution: UPDATE
-   Conflict Arbiter Indexes: hat_data_unique_idx
-   Conflict Filter: ((excluded.hat_color <> 'forbidden'::bpchar) AND (hat_data.* <> excluded.*))
-   CTE data
-     ->  Values Scan on "*VALUES*"
-   ->  CTE Scan on data
-(7 rows)
-
-SELECT * FROM hat_data WHERE hat_name IN ('h8', 'h9', 'h7') ORDER BY hat_name;
-  hat_name  | hat_color  
-------------+------------
- h7         | black     
- h8         | green     
- h9         | blue      
-(3 rows)
-
-DROP RULE hat_upsert ON hats;
-drop table hats;
-drop table hat_data;
--- test for pg_get_functiondef properly regurgitating SET parameters
--- Note that the function is kept around to stress pg_dump.
-CREATE FUNCTION func_with_set_params() RETURNS integer
-    AS 'select 1;'
-    LANGUAGE SQL
-    SET search_path TO PG_CATALOG
-    SET extra_float_digits TO 2
-    SET work_mem TO '4MB'
-    SET datestyle to iso, mdy
-    SET local_preload_libraries TO "Mixed/Case", 'c:/''a"/path', '', '0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789'
-    IMMUTABLE STRICT;
-SELECT pg_get_functiondef('func_with_set_params()'::regprocedure);
-                                                                            pg_get_functiondef                                                                            
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
- CREATE OR REPLACE FUNCTION public.func_with_set_params()                                                                                                                +
-  RETURNS integer                                                                                                                                                        +
-  LANGUAGE sql                                                                                                                                                           +
-  IMMUTABLE STRICT                                                                                                                                                       +
-  SET search_path TO 'pg_catalog'                                                                                                                                        +
-  SET extra_float_digits TO '2'                                                                                                                                          +
-  SET work_mem TO '4MB'                                                                                                                                                  +
-  SET "DateStyle" TO 'iso, mdy'                                                                                                                                          +
-  SET local_preload_libraries TO 'Mixed/Case', 'c:/''a"/path', '', '0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789'+
- AS $function$select 1;$function$                                                                                                                                        +
- 
-(1 row)
-
--- tests for pg_get_*def with invalid objects
-SELECT pg_get_constraintdef(0);
- pg_get_constraintdef 
-----------------------
- 
-(1 row)
-
-SELECT pg_get_functiondef(0);
- pg_get_functiondef 
---------------------
- 
-(1 row)
-
-SELECT pg_get_indexdef(0);
- pg_get_indexdef 
------------------
- 
-(1 row)
-
-SELECT pg_get_ruledef(0);
- pg_get_ruledef 
-----------------
- 
-(1 row)
-
-SELECT pg_get_statisticsobjdef(0);
- pg_get_statisticsobjdef 
--------------------------
- 
-(1 row)
-
-SELECT pg_get_triggerdef(0);
- pg_get_triggerdef 
--------------------
- 
-(1 row)
-
-SELECT pg_get_viewdef(0);
- pg_get_viewdef 
-----------------
- 
-(1 row)
-
-SELECT pg_get_function_arguments(0);
- pg_get_function_arguments 
----------------------------
- 
-(1 row)
-
-SELECT pg_get_function_identity_arguments(0);
- pg_get_function_identity_arguments 
-------------------------------------
- 
-(1 row)
-
-SELECT pg_get_function_result(0);
- pg_get_function_result 
-------------------------
- 
-(1 row)
-
-SELECT pg_get_function_arg_default(0, 0);
- pg_get_function_arg_default 
------------------------------
- 
-(1 row)
-
-SELECT pg_get_function_arg_default('pg_class'::regclass, 0);
- pg_get_function_arg_default 
------------------------------
- 
-(1 row)
-
-SELECT pg_get_partkeydef(0);
- pg_get_partkeydef 
--------------------
- 
-(1 row)
-
--- test rename for a rule defined on a partitioned table
-CREATE TABLE rules_parted_table (a int) PARTITION BY LIST (a);
-CREATE TABLE rules_parted_table_1 PARTITION OF rules_parted_table FOR VALUES IN (1);
-CREATE RULE rules_parted_table_insert AS ON INSERT to rules_parted_table
-    DO INSTEAD INSERT INTO rules_parted_table_1 VALUES (NEW.*);
-ALTER RULE rules_parted_table_insert ON rules_parted_table RENAME TO rules_parted_table_insert_redirect;
-DROP TABLE rules_parted_table;
---
--- Test enabling/disabling
---
-CREATE TABLE ruletest1 (a int);
-CREATE TABLE ruletest2 (b int);
-CREATE RULE rule1 AS ON INSERT TO ruletest1
-    DO INSTEAD INSERT INTO ruletest2 VALUES (NEW.*);
-INSERT INTO ruletest1 VALUES (1);
-ALTER TABLE ruletest1 DISABLE RULE rule1;
-INSERT INTO ruletest1 VALUES (2);
-ALTER TABLE ruletest1 ENABLE RULE rule1;
-SET session_replication_role = replica;
-INSERT INTO ruletest1 VALUES (3);
-ALTER TABLE ruletest1 ENABLE REPLICA RULE rule1;
-INSERT INTO ruletest1 VALUES (4);
-RESET session_replication_role;
-INSERT INTO ruletest1 VALUES (5);
-SELECT * FROM ruletest1;
- a 
----
- 2
- 3
- 5
-(3 rows)
-
-SELECT * FROM ruletest2;
- b 
----
- 1
- 4
-(2 rows)
-
-DROP TABLE ruletest1;
-DROP TABLE ruletest2;
diff -U3 /Users/kenaniah/workspace/postgres/src/test/regress/expected/psql.out /Users/kenaniah/workspace/postgres/src/test/regress/results/psql.out
--- /Users/kenaniah/workspace/postgres/src/test/regress/expected/psql.out	2021-10-03 18:09:17.000000000 -0700
+++ /Users/kenaniah/workspace/postgres/src/test/regress/results/psql.out	2021-10-03 20:08:20.000000000 -0700
@@ -54,5227 +54,11 @@
 -- \gx should work in FETCH_COUNT mode too
 \set FETCH_COUNT 1
 SELECT 1 as one, 2 as two \g
- one | two 
------+-----
-   1 |   2
-(1 row)
+dyld: lazy symbol binding failed: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
+
+dyld: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
 
-\gx
--[ RECORD 1 ]
-one | 1
-two | 2
-
-SELECT 3 as three, 4 as four \gx
--[ RECORD 1 ]
-three | 3
-four  | 4
-
-\g
- three | four 
--------+------
-     3 |    4
-(1 row)
-
-\unset FETCH_COUNT
--- \g/\gx with pset options
-SELECT 1 as one, 2 as two \g (format=csv csv_fieldsep='\t')
-one	two
-1	2
-\g
- one | two 
------+-----
-   1 |   2
-(1 row)
-
-SELECT 1 as one, 2 as two \gx (title='foo bar')
-foo bar
--[ RECORD 1 ]
-one | 1
-two | 2
-
-\g
- one | two 
------+-----
-   1 |   2
-(1 row)
-
--- \gset
-select 10 as test01, 20 as test02, 'Hello' as test03 \gset pref01_
-\echo :pref01_test01 :pref01_test02 :pref01_test03
-10 20 Hello
--- should fail: bad variable name
-select 10 as "bad name"
-\gset
-invalid variable name: "bad name"
-select 97 as "EOF", 'ok' as _foo \gset IGNORE
-attempt to \gset into specially treated variable "IGNOREEOF" ignored
-\echo :IGNORE_foo :IGNOREEOF
-ok 0
--- multiple backslash commands in one line
-select 1 as x, 2 as y \gset pref01_ \\ \echo :pref01_x
-1
-select 3 as x, 4 as y \gset pref01_ \echo :pref01_x \echo :pref01_y
-3
-4
-select 5 as x, 6 as y \gset pref01_ \\ \g \echo :pref01_x :pref01_y
- x | y 
----+---
- 5 | 6
-(1 row)
-
-5 6
-select 7 as x, 8 as y \g \gset pref01_ \echo :pref01_x :pref01_y
- x | y 
----+---
- 7 | 8
-(1 row)
-
-7 8
--- NULL should unset the variable
-\set var2 xyz
-select 1 as var1, NULL as var2, 3 as var3 \gset
-\echo :var1 :var2 :var3
-1 :var2 3
--- \gset requires just one tuple
-select 10 as test01, 20 as test02 from generate_series(1,3) \gset
-more than one row returned for \gset
-select 10 as test01, 20 as test02 from generate_series(1,0) \gset
-no rows returned for \gset
--- \gset should work in FETCH_COUNT mode too
-\set FETCH_COUNT 1
-select 1 as x, 2 as y \gset pref01_ \\ \echo :pref01_x
-1
-select 3 as x, 4 as y \gset pref01_ \echo :pref01_x \echo :pref01_y
-3
-4
-select 10 as test01, 20 as test02 from generate_series(1,3) \gset
-more than one row returned for \gset
-select 10 as test01, 20 as test02 from generate_series(1,0) \gset
-no rows returned for \gset
-\unset FETCH_COUNT
--- \gdesc
-SELECT
-    NULL AS zero,
-    1 AS one,
-    2.0 AS two,
-    'three' AS three,
-    $1 AS four,
-    sin($2) as five,
-    'foo'::varchar(4) as six,
-    CURRENT_DATE AS now
-\gdesc
- Column |         Type         
---------+----------------------
- zero   | text
- one    | integer
- two    | numeric
- three  | text
- four   | text
- five   | double precision
- six    | character varying(4)
- now    | date
-(8 rows)
-
--- should work with tuple-returning utilities, such as EXECUTE
-PREPARE test AS SELECT 1 AS first, 2 AS second;
-EXECUTE test \gdesc
- Column |  Type   
---------+---------
- first  | integer
- second | integer
-(2 rows)
-
-EXPLAIN EXECUTE test \gdesc
-   Column   | Type 
-------------+------
- QUERY PLAN | text
-(1 row)
-
--- should fail cleanly - syntax error
-SELECT 1 + \gdesc
-ERROR:  syntax error at end of input
-LINE 1: SELECT 1 + 
-                   ^
--- check behavior with empty results
-SELECT \gdesc
-The command has no result, or the result has no columns.
-CREATE TABLE bububu(a int) \gdesc
-The command has no result, or the result has no columns.
--- subject command should not have executed
-TABLE bububu;  -- fail
-ERROR:  relation "bububu" does not exist
-LINE 1: TABLE bububu;
-              ^
--- query buffer should remain unchanged
-SELECT 1 AS x, 'Hello', 2 AS y, true AS "dirty\name"
-\gdesc
-   Column   |  Type   
-------------+---------
- x          | integer
- ?column?   | text
- y          | integer
- dirty\name | boolean
-(4 rows)
-
-\g
- x | ?column? | y | dirty\name 
----+----------+---+------------
- 1 | Hello    | 2 | t
-(1 row)
-
--- all on one line
-SELECT 3 AS x, 'Hello', 4 AS y, true AS "dirty\name" \gdesc \g
-   Column   |  Type   
-------------+---------
- x          | integer
- ?column?   | text
- y          | integer
- dirty\name | boolean
-(4 rows)
-
- x | ?column? | y | dirty\name 
----+----------+---+------------
- 3 | Hello    | 4 | t
-(1 row)
-
--- \gexec
-create temporary table gexec_test(a int, b text, c date, d float);
-select format('create index on gexec_test(%I)', attname)
-from pg_attribute
-where attrelid = 'gexec_test'::regclass and attnum > 0
-order by attnum
-\gexec
-create index on gexec_test(a)
-create index on gexec_test(b)
-create index on gexec_test(c)
-create index on gexec_test(d)
--- \gexec should work in FETCH_COUNT mode too
--- (though the fetch limit applies to the executed queries not the meta query)
-\set FETCH_COUNT 1
-select 'select 1 as ones', 'select x.y, x.y*2 as double from generate_series(1,4) as x(y)'
-union all
-select 'drop table gexec_test', NULL
-union all
-select 'drop table gexec_test', 'select ''2000-01-01''::date as party_over'
-\gexec
-select 1 as ones
- ones 
-------
-    1
-(1 row)
-
-select x.y, x.y*2 as double from generate_series(1,4) as x(y)
- y | double 
----+--------
- 1 |      2
- 2 |      4
- 3 |      6
- 4 |      8
-(4 rows)
-
-drop table gexec_test
-drop table gexec_test
-ERROR:  table "gexec_test" does not exist
-select '2000-01-01'::date as party_over
- party_over 
-------------
- 01-01-2000
-(1 row)
-
-\unset FETCH_COUNT
--- show all pset options
-\pset
-border                   1
-columns                  0
-csv_fieldsep             ','
-expanded                 off
-fieldsep                 '|'
-fieldsep_zero            off
-footer                   on
-format                   aligned
-linestyle                ascii
-null                     ''
-numericlocale            off
-pager                    1
-pager_min_lines          0
-recordsep                '\n'
-recordsep_zero           off
-tableattr                
-title                    
-tuples_only              off
-unicode_border_linestyle single
-unicode_column_linestyle single
-unicode_header_linestyle single
--- test multi-line headers, wrapping, and newline indicators
--- in aligned, unaligned, and wrapped formats
-prepare q as select array_to_string(array_agg(repeat('x',2*n)),E'\n') as "ab
-
-c", array_to_string(array_agg(repeat('y',20-2*n)),E'\n') as "a
-bc" from generate_series(1,10) as n(n) group by n>1 order by n>1;
-\pset linestyle ascii
-\pset expanded off
-\pset columns 40
-\pset border 0
-\pset format unaligned
-execute q;
-ab
-
-c|a
-bc
-xx|yyyyyyyyyyyyyyyyyy
-xxxx
-xxxxxx
-xxxxxxxx
-xxxxxxxxxx
-xxxxxxxxxxxx
-xxxxxxxxxxxxxx
-xxxxxxxxxxxxxxxx
-xxxxxxxxxxxxxxxxxx
-xxxxxxxxxxxxxxxxxxxx|yyyyyyyyyyyyyyyy
-yyyyyyyyyyyyyy
-yyyyyyyyyyyy
-yyyyyyyyyy
-yyyyyyyy
-yyyyyy
-yyyy
-yy
-
-(2 rows)
-\pset format aligned
-execute q;
-         ab         +        a         +
-                    +        bc         
-         c                              
--------------------- ------------------
-xx                   yyyyyyyyyyyyyyyyyy
-xxxx                +yyyyyyyyyyyyyyyy  +
-xxxxxx              +yyyyyyyyyyyyyy    +
-xxxxxxxx            +yyyyyyyyyyyy      +
-xxxxxxxxxx          +yyyyyyyyyy        +
-xxxxxxxxxxxx        +yyyyyyyy          +
-xxxxxxxxxxxxxx      +yyyyyy            +
-xxxxxxxxxxxxxxxx    +yyyy              +
-xxxxxxxxxxxxxxxxxx  +yy                +
-xxxxxxxxxxxxxxxxxxxx 
-(2 rows)
-
-\pset format wrapped
-execute q;
-         ab         +        a         +
-                    +        bc         
-         c                              
--------------------- ------------------
-xx                   yyyyyyyyyyyyyyyyyy
-xxxx                +yyyyyyyyyyyyyyyy  +
-xxxxxx              +yyyyyyyyyyyyyy    +
-xxxxxxxx            +yyyyyyyyyyyy      +
-xxxxxxxxxx          +yyyyyyyyyy        +
-xxxxxxxxxxxx        +yyyyyyyy          +
-xxxxxxxxxxxxxx      +yyyyyy            +
-xxxxxxxxxxxxxxxx    +yyyy              +
-xxxxxxxxxxxxxxxxxx  +yy                +
-xxxxxxxxxxxxxxxxxxxx 
-(2 rows)
-
-\pset border 1
-\pset format unaligned
-execute q;
-ab
-
-c|a
-bc
-xx|yyyyyyyyyyyyyyyyyy
-xxxx
-xxxxxx
-xxxxxxxx
-xxxxxxxxxx
-xxxxxxxxxxxx
-xxxxxxxxxxxxxx
-xxxxxxxxxxxxxxxx
-xxxxxxxxxxxxxxxxxx
-xxxxxxxxxxxxxxxxxxxx|yyyyyyyyyyyyyyyy
-yyyyyyyyyyyyyy
-yyyyyyyyyyyy
-yyyyyyyyyy
-yyyyyyyy
-yyyyyy
-yyyy
-yy
-
-(2 rows)
-\pset format aligned
-execute q;
-          ab         +|         a         +
-                     +|         bc         
-          c           |                    
-----------------------+--------------------
- xx                   | yyyyyyyyyyyyyyyyyy
- xxxx                +| yyyyyyyyyyyyyyyy  +
- xxxxxx              +| yyyyyyyyyyyyyy    +
- xxxxxxxx            +| yyyyyyyyyyyy      +
- xxxxxxxxxx          +| yyyyyyyyyy        +
- xxxxxxxxxxxx        +| yyyyyyyy          +
- xxxxxxxxxxxxxx      +| yyyyyy            +
- xxxxxxxxxxxxxxxx    +| yyyy              +
- xxxxxxxxxxxxxxxxxx  +| yy                +
- xxxxxxxxxxxxxxxxxxxx | 
-(2 rows)
-
-\pset format wrapped
-execute q;
-        ab        +|         a         +
-                  +|         bc         
-         c         |                    
--------------------+--------------------
- xx                | yyyyyyyyyyyyyyyyyy
- xxxx             +| yyyyyyyyyyyyyyyy  +
- xxxxxx           +| yyyyyyyyyyyyyy    +
- xxxxxxxx         +| yyyyyyyyyyyy      +
- xxxxxxxxxx       +| yyyyyyyyyy        +
- xxxxxxxxxxxx     +| yyyyyyyy          +
- xxxxxxxxxxxxxx   +| yyyyyy            +
- xxxxxxxxxxxxxxxx +| yyyy              +
- xxxxxxxxxxxxxxxxx.| yy                +
-.x                +| 
- xxxxxxxxxxxxxxxxx.| 
-.xxx               | 
-(2 rows)
-
-\pset border 2
-\pset format unaligned
-execute q;
-ab
-
-c|a
-bc
-xx|yyyyyyyyyyyyyyyyyy
-xxxx
-xxxxxx
-xxxxxxxx
-xxxxxxxxxx
-xxxxxxxxxxxx
-xxxxxxxxxxxxxx
-xxxxxxxxxxxxxxxx
-xxxxxxxxxxxxxxxxxx
-xxxxxxxxxxxxxxxxxxxx|yyyyyyyyyyyyyyyy
-yyyyyyyyyyyyyy
-yyyyyyyyyyyy
-yyyyyyyyyy
-yyyyyyyy
-yyyyyy
-yyyy
-yy
-
-(2 rows)
-\pset format aligned
-execute q;
-+----------------------+--------------------+
-|          ab         +|         a         +|
-|                     +|         bc         |
-|          c           |                    |
-+----------------------+--------------------+
-| xx                   | yyyyyyyyyyyyyyyyyy |
-| xxxx                +| yyyyyyyyyyyyyyyy  +|
-| xxxxxx              +| yyyyyyyyyyyyyy    +|
-| xxxxxxxx            +| yyyyyyyyyyyy      +|
-| xxxxxxxxxx          +| yyyyyyyyyy        +|
-| xxxxxxxxxxxx        +| yyyyyyyy          +|
-| xxxxxxxxxxxxxx      +| yyyyyy            +|
-| xxxxxxxxxxxxxxxx    +| yyyy              +|
-| xxxxxxxxxxxxxxxxxx  +| yy                +|
-| xxxxxxxxxxxxxxxxxxxx |                    |
-+----------------------+--------------------+
-(2 rows)
-
-\pset format wrapped
-execute q;
-+-----------------+--------------------+
-|       ab       +|         a         +|
-|                +|         bc         |
-|        c        |                    |
-+-----------------+--------------------+
-| xx              | yyyyyyyyyyyyyyyyyy |
-| xxxx           +| yyyyyyyyyyyyyyyy  +|
-| xxxxxx         +| yyyyyyyyyyyyyy    +|
-| xxxxxxxx       +| yyyyyyyyyyyy      +|
-| xxxxxxxxxx     +| yyyyyyyyyy        +|
-| xxxxxxxxxxxx   +| yyyyyyyy          +|
-| xxxxxxxxxxxxxx +| yyyyyy            +|
-| xxxxxxxxxxxxxxx.| yyyy              +|
-|.x              +| yy                +|
-| xxxxxxxxxxxxxxx.|                    |
-|.xxx            +|                    |
-| xxxxxxxxxxxxxxx.|                    |
-|.xxxxx           |                    |
-+-----------------+--------------------+
-(2 rows)
-
-\pset expanded on
-\pset columns 20
-\pset border 0
-\pset format unaligned
-execute q;
-ab
-
-c|xx
-a
-bc|yyyyyyyyyyyyyyyyyy
-
-ab
-
-c|xxxx
-xxxxxx
-xxxxxxxx
-xxxxxxxxxx
-xxxxxxxxxxxx
-xxxxxxxxxxxxxx
-xxxxxxxxxxxxxxxx
-xxxxxxxxxxxxxxxxxx
-xxxxxxxxxxxxxxxxxxxx
-a
-bc|yyyyyyyyyyyyyyyy
-yyyyyyyyyyyyyy
-yyyyyyyyyyyy
-yyyyyyyyyy
-yyyyyyyy
-yyyyyy
-yyyy
-yy
-
-\pset format aligned
-execute q;
-* Record 1            
-ab+ xx
-  +
-c  
-a + yyyyyyyyyyyyyyyyyy
-bc 
-* Record 2            
-ab+ xxxx                +
-  + xxxxxx              +
-c   xxxxxxxx            +
-    xxxxxxxxxx          +
-    xxxxxxxxxxxx        +
-    xxxxxxxxxxxxxx      +
-    xxxxxxxxxxxxxxxx    +
-    xxxxxxxxxxxxxxxxxx  +
-    xxxxxxxxxxxxxxxxxxxx
-a + yyyyyyyyyyyyyyyy    +
-bc  yyyyyyyyyyyyyy      +
-    yyyyyyyyyyyy        +
-    yyyyyyyyyy          +
-    yyyyyyyy            +
-    yyyyyy              +
-    yyyy                +
-    yy                  +
-    
-
-\pset format wrapped
-execute q;
-* Record 1       
-ab+ xx
-  +
-c  
-a + yyyyyyyyyyyyyyy.
-bc .yyy
-* Record 2       
-ab+ xxxx           +
-  + xxxxxx         +
-c   xxxxxxxx       +
-    xxxxxxxxxx     +
-    xxxxxxxxxxxx   +
-    xxxxxxxxxxxxxx +
-    xxxxxxxxxxxxxxx.
-   .x              +
-    xxxxxxxxxxxxxxx.
-   .xxx            +
-    xxxxxxxxxxxxxxx.
-   .xxxxx
-a + yyyyyyyyyyyyyyy.
-bc .y              +
-    yyyyyyyyyyyyyy +
-    yyyyyyyyyyyy   +
-    yyyyyyyyyy     +
-    yyyyyyyy       +
-    yyyyyy         +
-    yyyy           +
-    yy             +
-    
-
-\pset border 1
-\pset format unaligned
-execute q;
-ab
-
-c|xx
-a
-bc|yyyyyyyyyyyyyyyyyy
-
-ab
-
-c|xxxx
-xxxxxx
-xxxxxxxx
-xxxxxxxxxx
-xxxxxxxxxxxx
-xxxxxxxxxxxxxx
-xxxxxxxxxxxxxxxx
-xxxxxxxxxxxxxxxxxx
-xxxxxxxxxxxxxxxxxxxx
-a
-bc|yyyyyyyyyyyyyyyy
-yyyyyyyyyyyyyy
-yyyyyyyyyyyy
-yyyyyyyyyy
-yyyyyyyy
-yyyyyy
-yyyy
-yy
-
-\pset format aligned
-execute q;
--[ RECORD 1 ]------------
-ab+| xx
-  +|
-c  |
-a +| yyyyyyyyyyyyyyyyyy
-bc |
--[ RECORD 2 ]------------
-ab+| xxxx                +
-  +| xxxxxx              +
-c  | xxxxxxxx            +
-   | xxxxxxxxxx          +
-   | xxxxxxxxxxxx        +
-   | xxxxxxxxxxxxxx      +
-   | xxxxxxxxxxxxxxxx    +
-   | xxxxxxxxxxxxxxxxxx  +
-   | xxxxxxxxxxxxxxxxxxxx
-a +| yyyyyyyyyyyyyyyy    +
-bc | yyyyyyyyyyyyyy      +
-   | yyyyyyyyyyyy        +
-   | yyyyyyyyyy          +
-   | yyyyyyyy            +
-   | yyyyyy              +
-   | yyyy                +
-   | yy                  +
-   | 
-
-\pset format wrapped
-execute q;
--[ RECORD 1 ]------
-ab+| xx
-  +|
-c  |
-a +| yyyyyyyyyyyyyy.
-bc |.yyyy
--[ RECORD 2 ]------
-ab+| xxxx          +
-  +| xxxxxx        +
-c  | xxxxxxxx      +
-   | xxxxxxxxxx    +
-   | xxxxxxxxxxxx  +
-   | xxxxxxxxxxxxxx+
-   | xxxxxxxxxxxxxx.
-   |.xx            +
-   | xxxxxxxxxxxxxx.
-   |.xxxx          +
-   | xxxxxxxxxxxxxx.
-   |.xxxxxx
-a +| yyyyyyyyyyyyyy.
-bc |.yy            +
-   | yyyyyyyyyyyyyy+
-   | yyyyyyyyyyyy  +
-   | yyyyyyyyyy    +
-   | yyyyyyyy      +
-   | yyyyyy        +
-   | yyyy          +
-   | yy            +
-   | 
-
-\pset border 2
-\pset format unaligned
-execute q;
-ab
-
-c|xx
-a
-bc|yyyyyyyyyyyyyyyyyy
-
-ab
-
-c|xxxx
-xxxxxx
-xxxxxxxx
-xxxxxxxxxx
-xxxxxxxxxxxx
-xxxxxxxxxxxxxx
-xxxxxxxxxxxxxxxx
-xxxxxxxxxxxxxxxxxx
-xxxxxxxxxxxxxxxxxxxx
-a
-bc|yyyyyyyyyyyyyyyy
-yyyyyyyyyyyyyy
-yyyyyyyyyyyy
-yyyyyyyyyy
-yyyyyyyy
-yyyyyy
-yyyy
-yy
-
-\pset format aligned
-execute q;
-+-[ RECORD 1 ]--------------+
-| ab+| xx                   |
-|   +|                      |
-| c  |                      |
-| a +| yyyyyyyyyyyyyyyyyy   |
-| bc |                      |
-+-[ RECORD 2 ]--------------+
-| ab+| xxxx                +|
-|   +| xxxxxx              +|
-| c  | xxxxxxxx            +|
-|    | xxxxxxxxxx          +|
-|    | xxxxxxxxxxxx        +|
-|    | xxxxxxxxxxxxxx      +|
-|    | xxxxxxxxxxxxxxxx    +|
-|    | xxxxxxxxxxxxxxxxxx  +|
-|    | xxxxxxxxxxxxxxxxxxxx |
-| a +| yyyyyyyyyyyyyyyy    +|
-| bc | yyyyyyyyyyyyyy      +|
-|    | yyyyyyyyyyyy        +|
-|    | yyyyyyyyyy          +|
-|    | yyyyyyyy            +|
-|    | yyyyyy              +|
-|    | yyyy                +|
-|    | yy                  +|
-|    |                      |
-+----+----------------------+
-
-\pset format wrapped
-execute q;
-+-[ RECORD 1 ]-----+
-| ab+| xx          |
-|   +|             |
-| c  |             |
-| a +| yyyyyyyyyyy.|
-| bc |.yyyyyyy     |
-+-[ RECORD 2 ]-----+
-| ab+| xxxx       +|
-|   +| xxxxxx     +|
-| c  | xxxxxxxx   +|
-|    | xxxxxxxxxx +|
-|    | xxxxxxxxxxx.|
-|    |.x          +|
-|    | xxxxxxxxxxx.|
-|    |.xxx        +|
-|    | xxxxxxxxxxx.|
-|    |.xxxxx      +|
-|    | xxxxxxxxxxx.|
-|    |.xxxxxxx    +|
-|    | xxxxxxxxxxx.|
-|    |.xxxxxxxxx   |
-| a +| yyyyyyyyyyy.|
-| bc |.yyyyy      +|
-|    | yyyyyyyyyyy.|
-|    |.yyy        +|
-|    | yyyyyyyyyyy.|
-|    |.y          +|
-|    | yyyyyyyyyy +|
-|    | yyyyyyyy   +|
-|    | yyyyyy     +|
-|    | yyyy       +|
-|    | yy         +|
-|    |             |
-+----+-------------+
-
-\pset linestyle old-ascii
-\pset expanded off
-\pset columns 40
-\pset border 0
-\pset format unaligned
-execute q;
-ab
-
-c|a
-bc
-xx|yyyyyyyyyyyyyyyyyy
-xxxx
-xxxxxx
-xxxxxxxx
-xxxxxxxxxx
-xxxxxxxxxxxx
-xxxxxxxxxxxxxx
-xxxxxxxxxxxxxxxx
-xxxxxxxxxxxxxxxxxx
-xxxxxxxxxxxxxxxxxxxx|yyyyyyyyyyyyyyyy
-yyyyyyyyyyyyyy
-yyyyyyyyyyyy
-yyyyyyyyyy
-yyyyyyyy
-yyyyyy
-yyyy
-yy
-
-(2 rows)
-\pset format aligned
-execute q;
-         ab                  a         
-                    +        bc        
-         c          +                  
--------------------- ------------------
-xx                   yyyyyyyyyyyyyyyyyy
-xxxx                 yyyyyyyyyyyyyyyy   
-xxxxxx               yyyyyyyyyyyyyy     
-xxxxxxxx             yyyyyyyyyyyy       
-xxxxxxxxxx           yyyyyyyyyy         
-xxxxxxxxxxxx         yyyyyyyy           
-xxxxxxxxxxxxxx       yyyyyy             
-xxxxxxxxxxxxxxxx     yyyy               
-xxxxxxxxxxxxxxxxxx   yy                 
-xxxxxxxxxxxxxxxxxxxx 
-(2 rows)
-
-\pset format wrapped
-execute q;
-         ab                  a         
-                    +        bc        
-         c          +                  
--------------------- ------------------
-xx                   yyyyyyyyyyyyyyyyyy
-xxxx                 yyyyyyyyyyyyyyyy   
-xxxxxx               yyyyyyyyyyyyyy     
-xxxxxxxx             yyyyyyyyyyyy       
-xxxxxxxxxx           yyyyyyyyyy         
-xxxxxxxxxxxx         yyyyyyyy           
-xxxxxxxxxxxxxx       yyyyyy             
-xxxxxxxxxxxxxxxx     yyyy               
-xxxxxxxxxxxxxxxxxx   yy                 
-xxxxxxxxxxxxxxxxxxxx 
-(2 rows)
-
-\pset border 1
-\pset format unaligned
-execute q;
-ab
-
-c|a
-bc
-xx|yyyyyyyyyyyyyyyyyy
-xxxx
-xxxxxx
-xxxxxxxx
-xxxxxxxxxx
-xxxxxxxxxxxx
-xxxxxxxxxxxxxx
-xxxxxxxxxxxxxxxx
-xxxxxxxxxxxxxxxxxx
-xxxxxxxxxxxxxxxxxxxx|yyyyyyyyyyyyyyyy
-yyyyyyyyyyyyyy
-yyyyyyyyyyyy
-yyyyyyyyyy
-yyyyyyyy
-yyyyyy
-yyyy
-yy
-
-(2 rows)
-\pset format aligned
-execute q;
-          ab          |         a          
-+                     |+        bc         
-+         c           |+                   
-----------------------+--------------------
- xx                   | yyyyyyyyyyyyyyyyyy
- xxxx                 | yyyyyyyyyyyyyyyy   
- xxxxxx               : yyyyyyyyyyyyyy     
- xxxxxxxx             : yyyyyyyyyyyy       
- xxxxxxxxxx           : yyyyyyyyyy         
- xxxxxxxxxxxx         : yyyyyyyy           
- xxxxxxxxxxxxxx       : yyyyyy             
- xxxxxxxxxxxxxxxx     : yyyy               
- xxxxxxxxxxxxxxxxxx   : yy                 
- xxxxxxxxxxxxxxxxxxxx : 
-(2 rows)
-
-\pset format wrapped
-execute q;
-        ab         |         a          
-+                  |+        bc         
-+        c         |+                   
--------------------+--------------------
- xx                | yyyyyyyyyyyyyyyyyy
- xxxx              | yyyyyyyyyyyyyyyy   
- xxxxxx            : yyyyyyyyyyyyyy     
- xxxxxxxx          : yyyyyyyyyyyy       
- xxxxxxxxxx        : yyyyyyyyyy         
- xxxxxxxxxxxx      : yyyyyyyy           
- xxxxxxxxxxxxxx    : yyyyyy             
- xxxxxxxxxxxxxxxx  : yyyy               
- xxxxxxxxxxxxxxxxx : yy                 
- x                 : 
- xxxxxxxxxxxxxxxxx   
- xxx                 
-(2 rows)
-
-\pset border 2
-\pset format unaligned
-execute q;
-ab
-
-c|a
-bc
-xx|yyyyyyyyyyyyyyyyyy
-xxxx
-xxxxxx
-xxxxxxxx
-xxxxxxxxxx
-xxxxxxxxxxxx
-xxxxxxxxxxxxxx
-xxxxxxxxxxxxxxxx
-xxxxxxxxxxxxxxxxxx
-xxxxxxxxxxxxxxxxxxxx|yyyyyyyyyyyyyyyy
-yyyyyyyyyyyyyy
-yyyyyyyyyyyy
-yyyyyyyyyy
-yyyyyyyy
-yyyyyy
-yyyy
-yy
-
-(2 rows)
-\pset format aligned
-execute q;
-+----------------------+--------------------+
-|          ab          |         a          |
-|+                     |+        bc         |
-|+         c           |+                   |
-+----------------------+--------------------+
-| xx                   | yyyyyyyyyyyyyyyyyy |
-| xxxx                 | yyyyyyyyyyyyyyyy   |
-| xxxxxx               : yyyyyyyyyyyyyy     |
-| xxxxxxxx             : yyyyyyyyyyyy       |
-| xxxxxxxxxx           : yyyyyyyyyy         |
-| xxxxxxxxxxxx         : yyyyyyyy           |
-| xxxxxxxxxxxxxx       : yyyyyy             |
-| xxxxxxxxxxxxxxxx     : yyyy               |
-| xxxxxxxxxxxxxxxxxx   : yy                 |
-| xxxxxxxxxxxxxxxxxxxx :                    |
-+----------------------+--------------------+
-(2 rows)
-
-\pset format wrapped
-execute q;
-+-----------------+--------------------+
-|       ab        |         a          |
-|+                |+        bc         |
-|+       c        |+                   |
-+-----------------+--------------------+
-| xx              | yyyyyyyyyyyyyyyyyy |
-| xxxx            | yyyyyyyyyyyyyyyy   |
-| xxxxxx          : yyyyyyyyyyyyyy     |
-| xxxxxxxx        : yyyyyyyyyyyy       |
-| xxxxxxxxxx      : yyyyyyyyyy         |
-| xxxxxxxxxxxx    : yyyyyyyy           |
-| xxxxxxxxxxxxxx  : yyyyyy             |
-| xxxxxxxxxxxxxxx : yyyy               |
-| x               : yy                 |
-| xxxxxxxxxxxxxxx :                    |
-| xxx                                  |
-| xxxxxxxxxxxxxxx                      |
-| xxxxx                                |
-+-----------------+--------------------+
-(2 rows)
-
-\pset expanded on
-\pset columns 20
-\pset border 0
-\pset format unaligned
-execute q;
-ab
-
-c|xx
-a
-bc|yyyyyyyyyyyyyyyyyy
-
-ab
-
-c|xxxx
-xxxxxx
-xxxxxxxx
-xxxxxxxxxx
-xxxxxxxxxxxx
-xxxxxxxxxxxxxx
-xxxxxxxxxxxxxxxx
-xxxxxxxxxxxxxxxxxx
-xxxxxxxxxxxxxxxxxxxx
-a
-bc|yyyyyyyyyyyyyyyy
-yyyyyyyyyyyyyy
-yyyyyyyyyyyy
-yyyyyyyyyy
-yyyyyyyy
-yyyyyy
-yyyy
-yy
-
-\pset format aligned
-execute q;
-* Record 1             
- ab xx
-+  
-+c 
- a  yyyyyyyyyyyyyyyyyy
-+bc
-* Record 2             
- ab xxxx
-+   xxxxxx
-+c  xxxxxxxx
-    xxxxxxxxxx
-    xxxxxxxxxxxx
-    xxxxxxxxxxxxxx
-    xxxxxxxxxxxxxxxx
-    xxxxxxxxxxxxxxxxxx
-    xxxxxxxxxxxxxxxxxxxx
- a  yyyyyyyyyyyyyyyy
-+bc yyyyyyyyyyyyyy
-    yyyyyyyyyyyy
-    yyyyyyyyyy
-    yyyyyyyy
-    yyyyyy
-    yyyy
-    yy
-    
-
-\pset format wrapped
-execute q;
-* Record 1         
- ab xx
-+  
-+c 
- a  yyyyyyyyyyyyyyyy
-+bc yy
-* Record 2         
- ab xxxx
-+   xxxxxx
-+c  xxxxxxxx
-    xxxxxxxxxx
-    xxxxxxxxxxxx
-    xxxxxxxxxxxxxx
-    xxxxxxxxxxxxxxxx
-    xxxxxxxxxxxxxxxx
-    xx
-    xxxxxxxxxxxxxxxx
-    xxxx
- a  yyyyyyyyyyyyyyyy
-+bc yyyyyyyyyyyyyy
-    yyyyyyyyyyyy
-    yyyyyyyyyy
-    yyyyyyyy
-    yyyyyy
-    yyyy
-    yy
-    
-
-\pset border 1
-\pset format unaligned
-execute q;
-ab
-
-c|xx
-a
-bc|yyyyyyyyyyyyyyyyyy
-
-ab
-
-c|xxxx
-xxxxxx
-xxxxxxxx
-xxxxxxxxxx
-xxxxxxxxxxxx
-xxxxxxxxxxxxxx
-xxxxxxxxxxxxxxxx
-xxxxxxxxxxxxxxxxxx
-xxxxxxxxxxxxxxxxxxxx
-a
-bc|yyyyyyyyyyyyyyyy
-yyyyyyyyyyyyyy
-yyyyyyyyyyyy
-yyyyyyyyyy
-yyyyyyyy
-yyyyyy
-yyyy
-yy
-
-\pset format aligned
-execute q;
--[ RECORD 1 ]-------------
- ab | xx
-+   ;
-+c  ;
- a  | yyyyyyyyyyyyyyyyyy
-+bc ;
--[ RECORD 2 ]-------------
- ab | xxxx
-+   : xxxxxx
-+c  : xxxxxxxx
-    : xxxxxxxxxx
-    : xxxxxxxxxxxx
-    : xxxxxxxxxxxxxx
-    : xxxxxxxxxxxxxxxx
-    : xxxxxxxxxxxxxxxxxx
-    : xxxxxxxxxxxxxxxxxxxx
- a  | yyyyyyyyyyyyyyyy
-+bc : yyyyyyyyyyyyyy
-    : yyyyyyyyyyyy
-    : yyyyyyyyyy
-    : yyyyyyyy
-    : yyyyyy
-    : yyyy
-    : yy
-    : 
-
-\pset format wrapped
-execute q;
--[ RECORD 1 ]-------
- ab | xx
-+   ;
-+c  ;
- a  | yyyyyyyyyyyyyy
-+bc ; yyyy
--[ RECORD 2 ]-------
- ab | xxxx
-+   : xxxxxx
-+c  : xxxxxxxx
-    : xxxxxxxxxx
-    : xxxxxxxxxxxx
-    : xxxxxxxxxxxxxx
-    : xxxxxxxxxxxxxx
-    ; xx
-    : xxxxxxxxxxxxxx
-    ; xxxx
-    : xxxxxxxxxxxxxx
-    ; xxxxxx
- a  | yyyyyyyyyyyyyy
-+bc ; yy
-    : yyyyyyyyyyyyyy
-    : yyyyyyyyyyyy
-    : yyyyyyyyyy
-    : yyyyyyyy
-    : yyyyyy
-    : yyyy
-    : yy
-    : 
-
-\pset border 2
-\pset format unaligned
-execute q;
-ab
-
-c|xx
-a
-bc|yyyyyyyyyyyyyyyyyy
-
-ab
-
-c|xxxx
-xxxxxx
-xxxxxxxx
-xxxxxxxxxx
-xxxxxxxxxxxx
-xxxxxxxxxxxxxx
-xxxxxxxxxxxxxxxx
-xxxxxxxxxxxxxxxxxx
-xxxxxxxxxxxxxxxxxxxx
-a
-bc|yyyyyyyyyyyyyyyy
-yyyyyyyyyyyyyy
-yyyyyyyyyyyy
-yyyyyyyyyy
-yyyyyyyy
-yyyyyy
-yyyy
-yy
-
-\pset format aligned
-execute q;
-+-[ RECORD 1 ]--------------+
-| ab | xx                   |
-|+   ;                      |
-|+c  ;                      |
-| a  | yyyyyyyyyyyyyyyyyy   |
-|+bc ;                      |
-+-[ RECORD 2 ]--------------+
-| ab | xxxx                 |
-|+   : xxxxxx               |
-|+c  : xxxxxxxx             |
-|    : xxxxxxxxxx           |
-|    : xxxxxxxxxxxx         |
-|    : xxxxxxxxxxxxxx       |
-|    : xxxxxxxxxxxxxxxx     |
-|    : xxxxxxxxxxxxxxxxxx   |
-|    : xxxxxxxxxxxxxxxxxxxx |
-| a  | yyyyyyyyyyyyyyyy     |
-|+bc : yyyyyyyyyyyyyy       |
-|    : yyyyyyyyyyyy         |
-|    : yyyyyyyyyy           |
-|    : yyyyyyyy             |
-|    : yyyyyy               |
-|    : yyyy                 |
-|    : yy                   |
-|    :                      |
-+----+----------------------+
-
-\pset format wrapped
-execute q;
-+-[ RECORD 1 ]-----+
-| ab | xx          |
-|+   ;             |
-|+c  ;             |
-| a  | yyyyyyyyyyy |
-|+bc ; yyyyyyy     |
-+-[ RECORD 2 ]-----+
-| ab | xxxx        |
-|+   : xxxxxx      |
-|+c  : xxxxxxxx    |
-|    : xxxxxxxxxx  |
-|    : xxxxxxxxxxx |
-|    ; x           |
-|    : xxxxxxxxxxx |
-|    ; xxx         |
-|    : xxxxxxxxxxx |
-|    ; xxxxx       |
-|    : xxxxxxxxxxx |
-|    ; xxxxxxx     |
-|    : xxxxxxxxxxx |
-|    ; xxxxxxxxx   |
-| a  | yyyyyyyyyyy |
-|+bc ; yyyyy       |
-|    : yyyyyyyyyyy |
-|    ; yyy         |
-|    : yyyyyyyyyyy |
-|    ; y           |
-|    : yyyyyyyyyy  |
-|    : yyyyyyyy    |
-|    : yyyyyy      |
-|    : yyyy        |
-|    : yy          |
-|    :             |
-+----+-------------+
-
-deallocate q;
--- test single-line header and data
-prepare q as select repeat('x',2*n) as "0123456789abcdef", repeat('y',20-2*n) as "0123456789" from generate_series(1,10) as n;
-\pset linestyle ascii
-\pset expanded off
-\pset columns 40
-\pset border 0
-\pset format unaligned
-execute q;
-0123456789abcdef|0123456789
-xx|yyyyyyyyyyyyyyyyyy
-xxxx|yyyyyyyyyyyyyyyy
-xxxxxx|yyyyyyyyyyyyyy
-xxxxxxxx|yyyyyyyyyyyy
-xxxxxxxxxx|yyyyyyyyyy
-xxxxxxxxxxxx|yyyyyyyy
-xxxxxxxxxxxxxx|yyyyyy
-xxxxxxxxxxxxxxxx|yyyy
-xxxxxxxxxxxxxxxxxx|yy
-xxxxxxxxxxxxxxxxxxxx|
-(10 rows)
-\pset format aligned
-execute q;
-  0123456789abcdef       0123456789     
--------------------- ------------------
-xx                   yyyyyyyyyyyyyyyyyy
-xxxx                 yyyyyyyyyyyyyyyy
-xxxxxx               yyyyyyyyyyyyyy
-xxxxxxxx             yyyyyyyyyyyy
-xxxxxxxxxx           yyyyyyyyyy
-xxxxxxxxxxxx         yyyyyyyy
-xxxxxxxxxxxxxx       yyyyyy
-xxxxxxxxxxxxxxxx     yyyy
-xxxxxxxxxxxxxxxxxx   yy
-xxxxxxxxxxxxxxxxxxxx 
-(10 rows)
-
-\pset format wrapped
-execute q;
-  0123456789abcdef       0123456789     
--------------------- ------------------
-xx                   yyyyyyyyyyyyyyyyyy
-xxxx                 yyyyyyyyyyyyyyyy
-xxxxxx               yyyyyyyyyyyyyy
-xxxxxxxx             yyyyyyyyyyyy
-xxxxxxxxxx           yyyyyyyyyy
-xxxxxxxxxxxx         yyyyyyyy
-xxxxxxxxxxxxxx       yyyyyy
-xxxxxxxxxxxxxxxx     yyyy
-xxxxxxxxxxxxxxxxxx   yy
-xxxxxxxxxxxxxxxxxxxx 
-(10 rows)
-
-\pset border 1
-\pset format unaligned
-execute q;
-0123456789abcdef|0123456789
-xx|yyyyyyyyyyyyyyyyyy
-xxxx|yyyyyyyyyyyyyyyy
-xxxxxx|yyyyyyyyyyyyyy
-xxxxxxxx|yyyyyyyyyyyy
-xxxxxxxxxx|yyyyyyyyyy
-xxxxxxxxxxxx|yyyyyyyy
-xxxxxxxxxxxxxx|yyyyyy
-xxxxxxxxxxxxxxxx|yyyy
-xxxxxxxxxxxxxxxxxx|yy
-xxxxxxxxxxxxxxxxxxxx|
-(10 rows)
-\pset format aligned
-execute q;
-   0123456789abcdef   |     0123456789     
-----------------------+--------------------
- xx                   | yyyyyyyyyyyyyyyyyy
- xxxx                 | yyyyyyyyyyyyyyyy
- xxxxxx               | yyyyyyyyyyyyyy
- xxxxxxxx             | yyyyyyyyyyyy
- xxxxxxxxxx           | yyyyyyyyyy
- xxxxxxxxxxxx         | yyyyyyyy
- xxxxxxxxxxxxxx       | yyyyyy
- xxxxxxxxxxxxxxxx     | yyyy
- xxxxxxxxxxxxxxxxxx   | yy
- xxxxxxxxxxxxxxxxxxxx | 
-(10 rows)
-
-\pset format wrapped
-execute q;
-  0123456789abcdef   |    0123456789    
----------------------+------------------
- xx                  | yyyyyyyyyyyyyyyy.
-                     |.yy
- xxxx                | yyyyyyyyyyyyyyyy
- xxxxxx              | yyyyyyyyyyyyyy
- xxxxxxxx            | yyyyyyyyyyyy
- xxxxxxxxxx          | yyyyyyyyyy
- xxxxxxxxxxxx        | yyyyyyyy
- xxxxxxxxxxxxxx      | yyyyyy
- xxxxxxxxxxxxxxxx    | yyyy
- xxxxxxxxxxxxxxxxxx  | yy
- xxxxxxxxxxxxxxxxxxx.| 
-.x                   | 
-(10 rows)
-
-\pset border 2
-\pset format unaligned
-execute q;
-0123456789abcdef|0123456789
-xx|yyyyyyyyyyyyyyyyyy
-xxxx|yyyyyyyyyyyyyyyy
-xxxxxx|yyyyyyyyyyyyyy
-xxxxxxxx|yyyyyyyyyyyy
-xxxxxxxxxx|yyyyyyyyyy
-xxxxxxxxxxxx|yyyyyyyy
-xxxxxxxxxxxxxx|yyyyyy
-xxxxxxxxxxxxxxxx|yyyy
-xxxxxxxxxxxxxxxxxx|yy
-xxxxxxxxxxxxxxxxxxxx|
-(10 rows)
-\pset format aligned
-execute q;
-+----------------------+--------------------+
-|   0123456789abcdef   |     0123456789     |
-+----------------------+--------------------+
-| xx                   | yyyyyyyyyyyyyyyyyy |
-| xxxx                 | yyyyyyyyyyyyyyyy   |
-| xxxxxx               | yyyyyyyyyyyyyy     |
-| xxxxxxxx             | yyyyyyyyyyyy       |
-| xxxxxxxxxx           | yyyyyyyyyy         |
-| xxxxxxxxxxxx         | yyyyyyyy           |
-| xxxxxxxxxxxxxx       | yyyyyy             |
-| xxxxxxxxxxxxxxxx     | yyyy               |
-| xxxxxxxxxxxxxxxxxx   | yy                 |
-| xxxxxxxxxxxxxxxxxxxx |                    |
-+----------------------+--------------------+
-(10 rows)
-
-\pset format wrapped
-execute q;
-+--------------------+-----------------+
-|  0123456789abcdef  |   0123456789    |
-+--------------------+-----------------+
-| xx                 | yyyyyyyyyyyyyyy.|
-|                    |.yyy             |
-| xxxx               | yyyyyyyyyyyyyyy.|
-|                    |.y               |
-| xxxxxx             | yyyyyyyyyyyyyy  |
-| xxxxxxxx           | yyyyyyyyyyyy    |
-| xxxxxxxxxx         | yyyyyyyyyy      |
-| xxxxxxxxxxxx       | yyyyyyyy        |
-| xxxxxxxxxxxxxx     | yyyyyy          |
-| xxxxxxxxxxxxxxxx   | yyyy            |
-| xxxxxxxxxxxxxxxxxx | yy              |
-| xxxxxxxxxxxxxxxxxx.|                 |
-|.xx                 |                 |
-+--------------------+-----------------+
-(10 rows)
-
-\pset expanded on
-\pset columns 30
-\pset border 0
-\pset format unaligned
-execute q;
-0123456789abcdef|xx
-0123456789|yyyyyyyyyyyyyyyyyy
-
-0123456789abcdef|xxxx
-0123456789|yyyyyyyyyyyyyyyy
-
-0123456789abcdef|xxxxxx
-0123456789|yyyyyyyyyyyyyy
-
-0123456789abcdef|xxxxxxxx
-0123456789|yyyyyyyyyyyy
-
-0123456789abcdef|xxxxxxxxxx
-0123456789|yyyyyyyyyy
-
-0123456789abcdef|xxxxxxxxxxxx
-0123456789|yyyyyyyy
-
-0123456789abcdef|xxxxxxxxxxxxxx
-0123456789|yyyyyy
-
-0123456789abcdef|xxxxxxxxxxxxxxxx
-0123456789|yyyy
-
-0123456789abcdef|xxxxxxxxxxxxxxxxxx
-0123456789|yy
-
-0123456789abcdef|xxxxxxxxxxxxxxxxxxxx
-0123456789|
-\pset format aligned
-execute q;
-* Record 1                          
-0123456789abcdef xx
-0123456789       yyyyyyyyyyyyyyyyyy
-* Record 2                          
-0123456789abcdef xxxx
-0123456789       yyyyyyyyyyyyyyyy
-* Record 3                          
-0123456789abcdef xxxxxx
-0123456789       yyyyyyyyyyyyyy
-* Record 4                          
-0123456789abcdef xxxxxxxx
-0123456789       yyyyyyyyyyyy
-* Record 5                          
-0123456789abcdef xxxxxxxxxx
-0123456789       yyyyyyyyyy
-* Record 6                          
-0123456789abcdef xxxxxxxxxxxx
-0123456789       yyyyyyyy
-* Record 7                          
-0123456789abcdef xxxxxxxxxxxxxx
-0123456789       yyyyyy
-* Record 8                          
-0123456789abcdef xxxxxxxxxxxxxxxx
-0123456789       yyyy
-* Record 9                          
-0123456789abcdef xxxxxxxxxxxxxxxxxx
-0123456789       yy
-* Record 10                         
-0123456789abcdef xxxxxxxxxxxxxxxxxxxx
-0123456789       
-
-\pset format wrapped
-execute q;
-* Record 1                  
-0123456789abcdef xx
-0123456789       yyyyyyyyyyyy.
-                .yyyyyy
-* Record 2                  
-0123456789abcdef xxxx
-0123456789       yyyyyyyyyyyy.
-                .yyyy
-* Record 3                  
-0123456789abcdef xxxxxx
-0123456789       yyyyyyyyyyyy.
-                .yy
-* Record 4                  
-0123456789abcdef xxxxxxxx
-0123456789       yyyyyyyyyyyy
-* Record 5                  
-0123456789abcdef xxxxxxxxxx
-0123456789       yyyyyyyyyy
-* Record 6                  
-0123456789abcdef xxxxxxxxxxxx
-0123456789       yyyyyyyy
-* Record 7                  
-0123456789abcdef xxxxxxxxxxxx.
-                .xx
-0123456789       yyyyyy
-* Record 8                  
-0123456789abcdef xxxxxxxxxxxx.
-                .xxxx
-0123456789       yyyy
-* Record 9                  
-0123456789abcdef xxxxxxxxxxxx.
-                .xxxxxx
-0123456789       yy
-* Record 10                 
-0123456789abcdef xxxxxxxxxxxx.
-                .xxxxxxxx
-0123456789       
-
-\pset border 1
-\pset format unaligned
-execute q;
-0123456789abcdef|xx
-0123456789|yyyyyyyyyyyyyyyyyy
-
-0123456789abcdef|xxxx
-0123456789|yyyyyyyyyyyyyyyy
-
-0123456789abcdef|xxxxxx
-0123456789|yyyyyyyyyyyyyy
-
-0123456789abcdef|xxxxxxxx
-0123456789|yyyyyyyyyyyy
-
-0123456789abcdef|xxxxxxxxxx
-0123456789|yyyyyyyyyy
-
-0123456789abcdef|xxxxxxxxxxxx
-0123456789|yyyyyyyy
-
-0123456789abcdef|xxxxxxxxxxxxxx
-0123456789|yyyyyy
-
-0123456789abcdef|xxxxxxxxxxxxxxxx
-0123456789|yyyy
-
-0123456789abcdef|xxxxxxxxxxxxxxxxxx
-0123456789|yy
-
-0123456789abcdef|xxxxxxxxxxxxxxxxxxxx
-0123456789|
-\pset format aligned
-execute q;
--[ RECORD 1 ]----+---------------------
-0123456789abcdef | xx
-0123456789       | yyyyyyyyyyyyyyyyyy
--[ RECORD 2 ]----+---------------------
-0123456789abcdef | xxxx
-0123456789       | yyyyyyyyyyyyyyyy
--[ RECORD 3 ]----+---------------------
-0123456789abcdef | xxxxxx
-0123456789       | yyyyyyyyyyyyyy
--[ RECORD 4 ]----+---------------------
-0123456789abcdef | xxxxxxxx
-0123456789       | yyyyyyyyyyyy
--[ RECORD 5 ]----+---------------------
-0123456789abcdef | xxxxxxxxxx
-0123456789       | yyyyyyyyyy
--[ RECORD 6 ]----+---------------------
-0123456789abcdef | xxxxxxxxxxxx
-0123456789       | yyyyyyyy
--[ RECORD 7 ]----+---------------------
-0123456789abcdef | xxxxxxxxxxxxxx
-0123456789       | yyyyyy
--[ RECORD 8 ]----+---------------------
-0123456789abcdef | xxxxxxxxxxxxxxxx
-0123456789       | yyyy
--[ RECORD 9 ]----+---------------------
-0123456789abcdef | xxxxxxxxxxxxxxxxxx
-0123456789       | yy
--[ RECORD 10 ]---+---------------------
-0123456789abcdef | xxxxxxxxxxxxxxxxxxxx
-0123456789       | 
-
-\pset format wrapped
-execute q;
--[ RECORD 1 ]----+-----------
-0123456789abcdef | xx
-0123456789       | yyyyyyyyyy.
-                 |.yyyyyyyy
--[ RECORD 2 ]----+-----------
-0123456789abcdef | xxxx
-0123456789       | yyyyyyyyyy.
-                 |.yyyyyy
--[ RECORD 3 ]----+-----------
-0123456789abcdef | xxxxxx
-0123456789       | yyyyyyyyyy.
-                 |.yyyy
--[ RECORD 4 ]----+-----------
-0123456789abcdef | xxxxxxxx
-0123456789       | yyyyyyyyyy.
-                 |.yy
--[ RECORD 5 ]----+-----------
-0123456789abcdef | xxxxxxxxxx
-0123456789       | yyyyyyyyyy
--[ RECORD 6 ]----+-----------
-0123456789abcdef | xxxxxxxxxx.
-                 |.xx
-0123456789       | yyyyyyyy
--[ RECORD 7 ]----+-----------
-0123456789abcdef | xxxxxxxxxx.
-                 |.xxxx
-0123456789       | yyyyyy
--[ RECORD 8 ]----+-----------
-0123456789abcdef | xxxxxxxxxx.
-                 |.xxxxxx
-0123456789       | yyyy
--[ RECORD 9 ]----+-----------
-0123456789abcdef | xxxxxxxxxx.
-                 |.xxxxxxxx
-0123456789       | yy
--[ RECORD 10 ]---+-----------
-0123456789abcdef | xxxxxxxxxx.
-                 |.xxxxxxxxxx
-0123456789       | 
-
-\pset border 2
-\pset format unaligned
-execute q;
-0123456789abcdef|xx
-0123456789|yyyyyyyyyyyyyyyyyy
-
-0123456789abcdef|xxxx
-0123456789|yyyyyyyyyyyyyyyy
-
-0123456789abcdef|xxxxxx
-0123456789|yyyyyyyyyyyyyy
-
-0123456789abcdef|xxxxxxxx
-0123456789|yyyyyyyyyyyy
-
-0123456789abcdef|xxxxxxxxxx
-0123456789|yyyyyyyyyy
-
-0123456789abcdef|xxxxxxxxxxxx
-0123456789|yyyyyyyy
-
-0123456789abcdef|xxxxxxxxxxxxxx
-0123456789|yyyyyy
-
-0123456789abcdef|xxxxxxxxxxxxxxxx
-0123456789|yyyy
-
-0123456789abcdef|xxxxxxxxxxxxxxxxxx
-0123456789|yy
-
-0123456789abcdef|xxxxxxxxxxxxxxxxxxxx
-0123456789|
-\pset format aligned
-execute q;
-+-[ RECORD 1 ]-----+----------------------+
-| 0123456789abcdef | xx                   |
-| 0123456789       | yyyyyyyyyyyyyyyyyy   |
-+-[ RECORD 2 ]-----+----------------------+
-| 0123456789abcdef | xxxx                 |
-| 0123456789       | yyyyyyyyyyyyyyyy     |
-+-[ RECORD 3 ]-----+----------------------+
-| 0123456789abcdef | xxxxxx               |
-| 0123456789       | yyyyyyyyyyyyyy       |
-+-[ RECORD 4 ]-----+----------------------+
-| 0123456789abcdef | xxxxxxxx             |
-| 0123456789       | yyyyyyyyyyyy         |
-+-[ RECORD 5 ]-----+----------------------+
-| 0123456789abcdef | xxxxxxxxxx           |
-| 0123456789       | yyyyyyyyyy           |
-+-[ RECORD 6 ]-----+----------------------+
-| 0123456789abcdef | xxxxxxxxxxxx         |
-| 0123456789       | yyyyyyyy             |
-+-[ RECORD 7 ]-----+----------------------+
-| 0123456789abcdef | xxxxxxxxxxxxxx       |
-| 0123456789       | yyyyyy               |
-+-[ RECORD 8 ]-----+----------------------+
-| 0123456789abcdef | xxxxxxxxxxxxxxxx     |
-| 0123456789       | yyyy                 |
-+-[ RECORD 9 ]-----+----------------------+
-| 0123456789abcdef | xxxxxxxxxxxxxxxxxx   |
-| 0123456789       | yy                   |
-+-[ RECORD 10 ]----+----------------------+
-| 0123456789abcdef | xxxxxxxxxxxxxxxxxxxx |
-| 0123456789       |                      |
-+------------------+----------------------+
-
-\pset format wrapped
-execute q;
-+-[ RECORD 1 ]-----+---------+
-| 0123456789abcdef | xx      |
-| 0123456789       | yyyyyyy.|
-|                  |.yyyyyyy.|
-|                  |.yyyy    |
-+-[ RECORD 2 ]-----+---------+
-| 0123456789abcdef | xxxx    |
-| 0123456789       | yyyyyyy.|
-|                  |.yyyyyyy.|
-|                  |.yy      |
-+-[ RECORD 3 ]-----+---------+
-| 0123456789abcdef | xxxxxx  |
-| 0123456789       | yyyyyyy.|
-|                  |.yyyyyyy |
-+-[ RECORD 4 ]-----+---------+
-| 0123456789abcdef | xxxxxxx.|
-|                  |.x       |
-| 0123456789       | yyyyyyy.|
-|                  |.yyyyy   |
-+-[ RECORD 5 ]-----+---------+
-| 0123456789abcdef | xxxxxxx.|
-|                  |.xxx     |
-| 0123456789       | yyyyyyy.|
-|                  |.yyy     |
-+-[ RECORD 6 ]-----+---------+
-| 0123456789abcdef | xxxxxxx.|
-|                  |.xxxxx   |
-| 0123456789       | yyyyyyy.|
-|                  |.y       |
-+-[ RECORD 7 ]-----+---------+
-| 0123456789abcdef | xxxxxxx.|
-|                  |.xxxxxxx |
-| 0123456789       | yyyyyy  |
-+-[ RECORD 8 ]-----+---------+
-| 0123456789abcdef | xxxxxxx.|
-|                  |.xxxxxxx.|
-|                  |.xx      |
-| 0123456789       | yyyy    |
-+-[ RECORD 9 ]-----+---------+
-| 0123456789abcdef | xxxxxxx.|
-|                  |.xxxxxxx.|
-|                  |.xxxx    |
-| 0123456789       | yy      |
-+-[ RECORD 10 ]----+---------+
-| 0123456789abcdef | xxxxxxx.|
-|                  |.xxxxxxx.|
-|                  |.xxxxxx  |
-| 0123456789       |         |
-+------------------+---------+
-
-\pset expanded on
-\pset columns 20
-\pset border 0
-\pset format unaligned
-execute q;
-0123456789abcdef|xx
-0123456789|yyyyyyyyyyyyyyyyyy
-
-0123456789abcdef|xxxx
-0123456789|yyyyyyyyyyyyyyyy
-
-0123456789abcdef|xxxxxx
-0123456789|yyyyyyyyyyyyyy
-
-0123456789abcdef|xxxxxxxx
-0123456789|yyyyyyyyyyyy
-
-0123456789abcdef|xxxxxxxxxx
-0123456789|yyyyyyyyyy
-
-0123456789abcdef|xxxxxxxxxxxx
-0123456789|yyyyyyyy
-
-0123456789abcdef|xxxxxxxxxxxxxx
-0123456789|yyyyyy
-
-0123456789abcdef|xxxxxxxxxxxxxxxx
-0123456789|yyyy
-
-0123456789abcdef|xxxxxxxxxxxxxxxxxx
-0123456789|yy
-
-0123456789abcdef|xxxxxxxxxxxxxxxxxxxx
-0123456789|
-\pset format aligned
-execute q;
-* Record 1                          
-0123456789abcdef xx
-0123456789       yyyyyyyyyyyyyyyyyy
-* Record 2                          
-0123456789abcdef xxxx
-0123456789       yyyyyyyyyyyyyyyy
-* Record 3                          
-0123456789abcdef xxxxxx
-0123456789       yyyyyyyyyyyyyy
-* Record 4                          
-0123456789abcdef xxxxxxxx
-0123456789       yyyyyyyyyyyy
-* Record 5                          
-0123456789abcdef xxxxxxxxxx
-0123456789       yyyyyyyyyy
-* Record 6                          
-0123456789abcdef xxxxxxxxxxxx
-0123456789       yyyyyyyy
-* Record 7                          
-0123456789abcdef xxxxxxxxxxxxxx
-0123456789       yyyyyy
-* Record 8                          
-0123456789abcdef xxxxxxxxxxxxxxxx
-0123456789       yyyy
-* Record 9                          
-0123456789abcdef xxxxxxxxxxxxxxxxxx
-0123456789       yy
-* Record 10                         
-0123456789abcdef xxxxxxxxxxxxxxxxxxxx
-0123456789       
-
-\pset format wrapped
-execute q;
-* Record 1         
-0123456789abcdef xx
-0123456789       yyy.
-                .yyy.
-                .yyy.
-                .yyy.
-                .yyy.
-                .yyy
-* Record 2         
-0123456789abcdef xxx.
-                .x
-0123456789       yyy.
-                .yyy.
-                .yyy.
-                .yyy.
-                .yyy.
-                .y
-* Record 3         
-0123456789abcdef xxx.
-                .xxx
-0123456789       yyy.
-                .yyy.
-                .yyy.
-                .yyy.
-                .yy
-* Record 4         
-0123456789abcdef xxx.
-                .xxx.
-                .xx
-0123456789       yyy.
-                .yyy.
-                .yyy.
-                .yyy
-* Record 5         
-0123456789abcdef xxx.
-                .xxx.
-                .xxx.
-                .x
-0123456789       yyy.
-                .yyy.
-                .yyy.
-                .y
-* Record 6         
-0123456789abcdef xxx.
-                .xxx.
-                .xxx.
-                .xxx
-0123456789       yyy.
-                .yyy.
-                .yy
-* Record 7         
-0123456789abcdef xxx.
-                .xxx.
-                .xxx.
-                .xxx.
-                .xx
-0123456789       yyy.
-                .yyy
-* Record 8         
-0123456789abcdef xxx.
-                .xxx.
-                .xxx.
-                .xxx.
-                .xxx.
-                .x
-0123456789       yyy.
-                .y
-* Record 9         
-0123456789abcdef xxx.
-                .xxx.
-                .xxx.
-                .xxx.
-                .xxx.
-                .xxx
-0123456789       yy
-* Record 10        
-0123456789abcdef xxx.
-                .xxx.
-                .xxx.
-                .xxx.
-                .xxx.
-                .xxx.
-                .xx
-0123456789       
-
-\pset border 1
-\pset format unaligned
-execute q;
-0123456789abcdef|xx
-0123456789|yyyyyyyyyyyyyyyyyy
-
-0123456789abcdef|xxxx
-0123456789|yyyyyyyyyyyyyyyy
-
-0123456789abcdef|xxxxxx
-0123456789|yyyyyyyyyyyyyy
-
-0123456789abcdef|xxxxxxxx
-0123456789|yyyyyyyyyyyy
-
-0123456789abcdef|xxxxxxxxxx
-0123456789|yyyyyyyyyy
-
-0123456789abcdef|xxxxxxxxxxxx
-0123456789|yyyyyyyy
-
-0123456789abcdef|xxxxxxxxxxxxxx
-0123456789|yyyyyy
-
-0123456789abcdef|xxxxxxxxxxxxxxxx
-0123456789|yyyy
-
-0123456789abcdef|xxxxxxxxxxxxxxxxxx
-0123456789|yy
-
-0123456789abcdef|xxxxxxxxxxxxxxxxxxxx
-0123456789|
-\pset format aligned
-execute q;
--[ RECORD 1 ]----+---------------------
-0123456789abcdef | xx
-0123456789       | yyyyyyyyyyyyyyyyyy
--[ RECORD 2 ]----+---------------------
-0123456789abcdef | xxxx
-0123456789       | yyyyyyyyyyyyyyyy
--[ RECORD 3 ]----+---------------------
-0123456789abcdef | xxxxxx
-0123456789       | yyyyyyyyyyyyyy
--[ RECORD 4 ]----+---------------------
-0123456789abcdef | xxxxxxxx
-0123456789       | yyyyyyyyyyyy
--[ RECORD 5 ]----+---------------------
-0123456789abcdef | xxxxxxxxxx
-0123456789       | yyyyyyyyyy
--[ RECORD 6 ]----+---------------------
-0123456789abcdef | xxxxxxxxxxxx
-0123456789       | yyyyyyyy
--[ RECORD 7 ]----+---------------------
-0123456789abcdef | xxxxxxxxxxxxxx
-0123456789       | yyyyyy
--[ RECORD 8 ]----+---------------------
-0123456789abcdef | xxxxxxxxxxxxxxxx
-0123456789       | yyyy
--[ RECORD 9 ]----+---------------------
-0123456789abcdef | xxxxxxxxxxxxxxxxxx
-0123456789       | yy
--[ RECORD 10 ]---+---------------------
-0123456789abcdef | xxxxxxxxxxxxxxxxxxxx
-0123456789       | 
-
-\pset format wrapped
-execute q;
--[ RECORD 1 ]----+----
-0123456789abcdef | xx
-0123456789       | yyy.
-                 |.yyy.
-                 |.yyy.
-                 |.yyy.
-                 |.yyy.
-                 |.yyy
--[ RECORD 2 ]----+----
-0123456789abcdef | xxx.
-                 |.x
-0123456789       | yyy.
-                 |.yyy.
-                 |.yyy.
-                 |.yyy.
-                 |.yyy.
-                 |.y
--[ RECORD 3 ]----+----
-0123456789abcdef | xxx.
-                 |.xxx
-0123456789       | yyy.
-                 |.yyy.
-                 |.yyy.
-                 |.yyy.
-                 |.yy
--[ RECORD 4 ]----+----
-0123456789abcdef | xxx.
-                 |.xxx.
-                 |.xx
-0123456789       | yyy.
-                 |.yyy.
-                 |.yyy.
-                 |.yyy
--[ RECORD 5 ]----+----
-0123456789abcdef | xxx.
-                 |.xxx.
-                 |.xxx.
-                 |.x
-0123456789       | yyy.
-                 |.yyy.
-                 |.yyy.
-                 |.y
--[ RECORD 6 ]----+----
-0123456789abcdef | xxx.
-                 |.xxx.
-                 |.xxx.
-                 |.xxx
-0123456789       | yyy.
-                 |.yyy.
-                 |.yy
--[ RECORD 7 ]----+----
-0123456789abcdef | xxx.
-                 |.xxx.
-                 |.xxx.
-                 |.xxx.
-                 |.xx
-0123456789       | yyy.
-                 |.yyy
--[ RECORD 8 ]----+----
-0123456789abcdef | xxx.
-                 |.xxx.
-                 |.xxx.
-                 |.xxx.
-                 |.xxx.
-                 |.x
-0123456789       | yyy.
-                 |.y
--[ RECORD 9 ]----+----
-0123456789abcdef | xxx.
-                 |.xxx.
-                 |.xxx.
-                 |.xxx.
-                 |.xxx.
-                 |.xxx
-0123456789       | yy
--[ RECORD 10 ]---+----
-0123456789abcdef | xxx.
-                 |.xxx.
-                 |.xxx.
-                 |.xxx.
-                 |.xxx.
-                 |.xxx.
-                 |.xx
-0123456789       | 
-
-\pset border 2
-\pset format unaligned
-execute q;
-0123456789abcdef|xx
-0123456789|yyyyyyyyyyyyyyyyyy
-
-0123456789abcdef|xxxx
-0123456789|yyyyyyyyyyyyyyyy
-
-0123456789abcdef|xxxxxx
-0123456789|yyyyyyyyyyyyyy
-
-0123456789abcdef|xxxxxxxx
-0123456789|yyyyyyyyyyyy
-
-0123456789abcdef|xxxxxxxxxx
-0123456789|yyyyyyyyyy
-
-0123456789abcdef|xxxxxxxxxxxx
-0123456789|yyyyyyyy
-
-0123456789abcdef|xxxxxxxxxxxxxx
-0123456789|yyyyyy
-
-0123456789abcdef|xxxxxxxxxxxxxxxx
-0123456789|yyyy
-
-0123456789abcdef|xxxxxxxxxxxxxxxxxx
-0123456789|yy
-
-0123456789abcdef|xxxxxxxxxxxxxxxxxxxx
-0123456789|
-\pset format aligned
-execute q;
-+-[ RECORD 1 ]-----+----------------------+
-| 0123456789abcdef | xx                   |
-| 0123456789       | yyyyyyyyyyyyyyyyyy   |
-+-[ RECORD 2 ]-----+----------------------+
-| 0123456789abcdef | xxxx                 |
-| 0123456789       | yyyyyyyyyyyyyyyy     |
-+-[ RECORD 3 ]-----+----------------------+
-| 0123456789abcdef | xxxxxx               |
-| 0123456789       | yyyyyyyyyyyyyy       |
-+-[ RECORD 4 ]-----+----------------------+
-| 0123456789abcdef | xxxxxxxx             |
-| 0123456789       | yyyyyyyyyyyy         |
-+-[ RECORD 5 ]-----+----------------------+
-| 0123456789abcdef | xxxxxxxxxx           |
-| 0123456789       | yyyyyyyyyy           |
-+-[ RECORD 6 ]-----+----------------------+
-| 0123456789abcdef | xxxxxxxxxxxx         |
-| 0123456789       | yyyyyyyy             |
-+-[ RECORD 7 ]-----+----------------------+
-| 0123456789abcdef | xxxxxxxxxxxxxx       |
-| 0123456789       | yyyyyy               |
-+-[ RECORD 8 ]-----+----------------------+
-| 0123456789abcdef | xxxxxxxxxxxxxxxx     |
-| 0123456789       | yyyy                 |
-+-[ RECORD 9 ]-----+----------------------+
-| 0123456789abcdef | xxxxxxxxxxxxxxxxxx   |
-| 0123456789       | yy                   |
-+-[ RECORD 10 ]----+----------------------+
-| 0123456789abcdef | xxxxxxxxxxxxxxxxxxxx |
-| 0123456789       |                      |
-+------------------+----------------------+
-
-\pset format wrapped
-execute q;
-+-[ RECORD 1 ]-----+-----+
-| 0123456789abcdef | xx  |
-| 0123456789       | yyy.|
-|                  |.yyy.|
-|                  |.yyy.|
-|                  |.yyy.|
-|                  |.yyy.|
-|                  |.yyy |
-+-[ RECORD 2 ]-----+-----+
-| 0123456789abcdef | xxx.|
-|                  |.x   |
-| 0123456789       | yyy.|
-|                  |.yyy.|
-|                  |.yyy.|
-|                  |.yyy.|
-|                  |.yyy.|
-|                  |.y   |
-+-[ RECORD 3 ]-----+-----+
-| 0123456789abcdef | xxx.|
-|                  |.xxx |
-| 0123456789       | yyy.|
-|                  |.yyy.|
-|                  |.yyy.|
-|                  |.yyy.|
-|                  |.yy  |
-+-[ RECORD 4 ]-----+-----+
-| 0123456789abcdef | xxx.|
-|                  |.xxx.|
-|                  |.xx  |
-| 0123456789       | yyy.|
-|                  |.yyy.|
-|                  |.yyy.|
-|                  |.yyy |
-+-[ RECORD 5 ]-----+-----+
-| 0123456789abcdef | xxx.|
-|                  |.xxx.|
-|                  |.xxx.|
-|                  |.x   |
-| 0123456789       | yyy.|
-|                  |.yyy.|
-|                  |.yyy.|
-|                  |.y   |
-+-[ RECORD 6 ]-----+-----+
-| 0123456789abcdef | xxx.|
-|                  |.xxx.|
-|                  |.xxx.|
-|                  |.xxx |
-| 0123456789       | yyy.|
-|                  |.yyy.|
-|                  |.yy  |
-+-[ RECORD 7 ]-----+-----+
-| 0123456789abcdef | xxx.|
-|                  |.xxx.|
-|                  |.xxx.|
-|                  |.xxx.|
-|                  |.xx  |
-| 0123456789       | yyy.|
-|                  |.yyy |
-+-[ RECORD 8 ]-----+-----+
-| 0123456789abcdef | xxx.|
-|                  |.xxx.|
-|                  |.xxx.|
-|                  |.xxx.|
-|                  |.xxx.|
-|                  |.x   |
-| 0123456789       | yyy.|
-|                  |.y   |
-+-[ RECORD 9 ]-----+-----+
-| 0123456789abcdef | xxx.|
-|                  |.xxx.|
-|                  |.xxx.|
-|                  |.xxx.|
-|                  |.xxx.|
-|                  |.xxx |
-| 0123456789       | yy  |
-+-[ RECORD 10 ]----+-----+
-| 0123456789abcdef | xxx.|
-|                  |.xxx.|
-|                  |.xxx.|
-|                  |.xxx.|
-|                  |.xxx.|
-|                  |.xxx.|
-|                  |.xx  |
-| 0123456789       |     |
-+------------------+-----+
-
-\pset linestyle old-ascii
-\pset expanded off
-\pset columns 40
-\pset border 0
-\pset format unaligned
-execute q;
-0123456789abcdef|0123456789
-xx|yyyyyyyyyyyyyyyyyy
-xxxx|yyyyyyyyyyyyyyyy
-xxxxxx|yyyyyyyyyyyyyy
-xxxxxxxx|yyyyyyyyyyyy
-xxxxxxxxxx|yyyyyyyyyy
-xxxxxxxxxxxx|yyyyyyyy
-xxxxxxxxxxxxxx|yyyyyy
-xxxxxxxxxxxxxxxx|yyyy
-xxxxxxxxxxxxxxxxxx|yy
-xxxxxxxxxxxxxxxxxxxx|
-(10 rows)
-\pset format aligned
-execute q;
-  0123456789abcdef       0123456789    
--------------------- ------------------
-xx                   yyyyyyyyyyyyyyyyyy
-xxxx                 yyyyyyyyyyyyyyyy
-xxxxxx               yyyyyyyyyyyyyy
-xxxxxxxx             yyyyyyyyyyyy
-xxxxxxxxxx           yyyyyyyyyy
-xxxxxxxxxxxx         yyyyyyyy
-xxxxxxxxxxxxxx       yyyyyy
-xxxxxxxxxxxxxxxx     yyyy
-xxxxxxxxxxxxxxxxxx   yy
-xxxxxxxxxxxxxxxxxxxx 
-(10 rows)
-
-\pset format wrapped
-execute q;
-  0123456789abcdef       0123456789    
--------------------- ------------------
-xx                   yyyyyyyyyyyyyyyyyy
-xxxx                 yyyyyyyyyyyyyyyy
-xxxxxx               yyyyyyyyyyyyyy
-xxxxxxxx             yyyyyyyyyyyy
-xxxxxxxxxx           yyyyyyyyyy
-xxxxxxxxxxxx         yyyyyyyy
-xxxxxxxxxxxxxx       yyyyyy
-xxxxxxxxxxxxxxxx     yyyy
-xxxxxxxxxxxxxxxxxx   yy
-xxxxxxxxxxxxxxxxxxxx 
-(10 rows)
-
-\pset border 1
-\pset format unaligned
-execute q;
-0123456789abcdef|0123456789
-xx|yyyyyyyyyyyyyyyyyy
-xxxx|yyyyyyyyyyyyyyyy
-xxxxxx|yyyyyyyyyyyyyy
-xxxxxxxx|yyyyyyyyyyyy
-xxxxxxxxxx|yyyyyyyyyy
-xxxxxxxxxxxx|yyyyyyyy
-xxxxxxxxxxxxxx|yyyyyy
-xxxxxxxxxxxxxxxx|yyyy
-xxxxxxxxxxxxxxxxxx|yy
-xxxxxxxxxxxxxxxxxxxx|
-(10 rows)
-\pset format aligned
-execute q;
-   0123456789abcdef   |     0123456789     
-----------------------+--------------------
- xx                   | yyyyyyyyyyyyyyyyyy
- xxxx                 | yyyyyyyyyyyyyyyy
- xxxxxx               | yyyyyyyyyyyyyy
- xxxxxxxx             | yyyyyyyyyyyy
- xxxxxxxxxx           | yyyyyyyyyy
- xxxxxxxxxxxx         | yyyyyyyy
- xxxxxxxxxxxxxx       | yyyyyy
- xxxxxxxxxxxxxxxx     | yyyy
- xxxxxxxxxxxxxxxxxx   | yy
- xxxxxxxxxxxxxxxxxxxx | 
-(10 rows)
-
-\pset format wrapped
-execute q;
-  0123456789abcdef   |    0123456789    
----------------------+------------------
- xx                  | yyyyyyyyyyyyyyyy 
-                     ; yy
- xxxx                | yyyyyyyyyyyyyyyy
- xxxxxx              | yyyyyyyyyyyyyy
- xxxxxxxx            | yyyyyyyyyyyy
- xxxxxxxxxx          | yyyyyyyyyy
- xxxxxxxxxxxx        | yyyyyyyy
- xxxxxxxxxxxxxx      | yyyyyy
- xxxxxxxxxxxxxxxx    | yyyy
- xxxxxxxxxxxxxxxxxx  | yy
- xxxxxxxxxxxxxxxxxxx | 
- x                     
-(10 rows)
-
-\pset border 2
-\pset format unaligned
-execute q;
-0123456789abcdef|0123456789
-xx|yyyyyyyyyyyyyyyyyy
-xxxx|yyyyyyyyyyyyyyyy
-xxxxxx|yyyyyyyyyyyyyy
-xxxxxxxx|yyyyyyyyyyyy
-xxxxxxxxxx|yyyyyyyyyy
-xxxxxxxxxxxx|yyyyyyyy
-xxxxxxxxxxxxxx|yyyyyy
-xxxxxxxxxxxxxxxx|yyyy
-xxxxxxxxxxxxxxxxxx|yy
-xxxxxxxxxxxxxxxxxxxx|
-(10 rows)
-\pset format aligned
-execute q;
-+----------------------+--------------------+
-|   0123456789abcdef   |     0123456789     |
-+----------------------+--------------------+
-| xx                   | yyyyyyyyyyyyyyyyyy |
-| xxxx                 | yyyyyyyyyyyyyyyy   |
-| xxxxxx               | yyyyyyyyyyyyyy     |
-| xxxxxxxx             | yyyyyyyyyyyy       |
-| xxxxxxxxxx           | yyyyyyyyyy         |
-| xxxxxxxxxxxx         | yyyyyyyy           |
-| xxxxxxxxxxxxxx       | yyyyyy             |
-| xxxxxxxxxxxxxxxx     | yyyy               |
-| xxxxxxxxxxxxxxxxxx   | yy                 |
-| xxxxxxxxxxxxxxxxxxxx |                    |
-+----------------------+--------------------+
-(10 rows)
-
-\pset format wrapped
-execute q;
-+--------------------+-----------------+
-|  0123456789abcdef  |   0123456789    |
-+--------------------+-----------------+
-| xx                 | yyyyyyyyyyyyyyy |
-|                    ; yyy             |
-| xxxx               | yyyyyyyyyyyyyyy |
-|                    ; y               |
-| xxxxxx             | yyyyyyyyyyyyyy  |
-| xxxxxxxx           | yyyyyyyyyyyy    |
-| xxxxxxxxxx         | yyyyyyyyyy      |
-| xxxxxxxxxxxx       | yyyyyyyy        |
-| xxxxxxxxxxxxxx     | yyyyyy          |
-| xxxxxxxxxxxxxxxx   | yyyy            |
-| xxxxxxxxxxxxxxxxxx | yy              |
-| xxxxxxxxxxxxxxxxxx |                 |
-| xx                                   |
-+--------------------+-----------------+
-(10 rows)
-
-\pset expanded on
-\pset border 0
-\pset format unaligned
-execute q;
-0123456789abcdef|xx
-0123456789|yyyyyyyyyyyyyyyyyy
-
-0123456789abcdef|xxxx
-0123456789|yyyyyyyyyyyyyyyy
-
-0123456789abcdef|xxxxxx
-0123456789|yyyyyyyyyyyyyy
-
-0123456789abcdef|xxxxxxxx
-0123456789|yyyyyyyyyyyy
-
-0123456789abcdef|xxxxxxxxxx
-0123456789|yyyyyyyyyy
-
-0123456789abcdef|xxxxxxxxxxxx
-0123456789|yyyyyyyy
-
-0123456789abcdef|xxxxxxxxxxxxxx
-0123456789|yyyyyy
-
-0123456789abcdef|xxxxxxxxxxxxxxxx
-0123456789|yyyy
-
-0123456789abcdef|xxxxxxxxxxxxxxxxxx
-0123456789|yy
-
-0123456789abcdef|xxxxxxxxxxxxxxxxxxxx
-0123456789|
-\pset format aligned
-execute q;
-* Record 1                          
-0123456789abcdef xx
-0123456789       yyyyyyyyyyyyyyyyyy
-* Record 2                          
-0123456789abcdef xxxx
-0123456789       yyyyyyyyyyyyyyyy
-* Record 3                          
-0123456789abcdef xxxxxx
-0123456789       yyyyyyyyyyyyyy
-* Record 4                          
-0123456789abcdef xxxxxxxx
-0123456789       yyyyyyyyyyyy
-* Record 5                          
-0123456789abcdef xxxxxxxxxx
-0123456789       yyyyyyyyyy
-* Record 6                          
-0123456789abcdef xxxxxxxxxxxx
-0123456789       yyyyyyyy
-* Record 7                          
-0123456789abcdef xxxxxxxxxxxxxx
-0123456789       yyyyyy
-* Record 8                          
-0123456789abcdef xxxxxxxxxxxxxxxx
-0123456789       yyyy
-* Record 9                          
-0123456789abcdef xxxxxxxxxxxxxxxxxx
-0123456789       yy
-* Record 10                         
-0123456789abcdef xxxxxxxxxxxxxxxxxxxx
-0123456789       
-
-\pset format wrapped
-execute q;
-* Record 1                          
-0123456789abcdef xx
-0123456789       yyyyyyyyyyyyyyyyyy
-* Record 2                          
-0123456789abcdef xxxx
-0123456789       yyyyyyyyyyyyyyyy
-* Record 3                          
-0123456789abcdef xxxxxx
-0123456789       yyyyyyyyyyyyyy
-* Record 4                          
-0123456789abcdef xxxxxxxx
-0123456789       yyyyyyyyyyyy
-* Record 5                          
-0123456789abcdef xxxxxxxxxx
-0123456789       yyyyyyyyyy
-* Record 6                          
-0123456789abcdef xxxxxxxxxxxx
-0123456789       yyyyyyyy
-* Record 7                          
-0123456789abcdef xxxxxxxxxxxxxx
-0123456789       yyyyyy
-* Record 8                          
-0123456789abcdef xxxxxxxxxxxxxxxx
-0123456789       yyyy
-* Record 9                          
-0123456789abcdef xxxxxxxxxxxxxxxxxx
-0123456789       yy
-* Record 10                         
-0123456789abcdef xxxxxxxxxxxxxxxxxxxx
-0123456789       
-
-\pset border 1
-\pset format unaligned
-execute q;
-0123456789abcdef|xx
-0123456789|yyyyyyyyyyyyyyyyyy
-
-0123456789abcdef|xxxx
-0123456789|yyyyyyyyyyyyyyyy
-
-0123456789abcdef|xxxxxx
-0123456789|yyyyyyyyyyyyyy
-
-0123456789abcdef|xxxxxxxx
-0123456789|yyyyyyyyyyyy
-
-0123456789abcdef|xxxxxxxxxx
-0123456789|yyyyyyyyyy
-
-0123456789abcdef|xxxxxxxxxxxx
-0123456789|yyyyyyyy
-
-0123456789abcdef|xxxxxxxxxxxxxx
-0123456789|yyyyyy
-
-0123456789abcdef|xxxxxxxxxxxxxxxx
-0123456789|yyyy
-
-0123456789abcdef|xxxxxxxxxxxxxxxxxx
-0123456789|yy
-
-0123456789abcdef|xxxxxxxxxxxxxxxxxxxx
-0123456789|
-\pset format aligned
-execute q;
--[ RECORD 1 ]----+---------------------
-0123456789abcdef | xx
-0123456789       | yyyyyyyyyyyyyyyyyy
--[ RECORD 2 ]----+---------------------
-0123456789abcdef | xxxx
-0123456789       | yyyyyyyyyyyyyyyy
--[ RECORD 3 ]----+---------------------
-0123456789abcdef | xxxxxx
-0123456789       | yyyyyyyyyyyyyy
--[ RECORD 4 ]----+---------------------
-0123456789abcdef | xxxxxxxx
-0123456789       | yyyyyyyyyyyy
--[ RECORD 5 ]----+---------------------
-0123456789abcdef | xxxxxxxxxx
-0123456789       | yyyyyyyyyy
--[ RECORD 6 ]----+---------------------
-0123456789abcdef | xxxxxxxxxxxx
-0123456789       | yyyyyyyy
--[ RECORD 7 ]----+---------------------
-0123456789abcdef | xxxxxxxxxxxxxx
-0123456789       | yyyyyy
--[ RECORD 8 ]----+---------------------
-0123456789abcdef | xxxxxxxxxxxxxxxx
-0123456789       | yyyy
--[ RECORD 9 ]----+---------------------
-0123456789abcdef | xxxxxxxxxxxxxxxxxx
-0123456789       | yy
--[ RECORD 10 ]---+---------------------
-0123456789abcdef | xxxxxxxxxxxxxxxxxxxx
-0123456789       | 
-
-\pset format wrapped
-execute q;
--[ RECORD 1 ]----+---------------------
-0123456789abcdef | xx
-0123456789       | yyyyyyyyyyyyyyyyyy
--[ RECORD 2 ]----+---------------------
-0123456789abcdef | xxxx
-0123456789       | yyyyyyyyyyyyyyyy
--[ RECORD 3 ]----+---------------------
-0123456789abcdef | xxxxxx
-0123456789       | yyyyyyyyyyyyyy
--[ RECORD 4 ]----+---------------------
-0123456789abcdef | xxxxxxxx
-0123456789       | yyyyyyyyyyyy
--[ RECORD 5 ]----+---------------------
-0123456789abcdef | xxxxxxxxxx
-0123456789       | yyyyyyyyyy
--[ RECORD 6 ]----+---------------------
-0123456789abcdef | xxxxxxxxxxxx
-0123456789       | yyyyyyyy
--[ RECORD 7 ]----+---------------------
-0123456789abcdef | xxxxxxxxxxxxxx
-0123456789       | yyyyyy
--[ RECORD 8 ]----+---------------------
-0123456789abcdef | xxxxxxxxxxxxxxxx
-0123456789       | yyyy
--[ RECORD 9 ]----+---------------------
-0123456789abcdef | xxxxxxxxxxxxxxxxxx
-0123456789       | yy
--[ RECORD 10 ]---+---------------------
-0123456789abcdef | xxxxxxxxxxxxxxxxxxxx
-0123456789       | 
-
-\pset border 2
-\pset format unaligned
-execute q;
-0123456789abcdef|xx
-0123456789|yyyyyyyyyyyyyyyyyy
-
-0123456789abcdef|xxxx
-0123456789|yyyyyyyyyyyyyyyy
-
-0123456789abcdef|xxxxxx
-0123456789|yyyyyyyyyyyyyy
-
-0123456789abcdef|xxxxxxxx
-0123456789|yyyyyyyyyyyy
-
-0123456789abcdef|xxxxxxxxxx
-0123456789|yyyyyyyyyy
-
-0123456789abcdef|xxxxxxxxxxxx
-0123456789|yyyyyyyy
-
-0123456789abcdef|xxxxxxxxxxxxxx
-0123456789|yyyyyy
-
-0123456789abcdef|xxxxxxxxxxxxxxxx
-0123456789|yyyy
-
-0123456789abcdef|xxxxxxxxxxxxxxxxxx
-0123456789|yy
-
-0123456789abcdef|xxxxxxxxxxxxxxxxxxxx
-0123456789|
-\pset format aligned
-execute q;
-+-[ RECORD 1 ]-----+----------------------+
-| 0123456789abcdef | xx                   |
-| 0123456789       | yyyyyyyyyyyyyyyyyy   |
-+-[ RECORD 2 ]-----+----------------------+
-| 0123456789abcdef | xxxx                 |
-| 0123456789       | yyyyyyyyyyyyyyyy     |
-+-[ RECORD 3 ]-----+----------------------+
-| 0123456789abcdef | xxxxxx               |
-| 0123456789       | yyyyyyyyyyyyyy       |
-+-[ RECORD 4 ]-----+----------------------+
-| 0123456789abcdef | xxxxxxxx             |
-| 0123456789       | yyyyyyyyyyyy         |
-+-[ RECORD 5 ]-----+----------------------+
-| 0123456789abcdef | xxxxxxxxxx           |
-| 0123456789       | yyyyyyyyyy           |
-+-[ RECORD 6 ]-----+----------------------+
-| 0123456789abcdef | xxxxxxxxxxxx         |
-| 0123456789       | yyyyyyyy             |
-+-[ RECORD 7 ]-----+----------------------+
-| 0123456789abcdef | xxxxxxxxxxxxxx       |
-| 0123456789       | yyyyyy               |
-+-[ RECORD 8 ]-----+----------------------+
-| 0123456789abcdef | xxxxxxxxxxxxxxxx     |
-| 0123456789       | yyyy                 |
-+-[ RECORD 9 ]-----+----------------------+
-| 0123456789abcdef | xxxxxxxxxxxxxxxxxx   |
-| 0123456789       | yy                   |
-+-[ RECORD 10 ]----+----------------------+
-| 0123456789abcdef | xxxxxxxxxxxxxxxxxxxx |
-| 0123456789       |                      |
-+------------------+----------------------+
-
-\pset format wrapped
-execute q;
-+-[ RECORD 1 ]-----+-------------------+
-| 0123456789abcdef | xx                |
-| 0123456789       | yyyyyyyyyyyyyyyyy |
-|                  ; y                 |
-+-[ RECORD 2 ]-----+-------------------+
-| 0123456789abcdef | xxxx              |
-| 0123456789       | yyyyyyyyyyyyyyyy  |
-+-[ RECORD 3 ]-----+-------------------+
-| 0123456789abcdef | xxxxxx            |
-| 0123456789       | yyyyyyyyyyyyyy    |
-+-[ RECORD 4 ]-----+-------------------+
-| 0123456789abcdef | xxxxxxxx          |
-| 0123456789       | yyyyyyyyyyyy      |
-+-[ RECORD 5 ]-----+-------------------+
-| 0123456789abcdef | xxxxxxxxxx        |
-| 0123456789       | yyyyyyyyyy        |
-+-[ RECORD 6 ]-----+-------------------+
-| 0123456789abcdef | xxxxxxxxxxxx      |
-| 0123456789       | yyyyyyyy          |
-+-[ RECORD 7 ]-----+-------------------+
-| 0123456789abcdef | xxxxxxxxxxxxxx    |
-| 0123456789       | yyyyyy            |
-+-[ RECORD 8 ]-----+-------------------+
-| 0123456789abcdef | xxxxxxxxxxxxxxxx  |
-| 0123456789       | yyyy              |
-+-[ RECORD 9 ]-----+-------------------+
-| 0123456789abcdef | xxxxxxxxxxxxxxxxx |
-|                  ; x                 |
-| 0123456789       | yy                |
-+-[ RECORD 10 ]----+-------------------+
-| 0123456789abcdef | xxxxxxxxxxxxxxxxx |
-|                  ; xxx               |
-| 0123456789       |                   |
-+------------------+-------------------+
-
-deallocate q;
-\pset linestyle ascii
-\pset border 1
--- support table for output-format tests (useful to create a footer)
-create table psql_serial_tab (id serial);
--- test header/footer/tuples_only behavior in aligned/unaligned/wrapped cases
-\pset format aligned
-\pset expanded off
-\d psql_serial_tab_id_seq
-               Sequence "public.psql_serial_tab_id_seq"
-  Type   | Start | Minimum |  Maximum   | Increment | Cycles? | Cache 
----------+-------+---------+------------+-----------+---------+-------
- integer |     1 |       1 | 2147483647 |         1 | no      |     1
-Owned by: public.psql_serial_tab.id
-
-\pset tuples_only true
-\df exp
- pg_catalog | exp  | double precision | double precision    | func
- pg_catalog | exp  | numeric          | numeric             | func
-
-\pset tuples_only false
-\pset expanded on
-\d psql_serial_tab_id_seq
-Sequence "public.psql_serial_tab_id_seq"
--[ RECORD 1 ]---------
-Type      | integer
-Start     | 1
-Minimum   | 1
-Maximum   | 2147483647
-Increment | 1
-Cycles?   | no
-Cache     | 1
-
-Owned by: public.psql_serial_tab.id
-
-\pset tuples_only true
-\df exp
-Schema              | pg_catalog
-Name                | exp
-Result data type    | double precision
-Argument data types | double precision
-Type                | func
---------------------+-----------------
-Schema              | pg_catalog
-Name                | exp
-Result data type    | numeric
-Argument data types | numeric
-Type                | func
-
-\pset tuples_only false
--- empty table is a special case for this format
-select 1 where false;
-(0 rows)
-
-\pset format unaligned
-\pset expanded off
-\d psql_serial_tab_id_seq
-Sequence "public.psql_serial_tab_id_seq"
-Type|Start|Minimum|Maximum|Increment|Cycles?|Cache
-integer|1|1|2147483647|1|no|1
-Owned by: public.psql_serial_tab.id
-\pset tuples_only true
-\df exp
-pg_catalog|exp|double precision|double precision|func
-pg_catalog|exp|numeric|numeric|func
-\pset tuples_only false
-\pset expanded on
-\d psql_serial_tab_id_seq
-Sequence "public.psql_serial_tab_id_seq"
-
-Type|integer
-Start|1
-Minimum|1
-Maximum|2147483647
-Increment|1
-Cycles?|no
-Cache|1
-
-Owned by: public.psql_serial_tab.id
-\pset tuples_only true
-\df exp
-Schema|pg_catalog
-Name|exp
-Result data type|double precision
-Argument data types|double precision
-Type|func
-
-Schema|pg_catalog
-Name|exp
-Result data type|numeric
-Argument data types|numeric
-Type|func
-\pset tuples_only false
-\pset format wrapped
-\pset expanded off
-\d psql_serial_tab_id_seq
-               Sequence "public.psql_serial_tab_id_seq"
-  Type   | Start | Minimum |  Maximum   | Increment | Cycles? | Cache 
----------+-------+---------+------------+-----------+---------+-------
- integer |     1 |       1 | 2147483647 |         1 | no      |     1
-Owned by: public.psql_serial_tab.id
-
-\pset tuples_only true
-\df exp
- pg_catalog | exp  | double precision | double precision    | func
- pg_catalog | exp  | numeric          | numeric             | func
-
-\pset tuples_only false
-\pset expanded on
-\d psql_serial_tab_id_seq
-Sequence "public.psql_serial_tab_id_seq"
--[ RECORD 1 ]---------
-Type      | integer
-Start     | 1
-Minimum   | 1
-Maximum   | 2147483647
-Increment | 1
-Cycles?   | no
-Cache     | 1
-
-Owned by: public.psql_serial_tab.id
-
-\pset tuples_only true
-\df exp
-Schema              | pg_catalog
-Name                | exp
-Result data type    | double precision
-Argument data types | double precision
-Type                | func
---------------------+-----------------
-Schema              | pg_catalog
-Name                | exp
-Result data type    | numeric
-Argument data types | numeric
-Type                | func
-
-\pset tuples_only false
--- check conditional am display
-\pset expanded off
-CREATE SCHEMA tableam_display;
-CREATE ROLE regress_display_role;
-ALTER SCHEMA tableam_display OWNER TO regress_display_role;
-SET search_path TO tableam_display;
-CREATE ACCESS METHOD heap_psql TYPE TABLE HANDLER heap_tableam_handler;
-SET ROLE TO regress_display_role;
--- Use only relations with a physical size of zero.
-CREATE TABLE tbl_heap_psql(f1 int, f2 char(100)) using heap_psql;
-CREATE TABLE tbl_heap(f1 int, f2 char(100)) using heap;
-CREATE VIEW view_heap_psql AS SELECT f1 from tbl_heap_psql;
-CREATE MATERIALIZED VIEW mat_view_heap_psql USING heap_psql AS SELECT f1 from tbl_heap_psql;
-\d+ tbl_heap_psql
-                              Table "tableam_display.tbl_heap_psql"
- Column |      Type      | Collation | Nullable | Default | Storage  | Stats target | Description 
---------+----------------+-----------+----------+---------+----------+--------------+-------------
- f1     | integer        |           |          |         | plain    |              | 
- f2     | character(100) |           |          |         | extended |              | 
-
-\d+ tbl_heap
-                                 Table "tableam_display.tbl_heap"
- Column |      Type      | Collation | Nullable | Default | Storage  | Stats target | Description 
---------+----------------+-----------+----------+---------+----------+--------------+-------------
- f1     | integer        |           |          |         | plain    |              | 
- f2     | character(100) |           |          |         | extended |              | 
-
-\set HIDE_TABLEAM off
-\d+ tbl_heap_psql
-                              Table "tableam_display.tbl_heap_psql"
- Column |      Type      | Collation | Nullable | Default | Storage  | Stats target | Description 
---------+----------------+-----------+----------+---------+----------+--------------+-------------
- f1     | integer        |           |          |         | plain    |              | 
- f2     | character(100) |           |          |         | extended |              | 
-Access method: heap_psql
-
-\d+ tbl_heap
-                                 Table "tableam_display.tbl_heap"
- Column |      Type      | Collation | Nullable | Default | Storage  | Stats target | Description 
---------+----------------+-----------+----------+---------+----------+--------------+-------------
- f1     | integer        |           |          |         | plain    |              | 
- f2     | character(100) |           |          |         | extended |              | 
-Access method: heap
-
--- AM is displayed for tables, indexes and materialized views.
-\d+
-                                                           List of relations
-     Schema      |        Name        |       Type        |        Owner         | Persistence | Access method |  Size   | Description 
------------------+--------------------+-------------------+----------------------+-------------+---------------+---------+-------------
- tableam_display | mat_view_heap_psql | materialized view | regress_display_role | permanent   | heap_psql     | 0 bytes | 
- tableam_display | tbl_heap           | table             | regress_display_role | permanent   | heap          | 0 bytes | 
- tableam_display | tbl_heap_psql      | table             | regress_display_role | permanent   | heap_psql     | 0 bytes | 
- tableam_display | view_heap_psql     | view              | regress_display_role | permanent   |               | 0 bytes | 
-(4 rows)
-
-\dt+
-                                                  List of relations
-     Schema      |     Name      | Type  |        Owner         | Persistence | Access method |  Size   | Description 
------------------+---------------+-------+----------------------+-------------+---------------+---------+-------------
- tableam_display | tbl_heap      | table | regress_display_role | permanent   | heap          | 0 bytes | 
- tableam_display | tbl_heap_psql | table | regress_display_role | permanent   | heap_psql     | 0 bytes | 
-(2 rows)
-
-\dm+
-                                                           List of relations
-     Schema      |        Name        |       Type        |        Owner         | Persistence | Access method |  Size   | Description 
------------------+--------------------+-------------------+----------------------+-------------+---------------+---------+-------------
- tableam_display | mat_view_heap_psql | materialized view | regress_display_role | permanent   | heap_psql     | 0 bytes | 
-(1 row)
-
--- But not for views and sequences.
-\dv+
-                                          List of relations
-     Schema      |      Name      | Type |        Owner         | Persistence |  Size   | Description 
------------------+----------------+------+----------------------+-------------+---------+-------------
- tableam_display | view_heap_psql | view | regress_display_role | permanent   | 0 bytes | 
-(1 row)
-
-\set HIDE_TABLEAM on
-\d+
-                                                   List of relations
-     Schema      |        Name        |       Type        |        Owner         | Persistence |  Size   | Description 
------------------+--------------------+-------------------+----------------------+-------------+---------+-------------
- tableam_display | mat_view_heap_psql | materialized view | regress_display_role | permanent   | 0 bytes | 
- tableam_display | tbl_heap           | table             | regress_display_role | permanent   | 0 bytes | 
- tableam_display | tbl_heap_psql      | table             | regress_display_role | permanent   | 0 bytes | 
- tableam_display | view_heap_psql     | view              | regress_display_role | permanent   | 0 bytes | 
-(4 rows)
-
-RESET ROLE;
-RESET search_path;
-DROP SCHEMA tableam_display CASCADE;
-NOTICE:  drop cascades to 4 other objects
-DETAIL:  drop cascades to table tableam_display.tbl_heap_psql
-drop cascades to table tableam_display.tbl_heap
-drop cascades to view tableam_display.view_heap_psql
-drop cascades to materialized view tableam_display.mat_view_heap_psql
-DROP ACCESS METHOD heap_psql;
-DROP ROLE regress_display_role;
--- test numericlocale (as best we can without control of psql's locale)
-\pset format aligned
-\pset expanded off
-\pset numericlocale true
-select n, -n as m, n * 111 as x, '1e90'::float8 as f
-from generate_series(0,3) n;
- n | m  |  x  |   f   
----+----+-----+-------
- 0 |  0 |   0 | 1e+90
- 1 | -1 | 111 | 1e+90
- 2 | -2 | 222 | 1e+90
- 3 | -3 | 333 | 1e+90
-(4 rows)
-
-\pset numericlocale false
--- test asciidoc output format
-\pset format asciidoc
-\pset border 1
-\pset expanded off
-\d psql_serial_tab_id_seq
-
-.Sequence "public.psql_serial_tab_id_seq"
-[options="header",cols="<l,>l,>l,>l,>l,<l,>l",frame="none"]
-|====
-^l|Type ^l|Start ^l|Minimum ^l|Maximum ^l|Increment ^l|Cycles? ^l|Cache
-|integer |1 |1 |2147483647 |1 |no |1
-|====
-
-....
-Owned by: public.psql_serial_tab.id
-....
-\pset tuples_only true
-\df exp
-
-[cols="<l,<l,<l,<l,<l",frame="none"]
-|====
-|pg_catalog |exp |double precision |double precision |func
-|pg_catalog |exp |numeric |numeric |func
-|====
-\pset tuples_only false
-\pset expanded on
-\d psql_serial_tab_id_seq
-
-.Sequence "public.psql_serial_tab_id_seq"
-[cols="h,l",frame="none"]
-|====
-2+^|Record 1
-<l|Type <l|integer
-<l|Start >l|1
-<l|Minimum >l|1
-<l|Maximum >l|2147483647
-<l|Increment >l|1
-<l|Cycles? <l|no
-<l|Cache >l|1
-|====
-
-....
-Owned by: public.psql_serial_tab.id
-....
-\pset tuples_only true
-\df exp
-
-[cols="h,l",frame="none"]
-|====
-2+|
-<l|Schema <l|pg_catalog
-<l|Name <l|exp
-<l|Result data type <l|double precision
-<l|Argument data types <l|double precision
-<l|Type <l|func
-2+|
-<l|Schema <l|pg_catalog
-<l|Name <l|exp
-<l|Result data type <l|numeric
-<l|Argument data types <l|numeric
-<l|Type <l|func
-|====
-\pset tuples_only false
-prepare q as
-  select 'some|text' as "a|title", '        ' as "empty ", n as int
-  from generate_series(1,2) as n;
-\pset expanded off
-\pset border 0
-execute q;
-
-[options="header",cols="<l,<l,>l",frame="none",grid="none"]
-|====
-^l|a\|title ^l|empty  ^l|int
-|some\|text |  |1
-|some\|text |  |2
-|====
-
-....
-(2 rows)
-....
-\pset border 1
-execute q;
-
-[options="header",cols="<l,<l,>l",frame="none"]
-|====
-^l|a\|title ^l|empty  ^l|int
-|some\|text |  |1
-|some\|text |  |2
-|====
-
-....
-(2 rows)
-....
-\pset border 2
-execute q;
-
-[options="header",cols="<l,<l,>l",frame="all",grid="all"]
-|====
-^l|a\|title ^l|empty  ^l|int
-|some\|text |  |1
-|some\|text |  |2
-|====
-
-....
-(2 rows)
-....
-\pset expanded on
-\pset border 0
-execute q;
-
-[cols="h,l",frame="none",grid="none"]
-|====
-2+^|Record 1
-<l|a\|title <l|some\|text
-<l|empty  <l| 
-<l|int >l|1
-2+^|Record 2
-<l|a\|title <l|some\|text
-<l|empty  <l| 
-<l|int >l|2
-|====
-\pset border 1
-execute q;
-
-[cols="h,l",frame="none"]
-|====
-2+^|Record 1
-<l|a\|title <l|some\|text
-<l|empty  <l| 
-<l|int >l|1
-2+^|Record 2
-<l|a\|title <l|some\|text
-<l|empty  <l| 
-<l|int >l|2
-|====
-\pset border 2
-execute q;
-
-[cols="h,l",frame="all",grid="all"]
-|====
-2+^|Record 1
-<l|a\|title <l|some\|text
-<l|empty  <l| 
-<l|int >l|1
-2+^|Record 2
-<l|a\|title <l|some\|text
-<l|empty  <l| 
-<l|int >l|2
-|====
-deallocate q;
--- test csv output format
-\pset format csv
-\pset border 1
-\pset expanded off
-\d psql_serial_tab_id_seq
-Type,Start,Minimum,Maximum,Increment,Cycles?,Cache
-integer,1,1,2147483647,1,no,1
-\pset tuples_only true
-\df exp
-pg_catalog,exp,double precision,double precision,func
-pg_catalog,exp,numeric,numeric,func
-\pset tuples_only false
-\pset expanded on
-\d psql_serial_tab_id_seq
-Type,integer
-Start,1
-Minimum,1
-Maximum,2147483647
-Increment,1
-Cycles?,no
-Cache,1
-\pset tuples_only true
-\df exp
-Schema,pg_catalog
-Name,exp
-Result data type,double precision
-Argument data types,double precision
-Type,func
-Schema,pg_catalog
-Name,exp
-Result data type,numeric
-Argument data types,numeric
-Type,func
-\pset tuples_only false
-prepare q as
-  select 'some"text' as "a""title", E'  <foo>\n<bar>' as "junk",
-         '   ' as "empty", n as int
-  from generate_series(1,2) as n;
-\pset expanded off
-execute q;
-"a""title",junk,empty,int
-"some""text","  <foo>
-<bar>",   ,1
-"some""text","  <foo>
-<bar>",   ,2
-\pset expanded on
-execute q;
-"a""title","some""text"
-junk,"  <foo>
-<bar>"
-empty,   
-int,1
-"a""title","some""text"
-junk,"  <foo>
-<bar>"
-empty,   
-int,2
-deallocate q;
--- special cases
-\pset expanded off
-select 'comma,comma' as comma, 'semi;semi' as semi;
-comma,semi
-"comma,comma",semi;semi
-\pset csv_fieldsep ';'
-select 'comma,comma' as comma, 'semi;semi' as semi;
-comma;semi
-comma,comma;"semi;semi"
-select '\.' as data;
-data
-"\."
-\pset csv_fieldsep '.'
-select '\' as d1, '' as d2;
-"d1"."d2"
-"\".""
--- illegal csv separators
-\pset csv_fieldsep ''
-\pset: csv_fieldsep must be a single one-byte character
-\pset csv_fieldsep '\0'
-\pset: csv_fieldsep must be a single one-byte character
-\pset csv_fieldsep '\n'
-\pset: csv_fieldsep cannot be a double quote, a newline, or a carriage return
-\pset csv_fieldsep '\r'
-\pset: csv_fieldsep cannot be a double quote, a newline, or a carriage return
-\pset csv_fieldsep '"'
-\pset: csv_fieldsep cannot be a double quote, a newline, or a carriage return
-\pset csv_fieldsep ',,'
-\pset: csv_fieldsep must be a single one-byte character
-\pset csv_fieldsep ','
--- test html output format
-\pset format html
-\pset border 1
-\pset expanded off
-\d psql_serial_tab_id_seq
-<table border="1">
-  <caption>Sequence &quot;public.psql_serial_tab_id_seq&quot;</caption>
-  <tr>
-    <th align="center">Type</th>
-    <th align="center">Start</th>
-    <th align="center">Minimum</th>
-    <th align="center">Maximum</th>
-    <th align="center">Increment</th>
-    <th align="center">Cycles?</th>
-    <th align="center">Cache</th>
-  </tr>
-  <tr valign="top">
-    <td align="left">integer</td>
-    <td align="right">1</td>
-    <td align="right">1</td>
-    <td align="right">2147483647</td>
-    <td align="right">1</td>
-    <td align="left">no</td>
-    <td align="right">1</td>
-  </tr>
-</table>
-<p>Owned by: public.psql_serial_tab.id<br />
-</p>
-\pset tuples_only true
-\df exp
-<table border="1">
-  <tr valign="top">
-    <td align="left">pg_catalog</td>
-    <td align="left">exp</td>
-    <td align="left">double precision</td>
-    <td align="left">double precision</td>
-    <td align="left">func</td>
-  </tr>
-  <tr valign="top">
-    <td align="left">pg_catalog</td>
-    <td align="left">exp</td>
-    <td align="left">numeric</td>
-    <td align="left">numeric</td>
-    <td align="left">func</td>
-  </tr>
-</table>
-
-\pset tuples_only false
-\pset expanded on
-\d psql_serial_tab_id_seq
-<table border="1">
-  <caption>Sequence &quot;public.psql_serial_tab_id_seq&quot;</caption>
-
-  <tr><td colspan="2" align="center">Record 1</td></tr>
-  <tr valign="top">
-    <th>Type</th>
-    <td align="left">integer</td>
-  </tr>
-  <tr valign="top">
-    <th>Start</th>
-    <td align="right">1</td>
-  </tr>
-  <tr valign="top">
-    <th>Minimum</th>
-    <td align="right">1</td>
-  </tr>
-  <tr valign="top">
-    <th>Maximum</th>
-    <td align="right">2147483647</td>
-  </tr>
-  <tr valign="top">
-    <th>Increment</th>
-    <td align="right">1</td>
-  </tr>
-  <tr valign="top">
-    <th>Cycles?</th>
-    <td align="left">no</td>
-  </tr>
-  <tr valign="top">
-    <th>Cache</th>
-    <td align="right">1</td>
-  </tr>
-</table>
-<p>Owned by: public.psql_serial_tab.id<br />
-</p>
-\pset tuples_only true
-\df exp
-<table border="1">
-
-  <tr><td colspan="2">&nbsp;</td></tr>
-  <tr valign="top">
-    <th>Schema</th>
-    <td align="left">pg_catalog</td>
-  </tr>
-  <tr valign="top">
-    <th>Name</th>
-    <td align="left">exp</td>
-  </tr>
-  <tr valign="top">
-    <th>Result data type</th>
-    <td align="left">double precision</td>
-  </tr>
-  <tr valign="top">
-    <th>Argument data types</th>
-    <td align="left">double precision</td>
-  </tr>
-  <tr valign="top">
-    <th>Type</th>
-    <td align="left">func</td>
-  </tr>
-
-  <tr><td colspan="2">&nbsp;</td></tr>
-  <tr valign="top">
-    <th>Schema</th>
-    <td align="left">pg_catalog</td>
-  </tr>
-  <tr valign="top">
-    <th>Name</th>
-    <td align="left">exp</td>
-  </tr>
-  <tr valign="top">
-    <th>Result data type</th>
-    <td align="left">numeric</td>
-  </tr>
-  <tr valign="top">
-    <th>Argument data types</th>
-    <td align="left">numeric</td>
-  </tr>
-  <tr valign="top">
-    <th>Type</th>
-    <td align="left">func</td>
-  </tr>
-</table>
-
-\pset tuples_only false
-prepare q as
-  select 'some"text' as "a&title", E'  <foo>\n<bar>' as "junk",
-         '   ' as "empty", n as int
-  from generate_series(1,2) as n;
-\pset expanded off
-\pset border 0
-execute q;
-<table border="0">
-  <tr>
-    <th align="center">a&amp;title</th>
-    <th align="center">junk</th>
-    <th align="center">empty</th>
-    <th align="center">int</th>
-  </tr>
-  <tr valign="top">
-    <td align="left">some&quot;text</td>
-    <td align="left">&nbsp;&nbsp;&lt;foo&gt;<br />
-&lt;bar&gt;</td>
-    <td align="left">&nbsp; </td>
-    <td align="right">1</td>
-  </tr>
-  <tr valign="top">
-    <td align="left">some&quot;text</td>
-    <td align="left">&nbsp;&nbsp;&lt;foo&gt;<br />
-&lt;bar&gt;</td>
-    <td align="left">&nbsp; </td>
-    <td align="right">2</td>
-  </tr>
-</table>
-<p>(2 rows)<br />
-</p>
-\pset border 1
-execute q;
-<table border="1">
-  <tr>
-    <th align="center">a&amp;title</th>
-    <th align="center">junk</th>
-    <th align="center">empty</th>
-    <th align="center">int</th>
-  </tr>
-  <tr valign="top">
-    <td align="left">some&quot;text</td>
-    <td align="left">&nbsp;&nbsp;&lt;foo&gt;<br />
-&lt;bar&gt;</td>
-    <td align="left">&nbsp; </td>
-    <td align="right">1</td>
-  </tr>
-  <tr valign="top">
-    <td align="left">some&quot;text</td>
-    <td align="left">&nbsp;&nbsp;&lt;foo&gt;<br />
-&lt;bar&gt;</td>
-    <td align="left">&nbsp; </td>
-    <td align="right">2</td>
-  </tr>
-</table>
-<p>(2 rows)<br />
-</p>
-\pset tableattr foobar
-execute q;
-<table border="1" foobar>
-  <tr>
-    <th align="center">a&amp;title</th>
-    <th align="center">junk</th>
-    <th align="center">empty</th>
-    <th align="center">int</th>
-  </tr>
-  <tr valign="top">
-    <td align="left">some&quot;text</td>
-    <td align="left">&nbsp;&nbsp;&lt;foo&gt;<br />
-&lt;bar&gt;</td>
-    <td align="left">&nbsp; </td>
-    <td align="right">1</td>
-  </tr>
-  <tr valign="top">
-    <td align="left">some&quot;text</td>
-    <td align="left">&nbsp;&nbsp;&lt;foo&gt;<br />
-&lt;bar&gt;</td>
-    <td align="left">&nbsp; </td>
-    <td align="right">2</td>
-  </tr>
-</table>
-<p>(2 rows)<br />
-</p>
-\pset tableattr
-\pset expanded on
-\pset border 0
-execute q;
-<table border="0">
-
-  <tr><td colspan="2" align="center">Record 1</td></tr>
-  <tr valign="top">
-    <th>a&amp;title</th>
-    <td align="left">some&quot;text</td>
-  </tr>
-  <tr valign="top">
-    <th>junk</th>
-    <td align="left">&nbsp;&nbsp;&lt;foo&gt;<br />
-&lt;bar&gt;</td>
-  </tr>
-  <tr valign="top">
-    <th>empty</th>
-    <td align="left">&nbsp; </td>
-  </tr>
-  <tr valign="top">
-    <th>int</th>
-    <td align="right">1</td>
-  </tr>
-
-  <tr><td colspan="2" align="center">Record 2</td></tr>
-  <tr valign="top">
-    <th>a&amp;title</th>
-    <td align="left">some&quot;text</td>
-  </tr>
-  <tr valign="top">
-    <th>junk</th>
-    <td align="left">&nbsp;&nbsp;&lt;foo&gt;<br />
-&lt;bar&gt;</td>
-  </tr>
-  <tr valign="top">
-    <th>empty</th>
-    <td align="left">&nbsp; </td>
-  </tr>
-  <tr valign="top">
-    <th>int</th>
-    <td align="right">2</td>
-  </tr>
-</table>
-
-\pset border 1
-execute q;
-<table border="1">
-
-  <tr><td colspan="2" align="center">Record 1</td></tr>
-  <tr valign="top">
-    <th>a&amp;title</th>
-    <td align="left">some&quot;text</td>
-  </tr>
-  <tr valign="top">
-    <th>junk</th>
-    <td align="left">&nbsp;&nbsp;&lt;foo&gt;<br />
-&lt;bar&gt;</td>
-  </tr>
-  <tr valign="top">
-    <th>empty</th>
-    <td align="left">&nbsp; </td>
-  </tr>
-  <tr valign="top">
-    <th>int</th>
-    <td align="right">1</td>
-  </tr>
-
-  <tr><td colspan="2" align="center">Record 2</td></tr>
-  <tr valign="top">
-    <th>a&amp;title</th>
-    <td align="left">some&quot;text</td>
-  </tr>
-  <tr valign="top">
-    <th>junk</th>
-    <td align="left">&nbsp;&nbsp;&lt;foo&gt;<br />
-&lt;bar&gt;</td>
-  </tr>
-  <tr valign="top">
-    <th>empty</th>
-    <td align="left">&nbsp; </td>
-  </tr>
-  <tr valign="top">
-    <th>int</th>
-    <td align="right">2</td>
-  </tr>
-</table>
-
-\pset tableattr foobar
-execute q;
-<table border="1" foobar>
-
-  <tr><td colspan="2" align="center">Record 1</td></tr>
-  <tr valign="top">
-    <th>a&amp;title</th>
-    <td align="left">some&quot;text</td>
-  </tr>
-  <tr valign="top">
-    <th>junk</th>
-    <td align="left">&nbsp;&nbsp;&lt;foo&gt;<br />
-&lt;bar&gt;</td>
-  </tr>
-  <tr valign="top">
-    <th>empty</th>
-    <td align="left">&nbsp; </td>
-  </tr>
-  <tr valign="top">
-    <th>int</th>
-    <td align="right">1</td>
-  </tr>
-
-  <tr><td colspan="2" align="center">Record 2</td></tr>
-  <tr valign="top">
-    <th>a&amp;title</th>
-    <td align="left">some&quot;text</td>
-  </tr>
-  <tr valign="top">
-    <th>junk</th>
-    <td align="left">&nbsp;&nbsp;&lt;foo&gt;<br />
-&lt;bar&gt;</td>
-  </tr>
-  <tr valign="top">
-    <th>empty</th>
-    <td align="left">&nbsp; </td>
-  </tr>
-  <tr valign="top">
-    <th>int</th>
-    <td align="right">2</td>
-  </tr>
-</table>
-
-\pset tableattr
-deallocate q;
--- test latex output format
-\pset format latex
-\pset border 1
-\pset expanded off
-\d psql_serial_tab_id_seq
-\begin{center}
-Sequence "public.psql\_serial\_tab\_id\_seq"
-\end{center}
-
-\begin{tabular}{l | r | r | r | r | l | r}
-\textit{Type} & \textit{Start} & \textit{Minimum} & \textit{Maximum} & \textit{Increment} & \textit{Cycles?} & \textit{Cache} \\
-\hline
-integer & 1 & 1 & 2147483647 & 1 & no & 1 \\
-\end{tabular}
-
-\noindent Owned by: public.psql\_serial\_tab.id \\
-
-\pset tuples_only true
-\df exp
-\begin{tabular}{l | l | l | l | l}
-pg\_catalog & exp & double precision & double precision & func \\
-pg\_catalog & exp & numeric & numeric & func \\
-\end{tabular}
-
-\noindent 
-\pset tuples_only false
-\pset expanded on
-\d psql_serial_tab_id_seq
-\begin{center}
-Sequence "public.psql\_serial\_tab\_id\_seq"
-\end{center}
-
-\begin{tabular}{c|l}
-\multicolumn{2}{c}{\textit{Record 1}} \\
-\hline
-Type & integer \\
-Start & 1 \\
-Minimum & 1 \\
-Maximum & 2147483647 \\
-Increment & 1 \\
-Cycles? & no \\
-Cache & 1 \\
-\end{tabular}
-
-\noindent Owned by: public.psql\_serial\_tab.id \\
-
-\pset tuples_only true
-\df exp
-\begin{tabular}{c|l}
-\hline
-Schema & pg\_catalog \\
-Name & exp \\
-Result data type & double precision \\
-Argument data types & double precision \\
-Type & func \\
-\hline
-Schema & pg\_catalog \\
-Name & exp \\
-Result data type & numeric \\
-Argument data types & numeric \\
-Type & func \\
-\end{tabular}
-
-\noindent 
-\pset tuples_only false
-prepare q as
-  select 'some\more_text' as "a$title", E'  #<foo>%&^~|\n{bar}' as "junk",
-         '   ' as "empty", n as int
-  from generate_series(1,2) as n;
-\pset expanded off
-\pset border 0
-execute q;
-\begin{tabular}{lllr}
-\textit{a\$title} & \textit{junk} & \textit{empty} & \textit{int} \\
-\hline
-some\textbackslash{}more\_text &   \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\} &     & 1 \\
-some\textbackslash{}more\_text &   \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\} &     & 2 \\
-\end{tabular}
-
-\noindent (2 rows) \\
-
-\pset border 1
-execute q;
-\begin{tabular}{l | l | l | r}
-\textit{a\$title} & \textit{junk} & \textit{empty} & \textit{int} \\
-\hline
-some\textbackslash{}more\_text &   \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\} &     & 1 \\
-some\textbackslash{}more\_text &   \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\} &     & 2 \\
-\end{tabular}
-
-\noindent (2 rows) \\
-
-\pset border 2
-execute q;
-\begin{tabular}{| l | l | l | r |}
-\hline
-\textit{a\$title} & \textit{junk} & \textit{empty} & \textit{int} \\
-\hline
-some\textbackslash{}more\_text &   \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\} &     & 1 \\
-some\textbackslash{}more\_text &   \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\} &     & 2 \\
-\hline
-\end{tabular}
-
-\noindent (2 rows) \\
-
-\pset border 3
-execute q;
-\begin{tabular}{| l | l | l | r |}
-\hline
-\textit{a\$title} & \textit{junk} & \textit{empty} & \textit{int} \\
-\hline
-some\textbackslash{}more\_text &   \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\} &     & 1 \\
-\hline
-some\textbackslash{}more\_text &   \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\} &     & 2 \\
-\hline
-\end{tabular}
-
-\noindent (2 rows) \\
-
-\pset expanded on
-\pset border 0
-execute q;
-\begin{tabular}{cl}
-\multicolumn{2}{c}{\textit{Record 1}} \\
-a\$title & some\textbackslash{}more\_text \\
-junk &   \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\} \\
-empty &     \\
-int & 1 \\
-\multicolumn{2}{c}{\textit{Record 2}} \\
-a\$title & some\textbackslash{}more\_text \\
-junk &   \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\} \\
-empty &     \\
-int & 2 \\
-\end{tabular}
-
-\noindent 
-\pset border 1
-execute q;
-\begin{tabular}{c|l}
-\multicolumn{2}{c}{\textit{Record 1}} \\
-\hline
-a\$title & some\textbackslash{}more\_text \\
-junk &   \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\} \\
-empty &     \\
-int & 1 \\
-\multicolumn{2}{c}{\textit{Record 2}} \\
-\hline
-a\$title & some\textbackslash{}more\_text \\
-junk &   \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\} \\
-empty &     \\
-int & 2 \\
-\end{tabular}
-
-\noindent 
-\pset border 2
-execute q;
-\begin{tabular}{|c|l|}
-\hline
-\multicolumn{2}{|c|}{\textit{Record 1}} \\
-\hline
-a\$title & some\textbackslash{}more\_text \\
-junk &   \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\} \\
-empty &     \\
-int & 1 \\
-\hline
-\multicolumn{2}{|c|}{\textit{Record 2}} \\
-\hline
-a\$title & some\textbackslash{}more\_text \\
-junk &   \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\} \\
-empty &     \\
-int & 2 \\
-\hline
-\end{tabular}
-
-\noindent 
-\pset border 3
-execute q;
-\begin{tabular}{|c|l|}
-\hline
-\multicolumn{2}{|c|}{\textit{Record 1}} \\
-\hline
-a\$title & some\textbackslash{}more\_text \\
-junk &   \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\} \\
-empty &     \\
-int & 1 \\
-\hline
-\multicolumn{2}{|c|}{\textit{Record 2}} \\
-\hline
-a\$title & some\textbackslash{}more\_text \\
-junk &   \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\} \\
-empty &     \\
-int & 2 \\
-\hline
-\end{tabular}
-
-\noindent 
-deallocate q;
--- test latex-longtable output format
-\pset format latex-longtable
-\pset border 1
-\pset expanded off
-\d psql_serial_tab_id_seq
-\begin{longtable}{l | r | r | r | r | l | r}
-\small\textbf{\textit{Type}} & \small\textbf{\textit{Start}} & \small\textbf{\textit{Minimum}} & \small\textbf{\textit{Maximum}} & \small\textbf{\textit{Increment}} & \small\textbf{\textit{Cycles?}} & \small\textbf{\textit{Cache}} \\
-\midrule
-\endfirsthead
-\small\textbf{\textit{Type}} & \small\textbf{\textit{Start}} & \small\textbf{\textit{Minimum}} & \small\textbf{\textit{Maximum}} & \small\textbf{\textit{Increment}} & \small\textbf{\textit{Cycles?}} & \small\textbf{\textit{Cache}} \\
-\midrule
-\endhead
-\caption[Sequence "public.psql\_serial\_tab\_id\_seq" (Continued)]{Sequence "public.psql\_serial\_tab\_id\_seq"}
-\endfoot
-\caption[Sequence "public.psql\_serial\_tab\_id\_seq"]{Sequence "public.psql\_serial\_tab\_id\_seq"}
-\endlastfoot
-\raggedright{integer}
-&
-\raggedright{1}
-&
-\raggedright{1}
-&
-\raggedright{2147483647}
-&
-\raggedright{1}
-&
-\raggedright{no}
-&
-\raggedright{1} \tabularnewline
-\end{longtable}
-\pset tuples_only true
-\df exp
-\begin{longtable}{l | l | l | l | l}
-\raggedright{pg\_catalog}
-&
-\raggedright{exp}
-&
-\raggedright{double precision}
-&
-\raggedright{double precision}
-&
-\raggedright{func} \tabularnewline
-\raggedright{pg\_catalog}
-&
-\raggedright{exp}
-&
-\raggedright{numeric}
-&
-\raggedright{numeric}
-&
-\raggedright{func} \tabularnewline
-\end{longtable}
-\pset tuples_only false
-\pset expanded on
-\d psql_serial_tab_id_seq
-\begin{center}
-Sequence "public.psql\_serial\_tab\_id\_seq"
-\end{center}
-
-\begin{tabular}{c|l}
-\multicolumn{2}{c}{\textit{Record 1}} \\
-\hline
-Type & integer \\
-Start & 1 \\
-Minimum & 1 \\
-Maximum & 2147483647 \\
-Increment & 1 \\
-Cycles? & no \\
-Cache & 1 \\
-\end{tabular}
-
-\noindent Owned by: public.psql\_serial\_tab.id \\
-
-\pset tuples_only true
-\df exp
-\begin{tabular}{c|l}
-\hline
-Schema & pg\_catalog \\
-Name & exp \\
-Result data type & double precision \\
-Argument data types & double precision \\
-Type & func \\
-\hline
-Schema & pg\_catalog \\
-Name & exp \\
-Result data type & numeric \\
-Argument data types & numeric \\
-Type & func \\
-\end{tabular}
-
-\noindent 
-\pset tuples_only false
-prepare q as
-  select 'some\more_text' as "a$title", E'  #<foo>%&^~|\n{bar}' as "junk",
-         '   ' as "empty", n as int
-  from generate_series(1,2) as n;
-\pset expanded off
-\pset border 0
-execute q;
-\begin{longtable}{lllr}
-\small\textbf{\textit{a\$title}} & \small\textbf{\textit{junk}} & \small\textbf{\textit{empty}} & \small\textbf{\textit{int}} \\
-\midrule
-\endfirsthead
-\small\textbf{\textit{a\$title}} & \small\textbf{\textit{junk}} & \small\textbf{\textit{empty}} & \small\textbf{\textit{int}} \\
-\midrule
-\endhead
-\raggedright{some\textbackslash{}more\_text}
-&
-\raggedright{  \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\}}
-&
-\raggedright{   }
-&
-\raggedright{1} \tabularnewline
-\raggedright{some\textbackslash{}more\_text}
-&
-\raggedright{  \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\}}
-&
-\raggedright{   }
-&
-\raggedright{2} \tabularnewline
-\end{longtable}
-\pset border 1
-execute q;
-\begin{longtable}{l | l | l | r}
-\small\textbf{\textit{a\$title}} & \small\textbf{\textit{junk}} & \small\textbf{\textit{empty}} & \small\textbf{\textit{int}} \\
-\midrule
-\endfirsthead
-\small\textbf{\textit{a\$title}} & \small\textbf{\textit{junk}} & \small\textbf{\textit{empty}} & \small\textbf{\textit{int}} \\
-\midrule
-\endhead
-\raggedright{some\textbackslash{}more\_text}
-&
-\raggedright{  \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\}}
-&
-\raggedright{   }
-&
-\raggedright{1} \tabularnewline
-\raggedright{some\textbackslash{}more\_text}
-&
-\raggedright{  \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\}}
-&
-\raggedright{   }
-&
-\raggedright{2} \tabularnewline
-\end{longtable}
-\pset border 2
-execute q;
-\begin{longtable}{| l | l | l | r |}
-\toprule
-\small\textbf{\textit{a\$title}} & \small\textbf{\textit{junk}} & \small\textbf{\textit{empty}} & \small\textbf{\textit{int}} \\
-\midrule
-\endfirsthead
-\toprule
-\small\textbf{\textit{a\$title}} & \small\textbf{\textit{junk}} & \small\textbf{\textit{empty}} & \small\textbf{\textit{int}} \\
-\midrule
-\endhead
-\bottomrule
-\endfoot
-\bottomrule
-\endlastfoot
-\raggedright{some\textbackslash{}more\_text}
-&
-\raggedright{  \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\}}
-&
-\raggedright{   }
-&
-\raggedright{1} \tabularnewline
-\raggedright{some\textbackslash{}more\_text}
-&
-\raggedright{  \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\}}
-&
-\raggedright{   }
-&
-\raggedright{2} \tabularnewline
-\end{longtable}
-\pset border 3
-execute q;
-\begin{longtable}{| l | l | l | r |}
-\toprule
-\small\textbf{\textit{a\$title}} & \small\textbf{\textit{junk}} & \small\textbf{\textit{empty}} & \small\textbf{\textit{int}} \\
-\midrule
-\endfirsthead
-\toprule
-\small\textbf{\textit{a\$title}} & \small\textbf{\textit{junk}} & \small\textbf{\textit{empty}} & \small\textbf{\textit{int}} \\
-\endhead
-\bottomrule
-\endfoot
-\bottomrule
-\endlastfoot
-\raggedright{some\textbackslash{}more\_text}
-&
-\raggedright{  \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\}}
-&
-\raggedright{   }
-&
-\raggedright{1} \tabularnewline
- \hline
-\raggedright{some\textbackslash{}more\_text}
-&
-\raggedright{  \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\}}
-&
-\raggedright{   }
-&
-\raggedright{2} \tabularnewline
- \hline
-\end{longtable}
-\pset tableattr lr
-execute q;
-\begin{longtable}{| p{lr\textwidth} | p{lr\textwidth} | p{lr\textwidth} | r |}
-\toprule
-\small\textbf{\textit{a\$title}} & \small\textbf{\textit{junk}} & \small\textbf{\textit{empty}} & \small\textbf{\textit{int}} \\
-\midrule
-\endfirsthead
-\toprule
-\small\textbf{\textit{a\$title}} & \small\textbf{\textit{junk}} & \small\textbf{\textit{empty}} & \small\textbf{\textit{int}} \\
-\endhead
-\bottomrule
-\endfoot
-\bottomrule
-\endlastfoot
-\raggedright{some\textbackslash{}more\_text}
-&
-\raggedright{  \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\}}
-&
-\raggedright{   }
-&
-\raggedright{1} \tabularnewline
- \hline
-\raggedright{some\textbackslash{}more\_text}
-&
-\raggedright{  \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\}}
-&
-\raggedright{   }
-&
-\raggedright{2} \tabularnewline
- \hline
-\end{longtable}
-\pset tableattr
-\pset expanded on
-\pset border 0
-execute q;
-\begin{tabular}{cl}
-\multicolumn{2}{c}{\textit{Record 1}} \\
-a\$title & some\textbackslash{}more\_text \\
-junk &   \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\} \\
-empty &     \\
-int & 1 \\
-\multicolumn{2}{c}{\textit{Record 2}} \\
-a\$title & some\textbackslash{}more\_text \\
-junk &   \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\} \\
-empty &     \\
-int & 2 \\
-\end{tabular}
-
-\noindent 
-\pset border 1
-execute q;
-\begin{tabular}{c|l}
-\multicolumn{2}{c}{\textit{Record 1}} \\
-\hline
-a\$title & some\textbackslash{}more\_text \\
-junk &   \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\} \\
-empty &     \\
-int & 1 \\
-\multicolumn{2}{c}{\textit{Record 2}} \\
-\hline
-a\$title & some\textbackslash{}more\_text \\
-junk &   \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\} \\
-empty &     \\
-int & 2 \\
-\end{tabular}
-
-\noindent 
-\pset border 2
-execute q;
-\begin{tabular}{|c|l|}
-\hline
-\multicolumn{2}{|c|}{\textit{Record 1}} \\
-\hline
-a\$title & some\textbackslash{}more\_text \\
-junk &   \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\} \\
-empty &     \\
-int & 1 \\
-\hline
-\multicolumn{2}{|c|}{\textit{Record 2}} \\
-\hline
-a\$title & some\textbackslash{}more\_text \\
-junk &   \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\} \\
-empty &     \\
-int & 2 \\
-\hline
-\end{tabular}
-
-\noindent 
-\pset border 3
-execute q;
-\begin{tabular}{|c|l|}
-\hline
-\multicolumn{2}{|c|}{\textit{Record 1}} \\
-\hline
-a\$title & some\textbackslash{}more\_text \\
-junk &   \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\} \\
-empty &     \\
-int & 1 \\
-\hline
-\multicolumn{2}{|c|}{\textit{Record 2}} \\
-\hline
-a\$title & some\textbackslash{}more\_text \\
-junk &   \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\} \\
-empty &     \\
-int & 2 \\
-\hline
-\end{tabular}
-
-\noindent 
-\pset tableattr lr
-execute q;
-\begin{tabular}{|c|l|}
-\hline
-\multicolumn{2}{|c|}{\textit{Record 1}} \\
-\hline
-a\$title & some\textbackslash{}more\_text \\
-junk &   \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\} \\
-empty &     \\
-int & 1 \\
-\hline
-\multicolumn{2}{|c|}{\textit{Record 2}} \\
-\hline
-a\$title & some\textbackslash{}more\_text \\
-junk &   \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\} \\
-empty &     \\
-int & 2 \\
-\hline
-\end{tabular}
-
-\noindent 
-\pset tableattr
-deallocate q;
--- test troff-ms output format
-\pset format troff-ms
-\pset border 1
-\pset expanded off
-\d psql_serial_tab_id_seq
-.LP
-.DS C
-Sequence "public.psql_serial_tab_id_seq"
-.DE
-.LP
-.TS
-center;
-l | r | r | r | r | l | r.
-\fIType\fP	\fIStart\fP	\fIMinimum\fP	\fIMaximum\fP	\fIIncrement\fP	\fICycles?\fP	\fICache\fP
-_
-integer	1	1	2147483647	1	no	1
-.TE
-.DS L
-Owned by: public.psql_serial_tab.id
-.DE
-\pset tuples_only true
-\df exp
-.LP
-.TS
-center;
-l | l | l | l | l.
-pg_catalog	exp	double precision	double precision	func
-pg_catalog	exp	numeric	numeric	func
-.TE
-.DS L
-.DE
-\pset tuples_only false
-\pset expanded on
-\d psql_serial_tab_id_seq
-.LP
-.DS C
-Sequence "public.psql_serial_tab_id_seq"
-.DE
-.LP
-.TS
-center;
-c s.
-\fIRecord 1\fP
-_
-.T&
-c | l.
-Type	integer
-Start	1
-Minimum	1
-Maximum	2147483647
-Increment	1
-Cycles?	no
-Cache	1
-.TE
-.DS L
-Owned by: public.psql_serial_tab.id
-.DE
-\pset tuples_only true
-\df exp
-.LP
-.TS
-center;
-c l;
-_
-Schema	pg_catalog
-Name	exp
-Result data type	double precision
-Argument data types	double precision
-Type	func
-_
-Schema	pg_catalog
-Name	exp
-Result data type	numeric
-Argument data types	numeric
-Type	func
-.TE
-.DS L
-.DE
-\pset tuples_only false
-prepare q as
-  select 'some\text' as "a\title", E'  <foo>\n<bar>' as "junk",
-         '   ' as "empty", n as int
-  from generate_series(1,2) as n;
-\pset expanded off
-\pset border 0
-execute q;
-.LP
-.TS
-center;
-lllr.
-\fIa\(rstitle\fP	\fIjunk\fP	\fIempty\fP	\fIint\fP
-_
-some\(rstext	  <foo>
-<bar>	   	1
-some\(rstext	  <foo>
-<bar>	   	2
-.TE
-.DS L
-(2 rows)
-.DE
-\pset border 1
-execute q;
-.LP
-.TS
-center;
-l | l | l | r.
-\fIa\(rstitle\fP	\fIjunk\fP	\fIempty\fP	\fIint\fP
-_
-some\(rstext	  <foo>
-<bar>	   	1
-some\(rstext	  <foo>
-<bar>	   	2
-.TE
-.DS L
-(2 rows)
-.DE
-\pset border 2
-execute q;
-.LP
-.TS
-center box;
-l | l | l | r.
-\fIa\(rstitle\fP	\fIjunk\fP	\fIempty\fP	\fIint\fP
-_
-some\(rstext	  <foo>
-<bar>	   	1
-some\(rstext	  <foo>
-<bar>	   	2
-.TE
-.DS L
-(2 rows)
-.DE
-\pset expanded on
-\pset border 0
-execute q;
-.LP
-.TS
-center;
-c s.
-\fIRecord 1\fP
-.T&
-c l.
-a\(rstitle	some\(rstext
-junk	  <foo>
-<bar>
-empty	   
-int	1
-.T&
-c s.
-\fIRecord 2\fP
-.T&
-c l.
-a\(rstitle	some\(rstext
-junk	  <foo>
-<bar>
-empty	   
-int	2
-.TE
-.DS L
-.DE
-\pset border 1
-execute q;
-.LP
-.TS
-center;
-c s.
-\fIRecord 1\fP
-_
-.T&
-c | l.
-a\(rstitle	some\(rstext
-junk	  <foo>
-<bar>
-empty	   
-int	1
-.T&
-c s.
-\fIRecord 2\fP
-_
-.T&
-c | l.
-a\(rstitle	some\(rstext
-junk	  <foo>
-<bar>
-empty	   
-int	2
-.TE
-.DS L
-.DE
-\pset border 2
-execute q;
-.LP
-.TS
-center box;
-c s.
-\fIRecord 1\fP
-_
-.T&
-c l.
-a\(rstitle	some\(rstext
-junk	  <foo>
-<bar>
-empty	   
-int	1
-_
-.T&
-c s.
-\fIRecord 2\fP
-_
-.T&
-c l.
-a\(rstitle	some\(rstext
-junk	  <foo>
-<bar>
-empty	   
-int	2
-.TE
-.DS L
-.DE
-deallocate q;
--- check ambiguous format requests
-\pset format a
-\pset: ambiguous abbreviation "a" matches both "aligned" and "asciidoc"
-\pset format l
--- clean up after output format tests
-drop table psql_serial_tab;
-\pset format aligned
-\pset expanded off
-\pset border 1
--- \echo and allied features
-\echo this is a test
-this is a test
-\echo -n without newline
-without newline\echo with -n newline
-with -n newline
-\echo '-n' with newline
--n with newline
-\set foo bar
-\echo foo = :foo
-foo = bar
-\qecho this is a test
-this is a test
-\qecho foo = :foo
-foo = bar
-\warn this is a test
-this is a test
-\warn foo = :foo
-foo = bar
--- tests for \if ... \endif
-\if true
-  select 'okay';
- ?column? 
-----------
- okay
-(1 row)
-
-  select 'still okay';
-  ?column?  
-------------
- still okay
-(1 row)
-
-\else
-  not okay;
-  still not okay
-\endif
--- at this point query buffer should still have last valid line
-\g
-  ?column?  
-------------
- still okay
-(1 row)
-
--- \if should work okay on part of a query
-select
-  \if true
-    42
-  \else
-    (bogus
-  \endif
-  forty_two;
- forty_two 
------------
-        42
-(1 row)
-
-select \if false \\ (bogus \else \\ 42 \endif \\ forty_two;
- forty_two 
------------
-        42
-(1 row)
-
--- test a large nested if using a variety of true-equivalents
-\if true
-	\if 1
-		\if yes
-			\if on
-				\echo 'all true'
-all true
-			\else
-				\echo 'should not print #1-1'
-			\endif
-		\else
-			\echo 'should not print #1-2'
-		\endif
-	\else
-		\echo 'should not print #1-3'
-	\endif
-\else
-	\echo 'should not print #1-4'
-\endif
--- test a variety of false-equivalents in an if/elif/else structure
-\if false
-	\echo 'should not print #2-1'
-\elif 0
-	\echo 'should not print #2-2'
-\elif no
-	\echo 'should not print #2-3'
-\elif off
-	\echo 'should not print #2-4'
-\else
-	\echo 'all false'
-all false
-\endif
--- test true-false elif after initial true branch
-\if true
-	\echo 'should print #2-5'
-should print #2-5
-\elif true
-	\echo 'should not print #2-6'
-\elif false
-	\echo 'should not print #2-7'
-\else
-	\echo 'should not print #2-8'
-\endif
--- test simple true-then-else
-\if true
-	\echo 'first thing true'
-first thing true
-\else
-	\echo 'should not print #3-1'
-\endif
--- test simple false-true-else
-\if false
-	\echo 'should not print #4-1'
-\elif true
-	\echo 'second thing true'
-second thing true
-\else
-	\echo 'should not print #5-1'
-\endif
--- invalid boolean expressions are false
-\if invalid boolean expression
-unrecognized value "invalid boolean expression" for "\if expression": Boolean expected
-	\echo 'will not print #6-1'
-\else
-	\echo 'will print anyway #6-2'
-will print anyway #6-2
-\endif
--- test un-matched endif
-\endif
-\endif: no matching \if
--- test un-matched else
-\else
-\else: no matching \if
--- test un-matched elif
-\elif
-\elif: no matching \if
--- test double-else error
-\if true
-\else
-\else
-\else: cannot occur after \else
-\endif
--- test elif out-of-order
-\if false
-\else
-\elif
-\elif: cannot occur after \else
-\endif
--- test if-endif matching in a false branch
-\if false
-    \if false
-        \echo 'should not print #7-1'
-    \else
-        \echo 'should not print #7-2'
-    \endif
-    \echo 'should not print #7-3'
-\else
-    \echo 'should print #7-4'
-should print #7-4
-\endif
--- show that vars and backticks are not expanded when ignoring extra args
-\set foo bar
-\echo :foo :'foo' :"foo"
-bar 'bar' "bar"
-\pset fieldsep | `nosuchcommand` :foo :'foo' :"foo"
-\pset: extra argument "nosuchcommand" ignored
-\pset: extra argument ":foo" ignored
-\pset: extra argument ":'foo'" ignored
-\pset: extra argument ":"foo"" ignored
--- show that vars and backticks are not expanded and commands are ignored
--- when in a false if-branch
-\set try_to_quit '\\q'
-\if false
-	:try_to_quit
-	\echo `nosuchcommand` :foo :'foo' :"foo"
-	\pset fieldsep | `nosuchcommand` :foo :'foo' :"foo"
-	\a
-	\C arg1
-	\c arg1 arg2 arg3 arg4
-	\cd arg1
-	\conninfo
-	\copy arg1 arg2 arg3 arg4 arg5 arg6
-	\copyright
-	SELECT 1 as one, 2, 3 \crosstabview
-	\dt arg1
-	\e arg1 arg2
-	\ef whole_line
-	\ev whole_line
-	\echo arg1 arg2 arg3 arg4 arg5
-	\echo arg1
-	\encoding arg1
-	\errverbose
-	\f arg1
-	\g arg1
-	\gx arg1
-	\gexec
-	SELECT 1 AS one \gset
-	\h
-	\?
-	\html
-	\i arg1
-	\ir arg1
-	\l arg1
-	\lo arg1 arg2
-invalid command \lo
-	\lo_list
-	\o arg1
-	\p
-	\password arg1
-	\prompt arg1 arg2
-	\pset arg1 arg2
-	\q
-	\reset
-	\s arg1
-	\set arg1 arg2 arg3 arg4 arg5 arg6 arg7
-	\setenv arg1 arg2
-	\sf whole_line
-	\sv whole_line
-	\t arg1
-	\T arg1
-	\timing arg1
-	\unset arg1
-	\w arg1
-	\watch arg1
-	\x arg1
-	-- \else here is eaten as part of OT_FILEPIPE argument
-	\w |/no/such/file \else
-	-- \endif here is eaten as part of whole-line argument
-	\! whole_line \endif
-	\z
-\else
-	\echo 'should print #8-1'
-should print #8-1
-\endif
--- :{?...} defined variable test
-\set i 1
-\if :{?i}
-  \echo '#9-1 ok, variable i is defined'
-#9-1 ok, variable i is defined
-\else
-  \echo 'should not print #9-2'
-\endif
-\if :{?no_such_variable}
-  \echo 'should not print #10-1'
-\else
-  \echo '#10-2 ok, variable no_such_variable is not defined'
-#10-2 ok, variable no_such_variable is not defined
-\endif
-SELECT :{?i} AS i_is_defined;
- i_is_defined 
---------------
- t
-(1 row)
-
-SELECT NOT :{?no_such_var} AS no_such_var_is_not_defined;
- no_such_var_is_not_defined 
-----------------------------
- t
-(1 row)
-
--- SHOW_CONTEXT
-\set SHOW_CONTEXT never
-do $$
-begin
-  raise notice 'foo';
-  raise exception 'bar';
-end $$;
-NOTICE:  foo
-ERROR:  bar
-\set SHOW_CONTEXT errors
-do $$
-begin
-  raise notice 'foo';
-  raise exception 'bar';
-end $$;
-NOTICE:  foo
-ERROR:  bar
-CONTEXT:  PL/pgSQL function inline_code_block line 4 at RAISE
-\set SHOW_CONTEXT always
-do $$
-begin
-  raise notice 'foo';
-  raise exception 'bar';
-end $$;
-NOTICE:  foo
-CONTEXT:  PL/pgSQL function inline_code_block line 3 at RAISE
-ERROR:  bar
-CONTEXT:  PL/pgSQL function inline_code_block line 4 at RAISE
--- test printing and clearing the query buffer
-SELECT 1;
- ?column? 
-----------
-        1
-(1 row)
-
-\p
-SELECT 1;
-SELECT 2 \r
-\p
-SELECT 1;
-SELECT 3 \p
-SELECT 3 
-UNION SELECT 4 \p
-SELECT 3 
-UNION SELECT 4 
-UNION SELECT 5
-ORDER BY 1;
- ?column? 
-----------
-        3
-        4
-        5
-(3 rows)
-
-\r
-\p
-SELECT 3 
-UNION SELECT 4 
-UNION SELECT 5
-ORDER BY 1;
--- tests for special result variables
--- working query, 2 rows selected
-SELECT 1 AS stuff UNION SELECT 2;
- stuff 
--------
-     1
-     2
-(2 rows)
-
-\echo 'error:' :ERROR
-error: false
-\echo 'error code:' :SQLSTATE
-error code: 00000
-\echo 'number of rows:' :ROW_COUNT
-number of rows: 2
--- syntax error
-SELECT 1 UNION;
-ERROR:  syntax error at or near ";"
-LINE 1: SELECT 1 UNION;
-                      ^
-\echo 'error:' :ERROR
-error: true
-\echo 'error code:' :SQLSTATE
-error code: 42601
-\echo 'number of rows:' :ROW_COUNT
-number of rows: 0
-\echo 'last error message:' :LAST_ERROR_MESSAGE
-last error message: syntax error at or near ";"
-\echo 'last error code:' :LAST_ERROR_SQLSTATE
-last error code: 42601
--- empty query
-;
-\echo 'error:' :ERROR
-error: false
-\echo 'error code:' :SQLSTATE
-error code: 00000
-\echo 'number of rows:' :ROW_COUNT
-number of rows: 0
--- must have kept previous values
-\echo 'last error message:' :LAST_ERROR_MESSAGE
-last error message: syntax error at or near ";"
-\echo 'last error code:' :LAST_ERROR_SQLSTATE
-last error code: 42601
--- other query error
-DROP TABLE this_table_does_not_exist;
-ERROR:  table "this_table_does_not_exist" does not exist
-\echo 'error:' :ERROR
-error: true
-\echo 'error code:' :SQLSTATE
-error code: 42P01
-\echo 'number of rows:' :ROW_COUNT
-number of rows: 0
-\echo 'last error message:' :LAST_ERROR_MESSAGE
-last error message: table "this_table_does_not_exist" does not exist
-\echo 'last error code:' :LAST_ERROR_SQLSTATE
-last error code: 42P01
--- nondefault verbosity error settings (except verbose, which is too unstable)
-\set VERBOSITY terse
-SELECT 1 UNION;
-ERROR:  syntax error at or near ";" at character 15
-\echo 'error:' :ERROR
-error: true
-\echo 'error code:' :SQLSTATE
-error code: 42601
-\echo 'last error message:' :LAST_ERROR_MESSAGE
-last error message: syntax error at or near ";"
-\set VERBOSITY sqlstate
-SELECT 1/0;
-ERROR:  22012
-\echo 'error:' :ERROR
-error: true
-\echo 'error code:' :SQLSTATE
-error code: 22012
-\echo 'last error message:' :LAST_ERROR_MESSAGE
-last error message: division by zero
-\set VERBOSITY default
--- working \gdesc
-SELECT 3 AS three, 4 AS four \gdesc
- Column |  Type   
---------+---------
- three  | integer
- four   | integer
-(2 rows)
-
-\echo 'error:' :ERROR
-error: false
-\echo 'error code:' :SQLSTATE
-error code: 00000
-\echo 'number of rows:' :ROW_COUNT
-number of rows: 2
--- \gdesc with an error
-SELECT 4 AS \gdesc
-ERROR:  syntax error at end of input
-LINE 1: SELECT 4 AS 
-                    ^
-\echo 'error:' :ERROR
-error: true
-\echo 'error code:' :SQLSTATE
-error code: 42601
-\echo 'number of rows:' :ROW_COUNT
-number of rows: 0
-\echo 'last error message:' :LAST_ERROR_MESSAGE
-last error message: syntax error at end of input
-\echo 'last error code:' :LAST_ERROR_SQLSTATE
-last error code: 42601
--- check row count for a cursor-fetched query
-\set FETCH_COUNT 10
-select unique2 from tenk1 order by unique2 limit 19;
- unique2 
----------
-       0
-       1
-       2
-       3
-       4
-       5
-       6
-       7
-       8
-       9
-      10
-      11
-      12
-      13
-      14
-      15
-      16
-      17
-      18
-(19 rows)
-
-\echo 'error:' :ERROR
-error: false
-\echo 'error code:' :SQLSTATE
-error code: 00000
-\echo 'number of rows:' :ROW_COUNT
-number of rows: 19
--- cursor-fetched query with an error after the first group
-select 1/(15-unique2) from tenk1 order by unique2 limit 19;
- ?column? 
-----------
-        0
-        0
-        0
-        0
-        0
-        0
-        0
-        0
-        0
-        0
-ERROR:  division by zero
-\echo 'error:' :ERROR
-error: true
-\echo 'error code:' :SQLSTATE
-error code: 22012
-\echo 'number of rows:' :ROW_COUNT
-number of rows: 0
-\echo 'last error message:' :LAST_ERROR_MESSAGE
-last error message: division by zero
-\echo 'last error code:' :LAST_ERROR_SQLSTATE
-last error code: 22012
-\unset FETCH_COUNT
-create schema testpart;
-create role regress_partitioning_role;
-alter schema testpart owner to regress_partitioning_role;
-set role to regress_partitioning_role;
--- run test inside own schema and hide other partitions
-set search_path to testpart;
-create table testtable_apple(logdate date);
-create table testtable_orange(logdate date);
-create index testtable_apple_index on testtable_apple(logdate);
-create index testtable_orange_index on testtable_orange(logdate);
-create table testpart_apple(logdate date) partition by range(logdate);
-create table testpart_orange(logdate date) partition by range(logdate);
-create index testpart_apple_index on testpart_apple(logdate);
-create index testpart_orange_index on testpart_orange(logdate);
--- only partition related object should be displayed
-\dP test*apple*
-                                         List of partitioned relations
-  Schema  |         Name         |           Owner           |       Type        | Parent name |     Table      
-----------+----------------------+---------------------------+-------------------+-------------+----------------
- testpart | testpart_apple       | regress_partitioning_role | partitioned table |             | 
- testpart | testpart_apple_index | regress_partitioning_role | partitioned index |             | testpart_apple
-(2 rows)
-
-\dPt test*apple*
-                     List of partitioned tables
-  Schema  |      Name      |           Owner           | Parent name 
-----------+----------------+---------------------------+-------------
- testpart | testpart_apple | regress_partitioning_role | 
-(1 row)
-
-\dPi test*apple*
-                                List of partitioned indexes
-  Schema  |         Name         |           Owner           | Parent name |     Table      
-----------+----------------------+---------------------------+-------------+----------------
- testpart | testpart_apple_index | regress_partitioning_role |             | testpart_apple
-(1 row)
-
-drop table testtable_apple;
-drop table testtable_orange;
-drop table testpart_apple;
-drop table testpart_orange;
-create table parent_tab (id int) partition by range (id);
-create index parent_index on parent_tab (id);
-create table child_0_10 partition of parent_tab
-  for values from (0) to (10);
-create table child_10_20 partition of parent_tab
-  for values from (10) to (20);
-create table child_20_30 partition of parent_tab
-  for values from (20) to (30);
-insert into parent_tab values (generate_series(0,29));
-create table child_30_40 partition of parent_tab
-for values from (30) to (40)
-  partition by range(id);
-create table child_30_35 partition of child_30_40
-  for values from (30) to (35);
-create table child_35_40 partition of child_30_40
-   for values from (35) to (40);
-insert into parent_tab values (generate_series(30,39));
-\dPt
-            List of partitioned tables
-  Schema  |    Name    |           Owner           
-----------+------------+---------------------------
- testpart | parent_tab | regress_partitioning_role
-(1 row)
-
-\dPi
-                   List of partitioned indexes
-  Schema  |     Name     |           Owner           |   Table    
-----------+--------------+---------------------------+------------
- testpart | parent_index | regress_partitioning_role | parent_tab
-(1 row)
-
-\dP testpart.*
-                                       List of partitioned relations
-  Schema  |        Name        |           Owner           |       Type        | Parent name  |    Table    
-----------+--------------------+---------------------------+-------------------+--------------+-------------
- testpart | parent_tab         | regress_partitioning_role | partitioned table |              | 
- testpart | child_30_40        | regress_partitioning_role | partitioned table | parent_tab   | 
- testpart | parent_index       | regress_partitioning_role | partitioned index |              | parent_tab
- testpart | child_30_40_id_idx | regress_partitioning_role | partitioned index | parent_index | child_30_40
-(4 rows)
-
-\dP
-                            List of partitioned relations
-  Schema  |     Name     |           Owner           |       Type        |   Table    
-----------+--------------+---------------------------+-------------------+------------
- testpart | parent_tab   | regress_partitioning_role | partitioned table | 
- testpart | parent_index | regress_partitioning_role | partitioned index | parent_tab
-(2 rows)
-
-\dPtn
-                    List of partitioned tables
-  Schema  |    Name     |           Owner           | Parent name 
-----------+-------------+---------------------------+-------------
- testpart | parent_tab  | regress_partitioning_role | 
- testpart | child_30_40 | regress_partitioning_role | parent_tab
-(2 rows)
-
-\dPin
-                              List of partitioned indexes
-  Schema  |        Name        |           Owner           | Parent name  |    Table    
-----------+--------------------+---------------------------+--------------+-------------
- testpart | parent_index       | regress_partitioning_role |              | parent_tab
- testpart | child_30_40_id_idx | regress_partitioning_role | parent_index | child_30_40
-(2 rows)
-
-\dPn
-                                       List of partitioned relations
-  Schema  |        Name        |           Owner           |       Type        | Parent name  |    Table    
-----------+--------------------+---------------------------+-------------------+--------------+-------------
- testpart | parent_tab         | regress_partitioning_role | partitioned table |              | 
- testpart | child_30_40        | regress_partitioning_role | partitioned table | parent_tab   | 
- testpart | parent_index       | regress_partitioning_role | partitioned index |              | parent_tab
- testpart | child_30_40_id_idx | regress_partitioning_role | partitioned index | parent_index | child_30_40
-(4 rows)
-
-\dPn testpart.*
-                                       List of partitioned relations
-  Schema  |        Name        |           Owner           |       Type        | Parent name  |    Table    
-----------+--------------------+---------------------------+-------------------+--------------+-------------
- testpart | parent_tab         | regress_partitioning_role | partitioned table |              | 
- testpart | child_30_40        | regress_partitioning_role | partitioned table | parent_tab   | 
- testpart | parent_index       | regress_partitioning_role | partitioned index |              | parent_tab
- testpart | child_30_40_id_idx | regress_partitioning_role | partitioned index | parent_index | child_30_40
-(4 rows)
-
-drop table parent_tab cascade;
-drop schema testpart;
-set search_path to default;
-set role to default;
-drop role regress_partitioning_role;
--- \d on toast table (use pg_statistic's toast table, which has a known name)
-\d pg_toast.pg_toast_2619
-TOAST table "pg_toast.pg_toast_2619"
-   Column   |  Type   
-------------+---------
- chunk_id   | oid
- chunk_seq  | integer
- chunk_data | bytea
-Owning table: "pg_catalog.pg_statistic"
-Indexes:
-    "pg_toast_2619_index" PRIMARY KEY, btree (chunk_id, chunk_seq)
-
--- check printing info about access methods
-\dA
-List of access methods
-  Name  | Type  
---------+-------
- brin   | Index
- btree  | Index
- gin    | Index
- gist   | Index
- hash   | Index
- heap   | Table
- heap2  | Table
- spgist | Index
-(8 rows)
-
-\dA *
-List of access methods
-  Name  | Type  
---------+-------
- brin   | Index
- btree  | Index
- gin    | Index
- gist   | Index
- hash   | Index
- heap   | Table
- heap2  | Table
- spgist | Index
-(8 rows)
-
-\dA h*
-List of access methods
- Name  | Type  
--------+-------
- hash  | Index
- heap  | Table
- heap2 | Table
-(3 rows)
-
-\dA foo
-List of access methods
- Name | Type 
-------+------
-(0 rows)
-
-\dA foo bar
-List of access methods
- Name | Type 
-------+------
-(0 rows)
-
-\dA: extra argument "bar" ignored
-\dA+
-                             List of access methods
-  Name  | Type  |       Handler        |              Description               
---------+-------+----------------------+----------------------------------------
- brin   | Index | brinhandler          | block range index (BRIN) access method
- btree  | Index | bthandler            | b-tree index access method
- gin    | Index | ginhandler           | GIN index access method
- gist   | Index | gisthandler          | GiST index access method
- hash   | Index | hashhandler          | hash index access method
- heap   | Table | heap_tableam_handler | heap table access method
- heap2  | Table | heap_tableam_handler | 
- spgist | Index | spghandler           | SP-GiST index access method
-(8 rows)
-
-\dA+ *
-                             List of access methods
-  Name  | Type  |       Handler        |              Description               
---------+-------+----------------------+----------------------------------------
- brin   | Index | brinhandler          | block range index (BRIN) access method
- btree  | Index | bthandler            | b-tree index access method
- gin    | Index | ginhandler           | GIN index access method
- gist   | Index | gisthandler          | GiST index access method
- hash   | Index | hashhandler          | hash index access method
- heap   | Table | heap_tableam_handler | heap table access method
- heap2  | Table | heap_tableam_handler | 
- spgist | Index | spghandler           | SP-GiST index access method
-(8 rows)
-
-\dA+ h*
-                     List of access methods
- Name  | Type  |       Handler        |       Description        
--------+-------+----------------------+--------------------------
- hash  | Index | hashhandler          | hash index access method
- heap  | Table | heap_tableam_handler | heap table access method
- heap2 | Table | heap_tableam_handler | 
-(3 rows)
-
-\dA+ foo
-       List of access methods
- Name | Type | Handler | Description 
-------+------+---------+-------------
-(0 rows)
-
-\dAc brin pg*.oid*
-                      List of operator classes
-  AM  | Input type | Storage type |    Operator class    | Default? 
-------+------------+--------------+----------------------+----------
- brin | oid        |              | oid_bloom_ops        | no
- brin | oid        |              | oid_minmax_multi_ops | no
- brin | oid        |              | oid_minmax_ops       | yes
-(3 rows)
-
-\dAf spgist
-          List of operator families
-   AM   | Operator family | Applicable types 
---------+-----------------+------------------
- spgist | box_ops         | box
- spgist | kd_point_ops    | point
- spgist | network_ops     | inet
- spgist | poly_ops        | polygon
- spgist | quad_point_ops  | point
- spgist | range_ops       | anyrange
- spgist | text_ops        | text
-(7 rows)
-
-\dAf btree int4
-              List of operator families
-  AM   | Operator family |     Applicable types      
--------+-----------------+---------------------------
- btree | integer_ops     | smallint, integer, bigint
-(1 row)
-
-\dAo+ btree float_ops
-                                List of operators of operator families
-  AM   | Operator family |               Operator                | Strategy | Purpose | Sort opfamily 
--------+-----------------+---------------------------------------+----------+---------+---------------
- btree | float_ops       | <(double precision,double precision)  |        1 | search  | 
- btree | float_ops       | <=(double precision,double precision) |        2 | search  | 
- btree | float_ops       | =(double precision,double precision)  |        3 | search  | 
- btree | float_ops       | >=(double precision,double precision) |        4 | search  | 
- btree | float_ops       | >(double precision,double precision)  |        5 | search  | 
- btree | float_ops       | <(real,real)                          |        1 | search  | 
- btree | float_ops       | <=(real,real)                         |        2 | search  | 
- btree | float_ops       | =(real,real)                          |        3 | search  | 
- btree | float_ops       | >=(real,real)                         |        4 | search  | 
- btree | float_ops       | >(real,real)                          |        5 | search  | 
- btree | float_ops       | <(double precision,real)              |        1 | search  | 
- btree | float_ops       | <=(double precision,real)             |        2 | search  | 
- btree | float_ops       | =(double precision,real)              |        3 | search  | 
- btree | float_ops       | >=(double precision,real)             |        4 | search  | 
- btree | float_ops       | >(double precision,real)              |        5 | search  | 
- btree | float_ops       | <(real,double precision)              |        1 | search  | 
- btree | float_ops       | <=(real,double precision)             |        2 | search  | 
- btree | float_ops       | =(real,double precision)              |        3 | search  | 
- btree | float_ops       | >=(real,double precision)             |        4 | search  | 
- btree | float_ops       | >(real,double precision)              |        5 | search  | 
-(20 rows)
-
-\dAo * pg_catalog.jsonb_path_ops
-             List of operators of operator families
- AM  | Operator family |      Operator      | Strategy | Purpose 
------+-----------------+--------------------+----------+---------
- gin | jsonb_path_ops  | @>(jsonb,jsonb)    |        7 | search
- gin | jsonb_path_ops  | @?(jsonb,jsonpath) |       15 | search
- gin | jsonb_path_ops  | @@(jsonb,jsonpath) |       16 | search
-(3 rows)
-
-\dAp+ btree float_ops
-                                                         List of support functions of operator families
-  AM   | Operator family | Registered left type | Registered right type | Number |                                   Function                                   
--------+-----------------+----------------------+-----------------------+--------+------------------------------------------------------------------------------
- btree | float_ops       | double precision     | double precision      |      1 | btfloat8cmp(double precision,double precision)
- btree | float_ops       | double precision     | double precision      |      2 | btfloat8sortsupport(internal)
- btree | float_ops       | double precision     | double precision      |      3 | in_range(double precision,double precision,double precision,boolean,boolean)
- btree | float_ops       | real                 | real                  |      1 | btfloat4cmp(real,real)
- btree | float_ops       | real                 | real                  |      2 | btfloat4sortsupport(internal)
- btree | float_ops       | double precision     | real                  |      1 | btfloat84cmp(double precision,real)
- btree | float_ops       | real                 | double precision      |      1 | btfloat48cmp(real,double precision)
- btree | float_ops       | real                 | double precision      |      3 | in_range(real,real,double precision,boolean,boolean)
-(8 rows)
-
-\dAp * pg_catalog.uuid_ops
-                            List of support functions of operator families
-  AM   | Operator family | Registered left type | Registered right type | Number |      Function      
--------+-----------------+----------------------+-----------------------+--------+--------------------
- btree | uuid_ops        | uuid                 | uuid                  |      1 | uuid_cmp
- btree | uuid_ops        | uuid                 | uuid                  |      2 | uuid_sortsupport
- btree | uuid_ops        | uuid                 | uuid                  |      4 | btequalimage
- hash  | uuid_ops        | uuid                 | uuid                  |      1 | uuid_hash
- hash  | uuid_ops        | uuid                 | uuid                  |      2 | uuid_hash_extended
-(5 rows)
-
--- check \df, \do with argument specifications
-\df *sqrt
-                             List of functions
-   Schema   |     Name     | Result data type | Argument data types | Type 
-------------+--------------+------------------+---------------------+------
- pg_catalog | dsqrt        | double precision | double precision    | func
- pg_catalog | numeric_sqrt | numeric          | numeric             | func
- pg_catalog | sqrt         | double precision | double precision    | func
- pg_catalog | sqrt         | numeric          | numeric             | func
-(4 rows)
-
-\df *sqrt num*
-                             List of functions
-   Schema   |     Name     | Result data type | Argument data types | Type 
-------------+--------------+------------------+---------------------+------
- pg_catalog | numeric_sqrt | numeric          | numeric             | func
- pg_catalog | sqrt         | numeric          | numeric             | func
-(2 rows)
-
-\df int*pl
-                            List of functions
-   Schema   |    Name     | Result data type | Argument data types | Type 
-------------+-------------+------------------+---------------------+------
- pg_catalog | int24pl     | integer          | smallint, integer   | func
- pg_catalog | int28pl     | bigint           | smallint, bigint    | func
- pg_catalog | int2pl      | smallint         | smallint, smallint  | func
- pg_catalog | int42pl     | integer          | integer, smallint   | func
- pg_catalog | int48pl     | bigint           | integer, bigint     | func
- pg_catalog | int4pl      | integer          | integer, integer    | func
- pg_catalog | int82pl     | bigint           | bigint, smallint    | func
- pg_catalog | int84pl     | bigint           | bigint, integer     | func
- pg_catalog | int8pl      | bigint           | bigint, bigint      | func
- pg_catalog | interval_pl | interval         | interval, interval  | func
-(10 rows)
-
-\df int*pl int4
-                          List of functions
-   Schema   |  Name   | Result data type | Argument data types | Type 
-------------+---------+------------------+---------------------+------
- pg_catalog | int42pl | integer          | integer, smallint   | func
- pg_catalog | int48pl | bigint           | integer, bigint     | func
- pg_catalog | int4pl  | integer          | integer, integer    | func
-(3 rows)
-
-\df int*pl * pg_catalog.int8
-                          List of functions
-   Schema   |  Name   | Result data type | Argument data types | Type 
-------------+---------+------------------+---------------------+------
- pg_catalog | int28pl | bigint           | smallint, bigint    | func
- pg_catalog | int48pl | bigint           | integer, bigint     | func
- pg_catalog | int8pl  | bigint           | bigint, bigint      | func
-(3 rows)
-
-\df acl* aclitem[]
-                                                                    List of functions
-   Schema   |    Name     | Result data type |                                        Argument data types                                         | Type 
-------------+-------------+------------------+----------------------------------------------------------------------------------------------------+------
- pg_catalog | aclcontains | boolean          | aclitem[], aclitem                                                                                 | func
- pg_catalog | aclexplode  | SETOF record     | acl aclitem[], OUT grantor oid, OUT grantee oid, OUT privilege_type text, OUT is_grantable boolean | func
- pg_catalog | aclinsert   | aclitem[]        | aclitem[], aclitem                                                                                 | func
- pg_catalog | aclremove   | aclitem[]        | aclitem[], aclitem                                                                                 | func
-(4 rows)
-
-\df has_database_privilege oid text
-                                  List of functions
-   Schema   |          Name          | Result data type | Argument data types | Type 
-------------+------------------------+------------------+---------------------+------
- pg_catalog | has_database_privilege | boolean          | oid, text           | func
- pg_catalog | has_database_privilege | boolean          | oid, text, text     | func
-(2 rows)
-
-\df has_database_privilege oid text -
-                                  List of functions
-   Schema   |          Name          | Result data type | Argument data types | Type 
-------------+------------------------+------------------+---------------------+------
- pg_catalog | has_database_privilege | boolean          | oid, text           | func
-(1 row)
-
-\dfa bit* small*
-                          List of functions
-   Schema   |  Name   | Result data type | Argument data types | Type 
-------------+---------+------------------+---------------------+------
- pg_catalog | bit_and | smallint         | smallint            | agg
- pg_catalog | bit_or  | smallint         | smallint            | agg
- pg_catalog | bit_xor | smallint         | smallint            | agg
-(3 rows)
-
-\do - pg_catalog.int4
-                               List of operators
-   Schema   | Name | Left arg type | Right arg type | Result type | Description 
-------------+------+---------------+----------------+-------------+-------------
- pg_catalog | -    |               | integer        | integer     | negate
-(1 row)
-
-\do && anyarray *
-                               List of operators
-   Schema   | Name | Left arg type | Right arg type | Result type | Description 
-------------+------+---------------+----------------+-------------+-------------
- pg_catalog | &&   | anyarray      | anyarray       | boolean     | overlaps
-(1 row)
-
--- AUTOCOMMIT
-CREATE TABLE ac_test (a int);
-\set AUTOCOMMIT off
-INSERT INTO ac_test VALUES (1);
-COMMIT;
-SELECT * FROM ac_test;
- a 
----
- 1
-(1 row)
-
-COMMIT;
-INSERT INTO ac_test VALUES (2);
-ROLLBACK;
-SELECT * FROM ac_test;
- a 
----
- 1
-(1 row)
-
-COMMIT;
-BEGIN;
-INSERT INTO ac_test VALUES (3);
-COMMIT;
-SELECT * FROM ac_test;
- a 
----
- 1
- 3
-(2 rows)
-
-COMMIT;
-BEGIN;
-INSERT INTO ac_test VALUES (4);
-ROLLBACK;
-SELECT * FROM ac_test;
- a 
----
- 1
- 3
-(2 rows)
-
-COMMIT;
-\set AUTOCOMMIT on
-DROP TABLE ac_test;
-SELECT * FROM ac_test;  -- should be gone now
-ERROR:  relation "ac_test" does not exist
-LINE 1: SELECT * FROM ac_test;
-                      ^
--- ON_ERROR_ROLLBACK
-\set ON_ERROR_ROLLBACK on
-CREATE TABLE oer_test (a int);
-BEGIN;
-INSERT INTO oer_test VALUES (1);
-INSERT INTO oer_test VALUES ('foo');
-ERROR:  invalid input syntax for type integer: "foo"
-LINE 1: INSERT INTO oer_test VALUES ('foo');
-                                     ^
-INSERT INTO oer_test VALUES (3);
-COMMIT;
-SELECT * FROM oer_test;
- a 
----
- 1
- 3
-(2 rows)
-
-BEGIN;
-INSERT INTO oer_test VALUES (4);
-ROLLBACK;
-SELECT * FROM oer_test;
- a 
----
- 1
- 3
-(2 rows)
-
-BEGIN;
-INSERT INTO oer_test VALUES (5);
-COMMIT AND CHAIN;
-INSERT INTO oer_test VALUES (6);
-COMMIT;
-SELECT * FROM oer_test;
- a 
----
- 1
- 3
- 5
- 6
-(4 rows)
-
-DROP TABLE oer_test;
-\set ON_ERROR_ROLLBACK off
--- ECHO errors
-\set ECHO errors
-ERROR:  relation "notexists" does not exist
-LINE 1: SELECT * FROM notexists;
-                      ^
-STATEMENT:  SELECT * FROM notexists;
diff -U3 /Users/kenaniah/workspace/postgres/src/test/regress/expected/psql_crosstab.out /Users/kenaniah/workspace/postgres/src/test/regress/results/psql_crosstab.out
--- /Users/kenaniah/workspace/postgres/src/test/regress/expected/psql_crosstab.out	2021-10-03 17:41:49.000000000 -0700
+++ /Users/kenaniah/workspace/postgres/src/test/regress/results/psql_crosstab.out	2021-10-03 20:08:20.000000000 -0700
@@ -38,179 +38,11 @@
 SELECT v, to_char(d, 'Mon') AS "month name", EXTRACT(month FROM d) AS num,
  count(*) FROM ctv_data  GROUP BY 1,2,3 ORDER BY 1
  \crosstabview v "month name" 4 num
- v  | Jan | Apr | Jul | Dec 
-----+-----+-----+-----+-----
- v0 |     |     |   2 |   1
- v1 |     |   2 |   1 |    
- v2 |   1 |     |     |    
-(3 rows)
+dyld: lazy symbol binding failed: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
+
+dyld: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
 
--- ordered months in vertical header, ordered years in horizontal header
-SELECT EXTRACT(year FROM d) AS year, to_char(d,'Mon') AS """month"" name",
-  EXTRACT(month FROM d) AS month,
-  format('sum=%s avg=%s', sum(i), avg(i)::numeric(2,1))
-  FROM ctv_data
-  GROUP BY EXTRACT(year FROM d), to_char(d,'Mon'), EXTRACT(month FROM d)
-ORDER BY month
-\crosstabview """month"" name" year format year
- "month" name |      2014       |      2015      
---------------+-----------------+----------------
- Jan          |                 | sum=3 avg=3.0
- Apr          |                 | sum=10 avg=5.0
- Jul          | sum=5 avg=5.0   | sum=4 avg=4.0
- Dec          | sum=-3 avg=-3.0 | 
-(4 rows)
-
--- combine contents vertically into the same cell (V/H duplicates)
-SELECT v, h, string_agg(c, E'\n') FROM ctv_data GROUP BY v, h ORDER BY 1,2,3
- \crosstabview 1 2 3
- v  | h4  |     | h0  |  h2  | h1  
-----+-----+-----+-----+------+-----
- v0 | qux+| qux |     |      | 
-    | dbl |     |     |      | 
- v1 |     |     | baz | foo +| 
-    |     |     |     | quux | 
- v2 |     |     |     |      | bar
-(3 rows)
-
--- horizontal ASC order from window function
-SELECT v,h, string_agg(c, E'\n') AS c, row_number() OVER(ORDER BY h) AS r
-FROM ctv_data GROUP BY v, h ORDER BY 1,3,2
- \crosstabview v h c r
- v  | h0  | h1  |  h2  | h4  |     
-----+-----+-----+------+-----+-----
- v0 |     |     |      | qux+| qux
-    |     |     |      | dbl | 
- v1 | baz |     | foo +|     | 
-    |     |     | quux |     | 
- v2 |     | bar |      |     | 
-(3 rows)
-
--- horizontal DESC order from window function
-SELECT v, h, string_agg(c, E'\n') AS c, row_number() OVER(ORDER BY h DESC) AS r
-FROM ctv_data GROUP BY v, h ORDER BY 1,3,2
- \crosstabview v h c r
- v  |     | h4  |  h2  | h1  | h0  
-----+-----+-----+------+-----+-----
- v0 | qux | qux+|      |     | 
-    |     | dbl |      |     | 
- v1 |     |     | foo +|     | baz
-    |     |     | quux |     | 
- v2 |     |     |      | bar | 
-(3 rows)
-
--- horizontal ASC order from window function, NULLs pushed rightmost
-SELECT v,h, string_agg(c, E'\n') AS c, row_number() OVER(ORDER BY h NULLS LAST) AS r
-FROM ctv_data GROUP BY v, h ORDER BY 1,3,2
- \crosstabview v h c r
- v  | h0  | h1  |  h2  | h4  |     
-----+-----+-----+------+-----+-----
- v0 |     |     |      | qux+| qux
-    |     |     |      | dbl | 
- v1 | baz |     | foo +|     | 
-    |     |     | quux |     | 
- v2 |     | bar |      |     | 
-(3 rows)
-
--- only null, no column name, 2 columns: error
-SELECT null,null \crosstabview
-\crosstabview: query must return at least three columns
--- only null, no column name, 3 columns: works
-SELECT null,null,null \crosstabview
- ?column? |  
-----------+--
-          | 
-(1 row)
-
--- null display
-\pset null '#null#'
-SELECT v,h, string_agg(i::text, E'\n') AS i FROM ctv_data
-GROUP BY v, h ORDER BY h,v
- \crosstabview v h i
- v  |   h0   | h1 | h2 | h4 | #null# 
-----+--------+----+----+----+--------
- v1 | #null# |    | 3 +|    | 
-    |        |    | 7  |    | 
- v2 |        | 3  |    |    | 
- v0 |        |    |    | 4 +| 5
-    |        |    |    | -3 | 
-(3 rows)
-
-\pset null ''
--- refer to columns by position
-SELECT v,h,string_agg(i::text, E'\n'), string_agg(c, E'\n')
-FROM ctv_data GROUP BY v, h ORDER BY h,v
- \crosstabview 2 1 4
- h  |  v1  | v2  | v0  
-----+------+-----+-----
- h0 | baz  |     | 
- h1 |      | bar | 
- h2 | foo +|     | 
-    | quux |     | 
- h4 |      |     | qux+
-    |      |     | dbl
-    |      |     | qux
-(5 rows)
-
--- refer to columns by positions and names mixed
-SELECT v,h, string_agg(i::text, E'\n') AS i, string_agg(c, E'\n') AS c
-FROM ctv_data GROUP BY v, h ORDER BY h,v
- \crosstabview 1 "h" 4
- v  | h0  | h1  |  h2  | h4  |     
-----+-----+-----+------+-----+-----
- v1 | baz |     | foo +|     | 
-    |     |     | quux |     | 
- v2 |     | bar |      |     | 
- v0 |     |     |      | qux+| qux
-    |     |     |      | dbl | 
-(3 rows)
-
--- refer to columns by quoted names, check downcasing of unquoted name
-SELECT 1 as "22", 2 as b, 3 as "Foo"
- \crosstabview "22" B "Foo"
- 22 | 2 
-----+---
-  1 | 3
-(1 row)
-
--- error: bad column name
-SELECT v,h,c,i FROM ctv_data
- \crosstabview v h j
-\crosstabview: column name not found: "j"
--- error: need to quote name
-SELECT 1 as "22", 2 as b, 3 as "Foo"
- \crosstabview 1 2 Foo
-\crosstabview: column name not found: "foo"
--- error: need to not quote name
-SELECT 1 as "22", 2 as b, 3 as "Foo"
- \crosstabview 1 "B" "Foo"
-\crosstabview: column name not found: "B"
--- error: bad column number
-SELECT v,h,i,c FROM ctv_data
- \crosstabview 2 1 5
-\crosstabview: column number 5 is out of range 1..4
--- error: same H and V columns
-SELECT v,h,i,c FROM ctv_data
- \crosstabview 2 h 4
-\crosstabview: vertical and horizontal headers must be different columns
--- error: too many columns
-SELECT a,a,1 FROM generate_series(1,3000) AS a
- \crosstabview
-\crosstabview: maximum number of columns (1600) exceeded
--- error: only one column
-SELECT 1 \crosstabview
-\crosstabview: query must return at least three columns
-DROP TABLE ctv_data;
--- check error reporting (bug #14476)
-CREATE TABLE ctv_data (x int, y int, v text);
-INSERT INTO ctv_data SELECT 1, x, '*' || x FROM generate_series(1,10) x;
-SELECT * FROM ctv_data \crosstabview
- x | 1  | 2  | 3  | 4  | 5  | 6  | 7  | 8  | 9  | 10  
----+----+----+----+----+----+----+----+----+----+-----
- 1 | *1 | *2 | *3 | *4 | *5 | *6 | *7 | *8 | *9 | *10
-(1 row)
-
-INSERT INTO ctv_data VALUES (1, 10, '*'); -- duplicate data to cause error
-SELECT * FROM ctv_data \crosstabview
-\crosstabview: query result contains multiple data values for row "1", column "10"
-DROP TABLE ctv_data;
diff -U3 /Users/kenaniah/workspace/postgres/src/test/regress/expected/amutils.out /Users/kenaniah/workspace/postgres/src/test/regress/results/amutils.out
--- /Users/kenaniah/workspace/postgres/src/test/regress/expected/amutils.out	2021-10-03 17:41:49.000000000 -0700
+++ /Users/kenaniah/workspace/postgres/src/test/regress/results/amutils.out	2021-10-03 20:08:20.000000000 -0700
@@ -93,20 +93,9 @@
                     'bogus']::text[])
          with ordinality as u(prop,ord)
  order by ord;
-        prop        | btree | hash | gist | spgist_radix | spgist_quad | gin | brin 
---------------------+-------+------+------+--------------+-------------+-----+------
- asc                | t     | f    | f    | f            | f           | f   | f
- desc               | f     | f    | f    | f            | f           | f   | f
- nulls_first        | f     | f    | f    | f            | f           | f   | f
- nulls_last         | t     | f    | f    | f            | f           | f   | f
- orderable          | t     | f    | f    | f            | f           | f   | f
- distance_orderable | f     | f    | t    | f            | t           | f   | f
- returnable         | t     | f    | f    | t            | t           | f   | f
- search_array       | t     | f    | f    | f            | f           | f   | f
- search_nulls       | t     | f    | t    | t            | t           | f   | t
- bogus              |       |      |      |              |             |     | 
-(10 rows)
-
+ERROR:  relation "hash_i4_index" does not exist
+LINE 3:        pg_index_column_has_property('hash_i4_index'::regclas...
+                                            ^
 select prop,
        pg_index_has_property('onek_hundred'::regclass, prop) as btree,
        pg_index_has_property('hash_i4_index'::regclass, prop) as hash,
@@ -119,15 +108,9 @@
                     'bogus']::text[])
          with ordinality as u(prop,ord)
  order by ord;
-     prop      | btree | hash | gist | spgist | gin | brin 
----------------+-------+------+------+--------+-----+------
- clusterable   | t     | f    | t    | f      | f   | f
- index_scan    | t     | t    | t    | t      | f   | f
- bitmap_scan   | t     | t    | t    | t      | t   | t
- backward_scan | t     | t    | f    | f      | f   | f
- bogus         |       |      |      |        |     | 
-(5 rows)
-
+ERROR:  relation "hash_i4_index" does not exist
+LINE 3:        pg_index_has_property('hash_i4_index'::regclass, prop...
+                                     ^
 select amname, prop, pg_indexam_has_property(a.oid, prop) as p
   from pg_am a,
        unnest(array['can_order', 'can_unique', 'can_multi_col',
diff -U3 /Users/kenaniah/workspace/postgres/src/test/regress/expected/stats_ext.out /Users/kenaniah/workspace/postgres/src/test/regress/results/stats_ext.out
--- /Users/kenaniah/workspace/postgres/src/test/regress/expected/stats_ext.out	2021-10-03 18:09:17.000000000 -0700
+++ /Users/kenaniah/workspace/postgres/src/test/regress/results/stats_ext.out	2021-10-03 20:08:20.000000000 -0700
@@ -99,3075 +99,11 @@
 CREATE STATISTICS ab1_b_a_stats ON b, a FROM ab1;
 ALTER TABLE ab1 DROP COLUMN a;
 \d ab1
-                Table "public.ab1"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- b      | integer |           |          | 
- c      | integer |           |          | 
-Statistics objects:
-    "public.ab1_b_c_stats" ON b, c FROM ab1
+dyld: lazy symbol binding failed: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
+
+dyld: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
 
--- Ensure statistics are dropped when table is
-SELECT stxname FROM pg_statistic_ext WHERE stxname LIKE 'ab1%';
-    stxname    
----------------
- ab1_b_c_stats
-(1 row)
-
-DROP TABLE ab1;
-SELECT stxname FROM pg_statistic_ext WHERE stxname LIKE 'ab1%';
- stxname 
----------
-(0 rows)
-
--- Ensure things work sanely with SET STATISTICS 0
-CREATE TABLE ab1 (a INTEGER, b INTEGER);
-ALTER TABLE ab1 ALTER a SET STATISTICS 0;
-INSERT INTO ab1 SELECT a, a%23 FROM generate_series(1, 1000) a;
-CREATE STATISTICS ab1_a_b_stats ON a, b FROM ab1;
-ANALYZE ab1;
-WARNING:  statistics object "public.ab1_a_b_stats" could not be computed for relation "public.ab1"
-ALTER TABLE ab1 ALTER a SET STATISTICS -1;
--- setting statistics target 0 skips the statistics, without printing any message, so check catalog
-ALTER STATISTICS ab1_a_b_stats SET STATISTICS 0;
-\d ab1
-                Table "public.ab1"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
- b      | integer |           |          | 
-Statistics objects:
-    "public.ab1_a_b_stats" ON a, b FROM ab1; STATISTICS 0
-
-ANALYZE ab1;
-SELECT stxname, stxdndistinct, stxddependencies, stxdmcv
-  FROM pg_statistic_ext s, pg_statistic_ext_data d
- WHERE s.stxname = 'ab1_a_b_stats'
-   AND d.stxoid = s.oid;
-    stxname    | stxdndistinct | stxddependencies | stxdmcv 
----------------+---------------+------------------+---------
- ab1_a_b_stats |               |                  | 
-(1 row)
-
-ALTER STATISTICS ab1_a_b_stats SET STATISTICS -1;
-\d+ ab1
-                                    Table "public.ab1"
- Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
---------+---------+-----------+----------+---------+---------+--------------+-------------
- a      | integer |           |          |         | plain   |              | 
- b      | integer |           |          |         | plain   |              | 
-Statistics objects:
-    "public.ab1_a_b_stats" ON a, b FROM ab1
-
--- partial analyze doesn't build stats either
-ANALYZE ab1 (a);
-WARNING:  statistics object "public.ab1_a_b_stats" could not be computed for relation "public.ab1"
-ANALYZE ab1;
-DROP TABLE ab1;
-ALTER STATISTICS ab1_a_b_stats SET STATISTICS 0;
-ERROR:  statistics object "ab1_a_b_stats" does not exist
-ALTER STATISTICS IF EXISTS ab1_a_b_stats SET STATISTICS 0;
-NOTICE:  statistics object "ab1_a_b_stats" does not exist, skipping
--- Ensure we can build statistics for tables with inheritance.
-CREATE TABLE ab1 (a INTEGER, b INTEGER);
-CREATE TABLE ab1c () INHERITS (ab1);
-INSERT INTO ab1 VALUES (1,1);
-CREATE STATISTICS ab1_a_b_stats ON a, b FROM ab1;
-ANALYZE ab1;
-DROP TABLE ab1 CASCADE;
-NOTICE:  drop cascades to table ab1c
--- basic test for statistics on expressions
-CREATE TABLE ab1 (a INTEGER, b INTEGER, c TIMESTAMP, d TIMESTAMPTZ);
--- expression stats may be built on a single expression column
-CREATE STATISTICS ab1_exprstat_1 ON (a+b) FROM ab1;
--- with a single expression, we only enable expression statistics
-CREATE STATISTICS ab1_exprstat_2 ON (a+b) FROM ab1;
-SELECT stxkind FROM pg_statistic_ext WHERE stxname = 'ab1_exprstat_2';
- stxkind 
----------
- {e}
-(1 row)
-
--- adding anything to the expression builds all statistics kinds
-CREATE STATISTICS ab1_exprstat_3 ON (a+b), a FROM ab1;
-SELECT stxkind FROM pg_statistic_ext WHERE stxname = 'ab1_exprstat_3';
-  stxkind  
------------
- {d,f,m,e}
-(1 row)
-
--- date_trunc on timestamptz is not immutable, but that should not matter
-CREATE STATISTICS ab1_exprstat_4 ON date_trunc('day', d) FROM ab1;
--- date_trunc on timestamp is immutable
-CREATE STATISTICS ab1_exprstat_5 ON date_trunc('day', c) FROM ab1;
--- insert some data and run analyze, to test that these cases build properly
-INSERT INTO ab1
-SELECT
-    generate_series(1,10),
-    generate_series(1,10),
-    generate_series('2020-10-01'::timestamp, '2020-10-10'::timestamp, interval '1 day'),
-    generate_series('2020-10-01'::timestamptz, '2020-10-10'::timestamptz, interval '1 day');
-ANALYZE ab1;
-DROP TABLE ab1;
--- Verify supported object types for extended statistics
-CREATE schema tststats;
-CREATE TABLE tststats.t (a int, b int, c text);
-CREATE INDEX ti ON tststats.t (a, b);
-CREATE SEQUENCE tststats.s;
-CREATE VIEW tststats.v AS SELECT * FROM tststats.t;
-CREATE MATERIALIZED VIEW tststats.mv AS SELECT * FROM tststats.t;
-CREATE TYPE tststats.ty AS (a int, b int, c text);
-CREATE FOREIGN DATA WRAPPER extstats_dummy_fdw;
-CREATE SERVER extstats_dummy_srv FOREIGN DATA WRAPPER extstats_dummy_fdw;
-CREATE FOREIGN TABLE tststats.f (a int, b int, c text) SERVER extstats_dummy_srv;
-CREATE TABLE tststats.pt (a int, b int, c text) PARTITION BY RANGE (a, b);
-CREATE TABLE tststats.pt1 PARTITION OF tststats.pt FOR VALUES FROM (-10, -10) TO (10, 10);
-CREATE STATISTICS tststats.s1 ON a, b FROM tststats.t;
-CREATE STATISTICS tststats.s2 ON a, b FROM tststats.ti;
-ERROR:  cannot define statistics for relation "ti"
-DETAIL:  This operation is not supported for indexes.
-CREATE STATISTICS tststats.s3 ON a, b FROM tststats.s;
-ERROR:  cannot define statistics for relation "s"
-DETAIL:  This operation is not supported for sequences.
-CREATE STATISTICS tststats.s4 ON a, b FROM tststats.v;
-ERROR:  cannot define statistics for relation "v"
-DETAIL:  This operation is not supported for views.
-CREATE STATISTICS tststats.s5 ON a, b FROM tststats.mv;
-CREATE STATISTICS tststats.s6 ON a, b FROM tststats.ty;
-ERROR:  cannot define statistics for relation "ty"
-DETAIL:  This operation is not supported for composite types.
-CREATE STATISTICS tststats.s7 ON a, b FROM tststats.f;
-CREATE STATISTICS tststats.s8 ON a, b FROM tststats.pt;
-CREATE STATISTICS tststats.s9 ON a, b FROM tststats.pt1;
-DO $$
-DECLARE
-	relname text := reltoastrelid::regclass FROM pg_class WHERE oid = 'tststats.t'::regclass;
-BEGIN
-	EXECUTE 'CREATE STATISTICS tststats.s10 ON a, b FROM ' || relname;
-EXCEPTION WHEN wrong_object_type THEN
-	RAISE NOTICE 'stats on toast table not created';
-END;
-$$;
-NOTICE:  stats on toast table not created
-DROP SCHEMA tststats CASCADE;
-NOTICE:  drop cascades to 7 other objects
-DETAIL:  drop cascades to table tststats.t
-drop cascades to sequence tststats.s
-drop cascades to view tststats.v
-drop cascades to materialized view tststats.mv
-drop cascades to type tststats.ty
-drop cascades to foreign table tststats.f
-drop cascades to table tststats.pt
-DROP FOREIGN DATA WRAPPER extstats_dummy_fdw CASCADE;
-NOTICE:  drop cascades to server extstats_dummy_srv
--- n-distinct tests
-CREATE TABLE ndistinct (
-    filler1 TEXT,
-    filler2 NUMERIC,
-    a INT,
-    b INT,
-    filler3 DATE,
-    c INT,
-    d INT
-)
-WITH (autovacuum_enabled = off);
--- over-estimates when using only per-column statistics
-INSERT INTO ndistinct (a, b, c, filler1)
-     SELECT i/100, i/100, i/100, cash_words((i/100)::money)
-       FROM generate_series(1,1000) s(i);
-ANALYZE ndistinct;
--- Group Aggregate, due to over-estimate of the number of groups
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY a, b');
- estimated | actual 
------------+--------
-       100 |     11
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY b, c');
- estimated | actual 
------------+--------
-       100 |     11
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY a, b, c');
- estimated | actual 
------------+--------
-       100 |     11
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY a, b, c, d');
- estimated | actual 
------------+--------
-       200 |     11
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY b, c, d');
- estimated | actual 
------------+--------
-       200 |     11
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY a, b, (a+1)');
- estimated | actual 
------------+--------
-       100 |     11
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY (a+1), (b+100)');
- estimated | actual 
------------+--------
-       100 |     11
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY (a+1), (b+100), (2*c)');
- estimated | actual 
------------+--------
-       100 |     11
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY a, (a+1), (b+100)');
- estimated | actual 
------------+--------
-       100 |     11
-(1 row)
-
--- correct command
-CREATE STATISTICS s10 ON a, b, c FROM ndistinct;
-ANALYZE ndistinct;
-SELECT s.stxkind, d.stxdndistinct
-  FROM pg_statistic_ext s, pg_statistic_ext_data d
- WHERE s.stxrelid = 'ndistinct'::regclass
-   AND d.stxoid = s.oid;
- stxkind |                    stxdndistinct                    
----------+-----------------------------------------------------
- {d,f,m} | {"3, 4": 11, "3, 6": 11, "4, 6": 11, "3, 4, 6": 11}
-(1 row)
-
--- minor improvement, make sure the ctid does not break the matching
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY ctid, a, b');
- estimated | actual 
------------+--------
-      1000 |   1000
-(1 row)
-
--- Hash Aggregate, thanks to estimates improved by the statistic
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY a, b');
- estimated | actual 
------------+--------
-        11 |     11
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY b, c');
- estimated | actual 
------------+--------
-        11 |     11
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY a, b, c');
- estimated | actual 
------------+--------
-        11 |     11
-(1 row)
-
--- partial improvement (match on attributes)
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY a, b, (a+1)');
- estimated | actual 
------------+--------
-        11 |     11
-(1 row)
-
--- expressions - no improvement
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY (a+1), (b+100)');
- estimated | actual 
------------+--------
-        11 |     11
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY (a+1), (b+100), (2*c)');
- estimated | actual 
------------+--------
-        11 |     11
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY a, (a+1), (b+100)');
- estimated | actual 
------------+--------
-        11 |     11
-(1 row)
-
--- last two plans keep using Group Aggregate, because 'd' is not covered
--- by the statistic and while it's NULL-only we assume 200 values for it
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY a, b, c, d');
- estimated | actual 
------------+--------
-       200 |     11
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY b, c, d');
- estimated | actual 
------------+--------
-       200 |     11
-(1 row)
-
-TRUNCATE TABLE ndistinct;
--- under-estimates when using only per-column statistics
-INSERT INTO ndistinct (a, b, c, filler1)
-     SELECT mod(i,13), mod(i,17), mod(i,19),
-            cash_words(mod(i,23)::int::money)
-       FROM generate_series(1,1000) s(i);
-ANALYZE ndistinct;
-SELECT s.stxkind, d.stxdndistinct
-  FROM pg_statistic_ext s, pg_statistic_ext_data d
- WHERE s.stxrelid = 'ndistinct'::regclass
-   AND d.stxoid = s.oid;
- stxkind |                      stxdndistinct                       
----------+----------------------------------------------------------
- {d,f,m} | {"3, 4": 221, "3, 6": 247, "4, 6": 323, "3, 4, 6": 1000}
-(1 row)
-
--- correct estimates
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY a, b');
- estimated | actual 
------------+--------
-       221 |    221
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY a, b, c');
- estimated | actual 
------------+--------
-      1000 |   1000
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY a, b, c, d');
- estimated | actual 
------------+--------
-      1000 |   1000
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY b, c, d');
- estimated | actual 
------------+--------
-       323 |    323
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY a, d');
- estimated | actual 
------------+--------
-       200 |     13
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY a, b, (a+1)');
- estimated | actual 
------------+--------
-       221 |    221
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY (a+1), (b+100)');
- estimated | actual 
------------+--------
-       221 |    221
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY (a+1), (b+100), (2*c)');
- estimated | actual 
------------+--------
-      1000 |   1000
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY a, (a+1), (b+100)');
- estimated | actual 
------------+--------
-       221 |    221
-(1 row)
-
-DROP STATISTICS s10;
-SELECT s.stxkind, d.stxdndistinct
-  FROM pg_statistic_ext s, pg_statistic_ext_data d
- WHERE s.stxrelid = 'ndistinct'::regclass
-   AND d.stxoid = s.oid;
- stxkind | stxdndistinct 
----------+---------------
-(0 rows)
-
--- dropping the statistics results in under-estimates
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY a, b');
- estimated | actual 
------------+--------
-       100 |    221
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY a, b, c');
- estimated | actual 
------------+--------
-       100 |   1000
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY a, b, c, d');
- estimated | actual 
------------+--------
-       200 |   1000
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY b, c, d');
- estimated | actual 
------------+--------
-       200 |    323
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY a, d');
- estimated | actual 
------------+--------
-       200 |     13
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY a, b, (a+1)');
- estimated | actual 
------------+--------
-       100 |    221
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY (a+1), (b+100)');
- estimated | actual 
------------+--------
-       100 |    221
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY (a+1), (b+100), (2*c)');
- estimated | actual 
------------+--------
-       100 |   1000
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY a, (a+1), (b+100)');
- estimated | actual 
------------+--------
-       100 |    221
-(1 row)
-
--- ndistinct estimates with statistics on expressions
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY (a+1), (b+100)');
- estimated | actual 
------------+--------
-       100 |    221
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY (a+1), (b+100), (2*c)');
- estimated | actual 
------------+--------
-       100 |   1000
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY a, (a+1), (b+100)');
- estimated | actual 
------------+--------
-       100 |    221
-(1 row)
-
-CREATE STATISTICS s10 (ndistinct) ON (a+1), (b+100), (2*c) FROM ndistinct;
-ANALYZE ndistinct;
-SELECT s.stxkind, d.stxdndistinct
-  FROM pg_statistic_ext s, pg_statistic_ext_data d
- WHERE s.stxrelid = 'ndistinct'::regclass
-   AND d.stxoid = s.oid;
- stxkind |                           stxdndistinct                           
----------+-------------------------------------------------------------------
- {d,e}   | {"-1, -2": 221, "-1, -3": 247, "-2, -3": 323, "-1, -2, -3": 1000}
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY (a+1), (b+100)');
- estimated | actual 
------------+--------
-       221 |    221
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY (a+1), (b+100), (2*c)');
- estimated | actual 
------------+--------
-      1000 |   1000
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY a, (a+1), (b+100)');
- estimated | actual 
------------+--------
-       221 |    221
-(1 row)
-
-DROP STATISTICS s10;
--- a mix of attributes and expressions
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY a, b');
- estimated | actual 
------------+--------
-       100 |    221
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY a, (2*c)');
- estimated | actual 
------------+--------
-       100 |    247
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY a, b, (2*c)');
- estimated | actual 
------------+--------
-       100 |   1000
-(1 row)
-
-CREATE STATISTICS s10 (ndistinct) ON a, b, (2*c) FROM ndistinct;
-ANALYZE ndistinct;
-SELECT s.stxkind, d.stxdndistinct
-  FROM pg_statistic_ext s, pg_statistic_ext_data d
- WHERE s.stxrelid = 'ndistinct'::regclass
-   AND d.stxoid = s.oid;
- stxkind |                        stxdndistinct                        
----------+-------------------------------------------------------------
- {d,e}   | {"3, 4": 221, "3, -1": 247, "4, -1": 323, "3, 4, -1": 1000}
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY a, b');
- estimated | actual 
------------+--------
-       221 |    221
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY a, (2*c)');
- estimated | actual 
------------+--------
-       247 |    247
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY a, b, (2*c)');
- estimated | actual 
------------+--------
-      1000 |   1000
-(1 row)
-
-DROP STATISTICS s10;
--- combination of multiple ndistinct statistics, with/without expressions
-TRUNCATE ndistinct;
--- two mostly independent groups of columns
-INSERT INTO ndistinct (a, b, c, d)
-     SELECT mod(i,3), mod(i,9), mod(i,5), mod(i,20)
-       FROM generate_series(1,1000) s(i);
-ANALYZE ndistinct;
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY a, b');
- estimated | actual 
------------+--------
-        27 |      9
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY a, (b+1)');
- estimated | actual 
------------+--------
-        27 |      9
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY (a*5), b');
- estimated | actual 
------------+--------
-        27 |      9
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY (a*5), (b+1)');
- estimated | actual 
------------+--------
-        27 |      9
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY (a*5), (b+1), c');
- estimated | actual 
------------+--------
-       100 |     45
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY a, b, (c*10)');
- estimated | actual 
------------+--------
-       100 |     45
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY a, (b+1), c, (d - 1)');
- estimated | actual 
------------+--------
-       100 |    180
-(1 row)
-
--- basic statistics on both attributes (no expressions)
-CREATE STATISTICS s11 (ndistinct) ON a, b FROM ndistinct;
-CREATE STATISTICS s12 (ndistinct) ON c, d FROM ndistinct;
-ANALYZE ndistinct;
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY a, b');
- estimated | actual 
------------+--------
-         9 |      9
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY a, (b+1)');
- estimated | actual 
------------+--------
-         9 |      9
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY (a*5), b');
- estimated | actual 
------------+--------
-         9 |      9
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY (a*5), (b+1)');
- estimated | actual 
------------+--------
-         9 |      9
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY (a*5), (b+1), c');
- estimated | actual 
------------+--------
-        45 |     45
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY a, b, (c*10)');
- estimated | actual 
------------+--------
-        45 |     45
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY a, (b+1), c, (d - 1)');
- estimated | actual 
------------+--------
-       100 |    180
-(1 row)
-
--- replace the second statistics by statistics on expressions
-DROP STATISTICS s12;
-CREATE STATISTICS s12 (ndistinct) ON (c * 10), (d - 1) FROM ndistinct;
-ANALYZE ndistinct;
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY a, b');
- estimated | actual 
------------+--------
-         9 |      9
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY a, (b+1)');
- estimated | actual 
------------+--------
-         9 |      9
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY (a*5), b');
- estimated | actual 
------------+--------
-         9 |      9
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY (a*5), (b+1)');
- estimated | actual 
------------+--------
-         9 |      9
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY (a*5), (b+1), c');
- estimated | actual 
------------+--------
-        45 |     45
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY a, b, (c*10)');
- estimated | actual 
------------+--------
-        45 |     45
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY a, (b+1), c, (d - 1)');
- estimated | actual 
------------+--------
-       100 |    180
-(1 row)
-
--- replace the second statistics by statistics on both attributes and expressions
-DROP STATISTICS s12;
-CREATE STATISTICS s12 (ndistinct) ON c, d, (c * 10), (d - 1) FROM ndistinct;
-ANALYZE ndistinct;
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY a, b');
- estimated | actual 
------------+--------
-         9 |      9
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY a, (b+1)');
- estimated | actual 
------------+--------
-         9 |      9
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY (a*5), b');
- estimated | actual 
------------+--------
-         9 |      9
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY (a*5), (b+1)');
- estimated | actual 
------------+--------
-         9 |      9
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY (a*5), (b+1), c');
- estimated | actual 
------------+--------
-        45 |     45
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY a, b, (c*10)');
- estimated | actual 
------------+--------
-        45 |     45
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY a, (b+1), c, (d - 1)');
- estimated | actual 
------------+--------
-       100 |    180
-(1 row)
-
--- replace the other statistics by statistics on both attributes and expressions
-DROP STATISTICS s11;
-CREATE STATISTICS s11 (ndistinct) ON a, b, (a*5), (b+1) FROM ndistinct;
-ANALYZE ndistinct;
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY a, b');
- estimated | actual 
------------+--------
-         9 |      9
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY a, (b+1)');
- estimated | actual 
------------+--------
-         9 |      9
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY (a*5), b');
- estimated | actual 
------------+--------
-         9 |      9
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY (a*5), (b+1)');
- estimated | actual 
------------+--------
-         9 |      9
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY (a*5), (b+1), c');
- estimated | actual 
------------+--------
-        45 |     45
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY a, b, (c*10)');
- estimated | actual 
------------+--------
-        45 |     45
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY a, (b+1), c, (d - 1)');
- estimated | actual 
------------+--------
-       100 |    180
-(1 row)
-
--- replace statistics by somewhat overlapping ones (this expected to get worse estimate
--- because the first statistics shall be applied to 3 columns, and the second one can't
--- be really applied)
-DROP STATISTICS s11;
-DROP STATISTICS s12;
-CREATE STATISTICS s11 (ndistinct) ON a, b, (a*5), (b+1) FROM ndistinct;
-CREATE STATISTICS s12 (ndistinct) ON a, (b+1), (c * 10) FROM ndistinct;
-ANALYZE ndistinct;
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY a, b');
- estimated | actual 
------------+--------
-         9 |      9
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY a, (b+1)');
- estimated | actual 
------------+--------
-         9 |      9
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY (a*5), b');
- estimated | actual 
------------+--------
-         9 |      9
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY (a*5), (b+1)');
- estimated | actual 
------------+--------
-         9 |      9
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY (a*5), (b+1), c');
- estimated | actual 
------------+--------
-        45 |     45
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY a, b, (c*10)');
- estimated | actual 
------------+--------
-       100 |     45
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT COUNT(*) FROM ndistinct GROUP BY a, (b+1), c, (d - 1)');
- estimated | actual 
------------+--------
-       100 |    180
-(1 row)
-
-DROP STATISTICS s11;
-DROP STATISTICS s12;
--- functional dependencies tests
-CREATE TABLE functional_dependencies (
-    filler1 TEXT,
-    filler2 NUMERIC,
-    a INT,
-    b TEXT,
-    filler3 DATE,
-    c INT,
-    d TEXT
-)
-WITH (autovacuum_enabled = off);
-CREATE INDEX fdeps_ab_idx ON functional_dependencies (a, b);
-CREATE INDEX fdeps_abc_idx ON functional_dependencies (a, b, c);
--- random data (no functional dependencies)
-INSERT INTO functional_dependencies (a, b, c, filler1)
-     SELECT mod(i, 5), mod(i, 7), mod(i, 11), i FROM generate_series(1,1000) s(i);
-ANALYZE functional_dependencies;
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE a = 1 AND b = ''1''');
- estimated | actual 
------------+--------
-        29 |     29
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE a = 1 AND b = ''1'' AND c = 1');
- estimated | actual 
------------+--------
-         3 |      3
-(1 row)
-
--- create statistics
-CREATE STATISTICS func_deps_stat (dependencies) ON a, b, c FROM functional_dependencies;
-ANALYZE functional_dependencies;
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE a = 1 AND b = ''1''');
- estimated | actual 
------------+--------
-        29 |     29
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE a = 1 AND b = ''1'' AND c = 1');
- estimated | actual 
------------+--------
-         3 |      3
-(1 row)
-
--- a => b, a => c, b => c
-TRUNCATE functional_dependencies;
-DROP STATISTICS func_deps_stat;
--- now do the same thing, but with expressions
-INSERT INTO functional_dependencies (a, b, c, filler1)
-     SELECT i, i, i, i FROM generate_series(1,5000) s(i);
-ANALYZE functional_dependencies;
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE mod(a, 11) = 1 AND mod(b::int, 13) = 1');
- estimated | actual 
------------+--------
-         1 |     35
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE mod(a, 11) = 1 AND mod(b::int, 13) = 1 AND mod(c, 7) = 1');
- estimated | actual 
------------+--------
-         1 |      5
-(1 row)
-
--- create statistics
-CREATE STATISTICS func_deps_stat (dependencies) ON (mod(a,11)), (mod(b::int, 13)), (mod(c, 7)) FROM functional_dependencies;
-ANALYZE functional_dependencies;
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE mod(a, 11) = 1 AND mod(b::int, 13) = 1');
- estimated | actual 
------------+--------
-        35 |     35
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE mod(a, 11) = 1 AND mod(b::int, 13) = 1 AND mod(c, 7) = 1');
- estimated | actual 
------------+--------
-         5 |      5
-(1 row)
-
--- a => b, a => c, b => c
-TRUNCATE functional_dependencies;
-DROP STATISTICS func_deps_stat;
-INSERT INTO functional_dependencies (a, b, c, filler1)
-     SELECT mod(i,100), mod(i,50), mod(i,25), i FROM generate_series(1,5000) s(i);
-ANALYZE functional_dependencies;
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE a = 1 AND b = ''1''');
- estimated | actual 
------------+--------
-         1 |     50
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE a = 1 AND b = ''1'' AND c = 1');
- estimated | actual 
------------+--------
-         1 |     50
-(1 row)
-
--- IN
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE a IN (1, 51) AND b = ''1''');
- estimated | actual 
------------+--------
-         2 |    100
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE a IN (1, 51) AND b IN (''1'', ''2'')');
- estimated | actual 
------------+--------
-         4 |    100
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE a IN (1, 2, 51, 52) AND b IN (''1'', ''2'')');
- estimated | actual 
------------+--------
-         8 |    200
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE a IN (1, 2, 51, 52) AND b = ''1''');
- estimated | actual 
------------+--------
-         4 |    100
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE a IN (1, 26, 51, 76) AND b IN (''1'', ''26'') AND c = 1');
- estimated | actual 
------------+--------
-         1 |    200
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE a IN (1, 26, 51, 76) AND b IN (''1'', ''26'') AND c IN (1)');
- estimated | actual 
------------+--------
-         1 |    200
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE a IN (1, 2, 26, 27, 51, 52, 76, 77) AND b IN (''1'', ''2'', ''26'', ''27'') AND c IN (1, 2)');
- estimated | actual 
------------+--------
-         3 |    400
-(1 row)
-
--- OR clauses referencing the same attribute
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE (a = 1 OR a = 51) AND b = ''1''');
- estimated | actual 
------------+--------
-         2 |    100
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE (a = 1 OR a = 51) AND (b = ''1'' OR b = ''2'')');
- estimated | actual 
------------+--------
-         4 |    100
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE (a = 1 OR a = 2 OR a = 51 OR a = 52) AND (b = ''1'' OR b = ''2'')');
- estimated | actual 
------------+--------
-         8 |    200
-(1 row)
-
--- OR clauses referencing different attributes
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE (a = 1 OR b = ''1'') AND b = ''1''');
- estimated | actual 
------------+--------
-         3 |    100
-(1 row)
-
--- ANY
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE a = ANY (ARRAY[1, 51]) AND b = ''1''');
- estimated | actual 
------------+--------
-         2 |    100
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE a = ANY (ARRAY[1, 51]) AND b = ANY (ARRAY[''1'', ''2''])');
- estimated | actual 
------------+--------
-         4 |    100
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE a = ANY (ARRAY[1, 2, 51, 52]) AND b = ANY (ARRAY[''1'', ''2''])');
- estimated | actual 
------------+--------
-         8 |    200
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE a = ANY (ARRAY[1, 26, 51, 76]) AND b = ANY (ARRAY[''1'', ''26'']) AND c = 1');
- estimated | actual 
------------+--------
-         1 |    200
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE a = ANY (ARRAY[1, 26, 51, 76]) AND b = ANY (ARRAY[''1'', ''26'']) AND c = ANY (ARRAY[1])');
- estimated | actual 
------------+--------
-         1 |    200
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE a = ANY (ARRAY[1, 2, 26, 27, 51, 52, 76, 77]) AND b = ANY (ARRAY[''1'', ''2'', ''26'', ''27'']) AND c = ANY (ARRAY[1, 2])');
- estimated | actual 
------------+--------
-         3 |    400
-(1 row)
-
--- ANY with inequalities should not benefit from functional dependencies
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE a < ANY (ARRAY[1, 51]) AND b > ''1''');
- estimated | actual 
------------+--------
-      2472 |   2400
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE a >= ANY (ARRAY[1, 51]) AND b <= ANY (ARRAY[''1'', ''2''])');
- estimated | actual 
------------+--------
-      1441 |   1250
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE a <= ANY (ARRAY[1, 2, 51, 52]) AND b >= ANY (ARRAY[''1'', ''2''])');
- estimated | actual 
------------+--------
-      3909 |   2550
-(1 row)
-
--- ALL (should not benefit from functional dependencies)
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE a IN (1, 51) AND b = ALL (ARRAY[''1''])');
- estimated | actual 
------------+--------
-         2 |    100
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE a IN (1, 51) AND b = ALL (ARRAY[''1'', ''2''])');
- estimated | actual 
------------+--------
-         1 |      0
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE a IN (1, 2, 51, 52) AND b = ALL (ARRAY[''1'', ''2''])');
- estimated | actual 
------------+--------
-         1 |      0
-(1 row)
-
--- create statistics
-CREATE STATISTICS func_deps_stat (dependencies) ON a, b, c FROM functional_dependencies;
-ANALYZE functional_dependencies;
--- print the detected dependencies
-SELECT dependencies FROM pg_stats_ext WHERE statistics_name = 'func_deps_stat';
-                                                dependencies                                                
-------------------------------------------------------------------------------------------------------------
- {"3 => 4": 1.000000, "3 => 6": 1.000000, "4 => 6": 1.000000, "3, 4 => 6": 1.000000, "3, 6 => 4": 1.000000}
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE a = 1 AND b = ''1''');
- estimated | actual 
------------+--------
-        50 |     50
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE a = 1 AND b = ''1'' AND c = 1');
- estimated | actual 
------------+--------
-        50 |     50
-(1 row)
-
--- IN
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE a IN (1, 51) AND b = ''1''');
- estimated | actual 
------------+--------
-       100 |    100
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE a IN (1, 51) AND b IN (''1'', ''2'')');
- estimated | actual 
------------+--------
-       100 |    100
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE a IN (1, 2, 51, 52) AND b IN (''1'', ''2'')');
- estimated | actual 
------------+--------
-       200 |    200
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE a IN (1, 2, 51, 52) AND b = ''1''');
- estimated | actual 
------------+--------
-       100 |    100
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE a IN (1, 26, 51, 76) AND b IN (''1'', ''26'') AND c = 1');
- estimated | actual 
------------+--------
-       200 |    200
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE a IN (1, 26, 51, 76) AND b IN (''1'', ''26'') AND c IN (1)');
- estimated | actual 
------------+--------
-       200 |    200
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE a IN (1, 2, 26, 27, 51, 52, 76, 77) AND b IN (''1'', ''2'', ''26'', ''27'') AND c IN (1, 2)');
- estimated | actual 
------------+--------
-       400 |    400
-(1 row)
-
--- OR clauses referencing the same attribute
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE (a = 1 OR a = 51) AND b = ''1''');
- estimated | actual 
------------+--------
-        99 |    100
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE (a = 1 OR a = 51) AND (b = ''1'' OR b = ''2'')');
- estimated | actual 
------------+--------
-        99 |    100
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE (a = 1 OR a = 2 OR a = 51 OR a = 52) AND (b = ''1'' OR b = ''2'')');
- estimated | actual 
------------+--------
-       197 |    200
-(1 row)
-
--- OR clauses referencing different attributes are incompatible
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE (a = 1 OR b = ''1'') AND b = ''1''');
- estimated | actual 
------------+--------
-         3 |    100
-(1 row)
-
--- ANY
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE a = ANY (ARRAY[1, 51]) AND b = ''1''');
- estimated | actual 
------------+--------
-       100 |    100
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE a = ANY (ARRAY[1, 51]) AND b = ANY (ARRAY[''1'', ''2''])');
- estimated | actual 
------------+--------
-       100 |    100
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE a = ANY (ARRAY[1, 2, 51, 52]) AND b = ANY (ARRAY[''1'', ''2''])');
- estimated | actual 
------------+--------
-       200 |    200
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE a = ANY (ARRAY[1, 26, 51, 76]) AND b = ANY (ARRAY[''1'', ''26'']) AND c = 1');
- estimated | actual 
------------+--------
-       200 |    200
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE a = ANY (ARRAY[1, 26, 51, 76]) AND b = ANY (ARRAY[''1'', ''26'']) AND c = ANY (ARRAY[1])');
- estimated | actual 
------------+--------
-       200 |    200
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE a = ANY (ARRAY[1, 2, 26, 27, 51, 52, 76, 77]) AND b = ANY (ARRAY[''1'', ''2'', ''26'', ''27'']) AND c = ANY (ARRAY[1, 2])');
- estimated | actual 
------------+--------
-       400 |    400
-(1 row)
-
--- ANY with inequalities should not benefit from functional dependencies
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE a < ANY (ARRAY[1, 51]) AND b > ''1''');
- estimated | actual 
------------+--------
-      2472 |   2400
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE a >= ANY (ARRAY[1, 51]) AND b <= ANY (ARRAY[''1'', ''2''])');
- estimated | actual 
------------+--------
-      1441 |   1250
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE a <= ANY (ARRAY[1, 2, 51, 52]) AND b >= ANY (ARRAY[''1'', ''2''])');
- estimated | actual 
------------+--------
-      3909 |   2550
-(1 row)
-
--- ALL (should not benefit from functional dependencies)
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE a IN (1, 51) AND b = ALL (ARRAY[''1''])');
- estimated | actual 
------------+--------
-         2 |    100
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE a IN (1, 51) AND b = ALL (ARRAY[''1'', ''2''])');
- estimated | actual 
------------+--------
-         1 |      0
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE a IN (1, 2, 51, 52) AND b = ALL (ARRAY[''1'', ''2''])');
- estimated | actual 
------------+--------
-         1 |      0
-(1 row)
-
--- changing the type of column c causes all its stats to be dropped, reverting
--- to default estimates without any statistics, i.e. 0.5% selectivity for each
--- condition
-ALTER TABLE functional_dependencies ALTER COLUMN c TYPE numeric;
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE a = 1 AND b = ''1'' AND c = 1');
- estimated | actual 
------------+--------
-         1 |     50
-(1 row)
-
-ANALYZE functional_dependencies;
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE a = 1 AND b = ''1'' AND c = 1');
- estimated | actual 
------------+--------
-        50 |     50
-(1 row)
-
-DROP STATISTICS func_deps_stat;
--- now try functional dependencies with expressions
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE (a * 2) = 2 AND upper(b) = ''1''');
- estimated | actual 
------------+--------
-         1 |     50
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE (a * 2) = 2 AND upper(b) = ''1'' AND (c + 1) = 2');
- estimated | actual 
------------+--------
-         1 |     50
-(1 row)
-
--- IN
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE (a * 2) IN (2, 102) AND upper(b) = ''1''');
- estimated | actual 
------------+--------
-         1 |    100
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE (a * 2) IN (2, 102) AND upper(b) IN (''1'', ''2'')');
- estimated | actual 
------------+--------
-         1 |    100
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE (a * 2) IN (2, 4, 102, 104) AND upper(b) IN (''1'', ''2'')');
- estimated | actual 
------------+--------
-         1 |    200
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE (a * 2) IN (2, 4, 102, 104) AND upper(b) = ''1''');
- estimated | actual 
------------+--------
-         1 |    100
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE (a * 2) IN (2, 52, 102, 152) AND upper(b) IN (''1'', ''26'') AND (c + 1) = 2');
- estimated | actual 
------------+--------
-         1 |    200
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE (a * 2) IN (2, 52, 102, 152) AND upper(b) IN (''1'', ''26'') AND (c + 1) IN (2)');
- estimated | actual 
------------+--------
-         1 |    200
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE (a * 2) IN (2, 4, 52, 54, 102, 104, 152, 154) AND upper(b) IN (''1'', ''2'', ''26'', ''27'') AND (c + 1) IN (2, 3)');
- estimated | actual 
------------+--------
-         1 |    400
-(1 row)
-
--- OR clauses referencing the same attribute
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE ((a * 2) = 2 OR (a * 2) = 102) AND upper(b) = ''1''');
- estimated | actual 
------------+--------
-         1 |    100
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE ((a * 2) = 2 OR (a * 2) = 102) AND (upper(b) = ''1'' OR upper(b) = ''2'')');
- estimated | actual 
------------+--------
-         1 |    100
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE ((a * 2) = 2 OR (a * 2) = 4 OR (a * 2) = 102 OR (a * 2) = 104) AND (upper(b) = ''1'' OR upper(b) = ''2'')');
- estimated | actual 
------------+--------
-         1 |    200
-(1 row)
-
--- OR clauses referencing different attributes
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE ((a * 2) = 2 OR upper(b) = ''1'') AND upper(b) = ''1''');
- estimated | actual 
------------+--------
-         1 |    100
-(1 row)
-
--- ANY
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE (a * 2) = ANY (ARRAY[2, 102]) AND upper(b) = ''1''');
- estimated | actual 
------------+--------
-         1 |    100
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE (a * 2) = ANY (ARRAY[2, 102]) AND upper(b) = ANY (ARRAY[''1'', ''2''])');
- estimated | actual 
------------+--------
-         1 |    100
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE (a * 2) = ANY (ARRAY[2, 4, 102, 104]) AND upper(b) = ANY (ARRAY[''1'', ''2''])');
- estimated | actual 
------------+--------
-         1 |    200
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE (a * 2) = ANY (ARRAY[2, 52, 102, 152]) AND upper(b) = ANY (ARRAY[''1'', ''26'']) AND (c + 1) = 2');
- estimated | actual 
------------+--------
-         1 |    200
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE (a * 2) = ANY (ARRAY[2, 52, 102, 152]) AND upper(b) = ANY (ARRAY[''1'', ''26'']) AND (c + 1) = ANY (ARRAY[2])');
- estimated | actual 
------------+--------
-         1 |    200
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE (a * 2) = ANY (ARRAY[2, 4, 52, 54, 102, 104, 152, 154]) AND upper(b) = ANY (ARRAY[''1'', ''2'', ''26'', ''27'']) AND (c + 1) = ANY (ARRAY[2, 3])');
- estimated | actual 
------------+--------
-         1 |    400
-(1 row)
-
--- ANY with inequalities should not benefit from functional dependencies
--- the estimates however improve thanks to having expression statistics
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE (a * 2) < ANY (ARRAY[2, 102]) AND upper(b) > ''1''');
- estimated | actual 
------------+--------
-       926 |   2400
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE (a * 2) >= ANY (ARRAY[2, 102]) AND upper(b) <= ANY (ARRAY[''1'', ''2''])');
- estimated | actual 
------------+--------
-      1543 |   1250
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE (a * 2) <= ANY (ARRAY[2, 4, 102, 104]) AND upper(b) >= ANY (ARRAY[''1'', ''2''])');
- estimated | actual 
------------+--------
-      2229 |   2550
-(1 row)
-
--- ALL (should not benefit from functional dependencies)
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE (a * 2) IN (2, 102) AND upper(b) = ALL (ARRAY[''1''])');
- estimated | actual 
------------+--------
-         1 |    100
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE (a * 2) IN (2, 102) AND upper(b) = ALL (ARRAY[''1'', ''2''])');
- estimated | actual 
------------+--------
-         1 |      0
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE (a * 2) IN (2, 4, 102, 104) AND upper(b) = ALL (ARRAY[''1'', ''2''])');
- estimated | actual 
------------+--------
-         1 |      0
-(1 row)
-
--- create statistics on expressions
-CREATE STATISTICS func_deps_stat (dependencies) ON (a * 2), upper(b), (c + 1) FROM functional_dependencies;
-ANALYZE functional_dependencies;
--- print the detected dependencies
-SELECT dependencies FROM pg_stats_ext WHERE statistics_name = 'func_deps_stat';
-                                                      dependencies                                                      
-------------------------------------------------------------------------------------------------------------------------
- {"-1 => -2": 1.000000, "-1 => -3": 1.000000, "-2 => -3": 1.000000, "-1, -2 => -3": 1.000000, "-1, -3 => -2": 1.000000}
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE (a * 2) = 2 AND upper(b) = ''1''');
- estimated | actual 
------------+--------
-        50 |     50
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE (a * 2) = 2 AND upper(b) = ''1'' AND (c + 1) = 2');
- estimated | actual 
------------+--------
-        50 |     50
-(1 row)
-
--- IN
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE (a * 2) IN (2, 102) AND upper(b) = ''1''');
- estimated | actual 
------------+--------
-       100 |    100
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE (a * 2) IN (2, 102) AND upper(b) IN (''1'', ''2'')');
- estimated | actual 
------------+--------
-       100 |    100
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE (a * 2) IN (2, 4, 102, 104) AND upper(b) IN (''1'', ''2'')');
- estimated | actual 
------------+--------
-       200 |    200
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE (a * 2) IN (2, 4, 102, 104) AND upper(b) = ''1''');
- estimated | actual 
------------+--------
-       100 |    100
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE (a * 2) IN (2, 52, 102, 152) AND upper(b) IN (''1'', ''26'') AND (c + 1) = 2');
- estimated | actual 
------------+--------
-       200 |    200
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE (a * 2) IN (2, 52, 102, 152) AND upper(b) IN (''1'', ''26'') AND (c + 1) IN (2)');
- estimated | actual 
------------+--------
-       200 |    200
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE (a * 2) IN (2, 4, 52, 54, 102, 104, 152, 154) AND upper(b) IN (''1'', ''2'', ''26'', ''27'') AND (c + 1) IN (2, 3)');
- estimated | actual 
------------+--------
-       400 |    400
-(1 row)
-
--- OR clauses referencing the same attribute
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE ((a * 2) = 2 OR (a * 2) = 102) AND upper(b) = ''1''');
- estimated | actual 
------------+--------
-        99 |    100
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE ((a * 2) = 2 OR (a * 2) = 102) AND (upper(b) = ''1'' OR upper(b) = ''2'')');
- estimated | actual 
------------+--------
-        99 |    100
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE ((a * 2) = 2 OR (a * 2) = 4 OR (a * 2) = 102 OR (a * 2) = 104) AND (upper(b) = ''1'' OR upper(b) = ''2'')');
- estimated | actual 
------------+--------
-       197 |    200
-(1 row)
-
--- OR clauses referencing different attributes
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE ((a * 2) = 2 OR upper(b) = ''1'') AND upper(b) = ''1''');
- estimated | actual 
------------+--------
-         3 |    100
-(1 row)
-
--- ANY
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE (a * 2) = ANY (ARRAY[2, 102]) AND upper(b) = ''1''');
- estimated | actual 
------------+--------
-       100 |    100
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE (a * 2) = ANY (ARRAY[2, 102]) AND upper(b) = ANY (ARRAY[''1'', ''2''])');
- estimated | actual 
------------+--------
-       100 |    100
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE (a * 2) = ANY (ARRAY[2, 4, 102, 104]) AND upper(b) = ANY (ARRAY[''1'', ''2''])');
- estimated | actual 
------------+--------
-       200 |    200
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE (a * 2) = ANY (ARRAY[2, 52, 102, 152]) AND upper(b) = ANY (ARRAY[''1'', ''26'']) AND (c + 1) = 2');
- estimated | actual 
------------+--------
-       200 |    200
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE (a * 2) = ANY (ARRAY[2, 52, 102, 152]) AND upper(b) = ANY (ARRAY[''1'', ''26'']) AND (c + 1) = ANY (ARRAY[2])');
- estimated | actual 
------------+--------
-       200 |    200
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE (a * 2) = ANY (ARRAY[2, 4, 52, 54, 102, 104, 152, 154]) AND upper(b) = ANY (ARRAY[''1'', ''2'', ''26'', ''27'']) AND (c + 1) = ANY (ARRAY[2, 3])');
- estimated | actual 
------------+--------
-       400 |    400
-(1 row)
-
--- ANY with inequalities should not benefit from functional dependencies
--- the estimates however improve thanks to having expression statistics
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE (a * 2) < ANY (ARRAY[2, 102]) AND upper(b) > ''1''');
- estimated | actual 
------------+--------
-      2472 |   2400
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE (a * 2) >= ANY (ARRAY[2, 102]) AND upper(b) <= ANY (ARRAY[''1'', ''2''])');
- estimated | actual 
------------+--------
-      1441 |   1250
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE (a * 2) <= ANY (ARRAY[2, 4, 102, 104]) AND upper(b) >= ANY (ARRAY[''1'', ''2''])');
- estimated | actual 
------------+--------
-      3909 |   2550
-(1 row)
-
--- ALL (should not benefit from functional dependencies)
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE (a * 2) IN (2, 102) AND upper(b) = ALL (ARRAY[''1''])');
- estimated | actual 
------------+--------
-         2 |    100
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE (a * 2) IN (2, 102) AND upper(b) = ALL (ARRAY[''1'', ''2''])');
- estimated | actual 
------------+--------
-         1 |      0
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies WHERE (a * 2) IN (2, 4, 102, 104) AND upper(b) = ALL (ARRAY[''1'', ''2''])');
- estimated | actual 
------------+--------
-         1 |      0
-(1 row)
-
--- check the ability to use multiple functional dependencies
-CREATE TABLE functional_dependencies_multi (
-	a INTEGER,
-	b INTEGER,
-	c INTEGER,
-	d INTEGER
-)
-WITH (autovacuum_enabled = off);
-INSERT INTO functional_dependencies_multi (a, b, c, d)
-    SELECT
-         mod(i,7),
-         mod(i,7),
-         mod(i,11),
-         mod(i,11)
-    FROM generate_series(1,5000) s(i);
-ANALYZE functional_dependencies_multi;
--- estimates without any functional dependencies
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies_multi WHERE a = 0 AND b = 0');
- estimated | actual 
------------+--------
-       102 |    714
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies_multi WHERE 0 = a AND 0 = b');
- estimated | actual 
------------+--------
-       102 |    714
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies_multi WHERE c = 0 AND d = 0');
- estimated | actual 
------------+--------
-        41 |    454
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies_multi WHERE a = 0 AND b = 0 AND c = 0 AND d = 0');
- estimated | actual 
------------+--------
-         1 |     64
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies_multi WHERE 0 = a AND b = 0 AND 0 = c AND d = 0');
- estimated | actual 
------------+--------
-         1 |     64
-(1 row)
-
--- create separate functional dependencies
-CREATE STATISTICS functional_dependencies_multi_1 (dependencies) ON a, b FROM functional_dependencies_multi;
-CREATE STATISTICS functional_dependencies_multi_2 (dependencies) ON c, d FROM functional_dependencies_multi;
-ANALYZE functional_dependencies_multi;
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies_multi WHERE a = 0 AND b = 0');
- estimated | actual 
------------+--------
-       714 |    714
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies_multi WHERE 0 = a AND 0 = b');
- estimated | actual 
------------+--------
-       714 |    714
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies_multi WHERE c = 0 AND d = 0');
- estimated | actual 
------------+--------
-       454 |    454
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies_multi WHERE a = 0 AND b = 0 AND c = 0 AND d = 0');
- estimated | actual 
------------+--------
-        65 |     64
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM functional_dependencies_multi WHERE 0 = a AND b = 0 AND 0 = c AND d = 0');
- estimated | actual 
------------+--------
-        65 |     64
-(1 row)
-
-DROP TABLE functional_dependencies_multi;
--- MCV lists
-CREATE TABLE mcv_lists (
-    filler1 TEXT,
-    filler2 NUMERIC,
-    a INT,
-    b VARCHAR,
-    filler3 DATE,
-    c INT,
-    d TEXT
-)
-WITH (autovacuum_enabled = off);
--- random data (no MCV list)
-INSERT INTO mcv_lists (a, b, c, filler1)
-     SELECT mod(i,37), mod(i,41), mod(i,43), mod(i,47) FROM generate_series(1,5000) s(i);
-ANALYZE mcv_lists;
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE a = 1 AND b = ''1''');
- estimated | actual 
------------+--------
-         3 |      4
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE a = 1 AND b = ''1'' AND c = 1');
- estimated | actual 
------------+--------
-         1 |      1
-(1 row)
-
--- create statistics
-CREATE STATISTICS mcv_lists_stats (mcv) ON a, b, c FROM mcv_lists;
-ANALYZE mcv_lists;
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE a = 1 AND b = ''1''');
- estimated | actual 
------------+--------
-         3 |      4
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE a = 1 AND b = ''1'' AND c = 1');
- estimated | actual 
------------+--------
-         1 |      1
-(1 row)
-
-TRUNCATE mcv_lists;
-DROP STATISTICS mcv_lists_stats;
--- random data (no MCV list), but with expression
-INSERT INTO mcv_lists (a, b, c, filler1)
-     SELECT i, i, i, i FROM generate_series(1,1000) s(i);
-ANALYZE mcv_lists;
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE mod(a,7) = 1 AND mod(b::int,11) = 1');
- estimated | actual 
------------+--------
-         1 |     13
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE mod(a,7) = 1 AND mod(b::int,11) = 1 AND mod(c,13) = 1');
- estimated | actual 
------------+--------
-         1 |      1
-(1 row)
-
--- create statistics
-CREATE STATISTICS mcv_lists_stats (mcv) ON (mod(a,7)), (mod(b::int,11)), (mod(c,13)) FROM mcv_lists;
-ANALYZE mcv_lists;
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE mod(a,7) = 1 AND mod(b::int,11) = 1');
- estimated | actual 
------------+--------
-        13 |     13
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE mod(a,7) = 1 AND mod(b::int,11) = 1 AND mod(c,13) = 1');
- estimated | actual 
------------+--------
-         1 |      1
-(1 row)
-
--- 100 distinct combinations, all in the MCV list
-TRUNCATE mcv_lists;
-DROP STATISTICS mcv_lists_stats;
-INSERT INTO mcv_lists (a, b, c, filler1)
-     SELECT mod(i,100), mod(i,50), mod(i,25), i FROM generate_series(1,5000) s(i);
-ANALYZE mcv_lists;
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE a = 1 AND b = ''1''');
- estimated | actual 
------------+--------
-         1 |     50
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE 1 = a AND ''1'' = b');
- estimated | actual 
------------+--------
-         1 |     50
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE a < 1 AND b < ''1''');
- estimated | actual 
------------+--------
-         1 |     50
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE 1 > a AND ''1'' > b');
- estimated | actual 
------------+--------
-         1 |     50
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE a <= 0 AND b <= ''0''');
- estimated | actual 
------------+--------
-         1 |     50
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE 0 >= a AND ''0'' >= b');
- estimated | actual 
------------+--------
-         1 |     50
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE a = 1 AND b = ''1'' AND c = 1');
- estimated | actual 
------------+--------
-         1 |     50
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE a < 5 AND b < ''1'' AND c < 5');
- estimated | actual 
------------+--------
-         1 |     50
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE a < 5 AND ''1'' > b AND 5 > c');
- estimated | actual 
------------+--------
-         1 |     50
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE a <= 4 AND b <= ''0'' AND c <= 4');
- estimated | actual 
------------+--------
-         1 |     50
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE 4 >= a AND ''0'' >= b AND 4 >= c');
- estimated | actual 
------------+--------
-         1 |     50
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE a = 1 OR b = ''1'' OR c = 1');
- estimated | actual 
------------+--------
-       343 |    200
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE a = 1 OR b = ''1'' OR c = 1 OR d IS NOT NULL');
- estimated | actual 
------------+--------
-       343 |    200
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE a IN (1, 2, 51, 52) AND b IN ( ''1'', ''2'')');
- estimated | actual 
------------+--------
-         8 |    200
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE a IN (1, 2, 51, 52, NULL) AND b IN ( ''1'', ''2'', NULL)');
- estimated | actual 
------------+--------
-         8 |    200
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE a = ANY (ARRAY[1, 2, 51, 52]) AND b = ANY (ARRAY[''1'', ''2''])');
- estimated | actual 
------------+--------
-         8 |    200
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE a = ANY (ARRAY[NULL, 1, 2, 51, 52]) AND b = ANY (ARRAY[''1'', ''2'', NULL])');
- estimated | actual 
------------+--------
-         8 |    200
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE a <= ANY (ARRAY[1, 2, 3]) AND b IN (''1'', ''2'', ''3'')');
- estimated | actual 
------------+--------
-        26 |    150
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE a <= ANY (ARRAY[1, NULL, 2, 3]) AND b IN (''1'', ''2'', NULL, ''3'')');
- estimated | actual 
------------+--------
-        26 |    150
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE a < ALL (ARRAY[4, 5]) AND c > ANY (ARRAY[1, 2, 3])');
- estimated | actual 
------------+--------
-        10 |    100
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE a < ALL (ARRAY[4, 5]) AND c > ANY (ARRAY[1, 2, 3, NULL])');
- estimated | actual 
------------+--------
-        10 |    100
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE a < ALL (ARRAY[4, 5]) AND b IN (''1'', ''2'', ''3'') AND c > ANY (ARRAY[1, 2, 3])');
- estimated | actual 
------------+--------
-         1 |    100
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE a < ALL (ARRAY[4, 5]) AND b IN (''1'', ''2'', NULL, ''3'') AND c > ANY (ARRAY[1, 2, NULL, 3])');
- estimated | actual 
------------+--------
-         1 |    100
-(1 row)
-
--- create statistics
-CREATE STATISTICS mcv_lists_stats (mcv) ON a, b, c FROM mcv_lists;
-ANALYZE mcv_lists;
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE a = 1 AND b = ''1''');
- estimated | actual 
------------+--------
-        50 |     50
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE 1 = a AND ''1'' = b');
- estimated | actual 
------------+--------
-        50 |     50
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE a < 1 AND b < ''1''');
- estimated | actual 
------------+--------
-        50 |     50
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE 1 > a AND ''1'' > b');
- estimated | actual 
------------+--------
-        50 |     50
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE a <= 0 AND b <= ''0''');
- estimated | actual 
------------+--------
-        50 |     50
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE 0 >= a AND ''0'' >= b');
- estimated | actual 
------------+--------
-        50 |     50
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE a = 1 AND b = ''1'' AND c = 1');
- estimated | actual 
------------+--------
-        50 |     50
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE a < 5 AND b < ''1'' AND c < 5');
- estimated | actual 
------------+--------
-        50 |     50
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE a < 5 AND ''1'' > b AND 5 > c');
- estimated | actual 
------------+--------
-        50 |     50
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE a <= 4 AND b <= ''0'' AND c <= 4');
- estimated | actual 
------------+--------
-        50 |     50
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE 4 >= a AND ''0'' >= b AND 4 >= c');
- estimated | actual 
------------+--------
-        50 |     50
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE a = 1 OR b = ''1'' OR c = 1');
- estimated | actual 
------------+--------
-       200 |    200
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE a = 1 OR b = ''1'' OR c = 1 OR d IS NOT NULL');
- estimated | actual 
------------+--------
-       200 |    200
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE a = 1 OR b = ''1'' OR c = 1 OR d IS NOT NULL');
- estimated | actual 
------------+--------
-       200 |    200
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE a IN (1, 2, 51, 52) AND b IN ( ''1'', ''2'')');
- estimated | actual 
------------+--------
-       200 |    200
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE a IN (1, 2, 51, 52, NULL) AND b IN ( ''1'', ''2'', NULL)');
- estimated | actual 
------------+--------
-       200 |    200
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE a = ANY (ARRAY[1, 2, 51, 52]) AND b = ANY (ARRAY[''1'', ''2''])');
- estimated | actual 
------------+--------
-       200 |    200
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE a = ANY (ARRAY[NULL, 1, 2, 51, 52]) AND b = ANY (ARRAY[''1'', ''2'', NULL])');
- estimated | actual 
------------+--------
-       200 |    200
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE a <= ANY (ARRAY[1, 2, 3]) AND b IN (''1'', ''2'', ''3'')');
- estimated | actual 
------------+--------
-       150 |    150
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE a <= ANY (ARRAY[1, NULL, 2, 3]) AND b IN (''1'', ''2'', NULL, ''3'')');
- estimated | actual 
------------+--------
-       150 |    150
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE a < ALL (ARRAY[4, 5]) AND c > ANY (ARRAY[1, 2, 3])');
- estimated | actual 
------------+--------
-       100 |    100
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE a < ALL (ARRAY[4, 5]) AND c > ANY (ARRAY[1, 2, 3, NULL])');
- estimated | actual 
------------+--------
-       100 |    100
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE a < ALL (ARRAY[4, 5]) AND b IN (''1'', ''2'', ''3'') AND c > ANY (ARRAY[1, 2, 3])');
- estimated | actual 
------------+--------
-       100 |    100
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE a < ALL (ARRAY[4, 5]) AND b IN (''1'', ''2'', NULL, ''3'') AND c > ANY (ARRAY[1, 2, NULL, 3])');
- estimated | actual 
------------+--------
-       100 |    100
-(1 row)
-
--- check change of unrelated column type does not reset the MCV statistics
-ALTER TABLE mcv_lists ALTER COLUMN d TYPE VARCHAR(64);
-SELECT d.stxdmcv IS NOT NULL
-  FROM pg_statistic_ext s, pg_statistic_ext_data d
- WHERE s.stxname = 'mcv_lists_stats'
-   AND d.stxoid = s.oid;
- ?column? 
-----------
- t
-(1 row)
-
--- check change of column type resets the MCV statistics
-ALTER TABLE mcv_lists ALTER COLUMN c TYPE numeric;
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE a = 1 AND b = ''1''');
- estimated | actual 
------------+--------
-         1 |     50
-(1 row)
-
-ANALYZE mcv_lists;
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE a = 1 AND b = ''1''');
- estimated | actual 
------------+--------
-        50 |     50
-(1 row)
-
--- 100 distinct combinations, all in the MCV list, but with expressions
-TRUNCATE mcv_lists;
-DROP STATISTICS mcv_lists_stats;
-INSERT INTO mcv_lists (a, b, c, filler1)
-     SELECT i, i, i, i FROM generate_series(1,1000) s(i);
-ANALYZE mcv_lists;
--- without any stats on the expressions, we have to use default selectivities, which
--- is why the estimates here are different from the pre-computed case above
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE mod(a,20) = 1 AND mod(b::int,10) = 1');
- estimated | actual 
------------+--------
-         1 |     50
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE 1 = mod(a,20) AND 1 = mod(b::int,10)');
- estimated | actual 
------------+--------
-         1 |     50
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE mod(a,20) < 1 AND mod(b::int,10) < 1');
- estimated | actual 
------------+--------
-       111 |     50
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE 1 > mod(a,20) AND 1 > mod(b::int,10)');
- estimated | actual 
------------+--------
-       111 |     50
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE mod(a,20) = 1 AND mod(b::int,10) = 1 AND mod(c,5) = 1');
- estimated | actual 
------------+--------
-         1 |     50
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE mod(a,20) = 1 OR mod(b::int,10) = 1 OR mod(c,25) = 1 OR d IS NOT NULL');
- estimated | actual 
------------+--------
-        15 |    120
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE mod(a,20) IN (1, 2, 51, 52, NULL) AND mod(b::int,10) IN ( 1, 2, NULL)');
- estimated | actual 
------------+--------
-         1 |    100
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE mod(a,20) = ANY (ARRAY[1, 2, 51, 52]) AND mod(b::int,10) = ANY (ARRAY[1, 2])');
- estimated | actual 
------------+--------
-         1 |    100
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE mod(a,20) <= ANY (ARRAY[1, NULL, 2, 3]) AND mod(b::int,10) IN (1, 2, NULL, 3)');
- estimated | actual 
------------+--------
-        11 |    150
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE mod(a,20) < ALL (ARRAY[4, 5]) AND mod(b::int,10) IN (1, 2, 3) AND mod(c,5) > ANY (ARRAY[1, 2, 3])');
- estimated | actual 
------------+--------
-         1 |    100
-(1 row)
-
--- create statistics with expressions only (we create three separate stats, in order not to build more complex extended stats)
-CREATE STATISTICS mcv_lists_stats_1 ON (mod(a,20)) FROM mcv_lists;
-CREATE STATISTICS mcv_lists_stats_2 ON (mod(b::int,10)) FROM mcv_lists;
-CREATE STATISTICS mcv_lists_stats_3 ON (mod(c,5)) FROM mcv_lists;
-ANALYZE mcv_lists;
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE mod(a,20) = 1 AND mod(b::int,10) = 1');
- estimated | actual 
------------+--------
-         5 |     50
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE 1 = mod(a,20) AND 1 = mod(b::int,10)');
- estimated | actual 
------------+--------
-         5 |     50
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE mod(a,20) < 1 AND mod(b::int,10) < 1');
- estimated | actual 
------------+--------
-         5 |     50
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE 1 > mod(a,20) AND 1 > mod(b::int,10)');
- estimated | actual 
------------+--------
-         5 |     50
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE mod(a,20) = 1 AND mod(b::int,10) = 1 AND mod(c,5) = 1');
- estimated | actual 
------------+--------
-         1 |     50
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE mod(a,20) = 1 OR mod(b::int,10) = 1 OR mod(c,25) = 1 OR d IS NOT NULL');
- estimated | actual 
------------+--------
-       149 |    120
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE mod(a,20) IN (1, 2, 51, 52, NULL) AND mod(b::int,10) IN ( 1, 2, NULL)');
- estimated | actual 
------------+--------
-        20 |    100
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE mod(a,20) = ANY (ARRAY[1, 2, 51, 52]) AND mod(b::int,10) = ANY (ARRAY[1, 2])');
- estimated | actual 
------------+--------
-        20 |    100
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE mod(a,20) <= ANY (ARRAY[1, NULL, 2, 3]) AND mod(b::int,10) IN (1, 2, NULL, 3)');
- estimated | actual 
------------+--------
-       116 |    150
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE mod(a,20) < ALL (ARRAY[4, 5]) AND mod(b::int,10) IN (1, 2, 3) AND mod(c,5) > ANY (ARRAY[1, 2, 3])');
- estimated | actual 
------------+--------
-        12 |    100
-(1 row)
-
-DROP STATISTICS mcv_lists_stats_1;
-DROP STATISTICS mcv_lists_stats_2;
-DROP STATISTICS mcv_lists_stats_3;
--- create statistics with both MCV and expressions
-CREATE STATISTICS mcv_lists_stats (mcv) ON (mod(a,20)), (mod(b::int,10)), (mod(c,5)) FROM mcv_lists;
-ANALYZE mcv_lists;
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE mod(a,20) = 1 AND mod(b::int,10) = 1');
- estimated | actual 
------------+--------
-        50 |     50
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE 1 = mod(a,20) AND 1 = mod(b::int,10)');
- estimated | actual 
------------+--------
-        50 |     50
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE mod(a,20) < 1 AND mod(b::int,10) < 1');
- estimated | actual 
------------+--------
-        50 |     50
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE 1 > mod(a,20) AND 1 > mod(b::int,10)');
- estimated | actual 
------------+--------
-        50 |     50
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE mod(a,20) = 1 AND mod(b::int,10) = 1 AND mod(c,5) = 1');
- estimated | actual 
------------+--------
-        50 |     50
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE mod(a,20) = 1 OR mod(b::int,10) = 1 OR mod(c,25) = 1 OR d IS NOT NULL');
- estimated | actual 
------------+--------
-       105 |    120
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE mod(a,20) IN (1, 2, 51, 52, NULL) AND mod(b::int,10) IN ( 1, 2, NULL)');
- estimated | actual 
------------+--------
-       100 |    100
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE mod(a,20) = ANY (ARRAY[1, 2, 51, 52]) AND mod(b::int,10) = ANY (ARRAY[1, 2])');
- estimated | actual 
------------+--------
-       100 |    100
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE mod(a,20) <= ANY (ARRAY[1, NULL, 2, 3]) AND mod(b::int,10) IN (1, 2, NULL, 3)');
- estimated | actual 
------------+--------
-       150 |    150
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE mod(a,20) < ALL (ARRAY[4, 5]) AND mod(b::int,10) IN (1, 2, 3) AND mod(c,5) > ANY (ARRAY[1, 2, 3])');
- estimated | actual 
------------+--------
-       100 |    100
-(1 row)
-
--- we can't use the statistic for OR clauses that are not fully covered (missing 'd' attribute)
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE mod(a,20) = 1 OR mod(b::int,10) = 1 OR mod(c,5) = 1 OR d IS NOT NULL');
- estimated | actual 
------------+--------
-       200 |    200
-(1 row)
-
--- 100 distinct combinations with NULL values, all in the MCV list
-TRUNCATE mcv_lists;
-DROP STATISTICS mcv_lists_stats;
-INSERT INTO mcv_lists (a, b, c, filler1)
-     SELECT
-         (CASE WHEN mod(i,100) = 1 THEN NULL ELSE mod(i,100) END),
-         (CASE WHEN mod(i,50) = 1  THEN NULL ELSE mod(i,50) END),
-         (CASE WHEN mod(i,25) = 1  THEN NULL ELSE mod(i,25) END),
-         i
-     FROM generate_series(1,5000) s(i);
-ANALYZE mcv_lists;
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE a IS NULL AND b IS NULL');
- estimated | actual 
------------+--------
-         1 |     50
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE a IS NULL AND b IS NULL AND c IS NULL');
- estimated | actual 
------------+--------
-         1 |     50
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE a IS NULL AND b IS NOT NULL');
- estimated | actual 
------------+--------
-        49 |      0
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE a IS NOT NULL AND b IS NULL AND c IS NOT NULL');
- estimated | actual 
------------+--------
-        95 |      0
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE a IN (0, 1) AND b IN (''0'', ''1'')');
- estimated | actual 
------------+--------
-         1 |     50
-(1 row)
-
--- create statistics
-CREATE STATISTICS mcv_lists_stats (mcv) ON a, b, c FROM mcv_lists;
-ANALYZE mcv_lists;
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE a IS NULL AND b IS NULL');
- estimated | actual 
------------+--------
-        50 |     50
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE a IS NULL AND b IS NULL AND c IS NULL');
- estimated | actual 
------------+--------
-        50 |     50
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE a IS NULL AND b IS NOT NULL');
- estimated | actual 
------------+--------
-         1 |      0
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE a IS NOT NULL AND b IS NULL AND c IS NOT NULL');
- estimated | actual 
------------+--------
-         1 |      0
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE a IN (0, 1) AND b IN (''0'', ''1'')');
- estimated | actual 
------------+--------
-        50 |     50
-(1 row)
-
--- test pg_mcv_list_items with a very simple (single item) MCV list
-TRUNCATE mcv_lists;
-INSERT INTO mcv_lists (a, b, c) SELECT 1, 2, 3 FROM generate_series(1,1000) s(i);
-ANALYZE mcv_lists;
-SELECT m.*
-  FROM pg_statistic_ext s, pg_statistic_ext_data d,
-       pg_mcv_list_items(d.stxdmcv) m
- WHERE s.stxname = 'mcv_lists_stats'
-   AND d.stxoid = s.oid;
- index | values  |  nulls  | frequency | base_frequency 
--------+---------+---------+-----------+----------------
-     0 | {1,2,3} | {f,f,f} |         1 |              1
-(1 row)
-
--- 2 distinct combinations with NULL values, all in the MCV list
-TRUNCATE mcv_lists;
-DROP STATISTICS mcv_lists_stats;
-INSERT INTO mcv_lists (a, b, c, d)
-     SELECT
-         NULL, -- always NULL
-         (CASE WHEN mod(i,2) = 0 THEN NULL ELSE 'x' END),
-         (CASE WHEN mod(i,2) = 0 THEN NULL ELSE 0 END),
-         (CASE WHEN mod(i,2) = 0 THEN NULL ELSE 'x' END)
-     FROM generate_series(1,5000) s(i);
-ANALYZE mcv_lists;
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE b = ''x'' OR d = ''x''');
- estimated | actual 
------------+--------
-      3750 |   2500
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE a = 1 OR b = ''x'' OR d = ''x''');
- estimated | actual 
------------+--------
-      3750 |   2500
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE a IS NULL AND (b = ''x'' OR d = ''x'')');
- estimated | actual 
------------+--------
-      3750 |   2500
-(1 row)
-
--- create statistics
-CREATE STATISTICS mcv_lists_stats (mcv) ON a, b, d FROM mcv_lists;
-ANALYZE mcv_lists;
--- test pg_mcv_list_items with MCV list containing variable-length data and NULLs
-SELECT m.*
-  FROM pg_statistic_ext s, pg_statistic_ext_data d,
-       pg_mcv_list_items(d.stxdmcv) m
- WHERE s.stxname = 'mcv_lists_stats'
-   AND d.stxoid = s.oid;
- index |      values      |  nulls  | frequency | base_frequency 
--------+------------------+---------+-----------+----------------
-     0 | {NULL,x,x}       | {t,f,f} |       0.5 |           0.25
-     1 | {NULL,NULL,NULL} | {t,t,t} |       0.5 |           0.25
-(2 rows)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE b = ''x'' OR d = ''x''');
- estimated | actual 
------------+--------
-      2500 |   2500
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE a = 1 OR b = ''x'' OR d = ''x''');
- estimated | actual 
------------+--------
-      2500 |   2500
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists WHERE a IS NULL AND (b = ''x'' OR d = ''x'')');
- estimated | actual 
------------+--------
-      2500 |   2500
-(1 row)
-
--- mcv with pass-by-ref fixlen types, e.g. uuid
-CREATE TABLE mcv_lists_uuid (
-    a UUID,
-    b UUID,
-    c UUID
-)
-WITH (autovacuum_enabled = off);
-INSERT INTO mcv_lists_uuid (a, b, c)
-     SELECT
-         md5(mod(i,100)::text)::uuid,
-         md5(mod(i,50)::text)::uuid,
-         md5(mod(i,25)::text)::uuid
-     FROM generate_series(1,5000) s(i);
-ANALYZE mcv_lists_uuid;
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists_uuid WHERE a = ''1679091c-5a88-0faf-6fb5-e6087eb1b2dc'' AND b = ''1679091c-5a88-0faf-6fb5-e6087eb1b2dc''');
- estimated | actual 
------------+--------
-         1 |     50
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists_uuid WHERE a = ''1679091c-5a88-0faf-6fb5-e6087eb1b2dc'' AND b = ''1679091c-5a88-0faf-6fb5-e6087eb1b2dc'' AND c = ''1679091c-5a88-0faf-6fb5-e6087eb1b2dc''');
- estimated | actual 
------------+--------
-         1 |     50
-(1 row)
-
-CREATE STATISTICS mcv_lists_uuid_stats (mcv) ON a, b, c
-  FROM mcv_lists_uuid;
-ANALYZE mcv_lists_uuid;
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists_uuid WHERE a = ''1679091c-5a88-0faf-6fb5-e6087eb1b2dc'' AND b = ''1679091c-5a88-0faf-6fb5-e6087eb1b2dc''');
- estimated | actual 
------------+--------
-        50 |     50
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists_uuid WHERE a = ''1679091c-5a88-0faf-6fb5-e6087eb1b2dc'' AND b = ''1679091c-5a88-0faf-6fb5-e6087eb1b2dc'' AND c = ''1679091c-5a88-0faf-6fb5-e6087eb1b2dc''');
- estimated | actual 
------------+--------
-        50 |     50
-(1 row)
-
-DROP TABLE mcv_lists_uuid;
--- mcv with arrays
-CREATE TABLE mcv_lists_arrays (
-    a TEXT[],
-    b NUMERIC[],
-    c INT[]
-)
-WITH (autovacuum_enabled = off);
-INSERT INTO mcv_lists_arrays (a, b, c)
-     SELECT
-         ARRAY[md5((i/100)::text), md5((i/100-1)::text), md5((i/100+1)::text)],
-         ARRAY[(i/100-1)::numeric/1000, (i/100)::numeric/1000, (i/100+1)::numeric/1000],
-         ARRAY[(i/100-1), i/100, (i/100+1)]
-     FROM generate_series(1,5000) s(i);
-CREATE STATISTICS mcv_lists_arrays_stats (mcv) ON a, b, c
-  FROM mcv_lists_arrays;
-ANALYZE mcv_lists_arrays;
--- mcv with bool
-CREATE TABLE mcv_lists_bool (
-    a BOOL,
-    b BOOL,
-    c BOOL
-)
-WITH (autovacuum_enabled = off);
-INSERT INTO mcv_lists_bool (a, b, c)
-     SELECT
-         (mod(i,2) = 0), (mod(i,4) = 0), (mod(i,8) = 0)
-     FROM generate_series(1,10000) s(i);
-ANALYZE mcv_lists_bool;
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists_bool WHERE a AND b AND c');
- estimated | actual 
------------+--------
-       156 |   1250
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists_bool WHERE NOT a AND b AND c');
- estimated | actual 
------------+--------
-       156 |      0
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists_bool WHERE NOT a AND NOT b AND c');
- estimated | actual 
------------+--------
-       469 |      0
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists_bool WHERE NOT a AND b AND NOT c');
- estimated | actual 
------------+--------
-      1094 |      0
-(1 row)
-
-CREATE STATISTICS mcv_lists_bool_stats (mcv) ON a, b, c
-  FROM mcv_lists_bool;
-ANALYZE mcv_lists_bool;
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists_bool WHERE a AND b AND c');
- estimated | actual 
------------+--------
-      1250 |   1250
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists_bool WHERE NOT a AND b AND c');
- estimated | actual 
------------+--------
-         1 |      0
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists_bool WHERE NOT a AND NOT b AND c');
- estimated | actual 
------------+--------
-         1 |      0
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists_bool WHERE NOT a AND b AND NOT c');
- estimated | actual 
------------+--------
-         1 |      0
-(1 row)
-
--- mcv covering just a small fraction of data
-CREATE TABLE mcv_lists_partial (
-    a INT,
-    b INT,
-    c INT
-);
--- 10 frequent groups, each with 100 elements
-INSERT INTO mcv_lists_partial (a, b, c)
-     SELECT
-         mod(i,10),
-         mod(i,10),
-         mod(i,10)
-     FROM generate_series(0,999) s(i);
--- 100 groups that will make it to the MCV list (includes the 10 frequent ones)
-INSERT INTO mcv_lists_partial (a, b, c)
-     SELECT
-         i,
-         i,
-         i
-     FROM generate_series(0,99) s(i);
--- 4000 groups in total, most of which won't make it (just a single item)
-INSERT INTO mcv_lists_partial (a, b, c)
-     SELECT
-         i,
-         i,
-         i
-     FROM generate_series(0,3999) s(i);
-ANALYZE mcv_lists_partial;
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists_partial WHERE a = 0 AND b = 0 AND c = 0');
- estimated | actual 
------------+--------
-         1 |    102
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists_partial WHERE a = 0 OR b = 0 OR c = 0');
- estimated | actual 
------------+--------
-       300 |    102
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists_partial WHERE a = 10 AND b = 10 AND c = 10');
- estimated | actual 
------------+--------
-         1 |      2
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists_partial WHERE a = 10 OR b = 10 OR c = 10');
- estimated | actual 
------------+--------
-         6 |      2
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists_partial WHERE a = 0 AND b = 0 AND c = 10');
- estimated | actual 
------------+--------
-         1 |      0
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists_partial WHERE a = 0 OR b = 0 OR c = 10');
- estimated | actual 
------------+--------
-       204 |    104
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists_partial WHERE (a = 0 AND b = 0 AND c = 0) OR (a = 1 AND b = 1 AND c = 1) OR (a = 2 AND b = 2 AND c = 2)');
- estimated | actual 
------------+--------
-         1 |    306
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists_partial WHERE (a = 0 AND b = 0) OR (a = 0 AND c = 0) OR (b = 0 AND c = 0)');
- estimated | actual 
------------+--------
-         6 |    102
-(1 row)
-
-CREATE STATISTICS mcv_lists_partial_stats (mcv) ON a, b, c
-  FROM mcv_lists_partial;
-ANALYZE mcv_lists_partial;
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists_partial WHERE a = 0 AND b = 0 AND c = 0');
- estimated | actual 
------------+--------
-       102 |    102
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists_partial WHERE a = 0 OR b = 0 OR c = 0');
- estimated | actual 
------------+--------
-        96 |    102
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists_partial WHERE a = 10 AND b = 10 AND c = 10');
- estimated | actual 
------------+--------
-         2 |      2
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists_partial WHERE a = 10 OR b = 10 OR c = 10');
- estimated | actual 
------------+--------
-         2 |      2
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists_partial WHERE a = 0 AND b = 0 AND c = 10');
- estimated | actual 
------------+--------
-         1 |      0
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists_partial WHERE a = 0 OR b = 0 OR c = 10');
- estimated | actual 
------------+--------
-       102 |    104
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists_partial WHERE (a = 0 AND b = 0 AND c = 0) OR (a = 1 AND b = 1 AND c = 1) OR (a = 2 AND b = 2 AND c = 2)');
- estimated | actual 
------------+--------
-       306 |    306
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists_partial WHERE (a = 0 AND b = 0) OR (a = 0 AND c = 0) OR (b = 0 AND c = 0)');
- estimated | actual 
------------+--------
-       108 |    102
-(1 row)
-
-DROP TABLE mcv_lists_partial;
--- check the ability to use multiple MCV lists
-CREATE TABLE mcv_lists_multi (
-	a INTEGER,
-	b INTEGER,
-	c INTEGER,
-	d INTEGER
-)
-WITH (autovacuum_enabled = off);
-INSERT INTO mcv_lists_multi (a, b, c, d)
-    SELECT
-         mod(i,5),
-         mod(i,5),
-         mod(i,7),
-         mod(i,7)
-    FROM generate_series(1,5000) s(i);
-ANALYZE mcv_lists_multi;
--- estimates without any mcv statistics
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists_multi WHERE a = 0 AND b = 0');
- estimated | actual 
------------+--------
-       200 |   1000
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists_multi WHERE c = 0 AND d = 0');
- estimated | actual 
------------+--------
-       102 |    714
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists_multi WHERE b = 0 AND c = 0');
- estimated | actual 
------------+--------
-       143 |    142
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists_multi WHERE b = 0 OR c = 0');
- estimated | actual 
------------+--------
-      1571 |   1572
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists_multi WHERE a = 0 AND b = 0 AND c = 0 AND d = 0');
- estimated | actual 
------------+--------
-         4 |    142
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists_multi WHERE (a = 0 AND b = 0) OR (c = 0 AND d = 0)');
- estimated | actual 
------------+--------
-       298 |   1572
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists_multi WHERE a = 0 OR b = 0 OR c = 0 OR d = 0');
- estimated | actual 
------------+--------
-      2649 |   1572
-(1 row)
-
--- create separate MCV statistics
-CREATE STATISTICS mcv_lists_multi_1 (mcv) ON a, b FROM mcv_lists_multi;
-CREATE STATISTICS mcv_lists_multi_2 (mcv) ON c, d FROM mcv_lists_multi;
-ANALYZE mcv_lists_multi;
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists_multi WHERE a = 0 AND b = 0');
- estimated | actual 
------------+--------
-      1000 |   1000
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists_multi WHERE c = 0 AND d = 0');
- estimated | actual 
------------+--------
-       714 |    714
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists_multi WHERE b = 0 AND c = 0');
- estimated | actual 
------------+--------
-       143 |    142
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists_multi WHERE b = 0 OR c = 0');
- estimated | actual 
------------+--------
-      1571 |   1572
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists_multi WHERE a = 0 AND b = 0 AND c = 0 AND d = 0');
- estimated | actual 
------------+--------
-       143 |    142
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists_multi WHERE (a = 0 AND b = 0) OR (c = 0 AND d = 0)');
- estimated | actual 
------------+--------
-      1571 |   1572
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM mcv_lists_multi WHERE a = 0 OR b = 0 OR c = 0 OR d = 0');
- estimated | actual 
------------+--------
-      1571 |   1572
-(1 row)
-
-DROP TABLE mcv_lists_multi;
--- statistics on integer expressions
-CREATE TABLE expr_stats (a int, b int, c int);
-INSERT INTO expr_stats SELECT mod(i,10), mod(i,10), mod(i,10) FROM generate_series(1,1000) s(i);
-ANALYZE expr_stats;
-SELECT * FROM check_estimated_rows('SELECT * FROM expr_stats WHERE (2*a) = 0 AND (3*b) = 0');
- estimated | actual 
------------+--------
-         1 |    100
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM expr_stats WHERE (a+b) = 0 AND (a-b) = 0');
- estimated | actual 
------------+--------
-         1 |    100
-(1 row)
-
-CREATE STATISTICS expr_stats_1 (mcv) ON (a+b), (a-b), (2*a), (3*b) FROM expr_stats;
-ANALYZE expr_stats;
-SELECT * FROM check_estimated_rows('SELECT * FROM expr_stats WHERE (2*a) = 0 AND (3*b) = 0');
- estimated | actual 
------------+--------
-       100 |    100
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM expr_stats WHERE (a+b) = 0 AND (a-b) = 0');
- estimated | actual 
------------+--------
-       100 |    100
-(1 row)
-
-DROP STATISTICS expr_stats_1;
-DROP TABLE expr_stats;
--- statistics on a mix columns and expressions
-CREATE TABLE expr_stats (a int, b int, c int);
-INSERT INTO expr_stats SELECT mod(i,10), mod(i,10), mod(i,10) FROM generate_series(1,1000) s(i);
-ANALYZE expr_stats;
-SELECT * FROM check_estimated_rows('SELECT * FROM expr_stats WHERE a = 0 AND (2*a) = 0 AND (3*b) = 0');
- estimated | actual 
------------+--------
-         1 |    100
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM expr_stats WHERE a = 3 AND b = 3 AND (a-b) = 0');
- estimated | actual 
------------+--------
-         1 |    100
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM expr_stats WHERE a = 0 AND b = 1 AND (a-b) = 0');
- estimated | actual 
------------+--------
-         1 |      0
-(1 row)
-
-CREATE STATISTICS expr_stats_1 (mcv) ON a, b, (2*a), (3*b), (a+b), (a-b) FROM expr_stats;
-ANALYZE expr_stats;
-SELECT * FROM check_estimated_rows('SELECT * FROM expr_stats WHERE a = 0 AND (2*a) = 0 AND (3*b) = 0');
- estimated | actual 
------------+--------
-       100 |    100
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM expr_stats WHERE a = 3 AND b = 3 AND (a-b) = 0');
- estimated | actual 
------------+--------
-       100 |    100
-(1 row)
-
-SELECT * FROM check_estimated_rows('SELECT * FROM expr_stats WHERE a = 0 AND b = 1 AND (a-b) = 0');
- estimated | actual 
------------+--------
-         1 |      0
-(1 row)
-
-DROP TABLE expr_stats;
--- statistics on expressions with different data types
-CREATE TABLE expr_stats (a int, b name, c text);
-INSERT INTO expr_stats SELECT mod(i,10), md5(mod(i,10)::text), md5(mod(i,10)::text) FROM generate_series(1,1000) s(i);
-ANALYZE expr_stats;
-SELECT * FROM check_estimated_rows('SELECT * FROM expr_stats WHERE a = 0 AND (b || c) <= ''z'' AND (c || b) >= ''0''');
- estimated | actual 
------------+--------
-        11 |    100
-(1 row)
-
-CREATE STATISTICS expr_stats_1 (mcv) ON a, b, (b || c), (c || b) FROM expr_stats;
-ANALYZE expr_stats;
-SELECT * FROM check_estimated_rows('SELECT * FROM expr_stats WHERE a = 0 AND (b || c) <= ''z'' AND (c || b) >= ''0''');
- estimated | actual 
------------+--------
-       100 |    100
-(1 row)
-
-DROP TABLE expr_stats;
--- test handling of a mix of compatible and incompatible expressions
-CREATE TABLE expr_stats_incompatible_test (
-    c0 double precision,
-    c1 boolean NOT NULL
-);
-CREATE STATISTICS expr_stat_comp_1 ON c0, c1 FROM expr_stats_incompatible_test;
-INSERT INTO expr_stats_incompatible_test VALUES (1234,false), (5678,true);
-ANALYZE expr_stats_incompatible_test;
-SELECT c0 FROM ONLY expr_stats_incompatible_test WHERE
-(
-  upper('x') LIKE ('x'||('[0,1]'::int4range))
-  AND
-  (c0 IN (0, 1) OR c1)
-);
- c0 
-----
-(0 rows)
-
-DROP TABLE expr_stats_incompatible_test;
--- Permission tests. Users should not be able to see specific data values in
--- the extended statistics, if they lack permission to see those values in
--- the underlying table.
---
--- Currently this is only relevant for MCV stats.
-CREATE SCHEMA tststats;
-CREATE TABLE tststats.priv_test_tbl (
-    a int,
-    b int
-);
-INSERT INTO tststats.priv_test_tbl
-     SELECT mod(i,5), mod(i,10) FROM generate_series(1,100) s(i);
-CREATE STATISTICS tststats.priv_test_stats (mcv) ON a, b
-  FROM tststats.priv_test_tbl;
-ANALYZE tststats.priv_test_tbl;
--- Check printing info about extended statistics by \dX
-create table stts_t1 (a int, b int);
-create statistics stts_1 (ndistinct) on a, b from stts_t1;
-create statistics stts_2 (ndistinct, dependencies) on a, b from stts_t1;
-create statistics stts_3 (ndistinct, dependencies, mcv) on a, b from stts_t1;
-create table stts_t2 (a int, b int, c int);
-create statistics stts_4 on b, c from stts_t2;
-create table stts_t3 (col1 int, col2 int, col3 int);
-create statistics stts_hoge on col1, col2, col3 from stts_t3;
-create schema stts_s1;
-create schema stts_s2;
-create statistics stts_s1.stts_foo on col1, col2 from stts_t3;
-create statistics stts_s2.stts_yama (dependencies, mcv) on col1, col3 from stts_t3;
-insert into stts_t1 select i,i from generate_series(1,100) i;
-analyze stts_t1;
-set search_path to public, stts_s1, stts_s2, tststats;
-\dX
-                                                        List of extended statistics
-  Schema  |          Name          |                            Definition                            | Ndistinct | Dependencies |   MCV   
-----------+------------------------+------------------------------------------------------------------+-----------+--------------+---------
- public   | func_deps_stat         | (a * 2), upper(b), (c + 1::numeric) FROM functional_dependencies |           | defined      | 
- public   | mcv_lists_arrays_stats | a, b, c FROM mcv_lists_arrays                                    |           |              | defined
- public   | mcv_lists_bool_stats   | a, b, c FROM mcv_lists_bool                                      |           |              | defined
- public   | mcv_lists_stats        | a, b, d FROM mcv_lists                                           |           |              | defined
- public   | stts_1                 | a, b FROM stts_t1                                                | defined   |              | 
- public   | stts_2                 | a, b FROM stts_t1                                                | defined   | defined      | 
- public   | stts_3                 | a, b FROM stts_t1                                                | defined   | defined      | defined
- public   | stts_4                 | b, c FROM stts_t2                                                | defined   | defined      | defined
- public   | stts_hoge              | col1, col2, col3 FROM stts_t3                                    | defined   | defined      | defined
- stts_s1  | stts_foo               | col1, col2 FROM stts_t3                                          | defined   | defined      | defined
- stts_s2  | stts_yama              | col1, col3 FROM stts_t3                                          |           | defined      | defined
- tststats | priv_test_stats        | a, b FROM priv_test_tbl                                          |           |              | defined
-(12 rows)
-
-\dX stts_?
-                       List of extended statistics
- Schema |  Name  |    Definition     | Ndistinct | Dependencies |   MCV   
---------+--------+-------------------+-----------+--------------+---------
- public | stts_1 | a, b FROM stts_t1 | defined   |              | 
- public | stts_2 | a, b FROM stts_t1 | defined   | defined      | 
- public | stts_3 | a, b FROM stts_t1 | defined   | defined      | defined
- public | stts_4 | b, c FROM stts_t2 | defined   | defined      | defined
-(4 rows)
-
-\dX *stts_hoge
-                               List of extended statistics
- Schema |   Name    |          Definition           | Ndistinct | Dependencies |   MCV   
---------+-----------+-------------------------------+-----------+--------------+---------
- public | stts_hoge | col1, col2, col3 FROM stts_t3 | defined   | defined      | defined
-(1 row)
-
-\dX+
-                                                        List of extended statistics
-  Schema  |          Name          |                            Definition                            | Ndistinct | Dependencies |   MCV   
-----------+------------------------+------------------------------------------------------------------+-----------+--------------+---------
- public   | func_deps_stat         | (a * 2), upper(b), (c + 1::numeric) FROM functional_dependencies |           | defined      | 
- public   | mcv_lists_arrays_stats | a, b, c FROM mcv_lists_arrays                                    |           |              | defined
- public   | mcv_lists_bool_stats   | a, b, c FROM mcv_lists_bool                                      |           |              | defined
- public   | mcv_lists_stats        | a, b, d FROM mcv_lists                                           |           |              | defined
- public   | stts_1                 | a, b FROM stts_t1                                                | defined   |              | 
- public   | stts_2                 | a, b FROM stts_t1                                                | defined   | defined      | 
- public   | stts_3                 | a, b FROM stts_t1                                                | defined   | defined      | defined
- public   | stts_4                 | b, c FROM stts_t2                                                | defined   | defined      | defined
- public   | stts_hoge              | col1, col2, col3 FROM stts_t3                                    | defined   | defined      | defined
- stts_s1  | stts_foo               | col1, col2 FROM stts_t3                                          | defined   | defined      | defined
- stts_s2  | stts_yama              | col1, col3 FROM stts_t3                                          |           | defined      | defined
- tststats | priv_test_stats        | a, b FROM priv_test_tbl                                          |           |              | defined
-(12 rows)
-
-\dX+ stts_?
-                       List of extended statistics
- Schema |  Name  |    Definition     | Ndistinct | Dependencies |   MCV   
---------+--------+-------------------+-----------+--------------+---------
- public | stts_1 | a, b FROM stts_t1 | defined   |              | 
- public | stts_2 | a, b FROM stts_t1 | defined   | defined      | 
- public | stts_3 | a, b FROM stts_t1 | defined   | defined      | defined
- public | stts_4 | b, c FROM stts_t2 | defined   | defined      | defined
-(4 rows)
-
-\dX+ *stts_hoge
-                               List of extended statistics
- Schema |   Name    |          Definition           | Ndistinct | Dependencies |   MCV   
---------+-----------+-------------------------------+-----------+--------------+---------
- public | stts_hoge | col1, col2, col3 FROM stts_t3 | defined   | defined      | defined
-(1 row)
-
-\dX+ stts_s2.stts_yama
-                            List of extended statistics
- Schema  |   Name    |       Definition        | Ndistinct | Dependencies |   MCV   
----------+-----------+-------------------------+-----------+--------------+---------
- stts_s2 | stts_yama | col1, col3 FROM stts_t3 |           | defined      | defined
-(1 row)
-
-set search_path to public, stts_s1;
-\dX
-                                                       List of extended statistics
- Schema  |          Name          |                            Definition                            | Ndistinct | Dependencies |   MCV   
----------+------------------------+------------------------------------------------------------------+-----------+--------------+---------
- public  | func_deps_stat         | (a * 2), upper(b), (c + 1::numeric) FROM functional_dependencies |           | defined      | 
- public  | mcv_lists_arrays_stats | a, b, c FROM mcv_lists_arrays                                    |           |              | defined
- public  | mcv_lists_bool_stats   | a, b, c FROM mcv_lists_bool                                      |           |              | defined
- public  | mcv_lists_stats        | a, b, d FROM mcv_lists                                           |           |              | defined
- public  | stts_1                 | a, b FROM stts_t1                                                | defined   |              | 
- public  | stts_2                 | a, b FROM stts_t1                                                | defined   | defined      | 
- public  | stts_3                 | a, b FROM stts_t1                                                | defined   | defined      | defined
- public  | stts_4                 | b, c FROM stts_t2                                                | defined   | defined      | defined
- public  | stts_hoge              | col1, col2, col3 FROM stts_t3                                    | defined   | defined      | defined
- stts_s1 | stts_foo               | col1, col2 FROM stts_t3                                          | defined   | defined      | defined
-(10 rows)
-
-create role regress_stats_ext nosuperuser;
-set role regress_stats_ext;
-\dX
-                                                       List of extended statistics
- Schema |          Name          |                            Definition                            | Ndistinct | Dependencies |   MCV   
---------+------------------------+------------------------------------------------------------------+-----------+--------------+---------
- public | func_deps_stat         | (a * 2), upper(b), (c + 1::numeric) FROM functional_dependencies |           | defined      | 
- public | mcv_lists_arrays_stats | a, b, c FROM mcv_lists_arrays                                    |           |              | defined
- public | mcv_lists_bool_stats   | a, b, c FROM mcv_lists_bool                                      |           |              | defined
- public | mcv_lists_stats        | a, b, d FROM mcv_lists                                           |           |              | defined
- public | stts_1                 | a, b FROM stts_t1                                                | defined   |              | 
- public | stts_2                 | a, b FROM stts_t1                                                | defined   | defined      | 
- public | stts_3                 | a, b FROM stts_t1                                                | defined   | defined      | defined
- public | stts_4                 | b, c FROM stts_t2                                                | defined   | defined      | defined
- public | stts_hoge              | col1, col2, col3 FROM stts_t3                                    | defined   | defined      | defined
-(9 rows)
-
-reset role;
-drop table stts_t1, stts_t2, stts_t3;
-drop schema stts_s1, stts_s2 cascade;
-drop user regress_stats_ext;
-reset search_path;
--- User with no access
-CREATE USER regress_stats_user1;
-GRANT USAGE ON SCHEMA tststats TO regress_stats_user1;
-SET SESSION AUTHORIZATION regress_stats_user1;
-SELECT * FROM tststats.priv_test_tbl; -- Permission denied
-ERROR:  permission denied for table priv_test_tbl
--- Attempt to gain access using a leaky operator
-CREATE FUNCTION op_leak(int, int) RETURNS bool
-    AS 'BEGIN RAISE NOTICE ''op_leak => %, %'', $1, $2; RETURN $1 < $2; END'
-    LANGUAGE plpgsql;
-CREATE OPERATOR <<< (procedure = op_leak, leftarg = int, rightarg = int,
-                     restrict = scalarltsel);
-SELECT * FROM tststats.priv_test_tbl WHERE a <<< 0 AND b <<< 0; -- Permission denied
-ERROR:  permission denied for table priv_test_tbl
-DELETE FROM tststats.priv_test_tbl WHERE a <<< 0 AND b <<< 0; -- Permission denied
-ERROR:  permission denied for table priv_test_tbl
--- Grant access via a security barrier view, but hide all data
-RESET SESSION AUTHORIZATION;
-CREATE VIEW tststats.priv_test_view WITH (security_barrier=true)
-    AS SELECT * FROM tststats.priv_test_tbl WHERE false;
-GRANT SELECT, DELETE ON tststats.priv_test_view TO regress_stats_user1;
--- Should now have access via the view, but see nothing and leak nothing
-SET SESSION AUTHORIZATION regress_stats_user1;
-SELECT * FROM tststats.priv_test_view WHERE a <<< 0 AND b <<< 0; -- Should not leak
- a | b 
----+---
-(0 rows)
-
-DELETE FROM tststats.priv_test_view WHERE a <<< 0 AND b <<< 0; -- Should not leak
--- Grant table access, but hide all data with RLS
-RESET SESSION AUTHORIZATION;
-ALTER TABLE tststats.priv_test_tbl ENABLE ROW LEVEL SECURITY;
-GRANT SELECT, DELETE ON tststats.priv_test_tbl TO regress_stats_user1;
--- Should now have direct table access, but see nothing and leak nothing
-SET SESSION AUTHORIZATION regress_stats_user1;
-SELECT * FROM tststats.priv_test_tbl WHERE a <<< 0 AND b <<< 0; -- Should not leak
- a | b 
----+---
-(0 rows)
-
-DELETE FROM tststats.priv_test_tbl WHERE a <<< 0 AND b <<< 0; -- Should not leak
--- Tidy up
-DROP OPERATOR <<< (int, int);
-DROP FUNCTION op_leak(int, int);
-RESET SESSION AUTHORIZATION;
-DROP SCHEMA tststats CASCADE;
-NOTICE:  drop cascades to 2 other objects
-DETAIL:  drop cascades to table tststats.priv_test_tbl
-drop cascades to view tststats.priv_test_view
-DROP USER regress_stats_user1;
diff -U3 /Users/kenaniah/workspace/postgres/src/test/regress/expected/publication.out /Users/kenaniah/workspace/postgres/src/test/regress/results/publication.out
--- /Users/kenaniah/workspace/postgres/src/test/regress/expected/publication.out	2021-10-03 18:09:17.000000000 -0700
+++ /Users/kenaniah/workspace/postgres/src/test/regress/results/publication.out	2021-10-03 20:08:21.000000000 -0700
@@ -76,248 +76,11 @@
 (1 row)
 
 \d+ testpub_tbl2
-                                                Table "public.testpub_tbl2"
- Column |  Type   | Collation | Nullable |                 Default                  | Storage  | Stats target | Description 
---------+---------+-----------+----------+------------------------------------------+----------+--------------+-------------
- id     | integer |           | not null | nextval('testpub_tbl2_id_seq'::regclass) | plain    |              | 
- data   | text    |           |          |                                          | extended |              | 
-Indexes:
-    "testpub_tbl2_pkey" PRIMARY KEY, btree (id)
-Publications:
-    "testpub_foralltables"
+dyld: lazy symbol binding failed: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
+
+dyld: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
 
-\dRp+ testpub_foralltables
-                              Publication testpub_foralltables
-          Owner           | All tables | Inserts | Updates | Deletes | Truncates | Via root 
---------------------------+------------+---------+---------+---------+-----------+----------
- regress_publication_user | t          | t       | t       | f       | f         | f
-(1 row)
-
-DROP TABLE testpub_tbl2;
-DROP PUBLICATION testpub_foralltables;
-CREATE TABLE testpub_tbl3 (a int);
-CREATE TABLE testpub_tbl3a (b text) INHERITS (testpub_tbl3);
-SET client_min_messages = 'ERROR';
-CREATE PUBLICATION testpub3 FOR TABLE testpub_tbl3;
-CREATE PUBLICATION testpub4 FOR TABLE ONLY testpub_tbl3;
-RESET client_min_messages;
-\dRp+ testpub3
-                                    Publication testpub3
-          Owner           | All tables | Inserts | Updates | Deletes | Truncates | Via root 
---------------------------+------------+---------+---------+---------+-----------+----------
- regress_publication_user | f          | t       | t       | t       | t         | f
-Tables:
-    "public.testpub_tbl3"
-    "public.testpub_tbl3a"
-
-\dRp+ testpub4
-                                    Publication testpub4
-          Owner           | All tables | Inserts | Updates | Deletes | Truncates | Via root 
---------------------------+------------+---------+---------+---------+-----------+----------
- regress_publication_user | f          | t       | t       | t       | t         | f
-Tables:
-    "public.testpub_tbl3"
-
-DROP TABLE testpub_tbl3, testpub_tbl3a;
-DROP PUBLICATION testpub3, testpub4;
--- Tests for partitioned tables
-SET client_min_messages = 'ERROR';
-CREATE PUBLICATION testpub_forparted;
-CREATE PUBLICATION testpub_forparted1;
-RESET client_min_messages;
-CREATE TABLE testpub_parted1 (LIKE testpub_parted);
-CREATE TABLE testpub_parted2 (LIKE testpub_parted);
-ALTER PUBLICATION testpub_forparted1 SET (publish='insert');
-ALTER TABLE testpub_parted ATTACH PARTITION testpub_parted1 FOR VALUES IN (1);
-ALTER TABLE testpub_parted ATTACH PARTITION testpub_parted2 FOR VALUES IN (2);
--- works despite missing REPLICA IDENTITY, because updates are not replicated
-UPDATE testpub_parted1 SET a = 1;
--- only parent is listed as being in publication, not the partition
-ALTER PUBLICATION testpub_forparted ADD TABLE testpub_parted;
-\dRp+ testpub_forparted
-                               Publication testpub_forparted
-          Owner           | All tables | Inserts | Updates | Deletes | Truncates | Via root 
---------------------------+------------+---------+---------+---------+-----------+----------
- regress_publication_user | f          | t       | t       | t       | t         | f
-Tables:
-    "public.testpub_parted"
-
--- should now fail, because parent's publication replicates updates
-UPDATE testpub_parted1 SET a = 1;
-ERROR:  cannot update table "testpub_parted1" because it does not have a replica identity and publishes updates
-HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
-ALTER TABLE testpub_parted DETACH PARTITION testpub_parted1;
--- works again, because parent's publication is no longer considered
-UPDATE testpub_parted1 SET a = 1;
-ALTER PUBLICATION testpub_forparted SET (publish_via_partition_root = true);
-\dRp+ testpub_forparted
-                               Publication testpub_forparted
-          Owner           | All tables | Inserts | Updates | Deletes | Truncates | Via root 
---------------------------+------------+---------+---------+---------+-----------+----------
- regress_publication_user | f          | t       | t       | t       | t         | t
-Tables:
-    "public.testpub_parted"
-
--- still fail, because parent's publication replicates updates
-UPDATE testpub_parted2 SET a = 2;
-ERROR:  cannot update table "testpub_parted2" because it does not have a replica identity and publishes updates
-HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
-ALTER PUBLICATION testpub_forparted DROP TABLE testpub_parted;
--- works again, because update is no longer replicated
-UPDATE testpub_parted2 SET a = 2;
-DROP TABLE testpub_parted1, testpub_parted2;
-DROP PUBLICATION testpub_forparted, testpub_forparted1;
--- Test cache invalidation FOR ALL TABLES publication
-SET client_min_messages = 'ERROR';
-CREATE TABLE testpub_tbl4(a int);
-INSERT INTO testpub_tbl4 values(1);
-UPDATE testpub_tbl4 set a = 2;
-CREATE PUBLICATION testpub_foralltables FOR ALL TABLES;
-RESET client_min_messages;
--- fail missing REPLICA IDENTITY
-UPDATE testpub_tbl4 set a = 3;
-ERROR:  cannot update table "testpub_tbl4" because it does not have a replica identity and publishes updates
-HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
-DROP PUBLICATION testpub_foralltables;
--- should pass after dropping the publication
-UPDATE testpub_tbl4 set a = 3;
-DROP TABLE testpub_tbl4;
--- fail - view
-CREATE PUBLICATION testpub_fortbl FOR TABLE testpub_view;
-ERROR:  cannot add relation "testpub_view" to publication
-DETAIL:  This operation is not supported for views.
-SET client_min_messages = 'ERROR';
-CREATE PUBLICATION testpub_fortbl FOR TABLE testpub_tbl1, pub_test.testpub_nopk;
-RESET client_min_messages;
--- fail - already added
-ALTER PUBLICATION testpub_fortbl ADD TABLE testpub_tbl1;
-ERROR:  relation "testpub_tbl1" is already member of publication "testpub_fortbl"
--- fail - already added
-CREATE PUBLICATION testpub_fortbl FOR TABLE testpub_tbl1;
-ERROR:  publication "testpub_fortbl" already exists
-\dRp+ testpub_fortbl
-                                 Publication testpub_fortbl
-          Owner           | All tables | Inserts | Updates | Deletes | Truncates | Via root 
---------------------------+------------+---------+---------+---------+-----------+----------
- regress_publication_user | f          | t       | t       | t       | t         | f
-Tables:
-    "pub_test.testpub_nopk"
-    "public.testpub_tbl1"
-
--- fail - view
-ALTER PUBLICATION testpub_default ADD TABLE testpub_view;
-ERROR:  cannot add relation "testpub_view" to publication
-DETAIL:  This operation is not supported for views.
-ALTER PUBLICATION testpub_default ADD TABLE testpub_tbl1;
-ALTER PUBLICATION testpub_default SET TABLE testpub_tbl1;
-ALTER PUBLICATION testpub_default ADD TABLE pub_test.testpub_nopk;
-ALTER PUBLICATION testpib_ins_trunct ADD TABLE pub_test.testpub_nopk, testpub_tbl1;
-\d+ pub_test.testpub_nopk
-                              Table "pub_test.testpub_nopk"
- Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
---------+---------+-----------+----------+---------+---------+--------------+-------------
- foo    | integer |           |          |         | plain   |              | 
- bar    | integer |           |          |         | plain   |              | 
-Publications:
-    "testpib_ins_trunct"
-    "testpub_default"
-    "testpub_fortbl"
-
-\d+ testpub_tbl1
-                                                Table "public.testpub_tbl1"
- Column |  Type   | Collation | Nullable |                 Default                  | Storage  | Stats target | Description 
---------+---------+-----------+----------+------------------------------------------+----------+--------------+-------------
- id     | integer |           | not null | nextval('testpub_tbl1_id_seq'::regclass) | plain    |              | 
- data   | text    |           |          |                                          | extended |              | 
-Indexes:
-    "testpub_tbl1_pkey" PRIMARY KEY, btree (id)
-Publications:
-    "testpib_ins_trunct"
-    "testpub_default"
-    "testpub_fortbl"
-
-\dRp+ testpub_default
-                                Publication testpub_default
-          Owner           | All tables | Inserts | Updates | Deletes | Truncates | Via root 
---------------------------+------------+---------+---------+---------+-----------+----------
- regress_publication_user | f          | t       | t       | t       | f         | f
-Tables:
-    "pub_test.testpub_nopk"
-    "public.testpub_tbl1"
-
-ALTER PUBLICATION testpub_default DROP TABLE testpub_tbl1, pub_test.testpub_nopk;
--- fail - nonexistent
-ALTER PUBLICATION testpub_default DROP TABLE pub_test.testpub_nopk;
-ERROR:  relation "testpub_nopk" is not part of the publication
-\d+ testpub_tbl1
-                                                Table "public.testpub_tbl1"
- Column |  Type   | Collation | Nullable |                 Default                  | Storage  | Stats target | Description 
---------+---------+-----------+----------+------------------------------------------+----------+--------------+-------------
- id     | integer |           | not null | nextval('testpub_tbl1_id_seq'::regclass) | plain    |              | 
- data   | text    |           |          |                                          | extended |              | 
-Indexes:
-    "testpub_tbl1_pkey" PRIMARY KEY, btree (id)
-Publications:
-    "testpib_ins_trunct"
-    "testpub_fortbl"
-
--- permissions
-SET ROLE regress_publication_user2;
-CREATE PUBLICATION testpub2;  -- fail
-ERROR:  permission denied for database regression
-SET ROLE regress_publication_user;
-GRANT CREATE ON DATABASE regression TO regress_publication_user2;
-SET ROLE regress_publication_user2;
-SET client_min_messages = 'ERROR';
-CREATE PUBLICATION testpub2;  -- ok
-RESET client_min_messages;
-ALTER PUBLICATION testpub2 ADD TABLE testpub_tbl1;  -- fail
-ERROR:  must be owner of table testpub_tbl1
-SET ROLE regress_publication_user;
-GRANT regress_publication_user TO regress_publication_user2;
-SET ROLE regress_publication_user2;
-ALTER PUBLICATION testpub2 ADD TABLE testpub_tbl1;  -- ok
-DROP PUBLICATION testpub2;
-SET ROLE regress_publication_user;
-REVOKE CREATE ON DATABASE regression FROM regress_publication_user2;
-DROP TABLE testpub_parted;
-DROP VIEW testpub_view;
-DROP TABLE testpub_tbl1;
-\dRp+ testpub_default
-                                Publication testpub_default
-          Owner           | All tables | Inserts | Updates | Deletes | Truncates | Via root 
---------------------------+------------+---------+---------+---------+-----------+----------
- regress_publication_user | f          | t       | t       | t       | f         | f
-(1 row)
-
--- fail - must be owner of publication
-SET ROLE regress_publication_user_dummy;
-ALTER PUBLICATION testpub_default RENAME TO testpub_dummy;
-ERROR:  must be owner of publication testpub_default
-RESET ROLE;
-ALTER PUBLICATION testpub_default RENAME TO testpub_foo;
-\dRp testpub_foo
-                                           List of publications
-    Name     |          Owner           | All tables | Inserts | Updates | Deletes | Truncates | Via root 
--------------+--------------------------+------------+---------+---------+---------+-----------+----------
- testpub_foo | regress_publication_user | f          | t       | t       | t       | f         | f
-(1 row)
-
--- rename back to keep the rest simple
-ALTER PUBLICATION testpub_foo RENAME TO testpub_default;
-ALTER PUBLICATION testpub_default OWNER TO regress_publication_user2;
-\dRp testpub_default
-                                             List of publications
-      Name       |           Owner           | All tables | Inserts | Updates | Deletes | Truncates | Via root 
------------------+---------------------------+------------+---------+---------+---------+-----------+----------
- testpub_default | regress_publication_user2 | f          | t       | t       | t       | f         | f
-(1 row)
-
-DROP PUBLICATION testpub_default;
-DROP PUBLICATION testpib_ins_trunct;
-DROP PUBLICATION testpub_fortbl;
-DROP SCHEMA pub_test CASCADE;
-NOTICE:  drop cascades to table pub_test.testpub_nopk
-RESET SESSION AUTHORIZATION;
-DROP ROLE regress_publication_user, regress_publication_user2;
-DROP ROLE regress_publication_user_dummy;
diff -U3 /Users/kenaniah/workspace/postgres/src/test/regress/expected/foreign_key.out /Users/kenaniah/workspace/postgres/src/test/regress/results/foreign_key.out
--- /Users/kenaniah/workspace/postgres/src/test/regress/expected/foreign_key.out	2021-10-03 17:41:49.000000000 -0700
+++ /Users/kenaniah/workspace/postgres/src/test/regress/results/foreign_key.out	2021-10-03 20:08:22.000000000 -0700
@@ -45,13 +45,16 @@
 
 -- Update a row from PK TABLE
 UPDATE PKTABLE SET ptest1=1 WHERE ptest1=2;
+ERROR:  cannot update table "fktable" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "UPDATE ONLY "public"."fktable" SET "ftest1" = $1 WHERE $2 OPERATOR(pg_catalog.=) "ftest1""
 -- Check FKTABLE for update of matched row
 SELECT * FROM FKTABLE;
  ftest1 | ftest2 
 --------+--------
+      2 |      3
       3 |      4
         |      1
-      1 |      3
 (3 rows)
 
 DROP TABLE FKTABLE;
@@ -106,69 +109,82 @@
 
 -- Delete a row from PK TABLE
 DELETE FROM PKTABLE WHERE ptest1=1 and ptest2=2;
+ERROR:  cannot update table "fktable" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "UPDATE ONLY "public"."fktable" SET "ftest1" = NULL, "ftest2" = NULL WHERE $1 OPERATOR(pg_catalog.=) "ftest1" AND $2 OPERATOR(pg_catalog.=) "ftest2""
 -- Check FKTABLE for removal of matched row
 SELECT * FROM FKTABLE;
  ftest1 | ftest2 | ftest3 
 --------+--------+--------
+      1 |      2 |      4
       1 |      3 |      5
       2 |      4 |      8
       3 |      6 |     12
         |        |      0
-        |        |      4
 (5 rows)
 
 -- Delete another row from PK TABLE
 DELETE FROM PKTABLE WHERE ptest1=5 and ptest2=10;
+ERROR:  cannot update table "fktable" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "UPDATE ONLY "public"."fktable" SET "ftest1" = NULL, "ftest2" = NULL WHERE $1 OPERATOR(pg_catalog.=) "ftest1" AND $2 OPERATOR(pg_catalog.=) "ftest2""
 -- Check FKTABLE (should be no change)
 SELECT * FROM FKTABLE;
  ftest1 | ftest2 | ftest3 
 --------+--------+--------
+      1 |      2 |      4
       1 |      3 |      5
       2 |      4 |      8
       3 |      6 |     12
         |        |      0
-        |        |      4
 (5 rows)
 
 -- Update a row from PK TABLE
 UPDATE PKTABLE SET ptest1=1 WHERE ptest1=2;
+ERROR:  cannot update table "fktable" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "UPDATE ONLY "public"."fktable" SET "ftest1" = NULL, "ftest2" = NULL WHERE $1 OPERATOR(pg_catalog.=) "ftest1" AND $2 OPERATOR(pg_catalog.=) "ftest2""
 -- Check FKTABLE for update of matched row
 SELECT * FROM FKTABLE;
  ftest1 | ftest2 | ftest3 
 --------+--------+--------
+      1 |      2 |      4
       1 |      3 |      5
+      2 |      4 |      8
       3 |      6 |     12
         |        |      0
-        |        |      4
-        |        |      8
 (5 rows)
 
 -- Check update with part of key null
 UPDATE FKTABLE SET ftest1 = NULL WHERE ftest1 = 1;
-ERROR:  insert or update on table "fktable" violates foreign key constraint "constrname"
-DETAIL:  MATCH FULL does not allow mixing of null and nonnull key values.
+ERROR:  cannot update table "fktable" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
 -- Check update with old and new key values equal
 UPDATE FKTABLE SET ftest1 = 1 WHERE ftest1 = 1;
+ERROR:  cannot update table "fktable" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
 -- Try altering the column type where foreign keys are involved
 ALTER TABLE PKTABLE ALTER COLUMN ptest1 TYPE bigint;
 ALTER TABLE FKTABLE ALTER COLUMN ftest1 TYPE bigint;
 SELECT * FROM PKTABLE;
  ptest1 | ptest2 | ptest3  
 --------+--------+---------
+      1 |      2 | Test1
       1 |      3 | Test1-2
+      2 |      4 | Test2
       3 |      6 | Test3
       4 |      8 | Test4
-      1 |      4 | Test2
-(4 rows)
+      5 |     10 | Test5
+(6 rows)
 
 SELECT * FROM FKTABLE;
  ftest1 | ftest2 | ftest3 
 --------+--------+--------
+      1 |      2 |      4
+      1 |      3 |      5
+      2 |      4 |      8
       3 |      6 |     12
         |        |      0
-        |        |      4
-        |        |      8
-      1 |      3 |      5
 (5 rows)
 
 DROP TABLE PKTABLE CASCADE;
@@ -221,41 +237,50 @@
 
 -- Delete a row from PK TABLE
 DELETE FROM PKTABLE WHERE ptest1=1 and ptest2=2;
+ERROR:  cannot update table "fktable" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "UPDATE ONLY "public"."fktable" SET "ftest1" = DEFAULT, "ftest2" = DEFAULT WHERE $1 OPERATOR(pg_catalog.=) "ftest1" AND $2 OPERATOR(pg_catalog.=) "ftest2""
 -- Check FKTABLE to check for removal
 SELECT * FROM FKTABLE;
  ftest1 | ftest2 | ftest3 
 --------+--------+--------
+      1 |      2 |      4
       1 |      3 |      5
       2 |      4 |      8
       3 |      6 |     12
         |        |      0
-     -1 |     -2 |      4
 (5 rows)
 
 -- Delete another row from PK TABLE
 DELETE FROM PKTABLE WHERE ptest1=5 and ptest2=10;
+ERROR:  cannot update table "fktable" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "UPDATE ONLY "public"."fktable" SET "ftest1" = DEFAULT, "ftest2" = DEFAULT WHERE $1 OPERATOR(pg_catalog.=) "ftest1" AND $2 OPERATOR(pg_catalog.=) "ftest2""
 -- Check FKTABLE (should be no change)
 SELECT * FROM FKTABLE;
  ftest1 | ftest2 | ftest3 
 --------+--------+--------
+      1 |      2 |      4
       1 |      3 |      5
       2 |      4 |      8
       3 |      6 |     12
         |        |      0
-     -1 |     -2 |      4
 (5 rows)
 
 -- Update a row from PK TABLE
 UPDATE PKTABLE SET ptest1=1 WHERE ptest1=2;
+ERROR:  cannot update table "fktable" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "UPDATE ONLY "public"."fktable" SET "ftest1" = DEFAULT, "ftest2" = DEFAULT WHERE $1 OPERATOR(pg_catalog.=) "ftest1" AND $2 OPERATOR(pg_catalog.=) "ftest2""
 -- Check FKTABLE for update of matched row
 SELECT * FROM FKTABLE;
  ftest1 | ftest2 | ftest3 
 --------+--------+--------
+      1 |      2 |      4
       1 |      3 |      5
+      2 |      4 |      8
       3 |      6 |     12
         |        |      0
-     -1 |     -2 |      4
-     -1 |     -2 |      8
 (5 rows)
 
 -- this should fail for lack of CASCADE
@@ -474,26 +499,32 @@
 
 -- Try to update something that will cascade
 UPDATE PKTABLE set ptest2=5 where ptest2=2;
+ERROR:  cannot update table "fktable" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "UPDATE ONLY "public"."fktable" SET "ftest1" = $1, "ftest2" = $2, "ftest3" = $3 WHERE $4 OPERATOR(pg_catalog.=) "ftest1" AND $5 OPERATOR(pg_catalog.=) "ftest2" AND $6 OPERATOR(pg_catalog.=) "ftest3""
 -- Try to update something that should not cascade
 UPDATE PKTABLE set ptest1=1 WHERE ptest2=3;
+ERROR:  cannot update table "fktable" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "UPDATE ONLY "public"."fktable" SET "ftest1" = $1, "ftest2" = $2, "ftest3" = $3 WHERE $4 OPERATOR(pg_catalog.=) "ftest1" AND $5 OPERATOR(pg_catalog.=) "ftest2" AND $6 OPERATOR(pg_catalog.=) "ftest3""
 -- Show PKTABLE and FKTABLE
 SELECT * from PKTABLE;
  ptest1 | ptest2 | ptest3 | ptest4 
 --------+--------+--------+--------
-      2 |      4 |      5 | test4
-      1 |      5 |      3 | test1
+      1 |      2 |      3 | test1
       1 |      3 |      3 | test2
-      1 |      3 |      4 | test3
+      2 |      3 |      4 | test3
+      2 |      4 |      5 | test4
 (4 rows)
 
 SELECT * from FKTABLE;
  ftest1 | ftest2 | ftest3 | ftest4 
 --------+--------+--------+--------
+      1 |      2 |      3 |      1
         |      2 |      3 |      2
       2 |        |      3 |      3
         |      2 |      7 |      4
         |      3 |      4 |      5
-      1 |      5 |      3 |      1
 (5 rows)
 
 -- Try to delete something that should cascade
@@ -502,19 +533,21 @@
 SELECT * from PKTABLE;
  ptest1 | ptest2 | ptest3 | ptest4 
 --------+--------+--------+--------
-      2 |      4 |      5 | test4
+      1 |      2 |      3 | test1
       1 |      3 |      3 | test2
-      1 |      3 |      4 | test3
-(3 rows)
+      2 |      3 |      4 | test3
+      2 |      4 |      5 | test4
+(4 rows)
 
 SELECT * from FKTABLE;
  ftest1 | ftest2 | ftest3 | ftest4 
 --------+--------+--------+--------
+      1 |      2 |      3 |      1
         |      2 |      3 |      2
       2 |        |      3 |      3
         |      2 |      7 |      4
         |      3 |      4 |      5
-(4 rows)
+(5 rows)
 
 -- Try to delete something that should not have a cascade
 DELETE FROM PKTABLE where ptest1=2;
@@ -522,18 +555,19 @@
 SELECT * from PKTABLE;
  ptest1 | ptest2 | ptest3 | ptest4 
 --------+--------+--------+--------
+      1 |      2 |      3 | test1
       1 |      3 |      3 | test2
-      1 |      3 |      4 | test3
 (2 rows)
 
 SELECT * from FKTABLE;
  ftest1 | ftest2 | ftest3 | ftest4 
 --------+--------+--------+--------
+      1 |      2 |      3 |      1
         |      2 |      3 |      2
       2 |        |      3 |      3
         |      2 |      7 |      4
         |      3 |      4 |      5
-(4 rows)
+(5 rows)
 
 DROP TABLE FKTABLE;
 DROP TABLE PKTABLE;
@@ -572,49 +606,58 @@
 
 -- Try to update something that will set null
 UPDATE PKTABLE set ptest2=5 where ptest2=2;
+ERROR:  cannot update table "fktable" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "UPDATE ONLY "public"."fktable" SET "ftest1" = NULL, "ftest2" = NULL, "ftest3" = NULL WHERE $1 OPERATOR(pg_catalog.=) "ftest1" AND $2 OPERATOR(pg_catalog.=) "ftest2" AND $3 OPERATOR(pg_catalog.=) "ftest3""
 -- Try to update something that should not set null
 UPDATE PKTABLE set ptest2=2 WHERE ptest2=3 and ptest1=1;
+ERROR:  duplicate key value violates unique constraint "pktable_pkey"
+DETAIL:  Key (ptest1, ptest2, ptest3)=(1, 2, 3) already exists.
 -- Show PKTABLE and FKTABLE
 SELECT * from PKTABLE;
  ptest1 | ptest2 | ptest3 | ptest4 
 --------+--------+--------+--------
+      1 |      2 |      3 | test1
+      1 |      3 |      3 | test2
       2 |      3 |      4 | test3
       2 |      4 |      5 | test4
-      1 |      5 |      3 | test1
-      1 |      2 |      3 | test2
 (4 rows)
 
 SELECT * from FKTABLE;
  ftest1 | ftest2 | ftest3 | ftest4 
 --------+--------+--------+--------
+      1 |      2 |      3 |      1
       2 |      3 |      4 |      1
         |      2 |      3 |      2
       2 |        |      3 |      3
         |      2 |      7 |      4
         |      3 |      4 |      5
-        |        |        |      1
 (6 rows)
 
 -- Try to delete something that should set default
 DELETE FROM PKTABLE where ptest1=2 and ptest2=3 and ptest3=4;
+ERROR:  cannot update table "fktable" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "UPDATE ONLY "public"."fktable" SET "ftest1" = DEFAULT, "ftest2" = DEFAULT, "ftest3" = DEFAULT WHERE $1 OPERATOR(pg_catalog.=) "ftest1" AND $2 OPERATOR(pg_catalog.=) "ftest2" AND $3 OPERATOR(pg_catalog.=) "ftest3""
 -- Show PKTABLE and FKTABLE
 SELECT * from PKTABLE;
  ptest1 | ptest2 | ptest3 | ptest4 
 --------+--------+--------+--------
+      1 |      2 |      3 | test1
+      1 |      3 |      3 | test2
+      2 |      3 |      4 | test3
       2 |      4 |      5 | test4
-      1 |      5 |      3 | test1
-      1 |      2 |      3 | test2
-(3 rows)
+(4 rows)
 
 SELECT * from FKTABLE;
  ftest1 | ftest2 | ftest3 | ftest4 
 --------+--------+--------+--------
+      1 |      2 |      3 |      1
+      2 |      3 |      4 |      1
         |      2 |      3 |      2
       2 |        |      3 |      3
         |      2 |      7 |      4
         |      3 |      4 |      5
-        |        |        |      1
-      0 |        |        |      1
 (6 rows)
 
 -- Try to delete something that should not set default
@@ -623,19 +666,21 @@
 SELECT * from PKTABLE;
  ptest1 | ptest2 | ptest3 | ptest4 
 --------+--------+--------+--------
+      1 |      2 |      3 | test1
+      1 |      3 |      3 | test2
+      2 |      3 |      4 | test3
       2 |      4 |      5 | test4
-      1 |      2 |      3 | test2
-(2 rows)
+(4 rows)
 
 SELECT * from FKTABLE;
  ftest1 | ftest2 | ftest3 | ftest4 
 --------+--------+--------+--------
+      1 |      2 |      3 |      1
+      2 |      3 |      4 |      1
         |      2 |      3 |      2
       2 |        |      3 |      3
         |      2 |      7 |      4
         |      3 |      4 |      5
-        |        |        |      1
-      0 |        |        |      1
 (6 rows)
 
 DROP TABLE FKTABLE;
@@ -678,81 +723,99 @@
 
 -- Try to update something that will fail
 UPDATE PKTABLE set ptest2=5 where ptest2=2;
-ERROR:  insert or update on table "fktable" violates foreign key constraint "constrname3"
-DETAIL:  Key (ftest1, ftest2, ftest3)=(0, -1, -2) is not present in table "pktable".
+ERROR:  cannot update table "fktable" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "UPDATE ONLY "public"."fktable" SET "ftest1" = DEFAULT, "ftest2" = DEFAULT, "ftest3" = DEFAULT WHERE $1 OPERATOR(pg_catalog.=) "ftest1" AND $2 OPERATOR(pg_catalog.=) "ftest2" AND $3 OPERATOR(pg_catalog.=) "ftest3""
 -- Try to update something that will set default
 UPDATE PKTABLE set ptest1=0, ptest2=-1, ptest3=-2 where ptest2=2;
+ERROR:  cannot update table "fktable" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "UPDATE ONLY "public"."fktable" SET "ftest1" = DEFAULT, "ftest2" = DEFAULT, "ftest3" = DEFAULT WHERE $1 OPERATOR(pg_catalog.=) "ftest1" AND $2 OPERATOR(pg_catalog.=) "ftest2" AND $3 OPERATOR(pg_catalog.=) "ftest3""
 UPDATE PKTABLE set ptest2=10 where ptest2=4;
+ERROR:  cannot update table "fktable" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "UPDATE ONLY "public"."fktable" SET "ftest1" = DEFAULT, "ftest2" = DEFAULT, "ftest3" = DEFAULT WHERE $1 OPERATOR(pg_catalog.=) "ftest1" AND $2 OPERATOR(pg_catalog.=) "ftest2" AND $3 OPERATOR(pg_catalog.=) "ftest3""
 -- Try to update something that should not set default
 UPDATE PKTABLE set ptest2=2 WHERE ptest2=3 and ptest1=1;
+ERROR:  duplicate key value violates unique constraint "pktable_pkey"
+DETAIL:  Key (ptest1, ptest2, ptest3)=(1, 2, 3) already exists.
 -- Show PKTABLE and FKTABLE
 SELECT * from PKTABLE;
  ptest1 | ptest2 | ptest3 | ptest4 
 --------+--------+--------+--------
+      1 |      2 |      3 | test1
+      1 |      3 |      3 | test2
       2 |      3 |      4 | test3
+      2 |      4 |      5 | test4
       2 |     -1 |      5 | test5
-      0 |     -1 |     -2 | test1
-      2 |     10 |      5 | test4
-      1 |      2 |      3 | test2
 (5 rows)
 
 SELECT * from FKTABLE;
  ftest1 | ftest2 | ftest3 | ftest4 
 --------+--------+--------+--------
+      1 |      2 |      3 |      1
       2 |      3 |      4 |      1
+      2 |      4 |      5 |      1
         |      2 |      3 |      2
       2 |        |      3 |      3
         |      2 |      7 |      4
         |      3 |      4 |      5
-      0 |     -1 |     -2 |      1
-      0 |     -1 |     -2 |      1
 (7 rows)
 
 -- Try to delete something that should set null
 DELETE FROM PKTABLE where ptest1=2 and ptest2=3 and ptest3=4;
+ERROR:  cannot update table "fktable" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "UPDATE ONLY "public"."fktable" SET "ftest1" = NULL, "ftest2" = NULL, "ftest3" = NULL WHERE $1 OPERATOR(pg_catalog.=) "ftest1" AND $2 OPERATOR(pg_catalog.=) "ftest2" AND $3 OPERATOR(pg_catalog.=) "ftest3""
 -- Show PKTABLE and FKTABLE
 SELECT * from PKTABLE;
  ptest1 | ptest2 | ptest3 | ptest4 
 --------+--------+--------+--------
+      1 |      2 |      3 | test1
+      1 |      3 |      3 | test2
+      2 |      3 |      4 | test3
+      2 |      4 |      5 | test4
       2 |     -1 |      5 | test5
-      0 |     -1 |     -2 | test1
-      2 |     10 |      5 | test4
-      1 |      2 |      3 | test2
-(4 rows)
+(5 rows)
 
 SELECT * from FKTABLE;
  ftest1 | ftest2 | ftest3 | ftest4 
 --------+--------+--------+--------
+      1 |      2 |      3 |      1
+      2 |      3 |      4 |      1
+      2 |      4 |      5 |      1
         |      2 |      3 |      2
       2 |        |      3 |      3
         |      2 |      7 |      4
         |      3 |      4 |      5
-      0 |     -1 |     -2 |      1
-      0 |     -1 |     -2 |      1
-        |        |        |      1
 (7 rows)
 
 -- Try to delete something that should not set null
 DELETE FROM PKTABLE where ptest2=-1 and ptest3=5;
+ERROR:  cannot update table "fktable" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "UPDATE ONLY "public"."fktable" SET "ftest1" = NULL, "ftest2" = NULL, "ftest3" = NULL WHERE $1 OPERATOR(pg_catalog.=) "ftest1" AND $2 OPERATOR(pg_catalog.=) "ftest2" AND $3 OPERATOR(pg_catalog.=) "ftest3""
 -- Show PKTABLE and FKTABLE
 SELECT * from PKTABLE;
  ptest1 | ptest2 | ptest3 | ptest4 
 --------+--------+--------+--------
-      0 |     -1 |     -2 | test1
-      2 |     10 |      5 | test4
-      1 |      2 |      3 | test2
-(3 rows)
+      1 |      2 |      3 | test1
+      1 |      3 |      3 | test2
+      2 |      3 |      4 | test3
+      2 |      4 |      5 | test4
+      2 |     -1 |      5 | test5
+(5 rows)
 
 SELECT * from FKTABLE;
  ftest1 | ftest2 | ftest3 | ftest4 
 --------+--------+--------+--------
+      1 |      2 |      3 |      1
+      2 |      3 |      4 |      1
+      2 |      4 |      5 |      1
         |      2 |      3 |      2
       2 |        |      3 |      3
         |      2 |      7 |      4
         |      3 |      4 |      5
-      0 |     -1 |     -2 |      1
-      0 |     -1 |     -2 |      1
-        |        |        |      1
 (7 rows)
 
 DROP TABLE FKTABLE;
@@ -798,9 +861,11 @@
 ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_ftest1_fkey"
 DETAIL:  Key (ftest1)=(43) is not present in table "pktable".
 UPDATE FKTABLE SET ftest1 = ftest1;	-- should succeed
+ERROR:  cannot update table "fktable" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
 UPDATE FKTABLE SET ftest1 = ftest1 + 1;	-- should fail
-ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_ftest1_fkey"
-DETAIL:  Key (ftest1)=(43) is not present in table "pktable".
+ERROR:  cannot update table "fktable" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
 DROP TABLE FKTABLE;
 -- This should fail, because we'd have to cast numeric to int which is
 -- not an implicit coercion (or use numeric=numeric, but that's not part
@@ -820,9 +885,11 @@
 ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_ftest1_fkey"
 DETAIL:  Key (ftest1)=(43) is not present in table "pktable".
 UPDATE FKTABLE SET ftest1 = ftest1;	-- should succeed
+ERROR:  cannot update table "fktable" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
 UPDATE FKTABLE SET ftest1 = ftest1 + 1;	-- should fail
-ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_ftest1_fkey"
-DETAIL:  Key (ftest1)=(43) is not present in table "pktable".
+ERROR:  cannot update table "fktable" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
 DROP TABLE FKTABLE;
 DROP TABLE PKTABLE;
 -- Two columns, two tables
@@ -1515,17 +1582,20 @@
 (1 row)
 
 update pktable2 set a = '0' where a = '-0';
+ERROR:  cannot update table "fktable2" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "UPDATE ONLY "public"."fktable2" SET "x" = $1, "y" = $2 WHERE $3 OPERATOR(pg_catalog.=) "x" AND $4 OPERATOR(pg_catalog.=) "y""
 select * from pktable2;
- a | b  
----+----
- 0 | -0
+ a  | b  
+----+----
+ -0 | -0
 (1 row)
 
 -- should have updated fktable2.x
 select * from fktable2;
- x | y  
----+----
- 0 | -0
+ x  | y  
+----+----
+ -0 | -0
 (1 row)
 
 drop table pktable2, fktable2;
@@ -1599,11 +1669,13 @@
 INSERT INTO fk_partitioned_fk (a,b) VALUES (2501, 2503);
 -- this update fails because there is no referenced row
 UPDATE fk_partitioned_fk SET a = a + 1 WHERE a = 2501;
-ERROR:  insert or update on table "fk_partitioned_fk_3_1" violates foreign key constraint "fk_partitioned_fk_a_b_fkey"
-DETAIL:  Key (a, b)=(2502, 2503) is not present in table "fk_notpartitioned_pk".
+ERROR:  cannot update table "fk_partitioned_fk_3_0" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
 -- but we can fix it thusly:
 INSERT INTO fk_notpartitioned_pk (a,b) VALUES (2502, 2503);
 UPDATE fk_partitioned_fk SET a = a + 1 WHERE a = 2501;
+ERROR:  cannot update table "fk_partitioned_fk_3_0" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
 -- these updates would leave lingering rows in the referencing table; disallow
 UPDATE fk_notpartitioned_pk SET b = 502 WHERE a = 500;
 ERROR:  update or delete on table "fk_notpartitioned_pk" violates foreign key constraint "fk_partitioned_fk_a_b_fkey" on table "fk_partitioned_fk"
@@ -1616,953 +1688,11 @@
 DETAIL:  Key (a, b)=(2500, 2502) is still referenced from table "fk_partitioned_fk".
 -- check psql behavior
 \d fk_notpartitioned_pk
-        Table "public.fk_notpartitioned_pk"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           | not null | 
- b      | integer |           | not null | 
-Indexes:
-    "fk_notpartitioned_pk_pkey" PRIMARY KEY, btree (a, b)
-Referenced by:
-    TABLE "fk_partitioned_fk" CONSTRAINT "fk_partitioned_fk_a_b_fkey" FOREIGN KEY (a, b) REFERENCES fk_notpartitioned_pk(a, b)
-
-ALTER TABLE fk_partitioned_fk DROP CONSTRAINT fk_partitioned_fk_a_b_fkey;
--- done.
-DROP TABLE fk_notpartitioned_pk, fk_partitioned_fk;
--- Altering a type referenced by a foreign key needs to drop/recreate the FK.
--- Ensure that works.
-CREATE TABLE fk_notpartitioned_pk (a INT, PRIMARY KEY(a), CHECK (a > 0));
-CREATE TABLE fk_partitioned_fk (a INT REFERENCES fk_notpartitioned_pk(a) PRIMARY KEY) PARTITION BY RANGE(a);
-CREATE TABLE fk_partitioned_fk_1 PARTITION OF fk_partitioned_fk FOR VALUES FROM (MINVALUE) TO (MAXVALUE);
-INSERT INTO fk_notpartitioned_pk VALUES (1);
-INSERT INTO fk_partitioned_fk VALUES (1);
-ALTER TABLE fk_notpartitioned_pk ALTER COLUMN a TYPE bigint;
-DELETE FROM fk_notpartitioned_pk WHERE a = 1;
-ERROR:  update or delete on table "fk_notpartitioned_pk" violates foreign key constraint "fk_partitioned_fk_a_fkey" on table "fk_partitioned_fk"
-DETAIL:  Key (a)=(1) is still referenced from table "fk_partitioned_fk".
-DROP TABLE fk_notpartitioned_pk, fk_partitioned_fk;
--- Test some other exotic foreign key features: MATCH SIMPLE, ON UPDATE/DELETE
--- actions
-CREATE TABLE fk_notpartitioned_pk (a int, b int, primary key (a, b));
-CREATE TABLE fk_partitioned_fk (a int default 2501, b int default 142857) PARTITION BY LIST (a);
-CREATE TABLE fk_partitioned_fk_1 PARTITION OF fk_partitioned_fk FOR VALUES IN (NULL,500,501,502);
-ALTER TABLE fk_partitioned_fk ADD FOREIGN KEY (a, b)
-  REFERENCES fk_notpartitioned_pk MATCH SIMPLE
-  ON DELETE SET NULL ON UPDATE SET NULL;
-CREATE TABLE fk_partitioned_fk_2 PARTITION OF fk_partitioned_fk FOR VALUES IN (1500,1502);
-CREATE TABLE fk_partitioned_fk_3 (a int, b int);
-ALTER TABLE fk_partitioned_fk ATTACH PARTITION fk_partitioned_fk_3 FOR VALUES IN (2500,2501,2502,2503);
--- this insert fails
-INSERT INTO fk_partitioned_fk (a, b) VALUES (2502, 2503);
-ERROR:  insert or update on table "fk_partitioned_fk_3" violates foreign key constraint "fk_partitioned_fk_a_b_fkey"
-DETAIL:  Key (a, b)=(2502, 2503) is not present in table "fk_notpartitioned_pk".
-INSERT INTO fk_partitioned_fk_3 (a, b) VALUES (2502, 2503);
-ERROR:  insert or update on table "fk_partitioned_fk_3" violates foreign key constraint "fk_partitioned_fk_a_b_fkey"
-DETAIL:  Key (a, b)=(2502, 2503) is not present in table "fk_notpartitioned_pk".
--- but since the FK is MATCH SIMPLE, this one doesn't
-INSERT INTO fk_partitioned_fk_3 (a, b) VALUES (2502, NULL);
--- now create the referenced row ...
-INSERT INTO fk_notpartitioned_pk VALUES (2502, 2503);
---- and now the same insert work
-INSERT INTO fk_partitioned_fk_3 (a, b) VALUES (2502, 2503);
--- this always works
-INSERT INTO fk_partitioned_fk (a,b) VALUES (NULL, NULL);
--- MATCH FULL
-INSERT INTO fk_notpartitioned_pk VALUES (1, 2);
-CREATE TABLE fk_partitioned_fk_full (x int, y int) PARTITION BY RANGE (x);
-CREATE TABLE fk_partitioned_fk_full_1 PARTITION OF fk_partitioned_fk_full DEFAULT;
-INSERT INTO fk_partitioned_fk_full VALUES (1, NULL);
-ALTER TABLE fk_partitioned_fk_full ADD FOREIGN KEY (x, y) REFERENCES fk_notpartitioned_pk MATCH FULL;  -- fails
-ERROR:  insert or update on table "fk_partitioned_fk_full_1" violates foreign key constraint "fk_partitioned_fk_full_x_y_fkey"
-DETAIL:  MATCH FULL does not allow mixing of null and nonnull key values.
-TRUNCATE fk_partitioned_fk_full;
-ALTER TABLE fk_partitioned_fk_full ADD FOREIGN KEY (x, y) REFERENCES fk_notpartitioned_pk MATCH FULL;
-INSERT INTO fk_partitioned_fk_full VALUES (1, NULL);  -- fails
-ERROR:  insert or update on table "fk_partitioned_fk_full_1" violates foreign key constraint "fk_partitioned_fk_full_x_y_fkey"
-DETAIL:  MATCH FULL does not allow mixing of null and nonnull key values.
-DROP TABLE fk_partitioned_fk_full;
--- ON UPDATE SET NULL
-SELECT tableoid::regclass, a, b FROM fk_partitioned_fk WHERE b IS NULL ORDER BY a;
-      tableoid       |  a   | b 
----------------------+------+---
- fk_partitioned_fk_3 | 2502 |  
- fk_partitioned_fk_1 |      |  
-(2 rows)
-
-UPDATE fk_notpartitioned_pk SET a = a + 1 WHERE a = 2502;
-SELECT tableoid::regclass, a, b FROM fk_partitioned_fk WHERE b IS NULL ORDER BY a;
-      tableoid       |  a   | b 
----------------------+------+---
- fk_partitioned_fk_3 | 2502 |  
- fk_partitioned_fk_1 |      |  
- fk_partitioned_fk_1 |      |  
-(3 rows)
-
--- ON DELETE SET NULL
-INSERT INTO fk_partitioned_fk VALUES (2503, 2503);
-SELECT count(*) FROM fk_partitioned_fk WHERE a IS NULL;
- count 
--------
-     2
-(1 row)
-
-DELETE FROM fk_notpartitioned_pk;
-SELECT count(*) FROM fk_partitioned_fk WHERE a IS NULL;
- count 
--------
-     3
-(1 row)
-
--- ON UPDATE/DELETE SET DEFAULT
-ALTER TABLE fk_partitioned_fk DROP CONSTRAINT fk_partitioned_fk_a_b_fkey;
-ALTER TABLE fk_partitioned_fk ADD FOREIGN KEY (a, b)
-  REFERENCES fk_notpartitioned_pk
-  ON DELETE SET DEFAULT ON UPDATE SET DEFAULT;
-INSERT INTO fk_notpartitioned_pk VALUES (2502, 2503);
-INSERT INTO fk_partitioned_fk_3 (a, b) VALUES (2502, 2503);
--- this fails, because the defaults for the referencing table are not present
--- in the referenced table:
-UPDATE fk_notpartitioned_pk SET a = 1500 WHERE a = 2502;
-ERROR:  insert or update on table "fk_partitioned_fk_3" violates foreign key constraint "fk_partitioned_fk_a_b_fkey"
-DETAIL:  Key (a, b)=(2501, 142857) is not present in table "fk_notpartitioned_pk".
--- but inserting the row we can make it work:
-INSERT INTO fk_notpartitioned_pk VALUES (2501, 142857);
-UPDATE fk_notpartitioned_pk SET a = 1500 WHERE a = 2502;
-SELECT * FROM fk_partitioned_fk WHERE b = 142857;
-  a   |   b    
-------+--------
- 2501 | 142857
-(1 row)
-
--- ON UPDATE/DELETE CASCADE
-ALTER TABLE fk_partitioned_fk DROP CONSTRAINT fk_partitioned_fk_a_b_fkey;
-ALTER TABLE fk_partitioned_fk ADD FOREIGN KEY (a, b)
-  REFERENCES fk_notpartitioned_pk
-  ON DELETE CASCADE ON UPDATE CASCADE;
-UPDATE fk_notpartitioned_pk SET a = 2502 WHERE a = 2501;
-SELECT * FROM fk_partitioned_fk WHERE b = 142857;
-  a   |   b    
-------+--------
- 2502 | 142857
-(1 row)
-
--- Now you see it ...
-SELECT * FROM fk_partitioned_fk WHERE b = 142857;
-  a   |   b    
-------+--------
- 2502 | 142857
-(1 row)
-
-DELETE FROM fk_notpartitioned_pk WHERE b = 142857;
--- now you don't.
-SELECT * FROM fk_partitioned_fk WHERE a = 142857;
- a | b 
----+---
-(0 rows)
-
--- verify that DROP works
-DROP TABLE fk_partitioned_fk_2;
--- Test behavior of the constraint together with attaching and detaching
--- partitions.
-CREATE TABLE fk_partitioned_fk_2 PARTITION OF fk_partitioned_fk FOR VALUES IN (1500,1502);
-ALTER TABLE fk_partitioned_fk DETACH PARTITION fk_partitioned_fk_2;
-BEGIN;
-DROP TABLE fk_partitioned_fk;
--- constraint should still be there
-\d fk_partitioned_fk_2;
-        Table "public.fk_partitioned_fk_2"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 2501
- b      | integer |           |          | 142857
-Foreign-key constraints:
-    "fk_partitioned_fk_a_b_fkey" FOREIGN KEY (a, b) REFERENCES fk_notpartitioned_pk(a, b) ON UPDATE CASCADE ON DELETE CASCADE
-
-ROLLBACK;
-ALTER TABLE fk_partitioned_fk ATTACH PARTITION fk_partitioned_fk_2 FOR VALUES IN (1500,1502);
-DROP TABLE fk_partitioned_fk_2;
-CREATE TABLE fk_partitioned_fk_2 (b int, c text, a int,
-	FOREIGN KEY (a, b) REFERENCES fk_notpartitioned_pk ON UPDATE CASCADE ON DELETE CASCADE);
-ALTER TABLE fk_partitioned_fk_2 DROP COLUMN c;
-ALTER TABLE fk_partitioned_fk ATTACH PARTITION fk_partitioned_fk_2 FOR VALUES IN (1500,1502);
--- should have only one constraint
-\d fk_partitioned_fk_2
-        Table "public.fk_partitioned_fk_2"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- b      | integer |           |          | 
- a      | integer |           |          | 
-Partition of: fk_partitioned_fk FOR VALUES IN (1500, 1502)
-Foreign-key constraints:
-    TABLE "fk_partitioned_fk" CONSTRAINT "fk_partitioned_fk_a_b_fkey" FOREIGN KEY (a, b) REFERENCES fk_notpartitioned_pk(a, b) ON UPDATE CASCADE ON DELETE CASCADE
-
-DROP TABLE fk_partitioned_fk_2;
-CREATE TABLE fk_partitioned_fk_4 (a int, b int, FOREIGN KEY (a, b) REFERENCES fk_notpartitioned_pk(a, b) ON UPDATE CASCADE ON DELETE CASCADE) PARTITION BY RANGE (b, a);
-CREATE TABLE fk_partitioned_fk_4_1 PARTITION OF fk_partitioned_fk_4 FOR VALUES FROM (1,1) TO (100,100);
-CREATE TABLE fk_partitioned_fk_4_2 (a int, b int, FOREIGN KEY (a, b) REFERENCES fk_notpartitioned_pk(a, b) ON UPDATE SET NULL);
-ALTER TABLE fk_partitioned_fk_4 ATTACH PARTITION fk_partitioned_fk_4_2 FOR VALUES FROM (100,100) TO (1000,1000);
-ALTER TABLE fk_partitioned_fk ATTACH PARTITION fk_partitioned_fk_4 FOR VALUES IN (3500,3502);
-ALTER TABLE fk_partitioned_fk DETACH PARTITION fk_partitioned_fk_4;
-ALTER TABLE fk_partitioned_fk ATTACH PARTITION fk_partitioned_fk_4 FOR VALUES IN (3500,3502);
--- should only have one constraint
-\d fk_partitioned_fk_4
-  Partitioned table "public.fk_partitioned_fk_4"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
- b      | integer |           |          | 
-Partition of: fk_partitioned_fk FOR VALUES IN (3500, 3502)
-Partition key: RANGE (b, a)
-Foreign-key constraints:
-    TABLE "fk_partitioned_fk" CONSTRAINT "fk_partitioned_fk_a_b_fkey" FOREIGN KEY (a, b) REFERENCES fk_notpartitioned_pk(a, b) ON UPDATE CASCADE ON DELETE CASCADE
-Number of partitions: 2 (Use \d+ to list them.)
-
-\d fk_partitioned_fk_4_1
-       Table "public.fk_partitioned_fk_4_1"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
- b      | integer |           |          | 
-Partition of: fk_partitioned_fk_4 FOR VALUES FROM (1, 1) TO (100, 100)
-Foreign-key constraints:
-    TABLE "fk_partitioned_fk" CONSTRAINT "fk_partitioned_fk_a_b_fkey" FOREIGN KEY (a, b) REFERENCES fk_notpartitioned_pk(a, b) ON UPDATE CASCADE ON DELETE CASCADE
-
--- this one has an FK with mismatched properties
-\d fk_partitioned_fk_4_2
-       Table "public.fk_partitioned_fk_4_2"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
- b      | integer |           |          | 
-Partition of: fk_partitioned_fk_4 FOR VALUES FROM (100, 100) TO (1000, 1000)
-Foreign-key constraints:
-    "fk_partitioned_fk_4_2_a_b_fkey" FOREIGN KEY (a, b) REFERENCES fk_notpartitioned_pk(a, b) ON UPDATE SET NULL
-    TABLE "fk_partitioned_fk" CONSTRAINT "fk_partitioned_fk_a_b_fkey" FOREIGN KEY (a, b) REFERENCES fk_notpartitioned_pk(a, b) ON UPDATE CASCADE ON DELETE CASCADE
-
-CREATE TABLE fk_partitioned_fk_5 (a int, b int,
-	FOREIGN KEY (a, b) REFERENCES fk_notpartitioned_pk(a, b) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE,
-	FOREIGN KEY (a, b) REFERENCES fk_notpartitioned_pk(a, b) MATCH FULL ON UPDATE CASCADE ON DELETE CASCADE)
-  PARTITION BY RANGE (a);
-CREATE TABLE fk_partitioned_fk_5_1 (a int, b int, FOREIGN KEY (a, b) REFERENCES fk_notpartitioned_pk);
-ALTER TABLE fk_partitioned_fk ATTACH PARTITION fk_partitioned_fk_5 FOR VALUES IN (4500);
-ALTER TABLE fk_partitioned_fk_5 ATTACH PARTITION fk_partitioned_fk_5_1 FOR VALUES FROM (0) TO (10);
-ALTER TABLE fk_partitioned_fk DETACH PARTITION fk_partitioned_fk_5;
-ALTER TABLE fk_partitioned_fk ATTACH PARTITION fk_partitioned_fk_5 FOR VALUES IN (4500);
--- this one has two constraints, similar but not quite the one in the parent,
--- so it gets a new one
-\d fk_partitioned_fk_5
-  Partitioned table "public.fk_partitioned_fk_5"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
- b      | integer |           |          | 
-Partition of: fk_partitioned_fk FOR VALUES IN (4500)
-Partition key: RANGE (a)
-Foreign-key constraints:
-    "fk_partitioned_fk_5_a_b_fkey" FOREIGN KEY (a, b) REFERENCES fk_notpartitioned_pk(a, b) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE
-    "fk_partitioned_fk_5_a_b_fkey1" FOREIGN KEY (a, b) REFERENCES fk_notpartitioned_pk(a, b) MATCH FULL ON UPDATE CASCADE ON DELETE CASCADE
-    TABLE "fk_partitioned_fk" CONSTRAINT "fk_partitioned_fk_a_b_fkey" FOREIGN KEY (a, b) REFERENCES fk_notpartitioned_pk(a, b) ON UPDATE CASCADE ON DELETE CASCADE
-Number of partitions: 1 (Use \d+ to list them.)
-
--- verify that it works to reattaching a child with multiple candidate
--- constraints
-ALTER TABLE fk_partitioned_fk_5 DETACH PARTITION fk_partitioned_fk_5_1;
-ALTER TABLE fk_partitioned_fk_5 ATTACH PARTITION fk_partitioned_fk_5_1 FOR VALUES FROM (0) TO (10);
-\d fk_partitioned_fk_5_1
-       Table "public.fk_partitioned_fk_5_1"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
- b      | integer |           |          | 
-Partition of: fk_partitioned_fk_5 FOR VALUES FROM (0) TO (10)
-Foreign-key constraints:
-    "fk_partitioned_fk_5_1_a_b_fkey" FOREIGN KEY (a, b) REFERENCES fk_notpartitioned_pk(a, b)
-    TABLE "fk_partitioned_fk_5" CONSTRAINT "fk_partitioned_fk_5_a_b_fkey" FOREIGN KEY (a, b) REFERENCES fk_notpartitioned_pk(a, b) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE
-    TABLE "fk_partitioned_fk_5" CONSTRAINT "fk_partitioned_fk_5_a_b_fkey1" FOREIGN KEY (a, b) REFERENCES fk_notpartitioned_pk(a, b) MATCH FULL ON UPDATE CASCADE ON DELETE CASCADE
-    TABLE "fk_partitioned_fk" CONSTRAINT "fk_partitioned_fk_a_b_fkey" FOREIGN KEY (a, b) REFERENCES fk_notpartitioned_pk(a, b) ON UPDATE CASCADE ON DELETE CASCADE
-
--- verify that attaching a table checks that the existing data satisfies the
--- constraint
-CREATE TABLE fk_partitioned_fk_2 (a int, b int) PARTITION BY RANGE (b);
-CREATE TABLE fk_partitioned_fk_2_1 PARTITION OF fk_partitioned_fk_2 FOR VALUES FROM (0) TO (1000);
-CREATE TABLE fk_partitioned_fk_2_2 PARTITION OF fk_partitioned_fk_2 FOR VALUES FROM (1000) TO (2000);
-INSERT INTO fk_partitioned_fk_2 VALUES (1600, 601), (1600, 1601);
-ALTER TABLE fk_partitioned_fk ATTACH PARTITION fk_partitioned_fk_2
-  FOR VALUES IN (1600);
-ERROR:  insert or update on table "fk_partitioned_fk_2_1" violates foreign key constraint "fk_partitioned_fk_a_b_fkey"
-DETAIL:  Key (a, b)=(1600, 601) is not present in table "fk_notpartitioned_pk".
-INSERT INTO fk_notpartitioned_pk VALUES (1600, 601), (1600, 1601);
-ALTER TABLE fk_partitioned_fk ATTACH PARTITION fk_partitioned_fk_2
-  FOR VALUES IN (1600);
--- leave these tables around intentionally
--- test the case when the referenced table is owned by a different user
-create role regress_other_partitioned_fk_owner;
-grant references on fk_notpartitioned_pk to regress_other_partitioned_fk_owner;
-set role regress_other_partitioned_fk_owner;
-create table other_partitioned_fk(a int, b int) partition by list (a);
-create table other_partitioned_fk_1 partition of other_partitioned_fk
-  for values in (2048);
-insert into other_partitioned_fk
-  select 2048, x from generate_series(1,10) x;
--- this should fail
-alter table other_partitioned_fk add foreign key (a, b)
-  references fk_notpartitioned_pk(a, b);
-ERROR:  insert or update on table "other_partitioned_fk_1" violates foreign key constraint "other_partitioned_fk_a_b_fkey"
-DETAIL:  Key (a, b)=(2048, 1) is not present in table "fk_notpartitioned_pk".
--- add the missing keys and retry
-reset role;
-insert into fk_notpartitioned_pk (a, b)
-  select 2048, x from generate_series(1,10) x;
-set role regress_other_partitioned_fk_owner;
-alter table other_partitioned_fk add foreign key (a, b)
-  references fk_notpartitioned_pk(a, b);
--- clean up
-drop table other_partitioned_fk;
-reset role;
-revoke all on fk_notpartitioned_pk from regress_other_partitioned_fk_owner;
-drop role regress_other_partitioned_fk_owner;
--- Test creating a constraint at the parent that already exists in partitions.
--- There should be no duplicated constraints, and attempts to drop the
--- constraint in partitions should raise appropriate errors.
-create schema fkpart0
-  create table pkey (a int primary key)
-  create table fk_part (a int) partition by list (a)
-  create table fk_part_1 partition of fk_part
-      (foreign key (a) references fkpart0.pkey) for values in (1)
-  create table fk_part_23 partition of fk_part
-      (foreign key (a) references fkpart0.pkey) for values in (2, 3)
-      partition by list (a)
-  create table fk_part_23_2 partition of fk_part_23 for values in (2);
-alter table fkpart0.fk_part add foreign key (a) references fkpart0.pkey;
-\d fkpart0.fk_part_1	\\ -- should have only one FK
-             Table "fkpart0.fk_part_1"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
-Partition of: fkpart0.fk_part FOR VALUES IN (1)
-Foreign-key constraints:
-    TABLE "fkpart0.fk_part" CONSTRAINT "fk_part_a_fkey" FOREIGN KEY (a) REFERENCES fkpart0.pkey(a)
-
-alter table fkpart0.fk_part_1 drop constraint fk_part_1_a_fkey;
-ERROR:  cannot drop inherited constraint "fk_part_1_a_fkey" of relation "fk_part_1"
-\d fkpart0.fk_part_23	\\ -- should have only one FK
-      Partitioned table "fkpart0.fk_part_23"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
-Partition of: fkpart0.fk_part FOR VALUES IN (2, 3)
-Partition key: LIST (a)
-Foreign-key constraints:
-    TABLE "fkpart0.fk_part" CONSTRAINT "fk_part_a_fkey" FOREIGN KEY (a) REFERENCES fkpart0.pkey(a)
-Number of partitions: 1 (Use \d+ to list them.)
-
-\d fkpart0.fk_part_23_2	\\ -- should have only one FK
-           Table "fkpart0.fk_part_23_2"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
-Partition of: fkpart0.fk_part_23 FOR VALUES IN (2)
-Foreign-key constraints:
-    TABLE "fkpart0.fk_part" CONSTRAINT "fk_part_a_fkey" FOREIGN KEY (a) REFERENCES fkpart0.pkey(a)
-
-alter table fkpart0.fk_part_23 drop constraint fk_part_23_a_fkey;
-ERROR:  cannot drop inherited constraint "fk_part_23_a_fkey" of relation "fk_part_23"
-alter table fkpart0.fk_part_23_2 drop constraint fk_part_23_a_fkey;
-ERROR:  cannot drop inherited constraint "fk_part_23_a_fkey" of relation "fk_part_23_2"
-create table fkpart0.fk_part_4 partition of fkpart0.fk_part for values in (4);
-\d fkpart0.fk_part_4
-             Table "fkpart0.fk_part_4"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
-Partition of: fkpart0.fk_part FOR VALUES IN (4)
-Foreign-key constraints:
-    TABLE "fkpart0.fk_part" CONSTRAINT "fk_part_a_fkey" FOREIGN KEY (a) REFERENCES fkpart0.pkey(a)
-
-alter table fkpart0.fk_part_4 drop constraint fk_part_a_fkey;
-ERROR:  cannot drop inherited constraint "fk_part_a_fkey" of relation "fk_part_4"
-create table fkpart0.fk_part_56 partition of fkpart0.fk_part
-    for values in (5,6) partition by list (a);
-create table fkpart0.fk_part_56_5 partition of fkpart0.fk_part_56
-    for values in (5);
-\d fkpart0.fk_part_56
-      Partitioned table "fkpart0.fk_part_56"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
-Partition of: fkpart0.fk_part FOR VALUES IN (5, 6)
-Partition key: LIST (a)
-Foreign-key constraints:
-    TABLE "fkpart0.fk_part" CONSTRAINT "fk_part_a_fkey" FOREIGN KEY (a) REFERENCES fkpart0.pkey(a)
-Number of partitions: 1 (Use \d+ to list them.)
-
-alter table fkpart0.fk_part_56 drop constraint fk_part_a_fkey;
-ERROR:  cannot drop inherited constraint "fk_part_a_fkey" of relation "fk_part_56"
-alter table fkpart0.fk_part_56_5 drop constraint fk_part_a_fkey;
-ERROR:  cannot drop inherited constraint "fk_part_a_fkey" of relation "fk_part_56_5"
--- verify that attaching and detaching partitions maintains the right set of
--- triggers
-create schema fkpart1
-  create table pkey (a int primary key)
-  create table fk_part (a int) partition by list (a)
-  create table fk_part_1 partition of fk_part for values in (1) partition by list (a)
-  create table fk_part_1_1 partition of fk_part_1 for values in (1);
-alter table fkpart1.fk_part add foreign key (a) references fkpart1.pkey;
-insert into fkpart1.fk_part values (1);		-- should fail
-ERROR:  insert or update on table "fk_part_1_1" violates foreign key constraint "fk_part_a_fkey"
-DETAIL:  Key (a)=(1) is not present in table "pkey".
-insert into fkpart1.pkey values (1);
-insert into fkpart1.fk_part values (1);
-delete from fkpart1.pkey where a = 1;		-- should fail
-ERROR:  update or delete on table "pkey" violates foreign key constraint "fk_part_a_fkey" on table "fk_part"
-DETAIL:  Key (a)=(1) is still referenced from table "fk_part".
-alter table fkpart1.fk_part detach partition fkpart1.fk_part_1;
-create table fkpart1.fk_part_1_2 partition of fkpart1.fk_part_1 for values in (2);
-insert into fkpart1.fk_part_1 values (2);	-- should fail
-ERROR:  insert or update on table "fk_part_1_2" violates foreign key constraint "fk_part_a_fkey"
-DETAIL:  Key (a)=(2) is not present in table "pkey".
-delete from fkpart1.pkey where a = 1;
-ERROR:  update or delete on table "pkey" violates foreign key constraint "fk_part_a_fkey" on table "fk_part_1"
-DETAIL:  Key (a)=(1) is still referenced from table "fk_part_1".
--- verify that attaching and detaching partitions manipulates the inheritance
--- properties of their FK constraints correctly
-create schema fkpart2
-  create table pkey (a int primary key)
-  create table fk_part (a int, constraint fkey foreign key (a) references fkpart2.pkey) partition by list (a)
-  create table fk_part_1 partition of fkpart2.fk_part for values in (1) partition by list (a)
-  create table fk_part_1_1 (a int, constraint my_fkey foreign key (a) references fkpart2.pkey);
-alter table fkpart2.fk_part_1 attach partition fkpart2.fk_part_1_1 for values in (1);
-alter table fkpart2.fk_part_1 drop constraint fkey;	-- should fail
-ERROR:  cannot drop inherited constraint "fkey" of relation "fk_part_1"
-alter table fkpart2.fk_part_1_1 drop constraint my_fkey;	-- should fail
-ERROR:  cannot drop inherited constraint "my_fkey" of relation "fk_part_1_1"
-alter table fkpart2.fk_part detach partition fkpart2.fk_part_1;
-alter table fkpart2.fk_part_1 drop constraint fkey;	-- ok
-alter table fkpart2.fk_part_1_1 drop constraint my_fkey;	-- doesn't exist
-ERROR:  constraint "my_fkey" of relation "fk_part_1_1" does not exist
--- verify constraint deferrability
-create schema fkpart3
-  create table pkey (a int primary key)
-  create table fk_part (a int, constraint fkey foreign key (a) references fkpart3.pkey deferrable initially immediate) partition by list (a)
-  create table fk_part_1 partition of fkpart3.fk_part for values in (1) partition by list (a)
-  create table fk_part_1_1 partition of fkpart3.fk_part_1 for values in (1)
-  create table fk_part_2 partition of fkpart3.fk_part for values in (2);
-begin;
-set constraints fkpart3.fkey deferred;
-insert into fkpart3.fk_part values (1);
-insert into fkpart3.pkey values (1);
-commit;
-begin;
-set constraints fkpart3.fkey deferred;
-delete from fkpart3.pkey;
-delete from fkpart3.fk_part;
-commit;
-drop schema fkpart0, fkpart1, fkpart2, fkpart3 cascade;
-NOTICE:  drop cascades to 10 other objects
-DETAIL:  drop cascades to table fkpart3.pkey
-drop cascades to table fkpart3.fk_part
-drop cascades to table fkpart2.pkey
-drop cascades to table fkpart2.fk_part
-drop cascades to table fkpart2.fk_part_1
-drop cascades to table fkpart1.pkey
-drop cascades to table fkpart1.fk_part
-drop cascades to table fkpart1.fk_part_1
-drop cascades to table fkpart0.pkey
-drop cascades to table fkpart0.fk_part
--- Test a partitioned table as referenced table.
--- Verify basic functionality with a regular partition creation and a partition
--- with a different column layout, as well as partitions added (created and
--- attached) after creating the foreign key.
-CREATE SCHEMA fkpart3;
-SET search_path TO fkpart3;
-CREATE TABLE pk (a int PRIMARY KEY) PARTITION BY RANGE (a);
-CREATE TABLE pk1 PARTITION OF pk FOR VALUES FROM (0) TO (1000);
-CREATE TABLE pk2 (b int, a int);
-ALTER TABLE pk2 DROP COLUMN b;
-ALTER TABLE pk2 ALTER a SET NOT NULL;
-ALTER TABLE pk ATTACH PARTITION pk2 FOR VALUES FROM (1000) TO (2000);
-CREATE TABLE fk (a int) PARTITION BY RANGE (a);
-CREATE TABLE fk1 PARTITION OF fk FOR VALUES FROM (0) TO (750);
-ALTER TABLE fk ADD FOREIGN KEY (a) REFERENCES pk;
-CREATE TABLE fk2 (b int, a int) ;
-ALTER TABLE fk2 DROP COLUMN b;
-ALTER TABLE fk ATTACH PARTITION fk2 FOR VALUES FROM (750) TO (3500);
-CREATE TABLE pk3 PARTITION OF pk FOR VALUES FROM (2000) TO (3000);
-CREATE TABLE pk4 (LIKE pk);
-ALTER TABLE pk ATTACH PARTITION pk4 FOR VALUES FROM (3000) TO (4000);
-CREATE TABLE pk5 (c int, b int, a int NOT NULL) PARTITION BY RANGE (a);
-ALTER TABLE pk5 DROP COLUMN b, DROP COLUMN c;
-CREATE TABLE pk51 PARTITION OF pk5 FOR VALUES FROM (4000) TO (4500);
-CREATE TABLE pk52 PARTITION OF pk5 FOR VALUES FROM (4500) TO (5000);
-ALTER TABLE pk ATTACH PARTITION pk5 FOR VALUES FROM (4000) TO (5000);
-CREATE TABLE fk3 PARTITION OF fk FOR VALUES FROM (3500) TO (5000);
--- these should fail: referenced value not present
-INSERT into fk VALUES (1);
-ERROR:  insert or update on table "fk1" violates foreign key constraint "fk_a_fkey"
-DETAIL:  Key (a)=(1) is not present in table "pk".
-INSERT into fk VALUES (1000);
-ERROR:  insert or update on table "fk2" violates foreign key constraint "fk_a_fkey"
-DETAIL:  Key (a)=(1000) is not present in table "pk".
-INSERT into fk VALUES (2000);
-ERROR:  insert or update on table "fk2" violates foreign key constraint "fk_a_fkey"
-DETAIL:  Key (a)=(2000) is not present in table "pk".
-INSERT into fk VALUES (3000);
-ERROR:  insert or update on table "fk2" violates foreign key constraint "fk_a_fkey"
-DETAIL:  Key (a)=(3000) is not present in table "pk".
-INSERT into fk VALUES (4000);
-ERROR:  insert or update on table "fk3" violates foreign key constraint "fk_a_fkey"
-DETAIL:  Key (a)=(4000) is not present in table "pk".
-INSERT into fk VALUES (4500);
-ERROR:  insert or update on table "fk3" violates foreign key constraint "fk_a_fkey"
-DETAIL:  Key (a)=(4500) is not present in table "pk".
--- insert into the referenced table, now they should work
-INSERT into pk VALUES (1), (1000), (2000), (3000), (4000), (4500);
-INSERT into fk VALUES (1), (1000), (2000), (3000), (4000), (4500);
--- should fail: referencing value present
-DELETE FROM pk WHERE a = 1;
-ERROR:  update or delete on table "pk1" violates foreign key constraint "fk_a_fkey1" on table "fk"
-DETAIL:  Key (a)=(1) is still referenced from table "fk".
-DELETE FROM pk WHERE a = 1000;
-ERROR:  update or delete on table "pk2" violates foreign key constraint "fk_a_fkey2" on table "fk"
-DETAIL:  Key (a)=(1000) is still referenced from table "fk".
-DELETE FROM pk WHERE a = 2000;
-ERROR:  update or delete on table "pk3" violates foreign key constraint "fk_a_fkey3" on table "fk"
-DETAIL:  Key (a)=(2000) is still referenced from table "fk".
-DELETE FROM pk WHERE a = 3000;
-ERROR:  update or delete on table "pk4" violates foreign key constraint "fk_a_fkey4" on table "fk"
-DETAIL:  Key (a)=(3000) is still referenced from table "fk".
-DELETE FROM pk WHERE a = 4000;
-ERROR:  update or delete on table "pk51" violates foreign key constraint "fk_a_fkey6" on table "fk"
-DETAIL:  Key (a)=(4000) is still referenced from table "fk".
-DELETE FROM pk WHERE a = 4500;
-ERROR:  update or delete on table "pk52" violates foreign key constraint "fk_a_fkey7" on table "fk"
-DETAIL:  Key (a)=(4500) is still referenced from table "fk".
-UPDATE pk SET a = 2 WHERE a = 1;
-ERROR:  update or delete on table "pk1" violates foreign key constraint "fk_a_fkey1" on table "fk"
-DETAIL:  Key (a)=(1) is still referenced from table "fk".
-UPDATE pk SET a = 1002 WHERE a = 1000;
-ERROR:  update or delete on table "pk2" violates foreign key constraint "fk_a_fkey2" on table "fk"
-DETAIL:  Key (a)=(1000) is still referenced from table "fk".
-UPDATE pk SET a = 2002 WHERE a = 2000;
-ERROR:  update or delete on table "pk3" violates foreign key constraint "fk_a_fkey3" on table "fk"
-DETAIL:  Key (a)=(2000) is still referenced from table "fk".
-UPDATE pk SET a = 3002 WHERE a = 3000;
-ERROR:  update or delete on table "pk4" violates foreign key constraint "fk_a_fkey4" on table "fk"
-DETAIL:  Key (a)=(3000) is still referenced from table "fk".
-UPDATE pk SET a = 4002 WHERE a = 4000;
-ERROR:  update or delete on table "pk51" violates foreign key constraint "fk_a_fkey6" on table "fk"
-DETAIL:  Key (a)=(4000) is still referenced from table "fk".
-UPDATE pk SET a = 4502 WHERE a = 4500;
-ERROR:  update or delete on table "pk52" violates foreign key constraint "fk_a_fkey7" on table "fk"
-DETAIL:  Key (a)=(4500) is still referenced from table "fk".
--- now they should work
-DELETE FROM fk;
-UPDATE pk SET a = 2 WHERE a = 1;
-DELETE FROM pk WHERE a = 2;
-UPDATE pk SET a = 1002 WHERE a = 1000;
-DELETE FROM pk WHERE a = 1002;
-UPDATE pk SET a = 2002 WHERE a = 2000;
-DELETE FROM pk WHERE a = 2002;
-UPDATE pk SET a = 3002 WHERE a = 3000;
-DELETE FROM pk WHERE a = 3002;
-UPDATE pk SET a = 4002 WHERE a = 4000;
-DELETE FROM pk WHERE a = 4002;
-UPDATE pk SET a = 4502 WHERE a = 4500;
-DELETE FROM pk WHERE a = 4502;
-CREATE SCHEMA fkpart4;
-SET search_path TO fkpart4;
--- dropping/detaching PARTITIONs is prevented if that would break
--- a foreign key's existing data
-CREATE TABLE droppk (a int PRIMARY KEY) PARTITION BY RANGE (a);
-CREATE TABLE droppk1 PARTITION OF droppk FOR VALUES FROM (0) TO (1000);
-CREATE TABLE droppk_d PARTITION OF droppk DEFAULT;
-CREATE TABLE droppk2 PARTITION OF droppk FOR VALUES FROM (1000) TO (2000)
-  PARTITION BY RANGE (a);
-CREATE TABLE droppk21 PARTITION OF droppk2 FOR VALUES FROM (1000) TO (1400);
-CREATE TABLE droppk2_d PARTITION OF droppk2 DEFAULT;
-INSERT into droppk VALUES (1), (1000), (1500), (2000);
-CREATE TABLE dropfk (a int REFERENCES droppk);
-INSERT into dropfk VALUES (1), (1000), (1500), (2000);
--- these should all fail
-ALTER TABLE droppk DETACH PARTITION droppk_d;
-ERROR:  removing partition "droppk_d" violates foreign key constraint "dropfk_a_fkey5"
-DETAIL:  Key (a)=(2000) is still referenced from table "dropfk".
-ALTER TABLE droppk2 DETACH PARTITION droppk2_d;
-ERROR:  removing partition "droppk2_d" violates foreign key constraint "dropfk_a_fkey4"
-DETAIL:  Key (a)=(1500) is still referenced from table "dropfk".
-ALTER TABLE droppk DETACH PARTITION droppk1;
-ERROR:  removing partition "droppk1" violates foreign key constraint "dropfk_a_fkey1"
-DETAIL:  Key (a)=(1) is still referenced from table "dropfk".
-ALTER TABLE droppk DETACH PARTITION droppk2;
-ERROR:  removing partition "droppk2" violates foreign key constraint "dropfk_a_fkey2"
-DETAIL:  Key (a)=(1000) is still referenced from table "dropfk".
-ALTER TABLE droppk2 DETACH PARTITION droppk21;
-ERROR:  removing partition "droppk21" violates foreign key constraint "dropfk_a_fkey3"
-DETAIL:  Key (a)=(1000) is still referenced from table "dropfk".
--- dropping partitions is disallowed
-DROP TABLE droppk_d;
-ERROR:  cannot drop table droppk_d because other objects depend on it
-DETAIL:  constraint dropfk_a_fkey on table dropfk depends on table droppk_d
-HINT:  Use DROP ... CASCADE to drop the dependent objects too.
-DROP TABLE droppk2_d;
-ERROR:  cannot drop table droppk2_d because other objects depend on it
-DETAIL:  constraint dropfk_a_fkey on table dropfk depends on table droppk2_d
-HINT:  Use DROP ... CASCADE to drop the dependent objects too.
-DROP TABLE droppk1;
-ERROR:  cannot drop table droppk1 because other objects depend on it
-DETAIL:  constraint dropfk_a_fkey on table dropfk depends on table droppk1
-HINT:  Use DROP ... CASCADE to drop the dependent objects too.
-DROP TABLE droppk2;
-ERROR:  cannot drop table droppk2 because other objects depend on it
-DETAIL:  constraint dropfk_a_fkey on table dropfk depends on table droppk2
-HINT:  Use DROP ... CASCADE to drop the dependent objects too.
-DROP TABLE droppk21;
-ERROR:  cannot drop table droppk21 because other objects depend on it
-DETAIL:  constraint dropfk_a_fkey on table dropfk depends on table droppk21
-HINT:  Use DROP ... CASCADE to drop the dependent objects too.
-DELETE FROM dropfk;
--- dropping partitions is disallowed, even when no referencing values
-DROP TABLE droppk_d;
-ERROR:  cannot drop table droppk_d because other objects depend on it
-DETAIL:  constraint dropfk_a_fkey on table dropfk depends on table droppk_d
-HINT:  Use DROP ... CASCADE to drop the dependent objects too.
-DROP TABLE droppk2_d;
-ERROR:  cannot drop table droppk2_d because other objects depend on it
-DETAIL:  constraint dropfk_a_fkey on table dropfk depends on table droppk2_d
-HINT:  Use DROP ... CASCADE to drop the dependent objects too.
-DROP TABLE droppk1;
-ERROR:  cannot drop table droppk1 because other objects depend on it
-DETAIL:  constraint dropfk_a_fkey on table dropfk depends on table droppk1
-HINT:  Use DROP ... CASCADE to drop the dependent objects too.
--- but DETACH is allowed, and DROP afterwards works
-ALTER TABLE droppk2 DETACH PARTITION droppk21;
-DROP TABLE droppk2;
-ERROR:  cannot drop table droppk2 because other objects depend on it
-DETAIL:  constraint dropfk_a_fkey on table dropfk depends on table droppk2
-HINT:  Use DROP ... CASCADE to drop the dependent objects too.
--- Verify that initial constraint creation and cloning behave correctly
-CREATE SCHEMA fkpart5;
-SET search_path TO fkpart5;
-CREATE TABLE pk (a int PRIMARY KEY) PARTITION BY LIST (a);
-CREATE TABLE pk1 PARTITION OF pk FOR VALUES IN (1) PARTITION BY LIST (a);
-CREATE TABLE pk11 PARTITION OF pk1 FOR VALUES IN (1);
-CREATE TABLE fk (a int) PARTITION BY LIST (a);
-CREATE TABLE fk1 PARTITION OF fk FOR VALUES IN (1) PARTITION BY LIST (a);
-CREATE TABLE fk11 PARTITION OF fk1 FOR VALUES IN (1);
-ALTER TABLE fk ADD FOREIGN KEY (a) REFERENCES pk;
-CREATE TABLE pk2 PARTITION OF pk FOR VALUES IN (2);
-CREATE TABLE pk3 (a int NOT NULL) PARTITION BY LIST (a);
-CREATE TABLE pk31 PARTITION OF pk3 FOR VALUES IN (31);
-CREATE TABLE pk32 (b int, a int NOT NULL);
-ALTER TABLE pk32 DROP COLUMN b;
-ALTER TABLE pk3 ATTACH PARTITION pk32 FOR VALUES IN (32);
-ALTER TABLE pk ATTACH PARTITION pk3 FOR VALUES IN (31, 32);
-CREATE TABLE fk2 PARTITION OF fk FOR VALUES IN (2);
-CREATE TABLE fk3 (b int, a int);
-ALTER TABLE fk3 DROP COLUMN b;
-ALTER TABLE fk ATTACH PARTITION fk3 FOR VALUES IN (3);
-SELECT pg_describe_object('pg_constraint'::regclass, oid, 0), confrelid::regclass,
-       CASE WHEN conparentid <> 0 THEN pg_describe_object('pg_constraint'::regclass, conparentid, 0) ELSE 'TOP' END
-FROM pg_catalog.pg_constraint
-WHERE conrelid IN (SELECT relid FROM pg_partition_tree('fk'))
-ORDER BY conrelid::regclass::text, conname;
-         pg_describe_object         | confrelid |               case                
-------------------------------------+-----------+-----------------------------------
- constraint fk_a_fkey on table fk   | pk        | TOP
- constraint fk_a_fkey1 on table fk  | pk1       | constraint fk_a_fkey on table fk
- constraint fk_a_fkey2 on table fk  | pk11      | constraint fk_a_fkey1 on table fk
- constraint fk_a_fkey3 on table fk  | pk2       | constraint fk_a_fkey on table fk
- constraint fk_a_fkey4 on table fk  | pk3       | constraint fk_a_fkey on table fk
- constraint fk_a_fkey5 on table fk  | pk31      | constraint fk_a_fkey4 on table fk
- constraint fk_a_fkey6 on table fk  | pk32      | constraint fk_a_fkey4 on table fk
- constraint fk_a_fkey on table fk1  | pk        | constraint fk_a_fkey on table fk
- constraint fk_a_fkey on table fk11 | pk        | constraint fk_a_fkey on table fk1
- constraint fk_a_fkey on table fk2  | pk        | constraint fk_a_fkey on table fk
- constraint fk_a_fkey on table fk3  | pk        | constraint fk_a_fkey on table fk
-(11 rows)
-
-CREATE TABLE fk4 (LIKE fk);
-INSERT INTO fk4 VALUES (50);
-ALTER TABLE fk ATTACH PARTITION fk4 FOR VALUES IN (50);
-ERROR:  insert or update on table "fk4" violates foreign key constraint "fk_a_fkey"
-DETAIL:  Key (a)=(50) is not present in table "pk".
--- Verify constraint deferrability
-CREATE SCHEMA fkpart9;
-SET search_path TO fkpart9;
-CREATE TABLE pk (a int PRIMARY KEY) PARTITION BY LIST (a);
-CREATE TABLE pk1 PARTITION OF pk FOR VALUES IN (1, 2) PARTITION BY LIST (a);
-CREATE TABLE pk11 PARTITION OF pk1 FOR VALUES IN (1);
-CREATE TABLE pk3 PARTITION OF pk FOR VALUES IN (3);
-CREATE TABLE fk (a int REFERENCES pk DEFERRABLE INITIALLY IMMEDIATE);
-INSERT INTO fk VALUES (1);		-- should fail
-ERROR:  insert or update on table "fk" violates foreign key constraint "fk_a_fkey"
-DETAIL:  Key (a)=(1) is not present in table "pk".
-BEGIN;
-SET CONSTRAINTS fk_a_fkey DEFERRED;
-INSERT INTO fk VALUES (1);
-COMMIT;							-- should fail
-ERROR:  insert or update on table "fk" violates foreign key constraint "fk_a_fkey"
-DETAIL:  Key (a)=(1) is not present in table "pk".
-BEGIN;
-SET CONSTRAINTS fk_a_fkey DEFERRED;
-INSERT INTO fk VALUES (1);
-INSERT INTO pk VALUES (1);
-COMMIT;							-- OK
-BEGIN;
-SET CONSTRAINTS fk_a_fkey DEFERRED;
-DELETE FROM pk WHERE a = 1;
-DELETE FROM fk WHERE a = 1;
-COMMIT;							-- OK
--- Verify constraint deferrability when changed by ALTER
--- Partitioned table at referencing end
-CREATE TABLE pt(f1 int, f2 int, f3 int, PRIMARY KEY(f1,f2));
-CREATE TABLE ref(f1 int, f2 int, f3 int)
-  PARTITION BY list(f1);
-CREATE TABLE ref1 PARTITION OF ref FOR VALUES IN (1);
-CREATE TABLE ref2 PARTITION OF ref FOR VALUES in (2);
-ALTER TABLE ref ADD FOREIGN KEY(f1,f2) REFERENCES pt;
-ALTER TABLE ref ALTER CONSTRAINT ref_f1_f2_fkey
-  DEFERRABLE INITIALLY DEFERRED;
-INSERT INTO pt VALUES(1,2,3);
-INSERT INTO ref VALUES(1,2,3);
-BEGIN;
-DELETE FROM pt;
-DELETE FROM ref;
-ABORT;
-DROP TABLE pt, ref;
--- Multi-level partitioning at referencing end
-CREATE TABLE pt(f1 int, f2 int, f3 int, PRIMARY KEY(f1,f2));
-CREATE TABLE ref(f1 int, f2 int, f3 int)
-  PARTITION BY list(f1);
-CREATE TABLE ref1_2 PARTITION OF ref FOR VALUES IN (1, 2) PARTITION BY list (f2);
-CREATE TABLE ref1 PARTITION OF ref1_2 FOR VALUES IN (1);
-CREATE TABLE ref2 PARTITION OF ref1_2 FOR VALUES IN (2) PARTITION BY list (f2);
-CREATE TABLE ref22 PARTITION OF ref2 FOR VALUES IN (2);
-ALTER TABLE ref ADD FOREIGN KEY(f1,f2) REFERENCES pt;
-INSERT INTO pt VALUES(1,2,3);
-INSERT INTO ref VALUES(1,2,3);
-ALTER TABLE ref22 ALTER CONSTRAINT ref_f1_f2_fkey
-  DEFERRABLE INITIALLY IMMEDIATE;	-- fails
-ERROR:  cannot alter constraint "ref_f1_f2_fkey" on relation "ref22"
-DETAIL:  Constraint "ref_f1_f2_fkey" is derived from constraint "ref_f1_f2_fkey" of relation "ref".
-HINT:  You may alter the constraint it derives from, instead.
-ALTER TABLE ref ALTER CONSTRAINT ref_f1_f2_fkey
-  DEFERRABLE INITIALLY DEFERRED;
-BEGIN;
-DELETE FROM pt;
-DELETE FROM ref;
-ABORT;
-DROP TABLE pt, ref;
--- Partitioned table at referenced end
-CREATE TABLE pt(f1 int, f2 int, f3 int, PRIMARY KEY(f1,f2))
-  PARTITION BY LIST(f1);
-CREATE TABLE pt1 PARTITION OF pt FOR VALUES IN (1);
-CREATE TABLE pt2 PARTITION OF pt FOR VALUES IN (2);
-CREATE TABLE ref(f1 int, f2 int, f3 int);
-ALTER TABLE ref ADD FOREIGN KEY(f1,f2) REFERENCES pt;
-ALTER TABLE ref ALTER CONSTRAINT ref_f1_f2_fkey
-  DEFERRABLE INITIALLY DEFERRED;
-INSERT INTO pt VALUES(1,2,3);
-INSERT INTO ref VALUES(1,2,3);
-BEGIN;
-DELETE FROM pt;
-DELETE FROM ref;
-ABORT;
-DROP TABLE pt, ref;
--- Multi-level partitioning at at referenced end
-CREATE TABLE pt(f1 int, f2 int, f3 int, PRIMARY KEY(f1,f2))
-  PARTITION BY LIST(f1);
-CREATE TABLE pt1_2 PARTITION OF pt FOR VALUES IN (1, 2) PARTITION BY LIST (f1);
-CREATE TABLE pt1 PARTITION OF pt1_2 FOR VALUES IN (1);
-CREATE TABLE pt2 PARTITION OF pt1_2 FOR VALUES IN (2);
-CREATE TABLE ref(f1 int, f2 int, f3 int);
-ALTER TABLE ref ADD FOREIGN KEY(f1,f2) REFERENCES pt;
-ALTER TABLE ref ALTER CONSTRAINT ref_f1_f2_fkey1
-  DEFERRABLE INITIALLY DEFERRED;	-- fails
-ERROR:  cannot alter constraint "ref_f1_f2_fkey1" on relation "ref"
-DETAIL:  Constraint "ref_f1_f2_fkey1" is derived from constraint "ref_f1_f2_fkey" of relation "ref".
-HINT:  You may alter the constraint it derives from, instead.
-ALTER TABLE ref ALTER CONSTRAINT ref_f1_f2_fkey
-  DEFERRABLE INITIALLY DEFERRED;
-INSERT INTO pt VALUES(1,2,3);
-INSERT INTO ref VALUES(1,2,3);
-BEGIN;
-DELETE FROM pt;
-DELETE FROM ref;
-ABORT;
-DROP TABLE pt, ref;
-DROP SCHEMA fkpart9 CASCADE;
-NOTICE:  drop cascades to 2 other objects
-DETAIL:  drop cascades to table pk
-drop cascades to table fk
--- Verify ON UPDATE/DELETE behavior
-CREATE SCHEMA fkpart6;
-SET search_path TO fkpart6;
-CREATE TABLE pk (a int PRIMARY KEY) PARTITION BY RANGE (a);
-CREATE TABLE pk1 PARTITION OF pk FOR VALUES FROM (1) TO (100) PARTITION BY RANGE (a);
-CREATE TABLE pk11 PARTITION OF pk1 FOR VALUES FROM (1) TO (50);
-CREATE TABLE pk12 PARTITION OF pk1 FOR VALUES FROM (50) TO (100);
-CREATE TABLE fk (a int) PARTITION BY RANGE (a);
-CREATE TABLE fk1 PARTITION OF fk FOR VALUES FROM (1) TO (100) PARTITION BY RANGE (a);
-CREATE TABLE fk11 PARTITION OF fk1 FOR VALUES FROM (1) TO (10);
-CREATE TABLE fk12 PARTITION OF fk1 FOR VALUES FROM (10) TO (100);
-ALTER TABLE fk ADD FOREIGN KEY (a) REFERENCES pk ON UPDATE CASCADE ON DELETE CASCADE;
-CREATE TABLE fk_d PARTITION OF fk DEFAULT;
-INSERT INTO pk VALUES (1);
-INSERT INTO fk VALUES (1);
-UPDATE pk SET a = 20;
-SELECT tableoid::regclass, * FROM fk;
- tableoid | a  
-----------+----
- fk12     | 20
-(1 row)
-
-DELETE FROM pk WHERE a = 20;
-SELECT tableoid::regclass, * FROM fk;
- tableoid | a 
-----------+---
-(0 rows)
-
-DROP TABLE fk;
-TRUNCATE TABLE pk;
-INSERT INTO pk VALUES (20), (50);
-CREATE TABLE fk (a int) PARTITION BY RANGE (a);
-CREATE TABLE fk1 PARTITION OF fk FOR VALUES FROM (1) TO (100) PARTITION BY RANGE (a);
-CREATE TABLE fk11 PARTITION OF fk1 FOR VALUES FROM (1) TO (10);
-CREATE TABLE fk12 PARTITION OF fk1 FOR VALUES FROM (10) TO (100);
-ALTER TABLE fk ADD FOREIGN KEY (a) REFERENCES pk ON UPDATE SET NULL ON DELETE SET NULL;
-CREATE TABLE fk_d PARTITION OF fk DEFAULT;
-INSERT INTO fk VALUES (20), (50);
-UPDATE pk SET a = 21 WHERE a = 20;
-DELETE FROM pk WHERE a = 50;
-SELECT tableoid::regclass, * FROM fk;
- tableoid | a 
-----------+---
- fk_d     |  
- fk_d     |  
-(2 rows)
-
-DROP TABLE fk;
-TRUNCATE TABLE pk;
-INSERT INTO pk VALUES (20), (30), (50);
-CREATE TABLE fk (id int, a int DEFAULT 50) PARTITION BY RANGE (a);
-CREATE TABLE fk1 PARTITION OF fk FOR VALUES FROM (1) TO (100) PARTITION BY RANGE (a);
-CREATE TABLE fk11 PARTITION OF fk1 FOR VALUES FROM (1) TO (10);
-CREATE TABLE fk12 PARTITION OF fk1 FOR VALUES FROM (10) TO (100);
-ALTER TABLE fk ADD FOREIGN KEY (a) REFERENCES pk ON UPDATE SET DEFAULT ON DELETE SET DEFAULT;
-CREATE TABLE fk_d PARTITION OF fk DEFAULT;
-INSERT INTO fk VALUES (1, 20), (2, 30);
-DELETE FROM pk WHERE a = 20 RETURNING *;
- a  
-----
- 20
-(1 row)
-
-UPDATE pk SET a = 90 WHERE a = 30 RETURNING *;
- a  
-----
- 90
-(1 row)
-
-SELECT tableoid::regclass, * FROM fk;
- tableoid | id | a  
-----------+----+----
- fk12     |  1 | 50
- fk12     |  2 | 50
-(2 rows)
-
-DROP TABLE fk;
-TRUNCATE TABLE pk;
-INSERT INTO pk VALUES (20), (30);
-CREATE TABLE fk (a int DEFAULT 50) PARTITION BY RANGE (a);
-CREATE TABLE fk1 PARTITION OF fk FOR VALUES FROM (1) TO (100) PARTITION BY RANGE (a);
-CREATE TABLE fk11 PARTITION OF fk1 FOR VALUES FROM (1) TO (10);
-CREATE TABLE fk12 PARTITION OF fk1 FOR VALUES FROM (10) TO (100);
-ALTER TABLE fk ADD FOREIGN KEY (a) REFERENCES pk ON UPDATE RESTRICT ON DELETE RESTRICT;
-CREATE TABLE fk_d PARTITION OF fk DEFAULT;
-INSERT INTO fk VALUES (20), (30);
-DELETE FROM pk WHERE a = 20;
-ERROR:  update or delete on table "pk11" violates foreign key constraint "fk_a_fkey2" on table "fk"
-DETAIL:  Key (a)=(20) is still referenced from table "fk".
-UPDATE pk SET a = 90 WHERE a = 30;
-ERROR:  update or delete on table "pk11" violates foreign key constraint "fk_a_fkey2" on table "fk"
-DETAIL:  Key (a)=(30) is still referenced from table "fk".
-SELECT tableoid::regclass, * FROM fk;
- tableoid | a  
-----------+----
- fk12     | 20
- fk12     | 30
-(2 rows)
+dyld: lazy symbol binding failed: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
+
+dyld: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
 
-DROP TABLE fk;
--- test for reported bug: relispartition not set
--- https://postgr.es/m/CA+HiwqHMsRtRYRWYTWavKJ8x14AFsv7bmAV46mYwnfD3vy8goQ@mail.gmail.com
-CREATE SCHEMA fkpart7
-  CREATE TABLE pkpart (a int) PARTITION BY LIST (a)
-  CREATE TABLE pkpart1 PARTITION OF pkpart FOR VALUES IN (1);
-ALTER TABLE fkpart7.pkpart1 ADD PRIMARY KEY (a);
-ALTER TABLE fkpart7.pkpart ADD PRIMARY KEY (a);
-CREATE TABLE fkpart7.fk (a int REFERENCES fkpart7.pkpart);
-DROP SCHEMA fkpart7 CASCADE;
-NOTICE:  drop cascades to 2 other objects
-DETAIL:  drop cascades to table fkpart7.pkpart
-drop cascades to table fkpart7.fk
--- ensure we check partitions are "not used" when dropping constraints
-CREATE SCHEMA fkpart8
-  CREATE TABLE tbl1(f1 int PRIMARY KEY)
-  CREATE TABLE tbl2(f1 int REFERENCES tbl1 DEFERRABLE INITIALLY DEFERRED) PARTITION BY RANGE(f1)
-  CREATE TABLE tbl2_p1 PARTITION OF tbl2 FOR VALUES FROM (minvalue) TO (maxvalue);
-INSERT INTO fkpart8.tbl1 VALUES(1);
-BEGIN;
-INSERT INTO fkpart8.tbl2 VALUES(1);
-ALTER TABLE fkpart8.tbl2 DROP CONSTRAINT tbl2_f1_fkey;
-ERROR:  cannot ALTER TABLE "tbl2_p1" because it has pending trigger events
-COMMIT;
-DROP SCHEMA fkpart8 CASCADE;
-NOTICE:  drop cascades to 2 other objects
-DETAIL:  drop cascades to table fkpart8.tbl1
-drop cascades to table fkpart8.tbl2
--- ensure FK referencing a multi-level partitioned table are
--- enforce reference to sub-children.
-CREATE SCHEMA fkpart9
-  CREATE TABLE pk (a INT PRIMARY KEY) PARTITION BY RANGE (a)
-  CREATE TABLE fk (
-    fk_a INT REFERENCES pk(a) ON DELETE CASCADE
-  )
-  CREATE TABLE pk1 PARTITION OF pk FOR VALUES FROM (30) TO (50) PARTITION BY RANGE (a)
-  CREATE TABLE pk11 PARTITION OF pk1 FOR VALUES FROM (30) TO (40);
-INSERT INTO fkpart9.pk VALUES (35);
-INSERT INTO fkpart9.fk VALUES (35);
-DELETE FROM fkpart9.pk WHERE a=35;
-SELECT * FROM fkpart9.pk;
- a 
----
-(0 rows)
-
-SELECT * FROM fkpart9.fk;
- fk_a 
-------
-(0 rows)
-
-DROP SCHEMA fkpart9 CASCADE;
-NOTICE:  drop cascades to 2 other objects
-DETAIL:  drop cascades to table fkpart9.pk
-drop cascades to table fkpart9.fk
--- test that ri_Check_Pk_Match() scans the correct partition for a deferred
--- ON DELETE/UPDATE NO ACTION constraint
-CREATE SCHEMA fkpart10
-  CREATE TABLE tbl1(f1 int PRIMARY KEY) PARTITION BY RANGE(f1)
-  CREATE TABLE tbl1_p1 PARTITION OF tbl1 FOR VALUES FROM (minvalue) TO (1)
-  CREATE TABLE tbl1_p2 PARTITION OF tbl1 FOR VALUES FROM (1) TO (maxvalue)
-  CREATE TABLE tbl2(f1 int REFERENCES tbl1 DEFERRABLE INITIALLY DEFERRED);
-INSERT INTO fkpart10.tbl1 VALUES (0), (1);
-INSERT INTO fkpart10.tbl2 VALUES (0), (1);
-BEGIN;
-DELETE FROM fkpart10.tbl1 WHERE f1 = 0;
-UPDATE fkpart10.tbl1 SET f1 = 2 WHERE f1 = 1;
-INSERT INTO fkpart10.tbl1 VALUES (0), (1);
-COMMIT;
-DROP SCHEMA fkpart10 CASCADE;
-NOTICE:  drop cascades to 2 other objects
-DETAIL:  drop cascades to table fkpart10.tbl1
-drop cascades to table fkpart10.tbl2
diff -U3 /Users/kenaniah/workspace/postgres/src/test/regress/expected/cluster.out /Users/kenaniah/workspace/postgres/src/test/regress/results/cluster.out
--- /Users/kenaniah/workspace/postgres/src/test/regress/expected/cluster.out	2021-10-03 17:41:49.000000000 -0700
+++ /Users/kenaniah/workspace/postgres/src/test/regress/results/cluster.out	2021-10-03 20:08:22.000000000 -0700
@@ -379,53 +379,57 @@
 -- Test MVCC-safety of cluster. There isn't much we can do to verify the
 -- results with a single backend...
 CREATE TABLE clustertest (key int PRIMARY KEY);
+ERROR:  permission denied for schema public
+LINE 1: CREATE TABLE clustertest (key int PRIMARY KEY);
+                     ^
 INSERT INTO clustertest VALUES (10);
+ERROR:  relation "clustertest" does not exist
+LINE 1: INSERT INTO clustertest VALUES (10);
+                    ^
 INSERT INTO clustertest VALUES (20);
+ERROR:  relation "clustertest" does not exist
+LINE 1: INSERT INTO clustertest VALUES (20);
+                    ^
 INSERT INTO clustertest VALUES (30);
+ERROR:  relation "clustertest" does not exist
+LINE 1: INSERT INTO clustertest VALUES (30);
+                    ^
 INSERT INTO clustertest VALUES (40);
+ERROR:  relation "clustertest" does not exist
+LINE 1: INSERT INTO clustertest VALUES (40);
+                    ^
 INSERT INTO clustertest VALUES (50);
+ERROR:  relation "clustertest" does not exist
+LINE 1: INSERT INTO clustertest VALUES (50);
+                    ^
 -- Use a transaction so that updates are not committed when CLUSTER sees 'em
 BEGIN;
 -- Test update where the old row version is found first in the scan
 UPDATE clustertest SET key = 100 WHERE key = 10;
+ERROR:  relation "clustertest" does not exist
+LINE 1: UPDATE clustertest SET key = 100 WHERE key = 10;
+               ^
 -- Test update where the new row version is found first in the scan
 UPDATE clustertest SET key = 35 WHERE key = 40;
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 -- Test longer update chain
 UPDATE clustertest SET key = 60 WHERE key = 50;
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 UPDATE clustertest SET key = 70 WHERE key = 60;
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 UPDATE clustertest SET key = 80 WHERE key = 70;
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 SELECT * FROM clustertest;
- key 
------
-  20
-  30
- 100
-  35
-  80
-(5 rows)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 CLUSTER clustertest_pkey ON clustertest;
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 SELECT * FROM clustertest;
- key 
------
-  20
-  30
-  35
-  80
- 100
-(5 rows)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 COMMIT;
 SELECT * FROM clustertest;
- key 
------
-  20
-  30
-  35
-  80
- 100
-(5 rows)
-
+ERROR:  relation "clustertest" does not exist
+LINE 1: SELECT * FROM clustertest;
+                      ^
 -- check that temp tables can be clustered
 create temp table clstr_temp (col1 int primary key, col2 text);
 insert into clstr_temp values (2, 'two'), (1, 'one');
@@ -441,6 +445,7 @@
 RESET SESSION AUTHORIZATION;
 -- check clustering an empty table
 DROP TABLE clustertest;
+ERROR:  table "clustertest" does not exist
 CREATE TABLE clustertest (f1 int PRIMARY KEY);
 CLUSTER clustertest USING clustertest_pkey;
 CLUSTER clustertest;
diff -U3 /Users/kenaniah/workspace/postgres/src/test/regress/expected/dependency.out /Users/kenaniah/workspace/postgres/src/test/regress/results/dependency.out
--- /Users/kenaniah/workspace/postgres/src/test/regress/expected/dependency.out	2021-10-03 17:41:49.000000000 -0700
+++ /Users/kenaniah/workspace/postgres/src/test/regress/results/dependency.out	2021-10-03 20:08:21.000000000 -0700
@@ -57,94 +57,25 @@
 -- this one is allowed
 DROP OWNED BY regress_dep_user0;
 CREATE TABLE deptest1 (f1 int unique);
+ERROR:  permission denied for schema public
+LINE 1: CREATE TABLE deptest1 (f1 int unique);
+                     ^
 GRANT ALL ON deptest1 TO regress_dep_user1 WITH GRANT OPTION;
+ERROR:  relation "deptest1" does not exist
 SET SESSION AUTHORIZATION regress_dep_user1;
 CREATE TABLE deptest (a serial primary key, b text);
+ERROR:  permission denied for schema public
+LINE 1: CREATE TABLE deptest (a serial primary key, b text);
+                     ^
 GRANT ALL ON deptest1 TO regress_dep_user2;
+ERROR:  relation "deptest1" does not exist
 RESET SESSION AUTHORIZATION;
 \z deptest1
-                                               Access privileges
- Schema |   Name   | Type  |                 Access privileges                  | Column privileges | Policies 
---------+----------+-------+----------------------------------------------------+-------------------+----------
- public | deptest1 | table | regress_dep_user0=arwdDxt/regress_dep_user0       +|                   | 
-        |          |       | regress_dep_user1=a*r*w*d*D*x*t*/regress_dep_user0+|                   | 
-        |          |       | regress_dep_user2=arwdDxt/regress_dep_user1        |                   | 
-(1 row)
+dyld: lazy symbol binding failed: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
 
-DROP OWNED BY regress_dep_user1;
--- all grants revoked
-\z deptest1
-                                           Access privileges
- Schema |   Name   | Type  |              Access privileges              | Column privileges | Policies 
---------+----------+-------+---------------------------------------------+-------------------+----------
- public | deptest1 | table | regress_dep_user0=arwdDxt/regress_dep_user0 |                   | 
-(1 row)
-
--- table was dropped
-\d deptest
--- Test REASSIGN OWNED
-GRANT ALL ON deptest1 TO regress_dep_user1;
-GRANT CREATE ON DATABASE regression TO regress_dep_user1;
-SET SESSION AUTHORIZATION regress_dep_user1;
-CREATE SCHEMA deptest;
-CREATE TABLE deptest (a serial primary key, b text);
-ALTER DEFAULT PRIVILEGES FOR ROLE regress_dep_user1 IN SCHEMA deptest
-  GRANT ALL ON TABLES TO regress_dep_user2;
-CREATE FUNCTION deptest_func() RETURNS void LANGUAGE plpgsql
-  AS $$ BEGIN END; $$;
-CREATE TYPE deptest_enum AS ENUM ('red');
-CREATE TYPE deptest_range AS RANGE (SUBTYPE = int4);
-CREATE TABLE deptest2 (f1 int);
--- make a serial column the hard way
-CREATE SEQUENCE ss1;
-ALTER TABLE deptest2 ALTER f1 SET DEFAULT nextval('ss1');
-ALTER SEQUENCE ss1 OWNED BY deptest2.f1;
--- When reassigning ownership of a composite type, its pg_class entry
--- should match
-CREATE TYPE deptest_t AS (a int);
-SELECT typowner = relowner
-FROM pg_type JOIN pg_class c ON typrelid = c.oid WHERE typname = 'deptest_t';
- ?column? 
-----------
- t
-(1 row)
-
-RESET SESSION AUTHORIZATION;
-REASSIGN OWNED BY regress_dep_user1 TO regress_dep_user2;
-\dt deptest
-              List of relations
- Schema |  Name   | Type  |       Owner       
---------+---------+-------+-------------------
- public | deptest | table | regress_dep_user2
-(1 row)
-
-SELECT typowner = relowner
-FROM pg_type JOIN pg_class c ON typrelid = c.oid WHERE typname = 'deptest_t';
- ?column? 
-----------
- t
-(1 row)
+dyld: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
 
--- doesn't work: grant still exists
-DROP USER regress_dep_user1;
-ERROR:  role "regress_dep_user1" cannot be dropped because some objects depend on it
-DETAIL:  privileges for database regression
-privileges for table deptest1
-owner of default privileges on new relations belonging to role regress_dep_user1 in schema deptest
-DROP OWNED BY regress_dep_user1;
-DROP USER regress_dep_user1;
-DROP USER regress_dep_user2;
-ERROR:  role "regress_dep_user2" cannot be dropped because some objects depend on it
-DETAIL:  owner of schema deptest
-owner of sequence deptest_a_seq
-owner of table deptest
-owner of function deptest_func()
-owner of type deptest_enum
-owner of type deptest_multirange
-owner of type deptest_range
-owner of table deptest2
-owner of sequence ss1
-owner of type deptest_t
-DROP OWNED BY regress_dep_user2, regress_dep_user0;
-DROP USER regress_dep_user2;
-DROP USER regress_dep_user0;
diff -U3 /Users/kenaniah/workspace/postgres/src/test/regress/expected/tsearch.out /Users/kenaniah/workspace/postgres/src/test/regress/results/tsearch.out
--- /Users/kenaniah/workspace/postgres/src/test/regress/expected/tsearch.out	2021-10-03 17:41:49.000000000 -0700
+++ /Users/kenaniah/workspace/postgres/src/test/regress/results/tsearch.out	2021-10-03 20:08:21.000000000 -0700
@@ -527,2327 +527,11 @@
 ERROR:  parameter "siglen" specified more than once
 CREATE INDEX wowidx2 ON test_tsvector USING gist (a tsvector_ops(siglen=1));
 \d test_tsvector
-            Table "public.test_tsvector"
- Column |   Type   | Collation | Nullable | Default 
---------+----------+-----------+----------+---------
- t      | text     |           |          | 
- a      | tsvector |           |          | 
-Indexes:
-    "wowidx" gist (a)
-    "wowidx2" gist (a tsvector_ops (siglen='1'))
-
-DROP INDEX wowidx;
-EXPLAIN (costs off) SELECT count(*) FROM test_tsvector WHERE a @@ 'wr|qh';
-                         QUERY PLAN                          
--------------------------------------------------------------
- Aggregate
-   ->  Bitmap Heap Scan on test_tsvector
-         Recheck Cond: (a @@ '''wr'' | ''qh'''::tsquery)
-         ->  Bitmap Index Scan on wowidx2
-               Index Cond: (a @@ '''wr'' | ''qh'''::tsquery)
-(5 rows)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ 'wr|qh';
- count 
--------
-   158
-(1 row)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ 'wr&qh';
- count 
--------
-    17
-(1 row)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ 'eq&yt';
- count 
--------
-     6
-(1 row)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ 'eq|yt';
- count 
--------
-    98
-(1 row)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ '(eq&yt)|(wr&qh)';
- count 
--------
-    23
-(1 row)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ '(eq|yt)&(wr|qh)';
- count 
--------
-    39
-(1 row)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ 'w:*|q:*';
- count 
--------
-   494
-(1 row)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ any ('{wr,qh}');
- count 
--------
-   158
-(1 row)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ 'no_such_lexeme';
- count 
--------
-     0
-(1 row)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ '!no_such_lexeme';
- count 
--------
-   508
-(1 row)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ 'pl <-> yh';
- count 
--------
-     1
-(1 row)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ 'yh <-> pl';
- count 
--------
-     0
-(1 row)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ 'qe <2> qt';
- count 
--------
-     1
-(1 row)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ '!pl <-> yh';
- count 
--------
-     3
-(1 row)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ '!pl <-> !yh';
- count 
--------
-   432
-(1 row)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ '!yh <-> pl';
- count 
--------
-     1
-(1 row)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ '!qe <2> qt';
- count 
--------
-     6
-(1 row)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ '!(pl <-> yh)';
- count 
--------
-   507
-(1 row)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ '!(yh <-> pl)';
- count 
--------
-   508
-(1 row)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ '!(qe <2> qt)';
- count 
--------
-   507
-(1 row)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ 'wd:A';
- count 
--------
-    56
-(1 row)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ 'wd:D';
- count 
--------
-    58
-(1 row)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ '!wd:A';
- count 
--------
-   452
-(1 row)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ '!wd:D';
- count 
--------
-   450
-(1 row)
-
-DROP INDEX wowidx2;
-CREATE INDEX wowidx ON test_tsvector USING gist (a tsvector_ops(siglen=484));
-\d test_tsvector
-            Table "public.test_tsvector"
- Column |   Type   | Collation | Nullable | Default 
---------+----------+-----------+----------+---------
- t      | text     |           |          | 
- a      | tsvector |           |          | 
-Indexes:
-    "wowidx" gist (a tsvector_ops (siglen='484'))
-
-EXPLAIN (costs off) SELECT count(*) FROM test_tsvector WHERE a @@ 'wr|qh';
-                         QUERY PLAN                          
--------------------------------------------------------------
- Aggregate
-   ->  Bitmap Heap Scan on test_tsvector
-         Recheck Cond: (a @@ '''wr'' | ''qh'''::tsquery)
-         ->  Bitmap Index Scan on wowidx
-               Index Cond: (a @@ '''wr'' | ''qh'''::tsquery)
-(5 rows)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ 'wr|qh';
- count 
--------
-   158
-(1 row)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ 'wr&qh';
- count 
--------
-    17
-(1 row)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ 'eq&yt';
- count 
--------
-     6
-(1 row)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ 'eq|yt';
- count 
--------
-    98
-(1 row)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ '(eq&yt)|(wr&qh)';
- count 
--------
-    23
-(1 row)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ '(eq|yt)&(wr|qh)';
- count 
--------
-    39
-(1 row)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ 'w:*|q:*';
- count 
--------
-   494
-(1 row)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ any ('{wr,qh}');
- count 
--------
-   158
-(1 row)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ 'no_such_lexeme';
- count 
--------
-     0
-(1 row)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ '!no_such_lexeme';
- count 
--------
-   508
-(1 row)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ 'pl <-> yh';
- count 
--------
-     1
-(1 row)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ 'yh <-> pl';
- count 
--------
-     0
-(1 row)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ 'qe <2> qt';
- count 
--------
-     1
-(1 row)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ '!pl <-> yh';
- count 
--------
-     3
-(1 row)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ '!pl <-> !yh';
- count 
--------
-   432
-(1 row)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ '!yh <-> pl';
- count 
--------
-     1
-(1 row)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ '!qe <2> qt';
- count 
--------
-     6
-(1 row)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ '!(pl <-> yh)';
- count 
--------
-   507
-(1 row)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ '!(yh <-> pl)';
- count 
--------
-   508
-(1 row)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ '!(qe <2> qt)';
- count 
--------
-   507
-(1 row)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ 'wd:A';
- count 
--------
-    56
-(1 row)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ 'wd:D';
- count 
--------
-    58
-(1 row)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ '!wd:A';
- count 
--------
-   452
-(1 row)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ '!wd:D';
- count 
--------
-   450
-(1 row)
-
-RESET enable_seqscan;
-RESET enable_indexscan;
-RESET enable_bitmapscan;
-DROP INDEX wowidx;
-CREATE INDEX wowidx ON test_tsvector USING gin (a);
-SET enable_seqscan=OFF;
--- GIN only supports bitmapscan, so no need to test plain indexscan
-explain (costs off) SELECT count(*) FROM test_tsvector WHERE a @@ 'wr|qh';
-                         QUERY PLAN                          
--------------------------------------------------------------
- Aggregate
-   ->  Bitmap Heap Scan on test_tsvector
-         Recheck Cond: (a @@ '''wr'' | ''qh'''::tsquery)
-         ->  Bitmap Index Scan on wowidx
-               Index Cond: (a @@ '''wr'' | ''qh'''::tsquery)
-(5 rows)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ 'wr|qh';
- count 
--------
-   158
-(1 row)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ 'wr&qh';
- count 
--------
-    17
-(1 row)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ 'eq&yt';
- count 
--------
-     6
-(1 row)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ 'eq|yt';
- count 
--------
-    98
-(1 row)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ '(eq&yt)|(wr&qh)';
- count 
--------
-    23
-(1 row)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ '(eq|yt)&(wr|qh)';
- count 
--------
-    39
-(1 row)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ 'w:*|q:*';
- count 
--------
-   494
-(1 row)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ any ('{wr,qh}');
- count 
--------
-   158
-(1 row)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ 'no_such_lexeme';
- count 
--------
-     0
-(1 row)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ '!no_such_lexeme';
- count 
--------
-   508
-(1 row)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ 'pl <-> yh';
- count 
--------
-     1
-(1 row)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ 'yh <-> pl';
- count 
--------
-     0
-(1 row)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ 'qe <2> qt';
- count 
--------
-     1
-(1 row)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ '!pl <-> yh';
- count 
--------
-     3
-(1 row)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ '!pl <-> !yh';
- count 
--------
-   432
-(1 row)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ '!yh <-> pl';
- count 
--------
-     1
-(1 row)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ '!qe <2> qt';
- count 
--------
-     6
-(1 row)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ '!(pl <-> yh)';
- count 
--------
-   507
-(1 row)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ '!(yh <-> pl)';
- count 
--------
-   508
-(1 row)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ '!(qe <2> qt)';
- count 
--------
-   507
-(1 row)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ 'wd:A';
- count 
--------
-    56
-(1 row)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ 'wd:D';
- count 
--------
-    58
-(1 row)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ '!wd:A';
- count 
--------
-   452
-(1 row)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ '!wd:D';
- count 
--------
-   450
-(1 row)
-
--- Test optimization of non-empty GIN_SEARCH_MODE_ALL queries
-EXPLAIN (COSTS OFF)
-SELECT count(*) FROM test_tsvector WHERE a @@ '!qh';
-                     QUERY PLAN                      
------------------------------------------------------
- Aggregate
-   ->  Bitmap Heap Scan on test_tsvector
-         Recheck Cond: (a @@ '!''qh'''::tsquery)
-         ->  Bitmap Index Scan on wowidx
-               Index Cond: (a @@ '!''qh'''::tsquery)
-(5 rows)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ '!qh';
- count 
--------
-   410
-(1 row)
-
-EXPLAIN (COSTS OFF)
-SELECT count(*) FROM test_tsvector WHERE a @@ 'wr' AND a @@ '!qh';
-                                     QUERY PLAN                                     
-------------------------------------------------------------------------------------
- Aggregate
-   ->  Bitmap Heap Scan on test_tsvector
-         Recheck Cond: ((a @@ '''wr'''::tsquery) AND (a @@ '!''qh'''::tsquery))
-         ->  Bitmap Index Scan on wowidx
-               Index Cond: ((a @@ '''wr'''::tsquery) AND (a @@ '!''qh'''::tsquery))
-(5 rows)
-
-SELECT count(*) FROM test_tsvector WHERE a @@ 'wr' AND a @@ '!qh';
- count 
--------
-    60
-(1 row)
-
-RESET enable_seqscan;
-INSERT INTO test_tsvector VALUES ('???', 'DFG:1A,2B,6C,10 FGH');
-SELECT * FROM ts_stat('SELECT a FROM test_tsvector') ORDER BY ndoc DESC, nentry DESC, word LIMIT 10;
- word | ndoc | nentry 
-------+------+--------
- qq   |  108 |    108
- qt   |  102 |    102
- qe   |  100 |    101
- qh   |   98 |     99
- qw   |   98 |     98
- qa   |   97 |     97
- ql   |   94 |     94
- qs   |   94 |     94
- qr   |   92 |     93
- qi   |   92 |     92
-(10 rows)
-
-SELECT * FROM ts_stat('SELECT a FROM test_tsvector', 'AB') ORDER BY ndoc DESC, nentry DESC, word;
- word | ndoc | nentry 
-------+------+--------
- DFG  |    1 |      2
-(1 row)
-
---dictionaries and to_tsvector
-SELECT ts_lexize('english_stem', 'skies');
- ts_lexize 
------------
- {sky}
-(1 row)
-
-SELECT ts_lexize('english_stem', 'identity');
- ts_lexize 
------------
- {ident}
-(1 row)
-
-SELECT * FROM ts_token_type('default');
- tokid |      alias      |               description                
--------+-----------------+------------------------------------------
-     1 | asciiword       | Word, all ASCII
-     2 | word            | Word, all letters
-     3 | numword         | Word, letters and digits
-     4 | email           | Email address
-     5 | url             | URL
-     6 | host            | Host
-     7 | sfloat          | Scientific notation
-     8 | version         | Version number
-     9 | hword_numpart   | Hyphenated word part, letters and digits
-    10 | hword_part      | Hyphenated word part, all letters
-    11 | hword_asciipart | Hyphenated word part, all ASCII
-    12 | blank           | Space symbols
-    13 | tag             | XML tag
-    14 | protocol        | Protocol head
-    15 | numhword        | Hyphenated word, letters and digits
-    16 | asciihword      | Hyphenated word, all ASCII
-    17 | hword           | Hyphenated word, all letters
-    18 | url_path        | URL path
-    19 | file            | File or path name
-    20 | float           | Decimal notation
-    21 | int             | Signed integer
-    22 | uint            | Unsigned integer
-    23 | entity          | XML entity
-(23 rows)
-
-SELECT * FROM ts_parse('default', '345 qwe@efd.r '' http://www.com/ http://aew.werc.ewr/?ad=qwe&dw 1aew.werc.ewr/?ad=qwe&dw 2aew.werc.ewr http://3aew.werc.ewr/?ad=qwe&dw http://4aew.werc.ewr http://5aew.werc.ewr:8100/?  ad=qwe&dw 6aew.werc.ewr:8100/?ad=qwe&dw 7aew.werc.ewr:8100/?ad=qwe&dw=%20%32 +4.0e-10 qwe qwe qwqwe 234.435 455 5.005 teodor@stack.net teodor@123-stack.net 123_teodor@stack.net 123-teodor@stack.net qwe-wer asdf <fr>qwer jf sdjk<we hjwer <werrwe> ewr1> ewri2 <a href="qwe<qwe>">
-/usr/local/fff /awdf/dwqe/4325 rewt/ewr wefjn /wqe-324/ewr gist.h gist.h.c gist.c. readline 4.2 4.2. 4.2, readline-4.2 readline-4.2. 234
-<i <b> wow  < jqw <> qwerty');
- tokid |                token                 
--------+--------------------------------------
-    22 | 345
-    12 |  
-     1 | qwe
-    12 | @
-    19 | efd.r
-    12 |  ' 
-    14 | http://
-     6 | www.com
-    12 | / 
-    14 | http://
-     5 | aew.werc.ewr/?ad=qwe&dw
-     6 | aew.werc.ewr
-    18 | /?ad=qwe&dw
-    12 |  
-     5 | 1aew.werc.ewr/?ad=qwe&dw
-     6 | 1aew.werc.ewr
-    18 | /?ad=qwe&dw
-    12 |  
-     6 | 2aew.werc.ewr
-    12 |  
-    14 | http://
-     5 | 3aew.werc.ewr/?ad=qwe&dw
-     6 | 3aew.werc.ewr
-    18 | /?ad=qwe&dw
-    12 |  
-    14 | http://
-     6 | 4aew.werc.ewr
-    12 |  
-    14 | http://
-     5 | 5aew.werc.ewr:8100/?
-     6 | 5aew.werc.ewr:8100
-    18 | /?
-    12 |   
-     1 | ad
-    12 | =
-     1 | qwe
-    12 | &
-     1 | dw
-    12 |  
-     5 | 6aew.werc.ewr:8100/?ad=qwe&dw
-     6 | 6aew.werc.ewr:8100
-    18 | /?ad=qwe&dw
-    12 |  
-     5 | 7aew.werc.ewr:8100/?ad=qwe&dw=%20%32
-     6 | 7aew.werc.ewr:8100
-    18 | /?ad=qwe&dw=%20%32
-    12 |  
-     7 | +4.0e-10
-    12 |  
-     1 | qwe
-    12 |  
-     1 | qwe
-    12 |  
-     1 | qwqwe
-    12 |  
-    20 | 234.435
-    12 |  
-    22 | 455
-    12 |  
-    20 | 5.005
-    12 |  
-     4 | teodor@stack.net
-    12 |  
-     4 | teodor@123-stack.net
-    12 |  
-     4 | 123_teodor@stack.net
-    12 |  
-     4 | 123-teodor@stack.net
-    12 |  
-    16 | qwe-wer
-    11 | qwe
-    12 | -
-    11 | wer
-    12 |  
-     1 | asdf
-    12 |  
-    13 | <fr>
-     1 | qwer
-    12 |  
-     1 | jf
-    12 |  
-     1 | sdjk
-    12 | <
-     1 | we
-    12 |  
-     1 | hjwer
-    12 |  
-    13 | <werrwe>
-    12 |  
-     3 | ewr1
-    12 | > 
-     3 | ewri2
-    12 |  
-    13 | <a href="qwe<qwe>">
-    12 |                                     +
-       | 
-    19 | /usr/local/fff
-    12 |  
-    19 | /awdf/dwqe/4325
-    12 |  
-    19 | rewt/ewr
-    12 |  
-     1 | wefjn
-    12 |  
-    19 | /wqe-324/ewr
-    12 |  
-    19 | gist.h
-    12 |  
-    19 | gist.h.c
-    12 |  
-    19 | gist.c
-    12 | . 
-     1 | readline
-    12 |  
-    20 | 4.2
-    12 |  
-    20 | 4.2
-    12 | . 
-    20 | 4.2
-    12 | , 
-     1 | readline
-    20 | -4.2
-    12 |  
-     1 | readline
-    20 | -4.2
-    12 | . 
-    22 | 234
-    12 |                                     +
-       | 
-    12 | <
-     1 | i
-    12 |  
-    13 | <b>
-    12 |  
-     1 | wow
-    12 |   
-    12 | < 
-     1 | jqw
-    12 |  
-    12 | <> 
-     1 | qwerty
-(139 rows)
-
-SELECT to_tsvector('english', '345 qwe@efd.r '' http://www.com/ http://aew.werc.ewr/?ad=qwe&dw 1aew.werc.ewr/?ad=qwe&dw 2aew.werc.ewr http://3aew.werc.ewr/?ad=qwe&dw http://4aew.werc.ewr http://5aew.werc.ewr:8100/?  ad=qwe&dw 6aew.werc.ewr:8100/?ad=qwe&dw 7aew.werc.ewr:8100/?ad=qwe&dw=%20%32 +4.0e-10 qwe qwe qwqwe 234.435 455 5.005 teodor@stack.net teodor@123-stack.net 123_teodor@stack.net 123-teodor@stack.net qwe-wer asdf <fr>qwer jf sdjk<we hjwer <werrwe> ewr1> ewri2 <a href="qwe<qwe>">
-/usr/local/fff /awdf/dwqe/4325 rewt/ewr wefjn /wqe-324/ewr gist.h gist.h.c gist.c. readline 4.2 4.2. 4.2, readline-4.2 readline-4.2. 234
-<i <b> wow  < jqw <> qwerty');
-                                                                                                                                                                                                                                                                                                                                                                                                                                                                              to_tsvector                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
- '+4.0e-10':28 '-4.2':63,65 '/?':18 '/?ad=qwe&dw':7,10,14,24 '/?ad=qwe&dw=%20%32':27 '/awdf/dwqe/4325':51 '/usr/local/fff':50 '/wqe-324/ewr':54 '123-teodor@stack.net':38 '123_teodor@stack.net':37 '1aew.werc.ewr':9 '1aew.werc.ewr/?ad=qwe&dw':8 '234':66 '234.435':32 '2aew.werc.ewr':11 '345':1 '3aew.werc.ewr':13 '3aew.werc.ewr/?ad=qwe&dw':12 '4.2':59,60,61 '455':33 '4aew.werc.ewr':15 '5.005':34 '5aew.werc.ewr:8100':17 '5aew.werc.ewr:8100/?':16 '6aew.werc.ewr:8100':23 '6aew.werc.ewr:8100/?ad=qwe&dw':22 '7aew.werc.ewr:8100':26 '7aew.werc.ewr:8100/?ad=qwe&dw=%20%32':25 'ad':19 'aew.werc.ewr':6 'aew.werc.ewr/?ad=qwe&dw':5 'asdf':42 'dw':21 'efd.r':3 'ewr1':48 'ewri2':49 'gist.c':57 'gist.h':55 'gist.h.c':56 'hjwer':47 'jf':44 'jqw':69 'qwe':2,20,29,30,40 'qwe-wer':39 'qwer':43 'qwerti':70 'qwqwe':31 'readlin':58,62,64 'rewt/ewr':52 'sdjk':45 'teodor@123-stack.net':36 'teodor@stack.net':35 'wefjn':53 'wer':41 'wow':68 'www.com':4
-(1 row)
-
-SELECT length(to_tsvector('english', '345 qwe@efd.r '' http://www.com/ http://aew.werc.ewr/?ad=qwe&dw 1aew.werc.ewr/?ad=qwe&dw 2aew.werc.ewr http://3aew.werc.ewr/?ad=qwe&dw http://4aew.werc.ewr http://5aew.werc.ewr:8100/?  ad=qwe&dw 6aew.werc.ewr:8100/?ad=qwe&dw 7aew.werc.ewr:8100/?ad=qwe&dw=%20%32 +4.0e-10 qwe qwe qwqwe 234.435 455 5.005 teodor@stack.net teodor@123-stack.net 123_teodor@stack.net 123-teodor@stack.net qwe-wer asdf <fr>qwer jf sdjk<we hjwer <werrwe> ewr1> ewri2 <a href="qwe<qwe>">
-/usr/local/fff /awdf/dwqe/4325 rewt/ewr wefjn /wqe-324/ewr gist.h gist.h.c gist.c. readline 4.2 4.2. 4.2, readline-4.2 readline-4.2. 234
-<i <b> wow  < jqw <> qwerty'));
- length 
---------
-     56
-(1 row)
-
--- ts_debug
-SELECT * from ts_debug('english', '<myns:foo-bar_baz.blurfl>abc&nm1;def&#xa9;ghi&#245;jkl</myns:foo-bar_baz.blurfl>');
-   alias   |   description   |           token            |  dictionaries  |  dictionary  | lexemes 
------------+-----------------+----------------------------+----------------+--------------+---------
- tag       | XML tag         | <myns:foo-bar_baz.blurfl>  | {}             |              | 
- asciiword | Word, all ASCII | abc                        | {english_stem} | english_stem | {abc}
- entity    | XML entity      | &nm1;                      | {}             |              | 
- asciiword | Word, all ASCII | def                        | {english_stem} | english_stem | {def}
- entity    | XML entity      | &#xa9;                     | {}             |              | 
- asciiword | Word, all ASCII | ghi                        | {english_stem} | english_stem | {ghi}
- entity    | XML entity      | &#245;                     | {}             |              | 
- asciiword | Word, all ASCII | jkl                        | {english_stem} | english_stem | {jkl}
- tag       | XML tag         | </myns:foo-bar_baz.blurfl> | {}             |              | 
-(9 rows)
-
--- check parsing of URLs
-SELECT * from ts_debug('english', 'http://www.harewoodsolutions.co.uk/press.aspx</span>');
-  alias   |  description  |                 token                  | dictionaries | dictionary |                 lexemes                  
-----------+---------------+----------------------------------------+--------------+------------+------------------------------------------
- protocol | Protocol head | http://                                | {}           |            | 
- url      | URL           | www.harewoodsolutions.co.uk/press.aspx | {simple}     | simple     | {www.harewoodsolutions.co.uk/press.aspx}
- host     | Host          | www.harewoodsolutions.co.uk            | {simple}     | simple     | {www.harewoodsolutions.co.uk}
- url_path | URL path      | /press.aspx                            | {simple}     | simple     | {/press.aspx}
- tag      | XML tag       | </span>                                | {}           |            | 
-(5 rows)
-
-SELECT * from ts_debug('english', 'http://aew.wer0c.ewr/id?ad=qwe&dw<span>');
-  alias   |  description  |           token            | dictionaries | dictionary |           lexemes            
-----------+---------------+----------------------------+--------------+------------+------------------------------
- protocol | Protocol head | http://                    | {}           |            | 
- url      | URL           | aew.wer0c.ewr/id?ad=qwe&dw | {simple}     | simple     | {aew.wer0c.ewr/id?ad=qwe&dw}
- host     | Host          | aew.wer0c.ewr              | {simple}     | simple     | {aew.wer0c.ewr}
- url_path | URL path      | /id?ad=qwe&dw              | {simple}     | simple     | {/id?ad=qwe&dw}
- tag      | XML tag       | <span>                     | {}           |            | 
-(5 rows)
-
-SELECT * from ts_debug('english', 'http://5aew.werc.ewr:8100/?');
-  alias   |  description  |        token         | dictionaries | dictionary |        lexemes         
-----------+---------------+----------------------+--------------+------------+------------------------
- protocol | Protocol head | http://              | {}           |            | 
- url      | URL           | 5aew.werc.ewr:8100/? | {simple}     | simple     | {5aew.werc.ewr:8100/?}
- host     | Host          | 5aew.werc.ewr:8100   | {simple}     | simple     | {5aew.werc.ewr:8100}
- url_path | URL path      | /?                   | {simple}     | simple     | {/?}
-(4 rows)
-
-SELECT * from ts_debug('english', '5aew.werc.ewr:8100/?xx');
-  alias   | description |         token          | dictionaries | dictionary |         lexemes          
-----------+-------------+------------------------+--------------+------------+--------------------------
- url      | URL         | 5aew.werc.ewr:8100/?xx | {simple}     | simple     | {5aew.werc.ewr:8100/?xx}
- host     | Host        | 5aew.werc.ewr:8100     | {simple}     | simple     | {5aew.werc.ewr:8100}
- url_path | URL path    | /?xx                   | {simple}     | simple     | {/?xx}
-(3 rows)
-
-SELECT token, alias,
-  dictionaries, dictionaries is null as dnull, array_dims(dictionaries) as ddims,
-  lexemes, lexemes is null as lnull, array_dims(lexemes) as ldims
-from ts_debug('english', 'a title');
- token |   alias   |  dictionaries  | dnull | ddims | lexemes | lnull | ldims 
--------+-----------+----------------+-------+-------+---------+-------+-------
- a     | asciiword | {english_stem} | f     | [1:1] | {}      | f     | 
-       | blank     | {}             | f     |       |         | t     | 
- title | asciiword | {english_stem} | f     | [1:1] | {titl}  | f     | [1:1]
-(3 rows)
-
--- to_tsquery
-SELECT to_tsquery('english', 'qwe & sKies ');
-  to_tsquery   
----------------
- 'qwe' & 'sky'
-(1 row)
-
-SELECT to_tsquery('simple', 'qwe & sKies ');
-   to_tsquery    
------------------
- 'qwe' & 'skies'
-(1 row)
-
-SELECT to_tsquery('english', '''the wether'':dc & ''           sKies '':BC ');
-       to_tsquery       
-------------------------
- 'wether':CD & 'sky':BC
-(1 row)
-
-SELECT to_tsquery('english', 'asd&(and|fghj)');
-   to_tsquery   
-----------------
- 'asd' & 'fghj'
-(1 row)
-
-SELECT to_tsquery('english', '(asd&and)|fghj');
-   to_tsquery   
-----------------
- 'asd' | 'fghj'
-(1 row)
-
-SELECT to_tsquery('english', '(asd&!and)|fghj');
-   to_tsquery   
-----------------
- 'asd' | 'fghj'
-(1 row)
-
-SELECT to_tsquery('english', '(the|and&(i&1))&fghj');
-  to_tsquery  
---------------
- '1' & 'fghj'
-(1 row)
-
-SELECT plainto_tsquery('english', 'the and z 1))& fghj');
-  plainto_tsquery   
---------------------
- 'z' & '1' & 'fghj'
-(1 row)
-
-SELECT plainto_tsquery('english', 'foo bar') && plainto_tsquery('english', 'asd');
-       ?column?        
------------------------
- 'foo' & 'bar' & 'asd'
-(1 row)
-
-SELECT plainto_tsquery('english', 'foo bar') || plainto_tsquery('english', 'asd fg');
-           ?column?           
-------------------------------
- 'foo' & 'bar' | 'asd' & 'fg'
-(1 row)
-
-SELECT plainto_tsquery('english', 'foo bar') || !!plainto_tsquery('english', 'asd fg');
-             ?column?              
------------------------------------
- 'foo' & 'bar' | !( 'asd' & 'fg' )
-(1 row)
-
-SELECT plainto_tsquery('english', 'foo bar') && 'asd | fg';
-             ?column?             
-----------------------------------
- 'foo' & 'bar' & ( 'asd' | 'fg' )
-(1 row)
-
--- Check stop word deletion, a and s are stop-words
-SELECT to_tsquery('english', '!(a & !b) & c');
- to_tsquery  
--------------
- !!'b' & 'c'
-(1 row)
-
-SELECT to_tsquery('english', '!(a & !b)');
- to_tsquery 
-------------
- !!'b'
-(1 row)
-
-SELECT to_tsquery('english', '(1 <-> 2) <-> a');
- to_tsquery  
--------------
- '1' <-> '2'
-(1 row)
-
-SELECT to_tsquery('english', '(1 <-> a) <-> 2');
- to_tsquery  
--------------
- '1' <2> '2'
-(1 row)
-
-SELECT to_tsquery('english', '(a <-> 1) <-> 2');
- to_tsquery  
--------------
- '1' <-> '2'
-(1 row)
-
-SELECT to_tsquery('english', 'a <-> (1 <-> 2)');
- to_tsquery  
--------------
- '1' <-> '2'
-(1 row)
-
-SELECT to_tsquery('english', '1 <-> (a <-> 2)');
- to_tsquery  
--------------
- '1' <2> '2'
-(1 row)
-
-SELECT to_tsquery('english', '1 <-> (2 <-> a)');
- to_tsquery  
--------------
- '1' <-> '2'
-(1 row)
-
-SELECT to_tsquery('english', '(1 <-> 2) <3> a');
- to_tsquery  
--------------
- '1' <-> '2'
-(1 row)
-
-SELECT to_tsquery('english', '(1 <-> a) <3> 2');
- to_tsquery  
--------------
- '1' <4> '2'
-(1 row)
-
-SELECT to_tsquery('english', '(a <-> 1) <3> 2');
- to_tsquery  
--------------
- '1' <3> '2'
-(1 row)
-
-SELECT to_tsquery('english', 'a <3> (1 <-> 2)');
- to_tsquery  
--------------
- '1' <-> '2'
-(1 row)
-
-SELECT to_tsquery('english', '1 <3> (a <-> 2)');
- to_tsquery  
--------------
- '1' <4> '2'
-(1 row)
-
-SELECT to_tsquery('english', '1 <3> (2 <-> a)');
- to_tsquery  
--------------
- '1' <3> '2'
-(1 row)
-
-SELECT to_tsquery('english', '(1 <3> 2) <-> a');
- to_tsquery  
--------------
- '1' <3> '2'
-(1 row)
-
-SELECT to_tsquery('english', '(1 <3> a) <-> 2');
- to_tsquery  
--------------
- '1' <4> '2'
-(1 row)
-
-SELECT to_tsquery('english', '(a <3> 1) <-> 2');
- to_tsquery  
--------------
- '1' <-> '2'
-(1 row)
-
-SELECT to_tsquery('english', 'a <-> (1 <3> 2)');
- to_tsquery  
--------------
- '1' <3> '2'
-(1 row)
-
-SELECT to_tsquery('english', '1 <-> (a <3> 2)');
- to_tsquery  
--------------
- '1' <4> '2'
-(1 row)
-
-SELECT to_tsquery('english', '1 <-> (2 <3> a)');
- to_tsquery  
--------------
- '1' <-> '2'
-(1 row)
-
-SELECT to_tsquery('english', '((a <-> 1) <-> 2) <-> s');
- to_tsquery  
--------------
- '1' <-> '2'
-(1 row)
-
-SELECT to_tsquery('english', '(2 <-> (a <-> 1)) <-> s');
- to_tsquery  
--------------
- '2' <2> '1'
-(1 row)
-
-SELECT to_tsquery('english', '((1 <-> a) <-> 2) <-> s');
- to_tsquery  
--------------
- '1' <2> '2'
-(1 row)
-
-SELECT to_tsquery('english', '(2 <-> (1 <-> a)) <-> s');
- to_tsquery  
--------------
- '2' <-> '1'
-(1 row)
-
-SELECT to_tsquery('english', 's <-> ((a <-> 1) <-> 2)');
- to_tsquery  
--------------
- '1' <-> '2'
-(1 row)
-
-SELECT to_tsquery('english', 's <-> (2 <-> (a <-> 1))');
- to_tsquery  
--------------
- '2' <2> '1'
-(1 row)
-
-SELECT to_tsquery('english', 's <-> ((1 <-> a) <-> 2)');
- to_tsquery  
--------------
- '1' <2> '2'
-(1 row)
-
-SELECT to_tsquery('english', 's <-> (2 <-> (1 <-> a))');
- to_tsquery  
--------------
- '2' <-> '1'
-(1 row)
-
-SELECT to_tsquery('english', '((a <-> 1) <-> s) <-> 2');
- to_tsquery  
--------------
- '1' <2> '2'
-(1 row)
-
-SELECT to_tsquery('english', '(s <-> (a <-> 1)) <-> 2');
- to_tsquery  
--------------
- '1' <-> '2'
-(1 row)
-
-SELECT to_tsquery('english', '((1 <-> a) <-> s) <-> 2');
- to_tsquery  
--------------
- '1' <3> '2'
-(1 row)
-
-SELECT to_tsquery('english', '(s <-> (1 <-> a)) <-> 2');
- to_tsquery  
--------------
- '1' <2> '2'
-(1 row)
-
-SELECT to_tsquery('english', '2 <-> ((a <-> 1) <-> s)');
- to_tsquery  
--------------
- '2' <2> '1'
-(1 row)
-
-SELECT to_tsquery('english', '2 <-> (s <-> (a <-> 1))');
- to_tsquery  
--------------
- '2' <3> '1'
-(1 row)
-
-SELECT to_tsquery('english', '2 <-> ((1 <-> a) <-> s)');
- to_tsquery  
--------------
- '2' <-> '1'
-(1 row)
-
-SELECT to_tsquery('english', '2 <-> (s <-> (1 <-> a))');
- to_tsquery  
--------------
- '2' <2> '1'
-(1 row)
-
-SELECT to_tsquery('english', 'foo <-> (a <-> (the <-> bar))');
-   to_tsquery    
------------------
- 'foo' <3> 'bar'
-(1 row)
-
-SELECT to_tsquery('english', '((foo <-> a) <-> the) <-> bar');
-   to_tsquery    
------------------
- 'foo' <3> 'bar'
-(1 row)
-
-SELECT to_tsquery('english', 'foo <-> a <-> the <-> bar');
-   to_tsquery    
------------------
- 'foo' <3> 'bar'
-(1 row)
-
-SELECT phraseto_tsquery('english', 'PostgreSQL can be extended by the user in many ways');
-                     phraseto_tsquery                      
------------------------------------------------------------
- 'postgresql' <3> 'extend' <3> 'user' <2> 'mani' <-> 'way'
-(1 row)
-
-SELECT ts_rank_cd(to_tsvector('english', '
-Day after day, day after day,
-  We stuck, nor breath nor motion,
-As idle as a painted Ship
-  Upon a painted Ocean.
-Water, water, every where
-  And all the boards did shrink;
-Water, water, every where,
-  Nor any drop to drink.
-S. T. Coleridge (1772-1834)
-'), to_tsquery('english', 'paint&water'));
- ts_rank_cd 
-------------
-       0.05
-(1 row)
-
-SELECT ts_rank_cd(to_tsvector('english', '
-Day after day, day after day,
-  We stuck, nor breath nor motion,
-As idle as a painted Ship
-  Upon a painted Ocean.
-Water, water, every where
-  And all the boards did shrink;
-Water, water, every where,
-  Nor any drop to drink.
-S. T. Coleridge (1772-1834)
-'), to_tsquery('english', 'breath&motion&water'));
- ts_rank_cd  
--------------
- 0.008333334
-(1 row)
-
-SELECT ts_rank_cd(to_tsvector('english', '
-Day after day, day after day,
-  We stuck, nor breath nor motion,
-As idle as a painted Ship
-  Upon a painted Ocean.
-Water, water, every where
-  And all the boards did shrink;
-Water, water, every where,
-  Nor any drop to drink.
-S. T. Coleridge (1772-1834)
-'), to_tsquery('english', 'ocean'));
- ts_rank_cd 
-------------
-        0.1
-(1 row)
-
-SELECT ts_rank_cd(to_tsvector('english', '
-Day after day, day after day,
-  We stuck, nor breath nor motion,
-As idle as a painted Ship
-  Upon a painted Ocean.
-Water, water, every where
-  And all the boards did shrink;
-Water, water, every where,
-  Nor any drop to drink.
-S. T. Coleridge (1772-1834)
-'), to_tsquery('english', 'painted <-> Ship'));
- ts_rank_cd 
-------------
-        0.1
-(1 row)
-
-SELECT ts_rank_cd(strip(to_tsvector('both stripped')),
-                  to_tsquery('both & stripped'));
- ts_rank_cd 
-------------
-          0
-(1 row)
-
-SELECT ts_rank_cd(to_tsvector('unstripped') || strip(to_tsvector('stripped')),
-                  to_tsquery('unstripped & stripped'));
- ts_rank_cd 
-------------
-          0
-(1 row)
-
---headline tests
-SELECT ts_headline('english', '
-Day after day, day after day,
-  We stuck, nor breath nor motion,
-As idle as a painted Ship
-  Upon a painted Ocean.
-Water, water, every where
-  And all the boards did shrink;
-Water, water, every where,
-  Nor any drop to drink.
-S. T. Coleridge (1772-1834)
-', to_tsquery('english', 'paint&water'));
-               ts_headline               
------------------------------------------
- <b>painted</b> Ocean.                  +
- <b>Water</b>, <b>water</b>, every where+
-   And all the boards did shrink;       +
- <b>Water</b>, <b>water</b>, every
-(1 row)
-
-SELECT ts_headline('english', '
-Day after day, day after day,
-  We stuck, nor breath nor motion,
-As idle as a painted Ship
-  Upon a painted Ocean.
-Water, water, every where
-  And all the boards did shrink;
-Water, water, every where,
-  Nor any drop to drink.
-S. T. Coleridge (1772-1834)
-', to_tsquery('english', 'breath&motion&water'));
-           ts_headline            
-----------------------------------
- <b>breath</b> nor <b>motion</b>,+
- As idle as a painted Ship       +
-   Upon a painted Ocean.         +
- <b>Water</b>, <b>water</b>
-(1 row)
-
-SELECT ts_headline('english', '
-Day after day, day after day,
-  We stuck, nor breath nor motion,
-As idle as a painted Ship
-  Upon a painted Ocean.
-Water, water, every where
-  And all the boards did shrink;
-Water, water, every where,
-  Nor any drop to drink.
-S. T. Coleridge (1772-1834)
-', to_tsquery('english', 'ocean'));
-           ts_headline            
-----------------------------------
- <b>Ocean</b>.                   +
- Water, water, every where       +
-   And all the boards did shrink;+
- Water, water, every where
-(1 row)
-
-SELECT ts_headline('english', '
-Day after day, day after day,
-  We stuck, nor breath nor motion,
-As idle as a painted Ship
-  Upon a painted Ocean.
-Water, water, every where
-  And all the boards did shrink;
-Water, water, every where,
-  Nor any drop to drink.
-S. T. Coleridge (1772-1834)
-', phraseto_tsquery('english', 'painted Ocean'));
-              ts_headline              
----------------------------------------
- <b>painted</b> Ship                  +
-   Upon a <b>painted</b> <b>Ocean</b>.+
- Water, water, every where            +
-   And all the boards did shrink
-(1 row)
-
-SELECT ts_headline('english', '
-Day after day, day after day,
-  We stuck, nor breath nor motion,
-As idle as a painted Ship
-  Upon a painted Ocean.
-Water, water, every where
-  And all the boards did shrink;
-Water, water, every where,
-  Nor any drop to drink.
-S. T. Coleridge (1772-1834)
-', phraseto_tsquery('english', 'idle as a painted Ship'));
-                 ts_headline                 
----------------------------------------------
- <b>idle</b> as a <b>painted</b> <b>Ship</b>+
-   Upon a <b>painted</b> Ocean.             +
- Water, water, every where                  +
-   And all the boards
-(1 row)
-
-SELECT ts_headline('english',
-'Lorem ipsum urna.  Nullam nullam ullamcorper urna.',
-to_tsquery('english','Lorem') && phraseto_tsquery('english','ullamcorper urna'),
-'MaxWords=100, MinWords=1');
-                                  ts_headline                                  
--------------------------------------------------------------------------------
- <b>Lorem</b> ipsum <b>urna</b>.  Nullam nullam <b>ullamcorper</b> <b>urna</b>
-(1 row)
-
-SELECT ts_headline('english', '
-<html>
-<!-- some comment -->
-<body>
-Sea view wow <u>foo bar</u> <i>qq</i>
-<a href="http://www.google.com/foo.bar.html" target="_blank">YES &nbsp;</a>
-ff-bg
-<script>
-       document.write(15);
-</script>
-</body>
-</html>',
-to_tsquery('english', 'sea&foo'), 'HighlightAll=true');
-                                 ts_headline                                 
------------------------------------------------------------------------------
-                                                                            +
- <html>                                                                     +
- <!-- some comment -->                                                      +
- <body>                                                                     +
- <b>Sea</b> view wow <u><b>foo</b> bar</u> <i>qq</i>                        +
- <a href="http://www.google.com/foo.bar.html" target="_blank">YES &nbsp;</a>+
- ff-bg                                                                      +
- <script>                                                                   +
-        document.write(15);                                                 +
- </script>                                                                  +
- </body>                                                                    +
- </html>
-(1 row)
-
-SELECT ts_headline('simple', '1 2 3 1 3'::text, '1 <-> 3', 'MaxWords=2, MinWords=1');
-    ts_headline    
--------------------
- <b>1</b> <b>3</b>
-(1 row)
-
-SELECT ts_headline('simple', '1 2 3 1 3'::text, '1 & 3', 'MaxWords=4, MinWords=1');
-     ts_headline     
----------------------
- <b>1</b> 2 <b>3</b>
-(1 row)
-
-SELECT ts_headline('simple', '1 2 3 1 3'::text, '1 <-> 3', 'MaxWords=4, MinWords=1');
-        ts_headline         
-----------------------------
- <b>3</b> <b>1</b> <b>3</b>
-(1 row)
-
---Check if headline fragments work
-SELECT ts_headline('english', '
-Day after day, day after day,
-  We stuck, nor breath nor motion,
-As idle as a painted Ship
-  Upon a painted Ocean.
-Water, water, every where
-  And all the boards did shrink;
-Water, water, every where,
-  Nor any drop to drink.
-S. T. Coleridge (1772-1834)
-', to_tsquery('english', 'ocean'), 'MaxFragments=1');
-            ts_headline             
-------------------------------------
- after day,                        +
-   We stuck, nor breath nor motion,+
- As idle as a painted Ship         +
-   Upon a painted <b>Ocean</b>.    +
- Water, water, every where         +
-   And all the boards did shrink;  +
- Water, water, every where,        +
-   Nor any drop
-(1 row)
-
---Check if more than one fragments are displayed
-SELECT ts_headline('english', '
-Day after day, day after day,
-  We stuck, nor breath nor motion,
-As idle as a painted Ship
-  Upon a painted Ocean.
-Water, water, every where
-  And all the boards did shrink;
-Water, water, every where,
-  Nor any drop to drink.
-S. T. Coleridge (1772-1834)
-', to_tsquery('english', 'Coleridge & stuck'), 'MaxFragments=2');
-                 ts_headline                  
-----------------------------------------------
- after day, day after day,                   +
-   We <b>stuck</b>, nor breath nor motion,   +
- As idle as a painted Ship                   +
-   Upon a painted Ocean.                     +
- Water, water, every where                   +
-   And all the boards did shrink;            +
- Water, water, every where ... drop to drink.+
- S. T. <b>Coleridge</b>
-(1 row)
-
---Fragments when there all query words are not in the document
-SELECT ts_headline('english', '
-Day after day, day after day,
-  We stuck, nor breath nor motion,
-As idle as a painted Ship
-  Upon a painted Ocean.
-Water, water, every where
-  And all the boards did shrink;
-Water, water, every where,
-  Nor any drop to drink.
-S. T. Coleridge (1772-1834)
-', to_tsquery('english', 'ocean & seahorse'), 'MaxFragments=1');
-            ts_headline             
-------------------------------------
-                                   +
- Day after day, day after day,     +
-   We stuck, nor breath nor motion,+
- As idle as
-(1 row)
-
---FragmentDelimiter option
-SELECT ts_headline('english', '
-Day after day, day after day,
-  We stuck, nor breath nor motion,
-As idle as a painted Ship
-  Upon a painted Ocean.
-Water, water, every where
-  And all the boards did shrink;
-Water, water, every where,
-  Nor any drop to drink.
-S. T. Coleridge (1772-1834)
-', to_tsquery('english', 'Coleridge & stuck'), 'MaxFragments=2,FragmentDelimiter=***');
-                ts_headline                 
---------------------------------------------
- after day, day after day,                 +
-   We <b>stuck</b>, nor breath nor motion, +
- As idle as a painted Ship                 +
-   Upon a painted Ocean.                   +
- Water, water, every where                 +
-   And all the boards did shrink;          +
- Water, water, every where***drop to drink.+
- S. T. <b>Coleridge</b>
-(1 row)
-
---Fragments with phrase search
-SELECT ts_headline('english',
-'Lorem ipsum urna.  Nullam nullam ullamcorper urna.',
-to_tsquery('english','Lorem') && phraseto_tsquery('english','ullamcorper urna'),
-'MaxFragments=100, MaxWords=100, MinWords=1');
-                                  ts_headline                                  
--------------------------------------------------------------------------------
- <b>Lorem</b> ipsum <b>urna</b>.  Nullam nullam <b>ullamcorper</b> <b>urna</b>
-(1 row)
-
---Rewrite sub system
-CREATE TABLE test_tsquery (txtkeyword TEXT, txtsample TEXT);
-\set ECHO none
-ALTER TABLE test_tsquery ADD COLUMN keyword tsquery;
-UPDATE test_tsquery SET keyword = to_tsquery('english', txtkeyword);
-ALTER TABLE test_tsquery ADD COLUMN sample tsquery;
-UPDATE test_tsquery SET sample = to_tsquery('english', txtsample::text);
-SELECT COUNT(*) FROM test_tsquery WHERE keyword <  'new <-> york';
- count 
--------
-     2
-(1 row)
-
-SELECT COUNT(*) FROM test_tsquery WHERE keyword <= 'new <-> york';
- count 
--------
-     3
-(1 row)
-
-SELECT COUNT(*) FROM test_tsquery WHERE keyword = 'new <-> york';
- count 
--------
-     1
-(1 row)
-
-SELECT COUNT(*) FROM test_tsquery WHERE keyword >= 'new <-> york';
- count 
--------
-     4
-(1 row)
-
-SELECT COUNT(*) FROM test_tsquery WHERE keyword >  'new <-> york';
- count 
--------
-     3
-(1 row)
-
-CREATE UNIQUE INDEX bt_tsq ON test_tsquery (keyword);
-SET enable_seqscan=OFF;
-SELECT COUNT(*) FROM test_tsquery WHERE keyword <  'new <-> york';
- count 
--------
-     2
-(1 row)
-
-SELECT COUNT(*) FROM test_tsquery WHERE keyword <= 'new <-> york';
- count 
--------
-     3
-(1 row)
-
-SELECT COUNT(*) FROM test_tsquery WHERE keyword = 'new <-> york';
- count 
--------
-     1
-(1 row)
-
-SELECT COUNT(*) FROM test_tsquery WHERE keyword >= 'new <-> york';
- count 
--------
-     4
-(1 row)
-
-SELECT COUNT(*) FROM test_tsquery WHERE keyword >  'new <-> york';
- count 
--------
-     3
-(1 row)
-
-RESET enable_seqscan;
-SELECT ts_rewrite('foo & bar & qq & new & york',  'new & york'::tsquery, 'big & apple | nyc | new & york & city');
-                                  ts_rewrite                                  
-------------------------------------------------------------------------------
- 'foo' & 'bar' & 'qq' & ( 'city' & 'new' & 'york' | 'nyc' | 'big' & 'apple' )
-(1 row)
-
-SELECT ts_rewrite(ts_rewrite('new & !york ', 'york', '!jersey'),
-                  'jersey', 'mexico');
-     ts_rewrite     
---------------------
- 'new' & !!'mexico'
-(1 row)
-
-SELECT ts_rewrite('moscow', 'SELECT keyword, sample FROM test_tsquery'::text );
-     ts_rewrite      
----------------------
- 'moskva' | 'moscow'
-(1 row)
-
-SELECT ts_rewrite('moscow & hotel', 'SELECT keyword, sample FROM test_tsquery'::text );
-            ts_rewrite             
------------------------------------
- 'hotel' & ( 'moskva' | 'moscow' )
-(1 row)
-
-SELECT ts_rewrite('bar & qq & foo & (new <-> york)', 'SELECT keyword, sample FROM test_tsquery'::text );
-                                     ts_rewrite                                      
--------------------------------------------------------------------------------------
- 'citi' & 'foo' & ( 'bar' | 'qq' ) & ( 'nyc' | 'big' <-> 'appl' | 'new' <-> 'york' )
-(1 row)
-
-SELECT ts_rewrite( 'moscow', 'SELECT keyword, sample FROM test_tsquery');
-     ts_rewrite      
----------------------
- 'moskva' | 'moscow'
-(1 row)
-
-SELECT ts_rewrite( 'moscow & hotel', 'SELECT keyword, sample FROM test_tsquery');
-            ts_rewrite             
------------------------------------
- 'hotel' & ( 'moskva' | 'moscow' )
-(1 row)
-
-SELECT ts_rewrite( 'bar & qq & foo & (new <-> york)', 'SELECT keyword, sample FROM test_tsquery');
-                                     ts_rewrite                                      
--------------------------------------------------------------------------------------
- 'citi' & 'foo' & ( 'bar' | 'qq' ) & ( 'nyc' | 'big' <-> 'appl' | 'new' <-> 'york' )
-(1 row)
-
-SELECT ts_rewrite('1 & (2 <-> 3)', 'SELECT keyword, sample FROM test_tsquery'::text );
- ts_rewrite  
--------------
- '2' <-> '4'
-(1 row)
-
-SELECT ts_rewrite('1 & (2 <2> 3)', 'SELECT keyword, sample FROM test_tsquery'::text );
-    ts_rewrite     
--------------------
- '1' & '2' <2> '3'
-(1 row)
-
-SELECT ts_rewrite('5 <-> (1 & (2 <-> 3))', 'SELECT keyword, sample FROM test_tsquery'::text );
-       ts_rewrite        
--------------------------
- '5' <-> ( '2' <-> '4' )
-(1 row)
-
-SELECT ts_rewrite('5 <-> (6 | 8)', 'SELECT keyword, sample FROM test_tsquery'::text );
-      ts_rewrite       
------------------------
- '5' <-> ( '6' | '8' )
-(1 row)
-
--- Check empty substitution
-SELECT ts_rewrite(to_tsquery('5 & (6 | 5)'), to_tsquery('5'), to_tsquery(''));
-NOTICE:  text-search query doesn't contain lexemes: ""
- ts_rewrite 
-------------
- '6'
-(1 row)
-
-SELECT ts_rewrite(to_tsquery('!5'), to_tsquery('5'), to_tsquery(''));
-NOTICE:  text-search query doesn't contain lexemes: ""
- ts_rewrite 
-------------
- 
-(1 row)
-
-SELECT keyword FROM test_tsquery WHERE keyword @> 'new';
-     keyword      
-------------------
- 'new' <-> 'york'
-(1 row)
-
-SELECT keyword FROM test_tsquery WHERE keyword @> 'moscow';
- keyword  
-----------
- 'moscow'
-(1 row)
-
-SELECT keyword FROM test_tsquery WHERE keyword <@ 'new';
- keyword 
----------
-(0 rows)
-
-SELECT keyword FROM test_tsquery WHERE keyword <@ 'moscow';
- keyword  
-----------
- 'moscow'
-(1 row)
-
-SELECT ts_rewrite( query, 'SELECT keyword, sample FROM test_tsquery' ) FROM to_tsquery('english', 'moscow') AS query;
-     ts_rewrite      
----------------------
- 'moskva' | 'moscow'
-(1 row)
-
-SELECT ts_rewrite( query, 'SELECT keyword, sample FROM test_tsquery' ) FROM to_tsquery('english', 'moscow & hotel') AS query;
-            ts_rewrite             
------------------------------------
- 'hotel' & ( 'moskva' | 'moscow' )
-(1 row)
-
-SELECT ts_rewrite( query, 'SELECT keyword, sample FROM test_tsquery' ) FROM to_tsquery('english', 'bar & qq & foo & (new <-> york)') AS query;
-                                     ts_rewrite                                      
--------------------------------------------------------------------------------------
- 'citi' & 'foo' & ( 'bar' | 'qq' ) & ( 'nyc' | 'big' <-> 'appl' | 'new' <-> 'york' )
-(1 row)
-
-SELECT ts_rewrite( query, 'SELECT keyword, sample FROM test_tsquery' ) FROM to_tsquery('english', 'moscow') AS query;
-     ts_rewrite      
----------------------
- 'moskva' | 'moscow'
-(1 row)
-
-SELECT ts_rewrite( query, 'SELECT keyword, sample FROM test_tsquery' ) FROM to_tsquery('english', 'moscow & hotel') AS query;
-            ts_rewrite             
------------------------------------
- 'hotel' & ( 'moskva' | 'moscow' )
-(1 row)
-
-SELECT ts_rewrite( query, 'SELECT keyword, sample FROM test_tsquery' ) FROM to_tsquery('english', 'bar & qq & foo & (new <-> york)') AS query;
-                                     ts_rewrite                                      
--------------------------------------------------------------------------------------
- 'citi' & 'foo' & ( 'bar' | 'qq' ) & ( 'nyc' | 'big' <-> 'appl' | 'new' <-> 'york' )
-(1 row)
-
-CREATE INDEX qq ON test_tsquery USING gist (keyword tsquery_ops);
-SET enable_seqscan=OFF;
-SELECT keyword FROM test_tsquery WHERE keyword @> 'new';
-     keyword      
-------------------
- 'new' <-> 'york'
-(1 row)
-
-SELECT keyword FROM test_tsquery WHERE keyword @> 'moscow';
- keyword  
-----------
- 'moscow'
-(1 row)
-
-SELECT keyword FROM test_tsquery WHERE keyword <@ 'new';
- keyword 
----------
-(0 rows)
-
-SELECT keyword FROM test_tsquery WHERE keyword <@ 'moscow';
- keyword  
-----------
- 'moscow'
-(1 row)
-
-SELECT ts_rewrite( query, 'SELECT keyword, sample FROM test_tsquery' ) FROM to_tsquery('english', 'moscow') AS query;
-     ts_rewrite      
----------------------
- 'moskva' | 'moscow'
-(1 row)
-
-SELECT ts_rewrite( query, 'SELECT keyword, sample FROM test_tsquery' ) FROM to_tsquery('english', 'moscow & hotel') AS query;
-            ts_rewrite             
------------------------------------
- 'hotel' & ( 'moskva' | 'moscow' )
-(1 row)
-
-SELECT ts_rewrite( query, 'SELECT keyword, sample FROM test_tsquery' ) FROM to_tsquery('english', 'bar & qq & foo & (new <-> york)') AS query;
-                                     ts_rewrite                                      
--------------------------------------------------------------------------------------
- 'citi' & 'foo' & ( 'bar' | 'qq' ) & ( 'nyc' | 'big' <-> 'appl' | 'new' <-> 'york' )
-(1 row)
-
-SELECT ts_rewrite( query, 'SELECT keyword, sample FROM test_tsquery' ) FROM to_tsquery('english', 'moscow') AS query;
-     ts_rewrite      
----------------------
- 'moskva' | 'moscow'
-(1 row)
-
-SELECT ts_rewrite( query, 'SELECT keyword, sample FROM test_tsquery' ) FROM to_tsquery('english', 'moscow & hotel') AS query;
-            ts_rewrite             
------------------------------------
- 'hotel' & ( 'moskva' | 'moscow' )
-(1 row)
-
-SELECT ts_rewrite( query, 'SELECT keyword, sample FROM test_tsquery' ) FROM to_tsquery('english', 'bar & qq & foo & (new <-> york)') AS query;
-                                     ts_rewrite                                      
--------------------------------------------------------------------------------------
- 'citi' & 'foo' & ( 'bar' | 'qq' ) & ( 'nyc' | 'big' <-> 'appl' | 'new' <-> 'york' )
-(1 row)
-
-SELECT ts_rewrite(tsquery_phrase('foo', 'foo'), 'foo', 'bar | baz');
-               ts_rewrite                
------------------------------------------
- ( 'bar' | 'baz' ) <-> ( 'bar' | 'baz' )
-(1 row)
-
-SELECT to_tsvector('foo bar') @@
-  ts_rewrite(tsquery_phrase('foo', 'foo'), 'foo', 'bar | baz');
- ?column? 
-----------
- f
-(1 row)
-
-SELECT to_tsvector('bar baz') @@
-  ts_rewrite(tsquery_phrase('foo', 'foo'), 'foo', 'bar | baz');
- ?column? 
-----------
- t
-(1 row)
-
-RESET enable_seqscan;
---test GUC
-SET default_text_search_config=simple;
-SELECT to_tsvector('SKIES My booKs');
-        to_tsvector         
-----------------------------
- 'books':3 'my':2 'skies':1
-(1 row)
-
-SELECT plainto_tsquery('SKIES My booKs');
-     plainto_tsquery      
---------------------------
- 'skies' & 'my' & 'books'
-(1 row)
-
-SELECT to_tsquery('SKIES & My | booKs');
-        to_tsquery        
---------------------------
- 'skies' & 'my' | 'books'
-(1 row)
-
-SET default_text_search_config=english;
-SELECT to_tsvector('SKIES My booKs');
-   to_tsvector    
-------------------
- 'book':3 'sky':1
-(1 row)
-
-SELECT plainto_tsquery('SKIES My booKs');
- plainto_tsquery 
------------------
- 'sky' & 'book'
-(1 row)
-
-SELECT to_tsquery('SKIES & My | booKs');
-   to_tsquery   
-----------------
- 'sky' | 'book'
-(1 row)
-
---trigger
-CREATE TRIGGER tsvectorupdate
-BEFORE UPDATE OR INSERT ON test_tsvector
-FOR EACH ROW EXECUTE PROCEDURE tsvector_update_trigger(a, 'pg_catalog.english', t);
-SELECT count(*) FROM test_tsvector WHERE a @@ to_tsquery('345&qwerty');
- count 
--------
-     0
-(1 row)
-
-INSERT INTO test_tsvector (t) VALUES ('345 qwerty');
-SELECT count(*) FROM test_tsvector WHERE a @@ to_tsquery('345&qwerty');
- count 
--------
-     1
-(1 row)
-
-UPDATE test_tsvector SET t = null WHERE t = '345 qwerty';
-SELECT count(*) FROM test_tsvector WHERE a @@ to_tsquery('345&qwerty');
- count 
--------
-     0
-(1 row)
-
-INSERT INTO test_tsvector (t) VALUES ('345 qwerty');
-SELECT count(*) FROM test_tsvector WHERE a @@ to_tsquery('345&qwerty');
- count 
--------
-     1
-(1 row)
-
--- Test inlining of immutable constant functions
--- to_tsquery(text) is not immutable, so it won't be inlined
-explain (costs off)
-select * from test_tsquery, to_tsquery('new') q where txtsample @@ q;
-                   QUERY PLAN                   
-------------------------------------------------
- Nested Loop
-   Join Filter: (test_tsquery.txtsample @@ q.q)
-   ->  Function Scan on to_tsquery q
-   ->  Seq Scan on test_tsquery
-(4 rows)
-
--- to_tsquery(regconfig, text) is an immutable function.
--- That allows us to get rid of using function scan and join at all.
-explain (costs off)
-select * from test_tsquery, to_tsquery('english', 'new') q where txtsample @@ q;
-                 QUERY PLAN                  
----------------------------------------------
- Seq Scan on test_tsquery
-   Filter: (txtsample @@ '''new'''::tsquery)
-(2 rows)
-
--- test finding items in GIN's pending list
-create temp table pendtest (ts tsvector);
-create index pendtest_idx on pendtest using gin(ts);
-insert into pendtest values (to_tsvector('Lore ipsam'));
-insert into pendtest values (to_tsvector('Lore ipsum'));
-select * from pendtest where 'ipsu:*'::tsquery @@ ts;
-         ts         
---------------------
- 'ipsum':2 'lore':1
-(1 row)
-
-select * from pendtest where 'ipsa:*'::tsquery @@ ts;
-         ts         
---------------------
- 'ipsam':2 'lore':1
-(1 row)
-
-select * from pendtest where 'ips:*'::tsquery @@ ts;
-         ts         
---------------------
- 'ipsam':2 'lore':1
- 'ipsum':2 'lore':1
-(2 rows)
-
-select * from pendtest where 'ipt:*'::tsquery @@ ts;
- ts 
-----
-(0 rows)
-
-select * from pendtest where 'ipi:*'::tsquery @@ ts;
- ts 
-----
-(0 rows)
-
---check OP_PHRASE on index
-create temp table phrase_index_test(fts tsvector);
-insert into phrase_index_test values ('A fat cat has just eaten a rat.');
-insert into phrase_index_test values (to_tsvector('english', 'A fat cat has just eaten a rat.'));
-create index phrase_index_test_idx on phrase_index_test using gin(fts);
-set enable_seqscan = off;
-select * from phrase_index_test where fts @@ phraseto_tsquery('english', 'fat cat');
-                fts                
------------------------------------
- 'cat':3 'eaten':6 'fat':2 'rat':8
-(1 row)
-
-set enable_seqscan = on;
--- test websearch_to_tsquery function
-select websearch_to_tsquery('simple', 'I have a fat:*ABCD cat');
-            websearch_to_tsquery             
----------------------------------------------
- 'i' & 'have' & 'a' & 'fat' & 'abcd' & 'cat'
-(1 row)
-
-select websearch_to_tsquery('simple', 'orange:**AABBCCDD');
- websearch_to_tsquery  
------------------------
- 'orange' & 'aabbccdd'
-(1 row)
-
-select websearch_to_tsquery('simple', 'fat:A!cat:B|rat:C<');
-          websearch_to_tsquery           
------------------------------------------
- 'fat' & 'a' & 'cat' & 'b' & 'rat' & 'c'
-(1 row)
-
-select websearch_to_tsquery('simple', 'fat:A : cat:B');
-   websearch_to_tsquery    
----------------------------
- 'fat' & 'a' & 'cat' & 'b'
-(1 row)
-
-select websearch_to_tsquery('simple', 'fat*rat');
- websearch_to_tsquery 
-----------------------
- 'fat' <-> 'rat'
-(1 row)
-
-select websearch_to_tsquery('simple', 'fat-rat');
-     websearch_to_tsquery      
--------------------------------
- 'fat-rat' <-> 'fat' <-> 'rat'
-(1 row)
-
-select websearch_to_tsquery('simple', 'fat_rat');
- websearch_to_tsquery 
-----------------------
- 'fat' <-> 'rat'
-(1 row)
-
--- weights are completely ignored
-select websearch_to_tsquery('simple', 'abc : def');
- websearch_to_tsquery 
-----------------------
- 'abc' & 'def'
-(1 row)
-
-select websearch_to_tsquery('simple', 'abc:def');
- websearch_to_tsquery 
-----------------------
- 'abc' & 'def'
-(1 row)
-
-select websearch_to_tsquery('simple', 'a:::b');
- websearch_to_tsquery 
-----------------------
- 'a' & 'b'
-(1 row)
-
-select websearch_to_tsquery('simple', 'abc:d');
- websearch_to_tsquery 
-----------------------
- 'abc' & 'd'
-(1 row)
-
-select websearch_to_tsquery('simple', ':');
-NOTICE:  text-search query contains only stop words or doesn't contain lexemes, ignored
- websearch_to_tsquery 
-----------------------
- 
-(1 row)
-
--- these operators are ignored
-select websearch_to_tsquery('simple', 'abc & def');
- websearch_to_tsquery 
-----------------------
- 'abc' & 'def'
-(1 row)
-
-select websearch_to_tsquery('simple', 'abc | def');
- websearch_to_tsquery 
-----------------------
- 'abc' & 'def'
-(1 row)
-
-select websearch_to_tsquery('simple', 'abc <-> def');
- websearch_to_tsquery 
-----------------------
- 'abc' & 'def'
-(1 row)
-
-select websearch_to_tsquery('simple', 'abc (pg or class)');
-  websearch_to_tsquery  
-------------------------
- 'abc' & 'pg' | 'class'
-(1 row)
-
--- NOT is ignored in quotes
-select websearch_to_tsquery('english', 'My brand new smartphone');
-     websearch_to_tsquery      
--------------------------------
- 'brand' & 'new' & 'smartphon'
-(1 row)
-
-select websearch_to_tsquery('english', 'My brand "new smartphone"');
-      websearch_to_tsquery       
----------------------------------
- 'brand' & 'new' <-> 'smartphon'
-(1 row)
-
-select websearch_to_tsquery('english', 'My brand "new -smartphone"');
-      websearch_to_tsquery       
----------------------------------
- 'brand' & 'new' <-> 'smartphon'
-(1 row)
-
--- test OR operator
-select websearch_to_tsquery('simple', 'cat or rat');
- websearch_to_tsquery 
-----------------------
- 'cat' | 'rat'
-(1 row)
-
-select websearch_to_tsquery('simple', 'cat OR rat');
- websearch_to_tsquery 
-----------------------
- 'cat' | 'rat'
-(1 row)
-
-select websearch_to_tsquery('simple', 'cat "OR" rat');
- websearch_to_tsquery 
-----------------------
- 'cat' & 'or' & 'rat'
-(1 row)
-
-select websearch_to_tsquery('simple', 'cat OR');
- websearch_to_tsquery 
-----------------------
- 'cat' & 'or'
-(1 row)
-
-select websearch_to_tsquery('simple', 'OR rat');
- websearch_to_tsquery 
-----------------------
- 'or' & 'rat'
-(1 row)
-
-select websearch_to_tsquery('simple', '"fat cat OR rat"');
-        websearch_to_tsquery        
-------------------------------------
- 'fat' <-> 'cat' <-> 'or' <-> 'rat'
-(1 row)
-
-select websearch_to_tsquery('simple', 'fat (cat OR rat');
- websearch_to_tsquery  
------------------------
- 'fat' & 'cat' | 'rat'
-(1 row)
-
-select websearch_to_tsquery('simple', 'or OR or');
- websearch_to_tsquery 
-----------------------
- 'or' | 'or'
-(1 row)
-
--- OR is an operator here ...
-select websearch_to_tsquery('simple', '"fat cat"or"fat rat"');
-       websearch_to_tsquery        
------------------------------------
- 'fat' <-> 'cat' | 'fat' <-> 'rat'
-(1 row)
-
-select websearch_to_tsquery('simple', 'fat or(rat');
- websearch_to_tsquery 
-----------------------
- 'fat' | 'rat'
-(1 row)
-
-select websearch_to_tsquery('simple', 'fat or)rat');
- websearch_to_tsquery 
-----------------------
- 'fat' | 'rat'
-(1 row)
-
-select websearch_to_tsquery('simple', 'fat or&rat');
- websearch_to_tsquery 
-----------------------
- 'fat' | 'rat'
-(1 row)
-
-select websearch_to_tsquery('simple', 'fat or|rat');
- websearch_to_tsquery 
-----------------------
- 'fat' | 'rat'
-(1 row)
-
-select websearch_to_tsquery('simple', 'fat or!rat');
- websearch_to_tsquery 
-----------------------
- 'fat' | 'rat'
-(1 row)
-
-select websearch_to_tsquery('simple', 'fat or<rat');
- websearch_to_tsquery 
-----------------------
- 'fat' | 'rat'
-(1 row)
-
-select websearch_to_tsquery('simple', 'fat or>rat');
- websearch_to_tsquery 
-----------------------
- 'fat' | 'rat'
-(1 row)
-
-select websearch_to_tsquery('simple', 'fat or ');
- websearch_to_tsquery 
-----------------------
- 'fat' & 'or'
-(1 row)
-
--- ... but not here
-select websearch_to_tsquery('simple', 'abc orange');
- websearch_to_tsquery 
-----------------------
- 'abc' & 'orange'
-(1 row)
-
-select websearch_to_tsquery('simple', 'abc OR1234');
- websearch_to_tsquery 
-----------------------
- 'abc' & 'or1234'
-(1 row)
-
-select websearch_to_tsquery('simple', 'abc or-abc');
-        websearch_to_tsquery         
--------------------------------------
- 'abc' & 'or-abc' <-> 'or' <-> 'abc'
-(1 row)
-
-select websearch_to_tsquery('simple', 'abc OR_abc');
-  websearch_to_tsquery  
-------------------------
- 'abc' & 'or' <-> 'abc'
-(1 row)
-
--- test quotes
-select websearch_to_tsquery('english', '"pg_class pg');
-   websearch_to_tsquery    
----------------------------
- 'pg' <-> 'class' <-> 'pg'
-(1 row)
-
-select websearch_to_tsquery('english', 'pg_class pg"');
-  websearch_to_tsquery   
--------------------------
- 'pg' <-> 'class' & 'pg'
-(1 row)
-
-select websearch_to_tsquery('english', '"pg_class pg"');
-   websearch_to_tsquery    
----------------------------
- 'pg' <-> 'class' <-> 'pg'
-(1 row)
-
-select websearch_to_tsquery('english', '"pg_class : pg"');
-   websearch_to_tsquery    
----------------------------
- 'pg' <-> 'class' <-> 'pg'
-(1 row)
-
-select websearch_to_tsquery('english', 'abc "pg_class pg"');
-       websearch_to_tsquery        
------------------------------------
- 'abc' & 'pg' <-> 'class' <-> 'pg'
-(1 row)
-
-select websearch_to_tsquery('english', '"pg_class pg" def');
-       websearch_to_tsquery        
------------------------------------
- 'pg' <-> 'class' <-> 'pg' & 'def'
-(1 row)
-
-select websearch_to_tsquery('english', 'abc "pg pg_class pg" def');
-                websearch_to_tsquery                
-----------------------------------------------------
- 'abc' & 'pg' <-> 'pg' <-> 'class' <-> 'pg' & 'def'
-(1 row)
-
-select websearch_to_tsquery('english', ' or "pg pg_class pg" or ');
-        websearch_to_tsquery        
-------------------------------------
- 'pg' <-> 'pg' <-> 'class' <-> 'pg'
-(1 row)
-
-select websearch_to_tsquery('english', '""pg pg_class pg""');
-      websearch_to_tsquery      
---------------------------------
- 'pg' & 'pg' <-> 'class' & 'pg'
-(1 row)
-
-select websearch_to_tsquery('english', 'abc """"" def');
- websearch_to_tsquery 
-----------------------
- 'abc' & 'def'
-(1 row)
-
-select websearch_to_tsquery('english', 'cat -"fat rat"');
-     websearch_to_tsquery     
-------------------------------
- 'cat' & !( 'fat' <-> 'rat' )
-(1 row)
-
-select websearch_to_tsquery('english', 'cat -"fat rat" cheese');
-          websearch_to_tsquery          
-----------------------------------------
- 'cat' & !( 'fat' <-> 'rat' ) & 'chees'
-(1 row)
-
-select websearch_to_tsquery('english', 'abc "def -"');
- websearch_to_tsquery 
-----------------------
- 'abc' & 'def'
-(1 row)
-
-select websearch_to_tsquery('english', 'abc "def :"');
- websearch_to_tsquery 
-----------------------
- 'abc' & 'def'
-(1 row)
-
-select websearch_to_tsquery('english', '"A fat cat" has just eaten a -rat.');
-        websearch_to_tsquery        
-------------------------------------
- 'fat' <-> 'cat' & 'eaten' & !'rat'
-(1 row)
-
-select websearch_to_tsquery('english', '"A fat cat" has just eaten OR !rat.');
-       websearch_to_tsquery        
------------------------------------
- 'fat' <-> 'cat' & 'eaten' | 'rat'
-(1 row)
-
-select websearch_to_tsquery('english', '"A fat cat" has just (+eaten OR -rat)');
-        websearch_to_tsquery        
-------------------------------------
- 'fat' <-> 'cat' & 'eaten' | !'rat'
-(1 row)
-
-select websearch_to_tsquery('english', 'this is ----fine');
- websearch_to_tsquery 
-----------------------
- !!!!'fine'
-(1 row)
-
-select websearch_to_tsquery('english', '(()) )))) this ||| is && -fine, "dear friend" OR good');
-          websearch_to_tsquery          
-----------------------------------------
- !'fine' & 'dear' <-> 'friend' | 'good'
-(1 row)
-
-select websearch_to_tsquery('english', 'an old <-> cat " is fine &&& too');
-  websearch_to_tsquery  
-------------------------
- 'old' & 'cat' & 'fine'
-(1 row)
-
-select websearch_to_tsquery('english', '"A the" OR just on');
-NOTICE:  text-search query contains only stop words or doesn't contain lexemes, ignored
- websearch_to_tsquery 
-----------------------
- 
-(1 row)
-
-select websearch_to_tsquery('english', '"a fat cat" ate a rat');
-      websearch_to_tsquery       
----------------------------------
- 'fat' <-> 'cat' & 'ate' & 'rat'
-(1 row)
-
-select to_tsvector('english', 'A fat cat ate a rat') @@
-	websearch_to_tsquery('english', '"a fat cat" ate a rat');
- ?column? 
-----------
- t
-(1 row)
-
-select to_tsvector('english', 'A fat grey cat ate a rat') @@
-	websearch_to_tsquery('english', '"a fat cat" ate a rat');
- ?column? 
-----------
- f
-(1 row)
-
--- cases handled by gettoken_tsvector()
-select websearch_to_tsquery('''');
-NOTICE:  text-search query contains only stop words or doesn't contain lexemes, ignored
- websearch_to_tsquery 
-----------------------
- 
-(1 row)
-
-select websearch_to_tsquery('''abc''''def''');
- websearch_to_tsquery 
-----------------------
- 'abc' <-> 'def'
-(1 row)
-
-select websearch_to_tsquery('\abc');
- websearch_to_tsquery 
-----------------------
- 'abc'
-(1 row)
-
-select websearch_to_tsquery('\');
-NOTICE:  text-search query contains only stop words or doesn't contain lexemes, ignored
- websearch_to_tsquery 
-----------------------
- 
-(1 row)
+dyld: lazy symbol binding failed: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
+
+dyld: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
 
diff -U3 /Users/kenaniah/workspace/postgres/src/test/regress/expected/foreign_data.out /Users/kenaniah/workspace/postgres/src/test/regress/results/foreign_data.out
--- /Users/kenaniah/workspace/postgres/src/test/regress/expected/foreign_data.out	2021-10-03 18:09:17.000000000 -0700
+++ /Users/kenaniah/workspace/postgres/src/test/regress/results/foreign_data.out	2021-10-03 20:08:21.000000000 -0700
@@ -724,1383 +724,11 @@
 COMMENT ON FOREIGN TABLE ft1 IS 'ft1';
 COMMENT ON COLUMN ft1.c1 IS 'ft1.c1';
 \d+ ft1
-                                                 Foreign table "public.ft1"
- Column |  Type   | Collation | Nullable | Default |          FDW options           | Storage  | Stats target | Description 
---------+---------+-----------+----------+---------+--------------------------------+----------+--------------+-------------
- c1     | integer |           | not null |         | ("param 1" 'val1')             | plain    |              | ft1.c1
- c2     | text    |           |          |         | (param2 'val2', param3 'val3') | extended |              | 
- c3     | date    |           |          |         |                                | plain    |              | 
-Check constraints:
-    "ft1_c2_check" CHECK (c2 <> ''::text)
-    "ft1_c3_check" CHECK (c3 >= '01-01-1994'::date AND c3 <= '01-31-1994'::date)
-Server: s0
-FDW options: (delimiter ',', quote '"', "be quoted" 'value')
-
-\det+
-                                 List of foreign tables
- Schema | Table | Server |                   FDW options                   | Description 
---------+-------+--------+-------------------------------------------------+-------------
- public | ft1   | s0     | (delimiter ',', quote '"', "be quoted" 'value') | ft1
-(1 row)
-
-CREATE INDEX id_ft1_c2 ON ft1 (c2);                             -- ERROR
-ERROR:  cannot create index on relation "ft1"
-DETAIL:  This operation is not supported for foreign tables.
-SELECT * FROM ft1;                                              -- ERROR
-ERROR:  foreign-data wrapper "dummy" has no handler
-EXPLAIN SELECT * FROM ft1;                                      -- ERROR
-ERROR:  foreign-data wrapper "dummy" has no handler
-CREATE TABLE lt1 (a INT) PARTITION BY RANGE (a);
-CREATE FOREIGN TABLE ft_part1
-  PARTITION OF lt1 FOR VALUES FROM (0) TO (1000) SERVER s0;
-CREATE INDEX ON lt1 (a);                              -- skips partition
-CREATE UNIQUE INDEX ON lt1 (a);                                 -- ERROR
-ERROR:  cannot create unique index on partitioned table "lt1"
-DETAIL:  Table "lt1" contains partitions that are foreign tables.
-ALTER TABLE lt1 ADD PRIMARY KEY (a);                            -- ERROR
-ERROR:  cannot create unique index on partitioned table "lt1"
-DETAIL:  Table "lt1" contains partitions that are foreign tables.
-DROP TABLE lt1;
-CREATE TABLE lt1 (a INT) PARTITION BY RANGE (a);
-CREATE INDEX ON lt1 (a);
-CREATE FOREIGN TABLE ft_part1
-  PARTITION OF lt1 FOR VALUES FROM (0) TO (1000) SERVER s0;
-CREATE FOREIGN TABLE ft_part2 (a INT) SERVER s0;
-ALTER TABLE lt1 ATTACH PARTITION ft_part2 FOR VALUES FROM (1000) TO (2000);
-DROP FOREIGN TABLE ft_part1, ft_part2;
-CREATE UNIQUE INDEX ON lt1 (a);
-ALTER TABLE lt1 ADD PRIMARY KEY (a);
-CREATE FOREIGN TABLE ft_part1
-  PARTITION OF lt1 FOR VALUES FROM (0) TO (1000) SERVER s0;     -- ERROR
-ERROR:  cannot create foreign partition of partitioned table "lt1"
-DETAIL:  Table "lt1" contains indexes that are unique.
-CREATE FOREIGN TABLE ft_part2 (a INT NOT NULL) SERVER s0;
-ALTER TABLE lt1 ATTACH PARTITION ft_part2
-  FOR VALUES FROM (1000) TO (2000);                             -- ERROR
-ERROR:  cannot attach foreign table "ft_part2" as partition of partitioned table "lt1"
-DETAIL:  Partitioned table "lt1" contains unique indexes.
-DROP TABLE lt1;
-DROP FOREIGN TABLE ft_part2;
-CREATE TABLE lt1 (a INT) PARTITION BY RANGE (a);
-CREATE INDEX ON lt1 (a);
-CREATE TABLE lt1_part1
-  PARTITION OF lt1 FOR VALUES FROM (0) TO (1000)
-  PARTITION BY RANGE (a);
-CREATE FOREIGN TABLE ft_part_1_1
-  PARTITION OF lt1_part1 FOR VALUES FROM (0) TO (100) SERVER s0;
-CREATE FOREIGN TABLE ft_part_1_2 (a INT) SERVER s0;
-ALTER TABLE lt1_part1 ATTACH PARTITION ft_part_1_2 FOR VALUES FROM (100) TO (200);
-CREATE UNIQUE INDEX ON lt1 (a);
-ERROR:  cannot create unique index on partitioned table "lt1"
-DETAIL:  Table "lt1" contains partitions that are foreign tables.
-ALTER TABLE lt1 ADD PRIMARY KEY (a);
-ERROR:  cannot create unique index on partitioned table "lt1_part1"
-DETAIL:  Table "lt1_part1" contains partitions that are foreign tables.
-DROP FOREIGN TABLE ft_part_1_1, ft_part_1_2;
-CREATE UNIQUE INDEX ON lt1 (a);
-ALTER TABLE lt1 ADD PRIMARY KEY (a);
-CREATE FOREIGN TABLE ft_part_1_1
-  PARTITION OF lt1_part1 FOR VALUES FROM (0) TO (100) SERVER s0;
-ERROR:  cannot create foreign partition of partitioned table "lt1_part1"
-DETAIL:  Table "lt1_part1" contains indexes that are unique.
-CREATE FOREIGN TABLE ft_part_1_2 (a INT NOT NULL) SERVER s0;
-ALTER TABLE lt1_part1 ATTACH PARTITION ft_part_1_2 FOR VALUES FROM (100) TO (200);
-ERROR:  cannot attach foreign table "ft_part_1_2" as partition of partitioned table "lt1_part1"
-DETAIL:  Partitioned table "lt1_part1" contains unique indexes.
-DROP TABLE lt1;
-DROP FOREIGN TABLE ft_part_1_2;
--- ALTER FOREIGN TABLE
-COMMENT ON FOREIGN TABLE ft1 IS 'foreign table';
-COMMENT ON FOREIGN TABLE ft1 IS NULL;
-COMMENT ON COLUMN ft1.c1 IS 'foreign column';
-COMMENT ON COLUMN ft1.c1 IS NULL;
-ALTER FOREIGN TABLE ft1 ADD COLUMN c4 integer;
-ALTER FOREIGN TABLE ft1 ADD COLUMN c5 integer DEFAULT 0;
-ALTER FOREIGN TABLE ft1 ADD COLUMN c6 integer;
-ALTER FOREIGN TABLE ft1 ADD COLUMN c7 integer NOT NULL;
-ALTER FOREIGN TABLE ft1 ADD COLUMN c8 integer;
-ALTER FOREIGN TABLE ft1 ADD COLUMN c9 integer;
-ALTER FOREIGN TABLE ft1 ADD COLUMN c10 integer OPTIONS (p1 'v1');
-ALTER FOREIGN TABLE ft1 ALTER COLUMN c4 SET DEFAULT 0;
-ALTER FOREIGN TABLE ft1 ALTER COLUMN c5 DROP DEFAULT;
-ALTER FOREIGN TABLE ft1 ALTER COLUMN c6 SET NOT NULL;
-ALTER FOREIGN TABLE ft1 ALTER COLUMN c7 DROP NOT NULL;
-ALTER FOREIGN TABLE ft1 ALTER COLUMN c8 TYPE char(10) USING '0'; -- ERROR
-ERROR:  "ft1" is not a table
-ALTER FOREIGN TABLE ft1 ALTER COLUMN c8 TYPE char(10);
-ALTER FOREIGN TABLE ft1 ALTER COLUMN c8 SET DATA TYPE text;
-ALTER FOREIGN TABLE ft1 ALTER COLUMN xmin OPTIONS (ADD p1 'v1'); -- ERROR
-ERROR:  cannot alter system column "xmin"
-ALTER FOREIGN TABLE ft1 ALTER COLUMN c7 OPTIONS (ADD p1 'v1', ADD p2 'v2'),
-                        ALTER COLUMN c8 OPTIONS (ADD p1 'v1', ADD p2 'v2');
-ALTER FOREIGN TABLE ft1 ALTER COLUMN c8 OPTIONS (SET p2 'V2', DROP p1);
-ALTER FOREIGN TABLE ft1 ALTER COLUMN c1 SET STATISTICS 10000;
-ALTER FOREIGN TABLE ft1 ALTER COLUMN c1 SET (n_distinct = 100);
-ALTER FOREIGN TABLE ft1 ALTER COLUMN c8 SET STATISTICS -1;
-ALTER FOREIGN TABLE ft1 ALTER COLUMN c8 SET STORAGE PLAIN;
-\d+ ft1
-                                                 Foreign table "public.ft1"
- Column |  Type   | Collation | Nullable | Default |          FDW options           | Storage  | Stats target | Description 
---------+---------+-----------+----------+---------+--------------------------------+----------+--------------+-------------
- c1     | integer |           | not null |         | ("param 1" 'val1')             | plain    | 10000        | 
- c2     | text    |           |          |         | (param2 'val2', param3 'val3') | extended |              | 
- c3     | date    |           |          |         |                                | plain    |              | 
- c4     | integer |           |          | 0       |                                | plain    |              | 
- c5     | integer |           |          |         |                                | plain    |              | 
- c6     | integer |           | not null |         |                                | plain    |              | 
- c7     | integer |           |          |         | (p1 'v1', p2 'v2')             | plain    |              | 
- c8     | text    |           |          |         | (p2 'V2')                      | plain    |              | 
- c9     | integer |           |          |         |                                | plain    |              | 
- c10    | integer |           |          |         | (p1 'v1')                      | plain    |              | 
-Check constraints:
-    "ft1_c2_check" CHECK (c2 <> ''::text)
-    "ft1_c3_check" CHECK (c3 >= '01-01-1994'::date AND c3 <= '01-31-1994'::date)
-Server: s0
-FDW options: (delimiter ',', quote '"', "be quoted" 'value')
-
--- can't change the column type if it's used elsewhere
-CREATE TABLE use_ft1_column_type (x ft1);
-ALTER FOREIGN TABLE ft1 ALTER COLUMN c8 SET DATA TYPE integer;	-- ERROR
-ERROR:  cannot alter foreign table "ft1" because column "use_ft1_column_type.x" uses its row type
-DROP TABLE use_ft1_column_type;
-ALTER FOREIGN TABLE ft1 ADD PRIMARY KEY (c7);                   -- ERROR
-ERROR:  primary key constraints are not supported on foreign tables
-LINE 1: ALTER FOREIGN TABLE ft1 ADD PRIMARY KEY (c7);
-                                    ^
-ALTER FOREIGN TABLE ft1 ADD CONSTRAINT ft1_c9_check CHECK (c9 < 0) NOT VALID;
-ALTER FOREIGN TABLE ft1 ALTER CONSTRAINT ft1_c9_check DEFERRABLE; -- ERROR
-ERROR:  ALTER action ALTER CONSTRAINT cannot be performed on relation "ft1"
-DETAIL:  This operation is not supported for foreign tables.
-ALTER FOREIGN TABLE ft1 DROP CONSTRAINT ft1_c9_check;
-ALTER FOREIGN TABLE ft1 DROP CONSTRAINT no_const;               -- ERROR
-ERROR:  constraint "no_const" of relation "ft1" does not exist
-ALTER FOREIGN TABLE ft1 DROP CONSTRAINT IF EXISTS no_const;
-NOTICE:  constraint "no_const" of relation "ft1" does not exist, skipping
-ALTER FOREIGN TABLE ft1 OWNER TO regress_test_role;
-ALTER FOREIGN TABLE ft1 OPTIONS (DROP delimiter, SET quote '~', ADD escape '@');
-ALTER FOREIGN TABLE ft1 DROP COLUMN no_column;                  -- ERROR
-ERROR:  column "no_column" of relation "ft1" does not exist
-ALTER FOREIGN TABLE ft1 DROP COLUMN IF EXISTS no_column;
-NOTICE:  column "no_column" of relation "ft1" does not exist, skipping
-ALTER FOREIGN TABLE ft1 DROP COLUMN c9;
-ALTER FOREIGN TABLE ft1 SET SCHEMA foreign_schema;
-ALTER FOREIGN TABLE ft1 SET TABLESPACE ts;                      -- ERROR
-ERROR:  relation "ft1" does not exist
-ALTER FOREIGN TABLE foreign_schema.ft1 RENAME c1 TO foreign_column_1;
-ALTER FOREIGN TABLE foreign_schema.ft1 RENAME TO foreign_table_1;
-\d foreign_schema.foreign_table_1
-                        Foreign table "foreign_schema.foreign_table_1"
-      Column      |  Type   | Collation | Nullable | Default |          FDW options           
-------------------+---------+-----------+----------+---------+--------------------------------
- foreign_column_1 | integer |           | not null |         | ("param 1" 'val1')
- c2               | text    |           |          |         | (param2 'val2', param3 'val3')
- c3               | date    |           |          |         | 
- c4               | integer |           |          | 0       | 
- c5               | integer |           |          |         | 
- c6               | integer |           | not null |         | 
- c7               | integer |           |          |         | (p1 'v1', p2 'v2')
- c8               | text    |           |          |         | (p2 'V2')
- c10              | integer |           |          |         | (p1 'v1')
-Check constraints:
-    "ft1_c2_check" CHECK (c2 <> ''::text)
-    "ft1_c3_check" CHECK (c3 >= '01-01-1994'::date AND c3 <= '01-31-1994'::date)
-Server: s0
-FDW options: (quote '~', "be quoted" 'value', escape '@')
-
--- alter noexisting table
-ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ADD COLUMN c4 integer;
-NOTICE:  relation "doesnt_exist_ft1" does not exist, skipping
-ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ADD COLUMN c6 integer;
-NOTICE:  relation "doesnt_exist_ft1" does not exist, skipping
-ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ADD COLUMN c7 integer NOT NULL;
-NOTICE:  relation "doesnt_exist_ft1" does not exist, skipping
-ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ADD COLUMN c8 integer;
-NOTICE:  relation "doesnt_exist_ft1" does not exist, skipping
-ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ADD COLUMN c9 integer;
-NOTICE:  relation "doesnt_exist_ft1" does not exist, skipping
-ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ADD COLUMN c10 integer OPTIONS (p1 'v1');
-NOTICE:  relation "doesnt_exist_ft1" does not exist, skipping
-ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ALTER COLUMN c6 SET NOT NULL;
-NOTICE:  relation "doesnt_exist_ft1" does not exist, skipping
-ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ALTER COLUMN c7 DROP NOT NULL;
-NOTICE:  relation "doesnt_exist_ft1" does not exist, skipping
-ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ALTER COLUMN c8 TYPE char(10);
-NOTICE:  relation "doesnt_exist_ft1" does not exist, skipping
-ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ALTER COLUMN c8 SET DATA TYPE text;
-NOTICE:  relation "doesnt_exist_ft1" does not exist, skipping
-ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ALTER COLUMN c7 OPTIONS (ADD p1 'v1', ADD p2 'v2'),
-                        ALTER COLUMN c8 OPTIONS (ADD p1 'v1', ADD p2 'v2');
-NOTICE:  relation "doesnt_exist_ft1" does not exist, skipping
-ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ALTER COLUMN c8 OPTIONS (SET p2 'V2', DROP p1);
-NOTICE:  relation "doesnt_exist_ft1" does not exist, skipping
-ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 DROP CONSTRAINT IF EXISTS no_const;
-NOTICE:  relation "doesnt_exist_ft1" does not exist, skipping
-ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 DROP CONSTRAINT ft1_c1_check;
-NOTICE:  relation "doesnt_exist_ft1" does not exist, skipping
-ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 OWNER TO regress_test_role;
-NOTICE:  relation "doesnt_exist_ft1" does not exist, skipping
-ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 OPTIONS (DROP delimiter, SET quote '~', ADD escape '@');
-NOTICE:  relation "doesnt_exist_ft1" does not exist, skipping
-ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 DROP COLUMN IF EXISTS no_column;
-NOTICE:  relation "doesnt_exist_ft1" does not exist, skipping
-ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 DROP COLUMN c9;
-NOTICE:  relation "doesnt_exist_ft1" does not exist, skipping
-ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 SET SCHEMA foreign_schema;
-NOTICE:  relation "doesnt_exist_ft1" does not exist, skipping
-ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 RENAME c1 TO foreign_column_1;
-NOTICE:  relation "doesnt_exist_ft1" does not exist, skipping
-ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 RENAME TO foreign_table_1;
-NOTICE:  relation "doesnt_exist_ft1" does not exist, skipping
--- Information schema
-SELECT * FROM information_schema.foreign_data_wrappers ORDER BY 1, 2;
- foreign_data_wrapper_catalog | foreign_data_wrapper_name | authorization_identifier  | library_name | foreign_data_wrapper_language 
-------------------------------+---------------------------+---------------------------+--------------+-------------------------------
- regression                   | dummy                     | regress_foreign_data_user |              | c
- regression                   | foo                       | regress_foreign_data_user |              | c
- regression                   | postgresql                | regress_foreign_data_user |              | c
-(3 rows)
-
-SELECT * FROM information_schema.foreign_data_wrapper_options ORDER BY 1, 2, 3;
- foreign_data_wrapper_catalog | foreign_data_wrapper_name | option_name  | option_value 
-------------------------------+---------------------------+--------------+--------------
- regression                   | foo                       | test wrapper | true
-(1 row)
-
-SELECT * FROM information_schema.foreign_servers ORDER BY 1, 2;
- foreign_server_catalog | foreign_server_name | foreign_data_wrapper_catalog | foreign_data_wrapper_name | foreign_server_type | foreign_server_version | authorization_identifier  
-------------------------+---------------------+------------------------------+---------------------------+---------------------+------------------------+---------------------------
- regression             | s0                  | regression                   | dummy                     |                     |                        | regress_foreign_data_user
- regression             | s4                  | regression                   | foo                       | oracle              |                        | regress_foreign_data_user
- regression             | s5                  | regression                   | foo                       |                     | 15.0                   | regress_test_role
- regression             | s6                  | regression                   | foo                       |                     | 16.0                   | regress_test_indirect
- regression             | s8                  | regression                   | postgresql                |                     |                        | regress_foreign_data_user
- regression             | t1                  | regression                   | foo                       |                     |                        | regress_test_indirect
- regression             | t2                  | regression                   | foo                       |                     |                        | regress_test_role
-(7 rows)
-
-SELECT * FROM information_schema.foreign_server_options ORDER BY 1, 2, 3;
- foreign_server_catalog | foreign_server_name |   option_name   | option_value 
-------------------------+---------------------+-----------------+--------------
- regression             | s4                  | dbname          | b
- regression             | s4                  | host            | a
- regression             | s6                  | dbname          | b
- regression             | s6                  | host            | a
- regression             | s8                  | connect_timeout | 30
- regression             | s8                  | dbname          | db1
-(6 rows)
-
-SELECT * FROM information_schema.user_mappings ORDER BY lower(authorization_identifier), 2, 3;
- authorization_identifier  | foreign_server_catalog | foreign_server_name 
----------------------------+------------------------+---------------------
- PUBLIC                    | regression             | s4
- PUBLIC                    | regression             | s8
- PUBLIC                    | regression             | t1
- regress_foreign_data_user | regression             | s4
- regress_foreign_data_user | regression             | s8
- regress_test_role         | regression             | s5
- regress_test_role         | regression             | s6
- regress_test_role         | regression             | t1
-(8 rows)
-
-SELECT * FROM information_schema.user_mapping_options ORDER BY lower(authorization_identifier), 2, 3, 4;
- authorization_identifier  | foreign_server_catalog | foreign_server_name | option_name  | option_value 
----------------------------+------------------------+---------------------+--------------+--------------
- PUBLIC                    | regression             | s4                  | this mapping | is public
- PUBLIC                    | regression             | t1                  | modified     | 1
- regress_foreign_data_user | regression             | s8                  | password     | public
- regress_test_role         | regression             | s5                  | modified     | 1
- regress_test_role         | regression             | s6                  | username     | test
- regress_test_role         | regression             | t1                  | password     | boo
- regress_test_role         | regression             | t1                  | username     | bob
-(7 rows)
-
-SELECT * FROM information_schema.usage_privileges WHERE object_type LIKE 'FOREIGN%' AND object_name IN ('s6', 'foo') ORDER BY 1, 2, 3, 4, 5;
-          grantor          |          grantee          | object_catalog | object_schema | object_name |     object_type      | privilege_type | is_grantable 
----------------------------+---------------------------+----------------+---------------+-------------+----------------------+----------------+--------------
- regress_foreign_data_user | regress_foreign_data_user | regression     |               | foo         | FOREIGN DATA WRAPPER | USAGE          | YES
- regress_foreign_data_user | regress_test_indirect     | regression     |               | foo         | FOREIGN DATA WRAPPER | USAGE          | NO
- regress_test_indirect     | regress_test_indirect     | regression     |               | s6          | FOREIGN SERVER       | USAGE          | YES
- regress_test_indirect     | regress_test_role2        | regression     |               | s6          | FOREIGN SERVER       | USAGE          | YES
-(4 rows)
-
-SELECT * FROM information_schema.role_usage_grants WHERE object_type LIKE 'FOREIGN%' AND object_name IN ('s6', 'foo') ORDER BY 1, 2, 3, 4, 5;
-          grantor          |          grantee          | object_catalog | object_schema | object_name |     object_type      | privilege_type | is_grantable 
----------------------------+---------------------------+----------------+---------------+-------------+----------------------+----------------+--------------
- regress_foreign_data_user | regress_foreign_data_user | regression     |               | foo         | FOREIGN DATA WRAPPER | USAGE          | YES
- regress_foreign_data_user | regress_test_indirect     | regression     |               | foo         | FOREIGN DATA WRAPPER | USAGE          | NO
- regress_test_indirect     | regress_test_indirect     | regression     |               | s6          | FOREIGN SERVER       | USAGE          | YES
- regress_test_indirect     | regress_test_role2        | regression     |               | s6          | FOREIGN SERVER       | USAGE          | YES
-(4 rows)
-
-SELECT * FROM information_schema.foreign_tables ORDER BY 1, 2, 3;
- foreign_table_catalog | foreign_table_schema | foreign_table_name | foreign_server_catalog | foreign_server_name 
------------------------+----------------------+--------------------+------------------------+---------------------
- regression            | foreign_schema       | foreign_table_1    | regression             | s0
-(1 row)
-
-SELECT * FROM information_schema.foreign_table_options ORDER BY 1, 2, 3, 4;
- foreign_table_catalog | foreign_table_schema | foreign_table_name | option_name | option_value 
------------------------+----------------------+--------------------+-------------+--------------
- regression            | foreign_schema       | foreign_table_1    | be quoted   | value
- regression            | foreign_schema       | foreign_table_1    | escape      | @
- regression            | foreign_schema       | foreign_table_1    | quote       | ~
-(3 rows)
-
-SET ROLE regress_test_role;
-SELECT * FROM information_schema.user_mapping_options ORDER BY 1, 2, 3, 4;
- authorization_identifier | foreign_server_catalog | foreign_server_name | option_name | option_value 
---------------------------+------------------------+---------------------+-------------+--------------
- PUBLIC                   | regression             | t1                  | modified    | 1
- regress_test_role        | regression             | s5                  | modified    | 1
- regress_test_role        | regression             | s6                  | username    | test
- regress_test_role        | regression             | t1                  | password    | boo
- regress_test_role        | regression             | t1                  | username    | bob
-(5 rows)
-
-SELECT * FROM information_schema.usage_privileges WHERE object_type LIKE 'FOREIGN%' AND object_name IN ('s6', 'foo') ORDER BY 1, 2, 3, 4, 5;
-          grantor          |        grantee        | object_catalog | object_schema | object_name |     object_type      | privilege_type | is_grantable 
----------------------------+-----------------------+----------------+---------------+-------------+----------------------+----------------+--------------
- regress_foreign_data_user | regress_test_indirect | regression     |               | foo         | FOREIGN DATA WRAPPER | USAGE          | NO
- regress_test_indirect     | regress_test_indirect | regression     |               | s6          | FOREIGN SERVER       | USAGE          | YES
- regress_test_indirect     | regress_test_role2    | regression     |               | s6          | FOREIGN SERVER       | USAGE          | YES
-(3 rows)
-
-SELECT * FROM information_schema.role_usage_grants WHERE object_type LIKE 'FOREIGN%' AND object_name IN ('s6', 'foo') ORDER BY 1, 2, 3, 4, 5;
-          grantor          |        grantee        | object_catalog | object_schema | object_name |     object_type      | privilege_type | is_grantable 
----------------------------+-----------------------+----------------+---------------+-------------+----------------------+----------------+--------------
- regress_foreign_data_user | regress_test_indirect | regression     |               | foo         | FOREIGN DATA WRAPPER | USAGE          | NO
- regress_test_indirect     | regress_test_indirect | regression     |               | s6          | FOREIGN SERVER       | USAGE          | YES
- regress_test_indirect     | regress_test_role2    | regression     |               | s6          | FOREIGN SERVER       | USAGE          | YES
-(3 rows)
-
-DROP USER MAPPING FOR current_user SERVER t1;
-SET ROLE regress_test_role2;
-SELECT * FROM information_schema.user_mapping_options ORDER BY 1, 2, 3, 4;
- authorization_identifier | foreign_server_catalog | foreign_server_name | option_name | option_value 
---------------------------+------------------------+---------------------+-------------+--------------
- regress_test_role        | regression             | s6                  | username    | 
-(1 row)
-
-RESET ROLE;
--- has_foreign_data_wrapper_privilege
-SELECT has_foreign_data_wrapper_privilege('regress_test_role',
-    (SELECT oid FROM pg_foreign_data_wrapper WHERE fdwname='foo'), 'USAGE');
- has_foreign_data_wrapper_privilege 
-------------------------------------
- t
-(1 row)
-
-SELECT has_foreign_data_wrapper_privilege('regress_test_role', 'foo', 'USAGE');
- has_foreign_data_wrapper_privilege 
-------------------------------------
- t
-(1 row)
-
-SELECT has_foreign_data_wrapper_privilege(
-    (SELECT oid FROM pg_roles WHERE rolname='regress_test_role'),
-    (SELECT oid FROM pg_foreign_data_wrapper WHERE fdwname='foo'), 'USAGE');
- has_foreign_data_wrapper_privilege 
-------------------------------------
- t
-(1 row)
-
-SELECT has_foreign_data_wrapper_privilege(
-    (SELECT oid FROM pg_foreign_data_wrapper WHERE fdwname='foo'), 'USAGE');
- has_foreign_data_wrapper_privilege 
-------------------------------------
- t
-(1 row)
-
-SELECT has_foreign_data_wrapper_privilege(
-    (SELECT oid FROM pg_roles WHERE rolname='regress_test_role'), 'foo', 'USAGE');
- has_foreign_data_wrapper_privilege 
-------------------------------------
- t
-(1 row)
-
-SELECT has_foreign_data_wrapper_privilege('foo', 'USAGE');
- has_foreign_data_wrapper_privilege 
-------------------------------------
- t
-(1 row)
-
-GRANT USAGE ON FOREIGN DATA WRAPPER foo TO regress_test_role;
-SELECT has_foreign_data_wrapper_privilege('regress_test_role', 'foo', 'USAGE');
- has_foreign_data_wrapper_privilege 
-------------------------------------
- t
-(1 row)
-
--- has_server_privilege
-SELECT has_server_privilege('regress_test_role',
-    (SELECT oid FROM pg_foreign_server WHERE srvname='s8'), 'USAGE');
- has_server_privilege 
-----------------------
- f
-(1 row)
-
-SELECT has_server_privilege('regress_test_role', 's8', 'USAGE');
- has_server_privilege 
-----------------------
- f
-(1 row)
-
-SELECT has_server_privilege(
-    (SELECT oid FROM pg_roles WHERE rolname='regress_test_role'),
-    (SELECT oid FROM pg_foreign_server WHERE srvname='s8'), 'USAGE');
- has_server_privilege 
-----------------------
- f
-(1 row)
-
-SELECT has_server_privilege(
-    (SELECT oid FROM pg_foreign_server WHERE srvname='s8'), 'USAGE');
- has_server_privilege 
-----------------------
- t
-(1 row)
-
-SELECT has_server_privilege(
-    (SELECT oid FROM pg_roles WHERE rolname='regress_test_role'), 's8', 'USAGE');
- has_server_privilege 
-----------------------
- f
-(1 row)
-
-SELECT has_server_privilege('s8', 'USAGE');
- has_server_privilege 
-----------------------
- t
-(1 row)
-
-GRANT USAGE ON FOREIGN SERVER s8 TO regress_test_role;
-SELECT has_server_privilege('regress_test_role', 's8', 'USAGE');
- has_server_privilege 
-----------------------
- t
-(1 row)
-
-REVOKE USAGE ON FOREIGN SERVER s8 FROM regress_test_role;
-GRANT USAGE ON FOREIGN SERVER s4 TO regress_test_role;
-DROP USER MAPPING FOR public SERVER s4;
-ALTER SERVER s6 OPTIONS (DROP host, DROP dbname);
-ALTER USER MAPPING FOR regress_test_role SERVER s6 OPTIONS (DROP username);
-ALTER FOREIGN DATA WRAPPER foo VALIDATOR postgresql_fdw_validator;
-WARNING:  changing the foreign-data wrapper validator can cause the options for dependent objects to become invalid
--- Privileges
-SET ROLE regress_unprivileged_role;
-CREATE FOREIGN DATA WRAPPER foobar;                             -- ERROR
-ERROR:  permission denied to create foreign-data wrapper "foobar"
-HINT:  Must be superuser to create a foreign-data wrapper.
-ALTER FOREIGN DATA WRAPPER foo OPTIONS (gotcha 'true');         -- ERROR
-ERROR:  permission denied to alter foreign-data wrapper "foo"
-HINT:  Must be superuser to alter a foreign-data wrapper.
-ALTER FOREIGN DATA WRAPPER foo OWNER TO regress_unprivileged_role; -- ERROR
-ERROR:  permission denied to change owner of foreign-data wrapper "foo"
-HINT:  Must be superuser to change owner of a foreign-data wrapper.
-DROP FOREIGN DATA WRAPPER foo;                                  -- ERROR
-ERROR:  must be owner of foreign-data wrapper foo
-GRANT USAGE ON FOREIGN DATA WRAPPER foo TO regress_test_role;   -- ERROR
-ERROR:  permission denied for foreign-data wrapper foo
-CREATE SERVER s9 FOREIGN DATA WRAPPER foo;                      -- ERROR
-ERROR:  permission denied for foreign-data wrapper foo
-ALTER SERVER s4 VERSION '0.5';                                  -- ERROR
-ERROR:  must be owner of foreign server s4
-ALTER SERVER s4 OWNER TO regress_unprivileged_role;             -- ERROR
-ERROR:  must be owner of foreign server s4
-DROP SERVER s4;                                                 -- ERROR
-ERROR:  must be owner of foreign server s4
-GRANT USAGE ON FOREIGN SERVER s4 TO regress_test_role;          -- ERROR
-ERROR:  permission denied for foreign server s4
-CREATE USER MAPPING FOR public SERVER s4;                       -- ERROR
-ERROR:  must be owner of foreign server s4
-ALTER USER MAPPING FOR regress_test_role SERVER s6 OPTIONS (gotcha 'true'); -- ERROR
-ERROR:  must be owner of foreign server s6
-DROP USER MAPPING FOR regress_test_role SERVER s6;              -- ERROR
-ERROR:  must be owner of foreign server s6
-RESET ROLE;
-GRANT USAGE ON FOREIGN DATA WRAPPER postgresql TO regress_unprivileged_role;
-GRANT USAGE ON FOREIGN DATA WRAPPER foo TO regress_unprivileged_role WITH GRANT OPTION;
-SET ROLE regress_unprivileged_role;
-CREATE FOREIGN DATA WRAPPER foobar;                             -- ERROR
-ERROR:  permission denied to create foreign-data wrapper "foobar"
-HINT:  Must be superuser to create a foreign-data wrapper.
-ALTER FOREIGN DATA WRAPPER foo OPTIONS (gotcha 'true');         -- ERROR
-ERROR:  permission denied to alter foreign-data wrapper "foo"
-HINT:  Must be superuser to alter a foreign-data wrapper.
-DROP FOREIGN DATA WRAPPER foo;                                  -- ERROR
-ERROR:  must be owner of foreign-data wrapper foo
-GRANT USAGE ON FOREIGN DATA WRAPPER postgresql TO regress_test_role; -- WARNING
-WARNING:  no privileges were granted for "postgresql"
-GRANT USAGE ON FOREIGN DATA WRAPPER foo TO regress_test_role;
-CREATE SERVER s9 FOREIGN DATA WRAPPER postgresql;
-ALTER SERVER s6 VERSION '0.5';                                  -- ERROR
-ERROR:  must be owner of foreign server s6
-DROP SERVER s6;                                                 -- ERROR
-ERROR:  must be owner of foreign server s6
-GRANT USAGE ON FOREIGN SERVER s6 TO regress_test_role;          -- ERROR
-ERROR:  permission denied for foreign server s6
-GRANT USAGE ON FOREIGN SERVER s9 TO regress_test_role;
-CREATE USER MAPPING FOR public SERVER s6;                       -- ERROR
-ERROR:  must be owner of foreign server s6
-CREATE USER MAPPING FOR public SERVER s9;
-ALTER USER MAPPING FOR regress_test_role SERVER s6 OPTIONS (gotcha 'true'); -- ERROR
-ERROR:  must be owner of foreign server s6
-DROP USER MAPPING FOR regress_test_role SERVER s6;              -- ERROR
-ERROR:  must be owner of foreign server s6
-RESET ROLE;
-REVOKE USAGE ON FOREIGN DATA WRAPPER foo FROM regress_unprivileged_role; -- ERROR
-ERROR:  dependent privileges exist
-HINT:  Use CASCADE to revoke them too.
-REVOKE USAGE ON FOREIGN DATA WRAPPER foo FROM regress_unprivileged_role CASCADE;
-SET ROLE regress_unprivileged_role;
-GRANT USAGE ON FOREIGN DATA WRAPPER foo TO regress_test_role;   -- ERROR
-ERROR:  permission denied for foreign-data wrapper foo
-CREATE SERVER s10 FOREIGN DATA WRAPPER foo;                     -- ERROR
-ERROR:  permission denied for foreign-data wrapper foo
-ALTER SERVER s9 VERSION '1.1';
-GRANT USAGE ON FOREIGN SERVER s9 TO regress_test_role;
-CREATE USER MAPPING FOR current_user SERVER s9;
-DROP SERVER s9 CASCADE;
-NOTICE:  drop cascades to 2 other objects
-DETAIL:  drop cascades to user mapping for public on server s9
-drop cascades to user mapping for regress_unprivileged_role on server s9
-RESET ROLE;
-CREATE SERVER s9 FOREIGN DATA WRAPPER foo;
-GRANT USAGE ON FOREIGN SERVER s9 TO regress_unprivileged_role;
-SET ROLE regress_unprivileged_role;
-ALTER SERVER s9 VERSION '1.2';                                  -- ERROR
-ERROR:  must be owner of foreign server s9
-GRANT USAGE ON FOREIGN SERVER s9 TO regress_test_role;          -- WARNING
-WARNING:  no privileges were granted for "s9"
-CREATE USER MAPPING FOR current_user SERVER s9;
-DROP SERVER s9 CASCADE;                                         -- ERROR
-ERROR:  must be owner of foreign server s9
--- Check visibility of user mapping data
-SET ROLE regress_test_role;
-CREATE SERVER s10 FOREIGN DATA WRAPPER foo;
-CREATE USER MAPPING FOR public SERVER s10 OPTIONS (user 'secret');
-CREATE USER MAPPING FOR regress_unprivileged_role SERVER s10 OPTIONS (user 'secret');
--- owner of server can see some option fields
-\deu+
-                 List of user mappings
- Server |         User name         |    FDW options    
---------+---------------------------+-------------------
- s10    | public                    | ("user" 'secret')
- s10    | regress_unprivileged_role | 
- s4     | regress_foreign_data_user | 
- s5     | regress_test_role         | (modified '1')
- s6     | regress_test_role         | 
- s8     | public                    | 
- s8     | regress_foreign_data_user | 
- s9     | regress_unprivileged_role | 
- t1     | public                    | (modified '1')
-(9 rows)
-
-RESET ROLE;
--- superuser can see all option fields
-\deu+
-                  List of user mappings
- Server |         User name         |     FDW options     
---------+---------------------------+---------------------
- s10    | public                    | ("user" 'secret')
- s10    | regress_unprivileged_role | ("user" 'secret')
- s4     | regress_foreign_data_user | 
- s5     | regress_test_role         | (modified '1')
- s6     | regress_test_role         | 
- s8     | public                    | 
- s8     | regress_foreign_data_user | (password 'public')
- s9     | regress_unprivileged_role | 
- t1     | public                    | (modified '1')
-(9 rows)
-
--- unprivileged user cannot see any option field
-SET ROLE regress_unprivileged_role;
-\deu+
-              List of user mappings
- Server |         User name         | FDW options 
---------+---------------------------+-------------
- s10    | public                    | 
- s10    | regress_unprivileged_role | 
- s4     | regress_foreign_data_user | 
- s5     | regress_test_role         | 
- s6     | regress_test_role         | 
- s8     | public                    | 
- s8     | regress_foreign_data_user | 
- s9     | regress_unprivileged_role | 
- t1     | public                    | 
-(9 rows)
-
-RESET ROLE;
-DROP SERVER s10 CASCADE;
-NOTICE:  drop cascades to 2 other objects
-DETAIL:  drop cascades to user mapping for public on server s10
-drop cascades to user mapping for regress_unprivileged_role on server s10
--- Triggers
-CREATE FUNCTION dummy_trigger() RETURNS TRIGGER AS $$
-  BEGIN
-    RETURN NULL;
-  END
-$$ language plpgsql;
-CREATE TRIGGER trigtest_before_stmt BEFORE INSERT OR UPDATE OR DELETE
-ON foreign_schema.foreign_table_1
-FOR EACH STATEMENT
-EXECUTE PROCEDURE dummy_trigger();
-CREATE TRIGGER trigtest_after_stmt AFTER INSERT OR UPDATE OR DELETE
-ON foreign_schema.foreign_table_1
-FOR EACH STATEMENT
-EXECUTE PROCEDURE dummy_trigger();
-CREATE TRIGGER trigtest_after_stmt_tt AFTER INSERT OR UPDATE OR DELETE -- ERROR
-ON foreign_schema.foreign_table_1
-REFERENCING NEW TABLE AS new_table
-FOR EACH STATEMENT
-EXECUTE PROCEDURE dummy_trigger();
-ERROR:  "foreign_table_1" is a foreign table
-DETAIL:  Triggers on foreign tables cannot have transition tables.
-CREATE TRIGGER trigtest_before_row BEFORE INSERT OR UPDATE OR DELETE
-ON foreign_schema.foreign_table_1
-FOR EACH ROW
-EXECUTE PROCEDURE dummy_trigger();
-CREATE TRIGGER trigtest_after_row AFTER INSERT OR UPDATE OR DELETE
-ON foreign_schema.foreign_table_1
-FOR EACH ROW
-EXECUTE PROCEDURE dummy_trigger();
-CREATE CONSTRAINT TRIGGER trigtest_constraint AFTER INSERT OR UPDATE OR DELETE
-ON foreign_schema.foreign_table_1
-FOR EACH ROW
-EXECUTE PROCEDURE dummy_trigger();
-ERROR:  "foreign_table_1" is a foreign table
-DETAIL:  Foreign tables cannot have constraint triggers.
-ALTER FOREIGN TABLE foreign_schema.foreign_table_1
-	DISABLE TRIGGER trigtest_before_stmt;
-ALTER FOREIGN TABLE foreign_schema.foreign_table_1
-	ENABLE TRIGGER trigtest_before_stmt;
-DROP TRIGGER trigtest_before_stmt ON foreign_schema.foreign_table_1;
-DROP TRIGGER trigtest_before_row ON foreign_schema.foreign_table_1;
-DROP TRIGGER trigtest_after_stmt ON foreign_schema.foreign_table_1;
-DROP TRIGGER trigtest_after_row ON foreign_schema.foreign_table_1;
-DROP FUNCTION dummy_trigger();
--- Table inheritance
-CREATE TABLE fd_pt1 (
-	c1 integer NOT NULL,
-	c2 text,
-	c3 date
-);
-CREATE FOREIGN TABLE ft2 () INHERITS (fd_pt1)
-  SERVER s0 OPTIONS (delimiter ',', quote '"', "be quoted" 'value');
-\d+ fd_pt1
-                                   Table "public.fd_pt1"
- Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
---------+---------+-----------+----------+---------+----------+--------------+-------------
- c1     | integer |           | not null |         | plain    |              | 
- c2     | text    |           |          |         | extended |              | 
- c3     | date    |           |          |         | plain    |              | 
-Child tables: ft2
-
-\d+ ft2
-                                       Foreign table "public.ft2"
- Column |  Type   | Collation | Nullable | Default | FDW options | Storage  | Stats target | Description 
---------+---------+-----------+----------+---------+-------------+----------+--------------+-------------
- c1     | integer |           | not null |         |             | plain    |              | 
- c2     | text    |           |          |         |             | extended |              | 
- c3     | date    |           |          |         |             | plain    |              | 
-Server: s0
-FDW options: (delimiter ',', quote '"', "be quoted" 'value')
-Inherits: fd_pt1
-
-DROP FOREIGN TABLE ft2;
-\d+ fd_pt1
-                                   Table "public.fd_pt1"
- Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
---------+---------+-----------+----------+---------+----------+--------------+-------------
- c1     | integer |           | not null |         | plain    |              | 
- c2     | text    |           |          |         | extended |              | 
- c3     | date    |           |          |         | plain    |              | 
-
-CREATE FOREIGN TABLE ft2 (
-	c1 integer NOT NULL,
-	c2 text,
-	c3 date
-) SERVER s0 OPTIONS (delimiter ',', quote '"', "be quoted" 'value');
-\d+ ft2
-                                       Foreign table "public.ft2"
- Column |  Type   | Collation | Nullable | Default | FDW options | Storage  | Stats target | Description 
---------+---------+-----------+----------+---------+-------------+----------+--------------+-------------
- c1     | integer |           | not null |         |             | plain    |              | 
- c2     | text    |           |          |         |             | extended |              | 
- c3     | date    |           |          |         |             | plain    |              | 
-Server: s0
-FDW options: (delimiter ',', quote '"', "be quoted" 'value')
-
-ALTER FOREIGN TABLE ft2 INHERIT fd_pt1;
-\d+ fd_pt1
-                                   Table "public.fd_pt1"
- Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
---------+---------+-----------+----------+---------+----------+--------------+-------------
- c1     | integer |           | not null |         | plain    |              | 
- c2     | text    |           |          |         | extended |              | 
- c3     | date    |           |          |         | plain    |              | 
-Child tables: ft2
-
-\d+ ft2
-                                       Foreign table "public.ft2"
- Column |  Type   | Collation | Nullable | Default | FDW options | Storage  | Stats target | Description 
---------+---------+-----------+----------+---------+-------------+----------+--------------+-------------
- c1     | integer |           | not null |         |             | plain    |              | 
- c2     | text    |           |          |         |             | extended |              | 
- c3     | date    |           |          |         |             | plain    |              | 
-Server: s0
-FDW options: (delimiter ',', quote '"', "be quoted" 'value')
-Inherits: fd_pt1
-
-CREATE TABLE ct3() INHERITS(ft2);
-CREATE FOREIGN TABLE ft3 (
-	c1 integer NOT NULL,
-	c2 text,
-	c3 date
-) INHERITS(ft2)
-  SERVER s0;
-NOTICE:  merging column "c1" with inherited definition
-NOTICE:  merging column "c2" with inherited definition
-NOTICE:  merging column "c3" with inherited definition
-\d+ ft2
-                                       Foreign table "public.ft2"
- Column |  Type   | Collation | Nullable | Default | FDW options | Storage  | Stats target | Description 
---------+---------+-----------+----------+---------+-------------+----------+--------------+-------------
- c1     | integer |           | not null |         |             | plain    |              | 
- c2     | text    |           |          |         |             | extended |              | 
- c3     | date    |           |          |         |             | plain    |              | 
-Server: s0
-FDW options: (delimiter ',', quote '"', "be quoted" 'value')
-Inherits: fd_pt1
-Child tables: ct3,
-              ft3
-
-\d+ ct3
-                                    Table "public.ct3"
- Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
---------+---------+-----------+----------+---------+----------+--------------+-------------
- c1     | integer |           | not null |         | plain    |              | 
- c2     | text    |           |          |         | extended |              | 
- c3     | date    |           |          |         | plain    |              | 
-Inherits: ft2
-
-\d+ ft3
-                                       Foreign table "public.ft3"
- Column |  Type   | Collation | Nullable | Default | FDW options | Storage  | Stats target | Description 
---------+---------+-----------+----------+---------+-------------+----------+--------------+-------------
- c1     | integer |           | not null |         |             | plain    |              | 
- c2     | text    |           |          |         |             | extended |              | 
- c3     | date    |           |          |         |             | plain    |              | 
-Server: s0
-Inherits: ft2
-
--- add attributes recursively
-ALTER TABLE fd_pt1 ADD COLUMN c4 integer;
-ALTER TABLE fd_pt1 ADD COLUMN c5 integer DEFAULT 0;
-ALTER TABLE fd_pt1 ADD COLUMN c6 integer;
-ALTER TABLE fd_pt1 ADD COLUMN c7 integer NOT NULL;
-ALTER TABLE fd_pt1 ADD COLUMN c8 integer;
-\d+ fd_pt1
-                                   Table "public.fd_pt1"
- Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
---------+---------+-----------+----------+---------+----------+--------------+-------------
- c1     | integer |           | not null |         | plain    |              | 
- c2     | text    |           |          |         | extended |              | 
- c3     | date    |           |          |         | plain    |              | 
- c4     | integer |           |          |         | plain    |              | 
- c5     | integer |           |          | 0       | plain    |              | 
- c6     | integer |           |          |         | plain    |              | 
- c7     | integer |           | not null |         | plain    |              | 
- c8     | integer |           |          |         | plain    |              | 
-Child tables: ft2
-
-\d+ ft2
-                                       Foreign table "public.ft2"
- Column |  Type   | Collation | Nullable | Default | FDW options | Storage  | Stats target | Description 
---------+---------+-----------+----------+---------+-------------+----------+--------------+-------------
- c1     | integer |           | not null |         |             | plain    |              | 
- c2     | text    |           |          |         |             | extended |              | 
- c3     | date    |           |          |         |             | plain    |              | 
- c4     | integer |           |          |         |             | plain    |              | 
- c5     | integer |           |          | 0       |             | plain    |              | 
- c6     | integer |           |          |         |             | plain    |              | 
- c7     | integer |           | not null |         |             | plain    |              | 
- c8     | integer |           |          |         |             | plain    |              | 
-Server: s0
-FDW options: (delimiter ',', quote '"', "be quoted" 'value')
-Inherits: fd_pt1
-Child tables: ct3,
-              ft3
-
-\d+ ct3
-                                    Table "public.ct3"
- Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
---------+---------+-----------+----------+---------+----------+--------------+-------------
- c1     | integer |           | not null |         | plain    |              | 
- c2     | text    |           |          |         | extended |              | 
- c3     | date    |           |          |         | plain    |              | 
- c4     | integer |           |          |         | plain    |              | 
- c5     | integer |           |          | 0       | plain    |              | 
- c6     | integer |           |          |         | plain    |              | 
- c7     | integer |           | not null |         | plain    |              | 
- c8     | integer |           |          |         | plain    |              | 
-Inherits: ft2
-
-\d+ ft3
-                                       Foreign table "public.ft3"
- Column |  Type   | Collation | Nullable | Default | FDW options | Storage  | Stats target | Description 
---------+---------+-----------+----------+---------+-------------+----------+--------------+-------------
- c1     | integer |           | not null |         |             | plain    |              | 
- c2     | text    |           |          |         |             | extended |              | 
- c3     | date    |           |          |         |             | plain    |              | 
- c4     | integer |           |          |         |             | plain    |              | 
- c5     | integer |           |          | 0       |             | plain    |              | 
- c6     | integer |           |          |         |             | plain    |              | 
- c7     | integer |           | not null |         |             | plain    |              | 
- c8     | integer |           |          |         |             | plain    |              | 
-Server: s0
-Inherits: ft2
-
--- alter attributes recursively
-ALTER TABLE fd_pt1 ALTER COLUMN c4 SET DEFAULT 0;
-ALTER TABLE fd_pt1 ALTER COLUMN c5 DROP DEFAULT;
-ALTER TABLE fd_pt1 ALTER COLUMN c6 SET NOT NULL;
-ALTER TABLE fd_pt1 ALTER COLUMN c7 DROP NOT NULL;
-ALTER TABLE fd_pt1 ALTER COLUMN c8 TYPE char(10) USING '0';        -- ERROR
-ERROR:  "ft2" is not a table
-ALTER TABLE fd_pt1 ALTER COLUMN c8 TYPE char(10);
-ALTER TABLE fd_pt1 ALTER COLUMN c8 SET DATA TYPE text;
-ALTER TABLE fd_pt1 ALTER COLUMN c1 SET STATISTICS 10000;
-ALTER TABLE fd_pt1 ALTER COLUMN c1 SET (n_distinct = 100);
-ALTER TABLE fd_pt1 ALTER COLUMN c8 SET STATISTICS -1;
-ALTER TABLE fd_pt1 ALTER COLUMN c8 SET STORAGE EXTERNAL;
-\d+ fd_pt1
-                                   Table "public.fd_pt1"
- Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
---------+---------+-----------+----------+---------+----------+--------------+-------------
- c1     | integer |           | not null |         | plain    | 10000        | 
- c2     | text    |           |          |         | extended |              | 
- c3     | date    |           |          |         | plain    |              | 
- c4     | integer |           |          | 0       | plain    |              | 
- c5     | integer |           |          |         | plain    |              | 
- c6     | integer |           | not null |         | plain    |              | 
- c7     | integer |           |          |         | plain    |              | 
- c8     | text    |           |          |         | external |              | 
-Child tables: ft2
-
-\d+ ft2
-                                       Foreign table "public.ft2"
- Column |  Type   | Collation | Nullable | Default | FDW options | Storage  | Stats target | Description 
---------+---------+-----------+----------+---------+-------------+----------+--------------+-------------
- c1     | integer |           | not null |         |             | plain    | 10000        | 
- c2     | text    |           |          |         |             | extended |              | 
- c3     | date    |           |          |         |             | plain    |              | 
- c4     | integer |           |          | 0       |             | plain    |              | 
- c5     | integer |           |          |         |             | plain    |              | 
- c6     | integer |           | not null |         |             | plain    |              | 
- c7     | integer |           |          |         |             | plain    |              | 
- c8     | text    |           |          |         |             | external |              | 
-Server: s0
-FDW options: (delimiter ',', quote '"', "be quoted" 'value')
-Inherits: fd_pt1
-Child tables: ct3,
-              ft3
-
--- drop attributes recursively
-ALTER TABLE fd_pt1 DROP COLUMN c4;
-ALTER TABLE fd_pt1 DROP COLUMN c5;
-ALTER TABLE fd_pt1 DROP COLUMN c6;
-ALTER TABLE fd_pt1 DROP COLUMN c7;
-ALTER TABLE fd_pt1 DROP COLUMN c8;
-\d+ fd_pt1
-                                   Table "public.fd_pt1"
- Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
---------+---------+-----------+----------+---------+----------+--------------+-------------
- c1     | integer |           | not null |         | plain    | 10000        | 
- c2     | text    |           |          |         | extended |              | 
- c3     | date    |           |          |         | plain    |              | 
-Child tables: ft2
-
-\d+ ft2
-                                       Foreign table "public.ft2"
- Column |  Type   | Collation | Nullable | Default | FDW options | Storage  | Stats target | Description 
---------+---------+-----------+----------+---------+-------------+----------+--------------+-------------
- c1     | integer |           | not null |         |             | plain    | 10000        | 
- c2     | text    |           |          |         |             | extended |              | 
- c3     | date    |           |          |         |             | plain    |              | 
-Server: s0
-FDW options: (delimiter ',', quote '"', "be quoted" 'value')
-Inherits: fd_pt1
-Child tables: ct3,
-              ft3
-
--- add constraints recursively
-ALTER TABLE fd_pt1 ADD CONSTRAINT fd_pt1chk1 CHECK (c1 > 0) NO INHERIT;
-ALTER TABLE fd_pt1 ADD CONSTRAINT fd_pt1chk2 CHECK (c2 <> '');
--- connoinherit should be true for NO INHERIT constraint
-SELECT relname, conname, contype, conislocal, coninhcount, connoinherit
-  FROM pg_class AS pc JOIN pg_constraint AS pgc ON (conrelid = pc.oid)
-  WHERE pc.relname = 'fd_pt1'
-  ORDER BY 1,2;
- relname |  conname   | contype | conislocal | coninhcount | connoinherit 
----------+------------+---------+------------+-------------+--------------
- fd_pt1  | fd_pt1chk1 | c       | t          |           0 | t
- fd_pt1  | fd_pt1chk2 | c       | t          |           0 | f
-(2 rows)
-
--- child does not inherit NO INHERIT constraints
-\d+ fd_pt1
-                                   Table "public.fd_pt1"
- Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
---------+---------+-----------+----------+---------+----------+--------------+-------------
- c1     | integer |           | not null |         | plain    | 10000        | 
- c2     | text    |           |          |         | extended |              | 
- c3     | date    |           |          |         | plain    |              | 
-Check constraints:
-    "fd_pt1chk1" CHECK (c1 > 0) NO INHERIT
-    "fd_pt1chk2" CHECK (c2 <> ''::text)
-Child tables: ft2
-
-\d+ ft2
-                                       Foreign table "public.ft2"
- Column |  Type   | Collation | Nullable | Default | FDW options | Storage  | Stats target | Description 
---------+---------+-----------+----------+---------+-------------+----------+--------------+-------------
- c1     | integer |           | not null |         |             | plain    | 10000        | 
- c2     | text    |           |          |         |             | extended |              | 
- c3     | date    |           |          |         |             | plain    |              | 
-Check constraints:
-    "fd_pt1chk2" CHECK (c2 <> ''::text)
-Server: s0
-FDW options: (delimiter ',', quote '"', "be quoted" 'value')
-Inherits: fd_pt1
-Child tables: ct3,
-              ft3
-
-DROP FOREIGN TABLE ft2; -- ERROR
-ERROR:  cannot drop foreign table ft2 because other objects depend on it
-DETAIL:  table ct3 depends on foreign table ft2
-foreign table ft3 depends on foreign table ft2
-HINT:  Use DROP ... CASCADE to drop the dependent objects too.
-DROP FOREIGN TABLE ft2 CASCADE;
-NOTICE:  drop cascades to 2 other objects
-DETAIL:  drop cascades to table ct3
-drop cascades to foreign table ft3
-CREATE FOREIGN TABLE ft2 (
-	c1 integer NOT NULL,
-	c2 text,
-	c3 date
-) SERVER s0 OPTIONS (delimiter ',', quote '"', "be quoted" 'value');
--- child must have parent's INHERIT constraints
-ALTER FOREIGN TABLE ft2 INHERIT fd_pt1;                            -- ERROR
-ERROR:  child table is missing constraint "fd_pt1chk2"
-ALTER FOREIGN TABLE ft2 ADD CONSTRAINT fd_pt1chk2 CHECK (c2 <> '');
-ALTER FOREIGN TABLE ft2 INHERIT fd_pt1;
--- child does not inherit NO INHERIT constraints
-\d+ fd_pt1
-                                   Table "public.fd_pt1"
- Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
---------+---------+-----------+----------+---------+----------+--------------+-------------
- c1     | integer |           | not null |         | plain    | 10000        | 
- c2     | text    |           |          |         | extended |              | 
- c3     | date    |           |          |         | plain    |              | 
-Check constraints:
-    "fd_pt1chk1" CHECK (c1 > 0) NO INHERIT
-    "fd_pt1chk2" CHECK (c2 <> ''::text)
-Child tables: ft2
-
-\d+ ft2
-                                       Foreign table "public.ft2"
- Column |  Type   | Collation | Nullable | Default | FDW options | Storage  | Stats target | Description 
---------+---------+-----------+----------+---------+-------------+----------+--------------+-------------
- c1     | integer |           | not null |         |             | plain    |              | 
- c2     | text    |           |          |         |             | extended |              | 
- c3     | date    |           |          |         |             | plain    |              | 
-Check constraints:
-    "fd_pt1chk2" CHECK (c2 <> ''::text)
-Server: s0
-FDW options: (delimiter ',', quote '"', "be quoted" 'value')
-Inherits: fd_pt1
-
--- drop constraints recursively
-ALTER TABLE fd_pt1 DROP CONSTRAINT fd_pt1chk1 CASCADE;
-ALTER TABLE fd_pt1 DROP CONSTRAINT fd_pt1chk2 CASCADE;
--- NOT VALID case
-INSERT INTO fd_pt1 VALUES (1, 'fd_pt1'::text, '1994-01-01'::date);
-ALTER TABLE fd_pt1 ADD CONSTRAINT fd_pt1chk3 CHECK (c2 <> '') NOT VALID;
-\d+ fd_pt1
-                                   Table "public.fd_pt1"
- Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
---------+---------+-----------+----------+---------+----------+--------------+-------------
- c1     | integer |           | not null |         | plain    | 10000        | 
- c2     | text    |           |          |         | extended |              | 
- c3     | date    |           |          |         | plain    |              | 
-Check constraints:
-    "fd_pt1chk3" CHECK (c2 <> ''::text) NOT VALID
-Child tables: ft2
-
-\d+ ft2
-                                       Foreign table "public.ft2"
- Column |  Type   | Collation | Nullable | Default | FDW options | Storage  | Stats target | Description 
---------+---------+-----------+----------+---------+-------------+----------+--------------+-------------
- c1     | integer |           | not null |         |             | plain    |              | 
- c2     | text    |           |          |         |             | extended |              | 
- c3     | date    |           |          |         |             | plain    |              | 
-Check constraints:
-    "fd_pt1chk2" CHECK (c2 <> ''::text)
-    "fd_pt1chk3" CHECK (c2 <> ''::text) NOT VALID
-Server: s0
-FDW options: (delimiter ',', quote '"', "be quoted" 'value')
-Inherits: fd_pt1
-
--- VALIDATE CONSTRAINT need do nothing on foreign tables
-ALTER TABLE fd_pt1 VALIDATE CONSTRAINT fd_pt1chk3;
-\d+ fd_pt1
-                                   Table "public.fd_pt1"
- Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
---------+---------+-----------+----------+---------+----------+--------------+-------------
- c1     | integer |           | not null |         | plain    | 10000        | 
- c2     | text    |           |          |         | extended |              | 
- c3     | date    |           |          |         | plain    |              | 
-Check constraints:
-    "fd_pt1chk3" CHECK (c2 <> ''::text)
-Child tables: ft2
-
-\d+ ft2
-                                       Foreign table "public.ft2"
- Column |  Type   | Collation | Nullable | Default | FDW options | Storage  | Stats target | Description 
---------+---------+-----------+----------+---------+-------------+----------+--------------+-------------
- c1     | integer |           | not null |         |             | plain    |              | 
- c2     | text    |           |          |         |             | extended |              | 
- c3     | date    |           |          |         |             | plain    |              | 
-Check constraints:
-    "fd_pt1chk2" CHECK (c2 <> ''::text)
-    "fd_pt1chk3" CHECK (c2 <> ''::text)
-Server: s0
-FDW options: (delimiter ',', quote '"', "be quoted" 'value')
-Inherits: fd_pt1
-
--- changes name of an attribute recursively
-ALTER TABLE fd_pt1 RENAME COLUMN c1 TO f1;
-ALTER TABLE fd_pt1 RENAME COLUMN c2 TO f2;
-ALTER TABLE fd_pt1 RENAME COLUMN c3 TO f3;
--- changes name of a constraint recursively
-ALTER TABLE fd_pt1 RENAME CONSTRAINT fd_pt1chk3 TO f2_check;
-\d+ fd_pt1
-                                   Table "public.fd_pt1"
- Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
---------+---------+-----------+----------+---------+----------+--------------+-------------
- f1     | integer |           | not null |         | plain    | 10000        | 
- f2     | text    |           |          |         | extended |              | 
- f3     | date    |           |          |         | plain    |              | 
-Check constraints:
-    "f2_check" CHECK (f2 <> ''::text)
-Child tables: ft2
-
-\d+ ft2
-                                       Foreign table "public.ft2"
- Column |  Type   | Collation | Nullable | Default | FDW options | Storage  | Stats target | Description 
---------+---------+-----------+----------+---------+-------------+----------+--------------+-------------
- f1     | integer |           | not null |         |             | plain    |              | 
- f2     | text    |           |          |         |             | extended |              | 
- f3     | date    |           |          |         |             | plain    |              | 
-Check constraints:
-    "f2_check" CHECK (f2 <> ''::text)
-    "fd_pt1chk2" CHECK (f2 <> ''::text)
-Server: s0
-FDW options: (delimiter ',', quote '"', "be quoted" 'value')
-Inherits: fd_pt1
-
--- TRUNCATE doesn't work on foreign tables, either directly or recursively
-TRUNCATE ft2;  -- ERROR
-ERROR:  foreign-data wrapper "dummy" has no handler
-TRUNCATE fd_pt1;  -- ERROR
-ERROR:  foreign-data wrapper "dummy" has no handler
-DROP TABLE fd_pt1 CASCADE;
-NOTICE:  drop cascades to foreign table ft2
--- IMPORT FOREIGN SCHEMA
-IMPORT FOREIGN SCHEMA s1 FROM SERVER s9 INTO public; -- ERROR
-ERROR:  foreign-data wrapper "foo" has no handler
-IMPORT FOREIGN SCHEMA s1 LIMIT TO (t1) FROM SERVER s9 INTO public; --ERROR
-ERROR:  foreign-data wrapper "foo" has no handler
-IMPORT FOREIGN SCHEMA s1 EXCEPT (t1) FROM SERVER s9 INTO public; -- ERROR
-ERROR:  foreign-data wrapper "foo" has no handler
-IMPORT FOREIGN SCHEMA s1 EXCEPT (t1, t2) FROM SERVER s9 INTO public
-OPTIONS (option1 'value1', option2 'value2'); -- ERROR
-ERROR:  foreign-data wrapper "foo" has no handler
--- DROP FOREIGN TABLE
-DROP FOREIGN TABLE no_table;                                    -- ERROR
-ERROR:  foreign table "no_table" does not exist
-DROP FOREIGN TABLE IF EXISTS no_table;
-NOTICE:  foreign table "no_table" does not exist, skipping
-DROP FOREIGN TABLE foreign_schema.foreign_table_1;
--- REASSIGN OWNED/DROP OWNED of foreign objects
-REASSIGN OWNED BY regress_test_role TO regress_test_role2;
-DROP OWNED BY regress_test_role2;
-ERROR:  cannot drop desired object(s) because other objects depend on them
-DETAIL:  user mapping for regress_test_role on server s5 depends on server s5
-HINT:  Use DROP ... CASCADE to drop the dependent objects too.
-DROP OWNED BY regress_test_role2 CASCADE;
-NOTICE:  drop cascades to user mapping for regress_test_role on server s5
--- Foreign partition DDL stuff
-CREATE TABLE fd_pt2 (
-	c1 integer NOT NULL,
-	c2 text,
-	c3 date
-) PARTITION BY LIST (c1);
-CREATE FOREIGN TABLE fd_pt2_1 PARTITION OF fd_pt2 FOR VALUES IN (1)
-  SERVER s0 OPTIONS (delimiter ',', quote '"', "be quoted" 'value');
-\d+ fd_pt2
-                             Partitioned table "public.fd_pt2"
- Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
---------+---------+-----------+----------+---------+----------+--------------+-------------
- c1     | integer |           | not null |         | plain    |              | 
- c2     | text    |           |          |         | extended |              | 
- c3     | date    |           |          |         | plain    |              | 
-Partition key: LIST (c1)
-Partitions: fd_pt2_1 FOR VALUES IN (1)
-
-\d+ fd_pt2_1
-                                     Foreign table "public.fd_pt2_1"
- Column |  Type   | Collation | Nullable | Default | FDW options | Storage  | Stats target | Description 
---------+---------+-----------+----------+---------+-------------+----------+--------------+-------------
- c1     | integer |           | not null |         |             | plain    |              | 
- c2     | text    |           |          |         |             | extended |              | 
- c3     | date    |           |          |         |             | plain    |              | 
-Partition of: fd_pt2 FOR VALUES IN (1)
-Partition constraint: ((c1 IS NOT NULL) AND (c1 = 1))
-Server: s0
-FDW options: (delimiter ',', quote '"', "be quoted" 'value')
-
--- partition cannot have additional columns
-DROP FOREIGN TABLE fd_pt2_1;
-CREATE FOREIGN TABLE fd_pt2_1 (
-	c1 integer NOT NULL,
-	c2 text,
-	c3 date,
-	c4 char
-) SERVER s0 OPTIONS (delimiter ',', quote '"', "be quoted" 'value');
-\d+ fd_pt2_1
-                                       Foreign table "public.fd_pt2_1"
- Column |     Type     | Collation | Nullable | Default | FDW options | Storage  | Stats target | Description 
---------+--------------+-----------+----------+---------+-------------+----------+--------------+-------------
- c1     | integer      |           | not null |         |             | plain    |              | 
- c2     | text         |           |          |         |             | extended |              | 
- c3     | date         |           |          |         |             | plain    |              | 
- c4     | character(1) |           |          |         |             | extended |              | 
-Server: s0
-FDW options: (delimiter ',', quote '"', "be quoted" 'value')
-
-ALTER TABLE fd_pt2 ATTACH PARTITION fd_pt2_1 FOR VALUES IN (1);       -- ERROR
-ERROR:  table "fd_pt2_1" contains column "c4" not found in parent "fd_pt2"
-DETAIL:  The new partition may contain only the columns present in parent.
-DROP FOREIGN TABLE fd_pt2_1;
-\d+ fd_pt2
-                             Partitioned table "public.fd_pt2"
- Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
---------+---------+-----------+----------+---------+----------+--------------+-------------
- c1     | integer |           | not null |         | plain    |              | 
- c2     | text    |           |          |         | extended |              | 
- c3     | date    |           |          |         | plain    |              | 
-Partition key: LIST (c1)
-Number of partitions: 0
-
-CREATE FOREIGN TABLE fd_pt2_1 (
-	c1 integer NOT NULL,
-	c2 text,
-	c3 date
-) SERVER s0 OPTIONS (delimiter ',', quote '"', "be quoted" 'value');
-\d+ fd_pt2_1
-                                     Foreign table "public.fd_pt2_1"
- Column |  Type   | Collation | Nullable | Default | FDW options | Storage  | Stats target | Description 
---------+---------+-----------+----------+---------+-------------+----------+--------------+-------------
- c1     | integer |           | not null |         |             | plain    |              | 
- c2     | text    |           |          |         |             | extended |              | 
- c3     | date    |           |          |         |             | plain    |              | 
-Server: s0
-FDW options: (delimiter ',', quote '"', "be quoted" 'value')
-
--- no attach partition validation occurs for foreign tables
-ALTER TABLE fd_pt2 ATTACH PARTITION fd_pt2_1 FOR VALUES IN (1);
-\d+ fd_pt2
-                             Partitioned table "public.fd_pt2"
- Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
---------+---------+-----------+----------+---------+----------+--------------+-------------
- c1     | integer |           | not null |         | plain    |              | 
- c2     | text    |           |          |         | extended |              | 
- c3     | date    |           |          |         | plain    |              | 
-Partition key: LIST (c1)
-Partitions: fd_pt2_1 FOR VALUES IN (1)
-
-\d+ fd_pt2_1
-                                     Foreign table "public.fd_pt2_1"
- Column |  Type   | Collation | Nullable | Default | FDW options | Storage  | Stats target | Description 
---------+---------+-----------+----------+---------+-------------+----------+--------------+-------------
- c1     | integer |           | not null |         |             | plain    |              | 
- c2     | text    |           |          |         |             | extended |              | 
- c3     | date    |           |          |         |             | plain    |              | 
-Partition of: fd_pt2 FOR VALUES IN (1)
-Partition constraint: ((c1 IS NOT NULL) AND (c1 = 1))
-Server: s0
-FDW options: (delimiter ',', quote '"', "be quoted" 'value')
-
--- cannot add column to a partition
-ALTER TABLE fd_pt2_1 ADD c4 char;
-ERROR:  cannot add column to a partition
--- ok to have a partition's own constraints though
-ALTER TABLE fd_pt2_1 ALTER c3 SET NOT NULL;
-ALTER TABLE fd_pt2_1 ADD CONSTRAINT p21chk CHECK (c2 <> '');
-\d+ fd_pt2
-                             Partitioned table "public.fd_pt2"
- Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
---------+---------+-----------+----------+---------+----------+--------------+-------------
- c1     | integer |           | not null |         | plain    |              | 
- c2     | text    |           |          |         | extended |              | 
- c3     | date    |           |          |         | plain    |              | 
-Partition key: LIST (c1)
-Partitions: fd_pt2_1 FOR VALUES IN (1)
-
-\d+ fd_pt2_1
-                                     Foreign table "public.fd_pt2_1"
- Column |  Type   | Collation | Nullable | Default | FDW options | Storage  | Stats target | Description 
---------+---------+-----------+----------+---------+-------------+----------+--------------+-------------
- c1     | integer |           | not null |         |             | plain    |              | 
- c2     | text    |           |          |         |             | extended |              | 
- c3     | date    |           | not null |         |             | plain    |              | 
-Partition of: fd_pt2 FOR VALUES IN (1)
-Partition constraint: ((c1 IS NOT NULL) AND (c1 = 1))
-Check constraints:
-    "p21chk" CHECK (c2 <> ''::text)
-Server: s0
-FDW options: (delimiter ',', quote '"', "be quoted" 'value')
-
--- cannot drop inherited NOT NULL constraint from a partition
-ALTER TABLE fd_pt2_1 ALTER c1 DROP NOT NULL;
-ERROR:  column "c1" is marked NOT NULL in parent table
--- partition must have parent's constraints
-ALTER TABLE fd_pt2 DETACH PARTITION fd_pt2_1;
-ALTER TABLE fd_pt2 ALTER c2 SET NOT NULL;
-\d+ fd_pt2
-                             Partitioned table "public.fd_pt2"
- Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
---------+---------+-----------+----------+---------+----------+--------------+-------------
- c1     | integer |           | not null |         | plain    |              | 
- c2     | text    |           | not null |         | extended |              | 
- c3     | date    |           |          |         | plain    |              | 
-Partition key: LIST (c1)
-Number of partitions: 0
-
-\d+ fd_pt2_1
-                                     Foreign table "public.fd_pt2_1"
- Column |  Type   | Collation | Nullable | Default | FDW options | Storage  | Stats target | Description 
---------+---------+-----------+----------+---------+-------------+----------+--------------+-------------
- c1     | integer |           | not null |         |             | plain    |              | 
- c2     | text    |           |          |         |             | extended |              | 
- c3     | date    |           | not null |         |             | plain    |              | 
-Check constraints:
-    "p21chk" CHECK (c2 <> ''::text)
-Server: s0
-FDW options: (delimiter ',', quote '"', "be quoted" 'value')
-
-ALTER TABLE fd_pt2 ATTACH PARTITION fd_pt2_1 FOR VALUES IN (1);       -- ERROR
-ERROR:  column "c2" in child table must be marked NOT NULL
-ALTER FOREIGN TABLE fd_pt2_1 ALTER c2 SET NOT NULL;
-ALTER TABLE fd_pt2 ATTACH PARTITION fd_pt2_1 FOR VALUES IN (1);
-ALTER TABLE fd_pt2 DETACH PARTITION fd_pt2_1;
-ALTER TABLE fd_pt2 ADD CONSTRAINT fd_pt2chk1 CHECK (c1 > 0);
-\d+ fd_pt2
-                             Partitioned table "public.fd_pt2"
- Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
---------+---------+-----------+----------+---------+----------+--------------+-------------
- c1     | integer |           | not null |         | plain    |              | 
- c2     | text    |           | not null |         | extended |              | 
- c3     | date    |           |          |         | plain    |              | 
-Partition key: LIST (c1)
-Check constraints:
-    "fd_pt2chk1" CHECK (c1 > 0)
-Number of partitions: 0
-
-\d+ fd_pt2_1
-                                     Foreign table "public.fd_pt2_1"
- Column |  Type   | Collation | Nullable | Default | FDW options | Storage  | Stats target | Description 
---------+---------+-----------+----------+---------+-------------+----------+--------------+-------------
- c1     | integer |           | not null |         |             | plain    |              | 
- c2     | text    |           | not null |         |             | extended |              | 
- c3     | date    |           | not null |         |             | plain    |              | 
-Check constraints:
-    "p21chk" CHECK (c2 <> ''::text)
-Server: s0
-FDW options: (delimiter ',', quote '"', "be quoted" 'value')
-
-ALTER TABLE fd_pt2 ATTACH PARTITION fd_pt2_1 FOR VALUES IN (1);       -- ERROR
-ERROR:  child table is missing constraint "fd_pt2chk1"
-ALTER FOREIGN TABLE fd_pt2_1 ADD CONSTRAINT fd_pt2chk1 CHECK (c1 > 0);
-ALTER TABLE fd_pt2 ATTACH PARTITION fd_pt2_1 FOR VALUES IN (1);
--- TRUNCATE doesn't work on foreign tables, either directly or recursively
-TRUNCATE fd_pt2_1;  -- ERROR
-ERROR:  foreign-data wrapper "dummy" has no handler
-TRUNCATE fd_pt2;  -- ERROR
-ERROR:  foreign-data wrapper "dummy" has no handler
-DROP FOREIGN TABLE fd_pt2_1;
-DROP TABLE fd_pt2;
--- foreign table cannot be part of partition tree made of temporary
--- relations.
-CREATE TEMP TABLE temp_parted (a int) PARTITION BY LIST (a);
-CREATE FOREIGN TABLE foreign_part PARTITION OF temp_parted DEFAULT
-  SERVER s0;  -- ERROR
-ERROR:  cannot create a permanent relation as partition of temporary relation "temp_parted"
-CREATE FOREIGN TABLE foreign_part (a int) SERVER s0;
-ALTER TABLE temp_parted ATTACH PARTITION foreign_part DEFAULT;  -- ERROR
-ERROR:  cannot attach a permanent relation as partition of temporary relation "temp_parted"
-DROP FOREIGN TABLE foreign_part;
-DROP TABLE temp_parted;
--- Cleanup
-DROP SCHEMA foreign_schema CASCADE;
-DROP ROLE regress_test_role;                                -- ERROR
-ERROR:  role "regress_test_role" cannot be dropped because some objects depend on it
-DETAIL:  privileges for foreign-data wrapper foo
-privileges for server s4
-owner of user mapping for regress_test_role on server s6
-DROP SERVER t1 CASCADE;
-NOTICE:  drop cascades to user mapping for public on server t1
-DROP USER MAPPING FOR regress_test_role SERVER s6;
-DROP FOREIGN DATA WRAPPER foo CASCADE;
-NOTICE:  drop cascades to 5 other objects
-DETAIL:  drop cascades to server s4
-drop cascades to user mapping for regress_foreign_data_user on server s4
-drop cascades to server s6
-drop cascades to server s9
-drop cascades to user mapping for regress_unprivileged_role on server s9
-DROP SERVER s8 CASCADE;
-NOTICE:  drop cascades to 2 other objects
-DETAIL:  drop cascades to user mapping for regress_foreign_data_user on server s8
-drop cascades to user mapping for public on server s8
-DROP ROLE regress_test_indirect;
-DROP ROLE regress_test_role;
-DROP ROLE regress_unprivileged_role;                        -- ERROR
-ERROR:  role "regress_unprivileged_role" cannot be dropped because some objects depend on it
-DETAIL:  privileges for foreign-data wrapper postgresql
-REVOKE ALL ON FOREIGN DATA WRAPPER postgresql FROM regress_unprivileged_role;
-DROP ROLE regress_unprivileged_role;
-DROP ROLE regress_test_role2;
-DROP FOREIGN DATA WRAPPER postgresql CASCADE;
-DROP FOREIGN DATA WRAPPER dummy CASCADE;
-NOTICE:  drop cascades to server s0
-\c
-DROP ROLE regress_foreign_data_user;
--- At this point we should have no wrappers, no servers, and no mappings.
-SELECT fdwname, fdwhandler, fdwvalidator, fdwoptions FROM pg_foreign_data_wrapper;
- fdwname | fdwhandler | fdwvalidator | fdwoptions 
----------+------------+--------------+------------
-(0 rows)
-
-SELECT srvname, srvoptions FROM pg_foreign_server;
- srvname | srvoptions 
----------+------------
-(0 rows)
-
-SELECT * FROM pg_user_mapping;
- oid | umuser | umserver | umoptions 
------+--------+----------+-----------
-(0 rows)
+dyld: lazy symbol binding failed: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
+
+dyld: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
 
diff -U3 /Users/kenaniah/workspace/postgres/src/test/regress/expected/indirect_toast.out /Users/kenaniah/workspace/postgres/src/test/regress/results/indirect_toast.out
--- /Users/kenaniah/workspace/postgres/src/test/regress/expected/indirect_toast.out	2021-10-03 17:41:49.000000000 -0700
+++ /Users/kenaniah/workspace/postgres/src/test/regress/results/indirect_toast.out	2021-10-03 20:08:22.000000000 -0700
@@ -21,50 +21,26 @@
 
 -- modification without changing varlenas
 UPDATE indtoasttest SET cnt = cnt +1 RETURNING substring(indtoasttest::text, 1, 200);
-                                                                                                substring                                                                                                 
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
- (two-compressed,1,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012
- (two-toasted,1,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345
- ("one-compressed,one-null",1,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
- ("one-toasted,one-null",1,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123
-(4 rows)
-
+ERROR:  cannot update table "indtoasttest" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
 -- modification without modifying assigned value
 UPDATE indtoasttest SET cnt = cnt +1, f1 = f1 RETURNING substring(indtoasttest::text, 1, 200);
-                                                                                                substring                                                                                                 
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
- (two-compressed,2,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012
- (two-toasted,2,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345
- ("one-compressed,one-null",2,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
- ("one-toasted,one-null",2,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123
-(4 rows)
-
+ERROR:  cannot update table "indtoasttest" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
 -- modification modifying, but effectively not changing
 UPDATE indtoasttest SET cnt = cnt +1, f1 = f1||'' RETURNING substring(indtoasttest::text, 1, 200);
-                                                                                                substring                                                                                                 
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
- (two-compressed,3,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012
- (two-toasted,3,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345
- ("one-compressed,one-null",3,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
- ("one-toasted,one-null",3,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123
-(4 rows)
-
+ERROR:  cannot update table "indtoasttest" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
 UPDATE indtoasttest SET cnt = cnt +1, f1 = '-'||f1||'-' RETURNING substring(indtoasttest::text, 1, 200);
-                                                                                                substring                                                                                                 
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
- (two-compressed,4,-1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901
- (two-toasted,4,-1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234
- ("one-compressed,one-null",4,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
- ("one-toasted,one-null",4,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123
-(4 rows)
-
+ERROR:  cannot update table "indtoasttest" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
 SELECT substring(indtoasttest::text, 1, 200) FROM indtoasttest;
                                                                                                 substring                                                                                                 
 ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
- (two-compressed,4,-1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901
- (two-toasted,4,-1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234
- ("one-compressed,one-null",4,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
- ("one-toasted,one-null",4,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123
+ (two-compressed,0,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012
+ (two-toasted,0,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345
+ ("one-compressed,one-null",0,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
+ ("one-toasted,one-null",0,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123
 (4 rows)
 
 -- check we didn't screw with main/toast tuple visibility
@@ -72,10 +48,10 @@
 SELECT substring(indtoasttest::text, 1, 200) FROM indtoasttest;
                                                                                                 substring                                                                                                 
 ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
- (two-compressed,4,-1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901
- (two-toasted,4,-1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234
- ("one-compressed,one-null",4,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
- ("one-toasted,one-null",4,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123
+ (two-compressed,0,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012
+ (two-toasted,0,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345
+ ("one-compressed,one-null",0,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
+ ("one-toasted,one-null",0,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123
 (4 rows)
 
 -- now create a trigger that forces all Datums to be indirect ones
@@ -93,51 +69,27 @@
         EXECUTE PROCEDURE update_using_indirect();
 -- modification without changing varlenas
 UPDATE indtoasttest SET cnt = cnt +1 RETURNING substring(indtoasttest::text, 1, 200);
-                                                                                                substring                                                                                                 
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
- (two-compressed,5,-1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901
- (two-toasted,5,-1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234
- ("one-compressed,one-null",5,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
- ("one-toasted,one-null",5,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123
-(4 rows)
-
+ERROR:  cannot update table "indtoasttest" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
 -- modification without modifying assigned value
 UPDATE indtoasttest SET cnt = cnt +1, f1 = f1 RETURNING substring(indtoasttest::text, 1, 200);
-                                                                                                substring                                                                                                 
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
- (two-compressed,6,-1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901
- (two-toasted,6,-1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234
- ("one-compressed,one-null",6,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
- ("one-toasted,one-null",6,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123
-(4 rows)
-
+ERROR:  cannot update table "indtoasttest" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
 -- modification modifying, but effectively not changing
 UPDATE indtoasttest SET cnt = cnt +1, f1 = f1||'' RETURNING substring(indtoasttest::text, 1, 200);
-                                                                                                substring                                                                                                 
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
- (two-compressed,7,-1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901
- (two-toasted,7,-1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234
- ("one-compressed,one-null",7,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
- ("one-toasted,one-null",7,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123
-(4 rows)
-
+ERROR:  cannot update table "indtoasttest" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
 UPDATE indtoasttest SET cnt = cnt +1, f1 = '-'||f1||'-' RETURNING substring(indtoasttest::text, 1, 200);
-                                                                                                substring                                                                                                 
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
- (two-compressed,8,--123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
- (two-toasted,8,--123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123
- ("one-compressed,one-null",8,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
- ("one-toasted,one-null",8,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123
-(4 rows)
-
+ERROR:  cannot update table "indtoasttest" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
 INSERT INTO indtoasttest(descr, f1, f2) VALUES('one-toasted,one-null, via indirect', repeat('1234567890',30000), NULL);
 SELECT substring(indtoasttest::text, 1, 200) FROM indtoasttest;
                                                                                                 substring                                                                                                 
 ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
- (two-compressed,8,--123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
- (two-toasted,8,--123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123
- ("one-compressed,one-null",8,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
- ("one-toasted,one-null",8,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123
+ (two-compressed,0,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012
+ (two-toasted,0,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345
+ ("one-compressed,one-null",0,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
+ ("one-toasted,one-null",0,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123
  ("one-toasted,one-null, via indirect",0,1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
 (5 rows)
 
@@ -146,10 +98,10 @@
 SELECT substring(indtoasttest::text, 1, 200) FROM indtoasttest;
                                                                                                 substring                                                                                                 
 ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
- (two-compressed,8,--123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
- (two-toasted,8,--123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123
- ("one-compressed,one-null",8,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
- ("one-toasted,one-null",8,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123
+ (two-compressed,0,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012
+ (two-toasted,0,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345
+ ("one-compressed,one-null",0,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
+ ("one-toasted,one-null",0,,12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123
  ("one-toasted,one-null, via indirect",0,1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
 (5 rows)
 
diff -U3 /Users/kenaniah/workspace/postgres/src/test/regress/expected/limit.out /Users/kenaniah/workspace/postgres/src/test/regress/results/limit.out
--- /Users/kenaniah/workspace/postgres/src/test/regress/expected/limit.out	2021-10-03 17:41:49.000000000 -0700
+++ /Users/kenaniah/workspace/postgres/src/test/regress/results/limit.out	2021-10-03 20:08:23.000000000 -0700
@@ -633,62 +633,11 @@
 CREATE VIEW limit_thousand_v_1 AS SELECT thousand FROM onek WHERE thousand < 995
 		ORDER BY thousand FETCH FIRST 5 ROWS WITH TIES OFFSET 10;
 \d+ limit_thousand_v_1
-                      View "public.limit_thousand_v_1"
-  Column  |  Type   | Collation | Nullable | Default | Storage | Description 
-----------+---------+-----------+----------+---------+---------+-------------
- thousand | integer |           |          |         | plain   | 
-View definition:
- SELECT onek.thousand
-   FROM onek
-  WHERE onek.thousand < 995
-  ORDER BY onek.thousand
- OFFSET 10
- FETCH FIRST 5 ROWS WITH TIES;
+dyld: lazy symbol binding failed: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
 
-CREATE VIEW limit_thousand_v_2 AS SELECT thousand FROM onek WHERE thousand < 995
-		ORDER BY thousand OFFSET 10 FETCH FIRST 5 ROWS ONLY;
-\d+ limit_thousand_v_2
-                      View "public.limit_thousand_v_2"
-  Column  |  Type   | Collation | Nullable | Default | Storage | Description 
-----------+---------+-----------+----------+---------+---------+-------------
- thousand | integer |           |          |         | plain   | 
-View definition:
- SELECT onek.thousand
-   FROM onek
-  WHERE onek.thousand < 995
-  ORDER BY onek.thousand
- OFFSET 10
- LIMIT 5;
+dyld: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
 
-CREATE VIEW limit_thousand_v_3 AS SELECT thousand FROM onek WHERE thousand < 995
-		ORDER BY thousand FETCH FIRST NULL ROWS WITH TIES;		-- fails
-ERROR:  row count cannot be null in FETCH FIRST ... WITH TIES clause
-CREATE VIEW limit_thousand_v_3 AS SELECT thousand FROM onek WHERE thousand < 995
-		ORDER BY thousand FETCH FIRST (NULL+1) ROWS WITH TIES;
-\d+ limit_thousand_v_3
-                      View "public.limit_thousand_v_3"
-  Column  |  Type   | Collation | Nullable | Default | Storage | Description 
-----------+---------+-----------+----------+---------+---------+-------------
- thousand | integer |           |          |         | plain   | 
-View definition:
- SELECT onek.thousand
-   FROM onek
-  WHERE onek.thousand < 995
-  ORDER BY onek.thousand
- FETCH FIRST (NULL::integer + 1) ROWS WITH TIES;
-
-CREATE VIEW limit_thousand_v_4 AS SELECT thousand FROM onek WHERE thousand < 995
-		ORDER BY thousand FETCH FIRST NULL ROWS ONLY;
-\d+ limit_thousand_v_4
-                      View "public.limit_thousand_v_4"
-  Column  |  Type   | Collation | Nullable | Default | Storage | Description 
-----------+---------+-----------+----------+---------+---------+-------------
- thousand | integer |           |          |         | plain   | 
-View definition:
- SELECT onek.thousand
-   FROM onek
-  WHERE onek.thousand < 995
-  ORDER BY onek.thousand
- LIMIT ALL;
-
--- leave these views
diff -U3 /Users/kenaniah/workspace/postgres/src/test/regress/expected/plpgsql.out /Users/kenaniah/workspace/postgres/src/test/regress/results/plpgsql.out
--- /Users/kenaniah/workspace/postgres/src/test/regress/expected/plpgsql.out	2021-10-03 17:41:49.000000000 -0700
+++ /Users/kenaniah/workspace/postgres/src/test/regress/results/plpgsql.out	2021-10-03 20:08:24.000000000 -0700
@@ -1083,17 +1083,77 @@
 -- These are already wired to the wall connectors
 --
 insert into PSlot values ('PS.base.b1', 'PF0_1', '', 'WS.002.1a');
+ERROR:  cannot update table "wslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "update WSlot set backlink = blname where slotname = myname"
+PL/pgSQL function tg_backlink_set(character,character) line 33 at SQL statement
+PL/pgSQL function tg_backlink_a() line 7 at assignment
 insert into PSlot values ('PS.base.b2', 'PF0_1', '', 'WS.002.1b');
+ERROR:  cannot update table "wslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "update WSlot set backlink = blname where slotname = myname"
+PL/pgSQL function tg_backlink_set(character,character) line 33 at SQL statement
+PL/pgSQL function tg_backlink_a() line 7 at assignment
 insert into PSlot values ('PS.base.b3', 'PF0_1', '', 'WS.002.2a');
+ERROR:  cannot update table "wslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "update WSlot set backlink = blname where slotname = myname"
+PL/pgSQL function tg_backlink_set(character,character) line 33 at SQL statement
+PL/pgSQL function tg_backlink_a() line 7 at assignment
 insert into PSlot values ('PS.base.b4', 'PF0_1', '', 'WS.002.2b');
+ERROR:  cannot update table "wslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "update WSlot set backlink = blname where slotname = myname"
+PL/pgSQL function tg_backlink_set(character,character) line 33 at SQL statement
+PL/pgSQL function tg_backlink_a() line 7 at assignment
 insert into PSlot values ('PS.base.b5', 'PF0_1', '', 'WS.002.3a');
+ERROR:  cannot update table "wslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "update WSlot set backlink = blname where slotname = myname"
+PL/pgSQL function tg_backlink_set(character,character) line 33 at SQL statement
+PL/pgSQL function tg_backlink_a() line 7 at assignment
 insert into PSlot values ('PS.base.b6', 'PF0_1', '', 'WS.002.3b');
+ERROR:  cannot update table "wslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "update WSlot set backlink = blname where slotname = myname"
+PL/pgSQL function tg_backlink_set(character,character) line 33 at SQL statement
+PL/pgSQL function tg_backlink_a() line 7 at assignment
 insert into PSlot values ('PS.base.c1', 'PF0_1', '', 'WS.003.1a');
+ERROR:  cannot update table "wslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "update WSlot set backlink = blname where slotname = myname"
+PL/pgSQL function tg_backlink_set(character,character) line 33 at SQL statement
+PL/pgSQL function tg_backlink_a() line 7 at assignment
 insert into PSlot values ('PS.base.c2', 'PF0_1', '', 'WS.003.1b');
+ERROR:  cannot update table "wslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "update WSlot set backlink = blname where slotname = myname"
+PL/pgSQL function tg_backlink_set(character,character) line 33 at SQL statement
+PL/pgSQL function tg_backlink_a() line 7 at assignment
 insert into PSlot values ('PS.base.c3', 'PF0_1', '', 'WS.003.2a');
+ERROR:  cannot update table "wslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "update WSlot set backlink = blname where slotname = myname"
+PL/pgSQL function tg_backlink_set(character,character) line 33 at SQL statement
+PL/pgSQL function tg_backlink_a() line 7 at assignment
 insert into PSlot values ('PS.base.c4', 'PF0_1', '', 'WS.003.2b');
+ERROR:  cannot update table "wslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "update WSlot set backlink = blname where slotname = myname"
+PL/pgSQL function tg_backlink_set(character,character) line 33 at SQL statement
+PL/pgSQL function tg_backlink_a() line 7 at assignment
 insert into PSlot values ('PS.base.c5', 'PF0_1', '', 'WS.003.3a');
+ERROR:  cannot update table "wslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "update WSlot set backlink = blname where slotname = myname"
+PL/pgSQL function tg_backlink_set(character,character) line 33 at SQL statement
+PL/pgSQL function tg_backlink_a() line 7 at assignment
 insert into PSlot values ('PS.base.c6', 'PF0_1', '', 'WS.003.3b');
+ERROR:  cannot update table "wslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "update WSlot set backlink = blname where slotname = myname"
+PL/pgSQL function tg_backlink_set(character,character) line 33 at SQL statement
+PL/pgSQL function tg_backlink_a() line 7 at assignment
 --
 -- This patchfield will be renamed later into PF0_2 - so its
 -- slots references in pfname should follow
@@ -1113,41 +1173,165 @@
 insert into PSlot values ('PS.base.tb6', 'PF0_X', '', '');
 insert into PField values ('PF1_1', 'Wallslots first floor');
 insert into PSlot values ('PS.first.a1', 'PF1_1', '', 'WS.101.1a');
+ERROR:  cannot update table "wslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "update WSlot set backlink = blname where slotname = myname"
+PL/pgSQL function tg_backlink_set(character,character) line 33 at SQL statement
+PL/pgSQL function tg_backlink_a() line 7 at assignment
 insert into PSlot values ('PS.first.a2', 'PF1_1', '', 'WS.101.1b');
+ERROR:  cannot update table "wslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "update WSlot set backlink = blname where slotname = myname"
+PL/pgSQL function tg_backlink_set(character,character) line 33 at SQL statement
+PL/pgSQL function tg_backlink_a() line 7 at assignment
 insert into PSlot values ('PS.first.a3', 'PF1_1', '', 'WS.101.2a');
+ERROR:  cannot update table "wslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "update WSlot set backlink = blname where slotname = myname"
+PL/pgSQL function tg_backlink_set(character,character) line 33 at SQL statement
+PL/pgSQL function tg_backlink_a() line 7 at assignment
 insert into PSlot values ('PS.first.a4', 'PF1_1', '', 'WS.101.2b');
+ERROR:  cannot update table "wslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "update WSlot set backlink = blname where slotname = myname"
+PL/pgSQL function tg_backlink_set(character,character) line 33 at SQL statement
+PL/pgSQL function tg_backlink_a() line 7 at assignment
 insert into PSlot values ('PS.first.a5', 'PF1_1', '', 'WS.101.3a');
+ERROR:  cannot update table "wslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "update WSlot set backlink = blname where slotname = myname"
+PL/pgSQL function tg_backlink_set(character,character) line 33 at SQL statement
+PL/pgSQL function tg_backlink_a() line 7 at assignment
 insert into PSlot values ('PS.first.a6', 'PF1_1', '', 'WS.101.3b');
+ERROR:  cannot update table "wslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "update WSlot set backlink = blname where slotname = myname"
+PL/pgSQL function tg_backlink_set(character,character) line 33 at SQL statement
+PL/pgSQL function tg_backlink_a() line 7 at assignment
 insert into PSlot values ('PS.first.b1', 'PF1_1', '', 'WS.102.1a');
+ERROR:  cannot update table "wslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "update WSlot set backlink = blname where slotname = myname"
+PL/pgSQL function tg_backlink_set(character,character) line 33 at SQL statement
+PL/pgSQL function tg_backlink_a() line 7 at assignment
 insert into PSlot values ('PS.first.b2', 'PF1_1', '', 'WS.102.1b');
+ERROR:  cannot update table "wslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "update WSlot set backlink = blname where slotname = myname"
+PL/pgSQL function tg_backlink_set(character,character) line 33 at SQL statement
+PL/pgSQL function tg_backlink_a() line 7 at assignment
 insert into PSlot values ('PS.first.b3', 'PF1_1', '', 'WS.102.2a');
+ERROR:  cannot update table "wslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "update WSlot set backlink = blname where slotname = myname"
+PL/pgSQL function tg_backlink_set(character,character) line 33 at SQL statement
+PL/pgSQL function tg_backlink_a() line 7 at assignment
 insert into PSlot values ('PS.first.b4', 'PF1_1', '', 'WS.102.2b');
+ERROR:  cannot update table "wslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "update WSlot set backlink = blname where slotname = myname"
+PL/pgSQL function tg_backlink_set(character,character) line 33 at SQL statement
+PL/pgSQL function tg_backlink_a() line 7 at assignment
 insert into PSlot values ('PS.first.b5', 'PF1_1', '', 'WS.102.3a');
+ERROR:  cannot update table "wslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "update WSlot set backlink = blname where slotname = myname"
+PL/pgSQL function tg_backlink_set(character,character) line 33 at SQL statement
+PL/pgSQL function tg_backlink_a() line 7 at assignment
 insert into PSlot values ('PS.first.b6', 'PF1_1', '', 'WS.102.3b');
+ERROR:  cannot update table "wslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "update WSlot set backlink = blname where slotname = myname"
+PL/pgSQL function tg_backlink_set(character,character) line 33 at SQL statement
+PL/pgSQL function tg_backlink_a() line 7 at assignment
 insert into PSlot values ('PS.first.c1', 'PF1_1', '', 'WS.105.1a');
+ERROR:  cannot update table "wslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "update WSlot set backlink = blname where slotname = myname"
+PL/pgSQL function tg_backlink_set(character,character) line 33 at SQL statement
+PL/pgSQL function tg_backlink_a() line 7 at assignment
 insert into PSlot values ('PS.first.c2', 'PF1_1', '', 'WS.105.1b');
+ERROR:  cannot update table "wslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "update WSlot set backlink = blname where slotname = myname"
+PL/pgSQL function tg_backlink_set(character,character) line 33 at SQL statement
+PL/pgSQL function tg_backlink_a() line 7 at assignment
 insert into PSlot values ('PS.first.c3', 'PF1_1', '', 'WS.105.2a');
+ERROR:  cannot update table "wslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "update WSlot set backlink = blname where slotname = myname"
+PL/pgSQL function tg_backlink_set(character,character) line 33 at SQL statement
+PL/pgSQL function tg_backlink_a() line 7 at assignment
 insert into PSlot values ('PS.first.c4', 'PF1_1', '', 'WS.105.2b');
+ERROR:  cannot update table "wslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "update WSlot set backlink = blname where slotname = myname"
+PL/pgSQL function tg_backlink_set(character,character) line 33 at SQL statement
+PL/pgSQL function tg_backlink_a() line 7 at assignment
 insert into PSlot values ('PS.first.c5', 'PF1_1', '', 'WS.105.3a');
+ERROR:  cannot update table "wslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "update WSlot set backlink = blname where slotname = myname"
+PL/pgSQL function tg_backlink_set(character,character) line 33 at SQL statement
+PL/pgSQL function tg_backlink_a() line 7 at assignment
 insert into PSlot values ('PS.first.c6', 'PF1_1', '', 'WS.105.3b');
+ERROR:  cannot update table "wslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "update WSlot set backlink = blname where slotname = myname"
+PL/pgSQL function tg_backlink_set(character,character) line 33 at SQL statement
+PL/pgSQL function tg_backlink_a() line 7 at assignment
 insert into PSlot values ('PS.first.d1', 'PF1_1', '', 'WS.106.1a');
+ERROR:  cannot update table "wslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "update WSlot set backlink = blname where slotname = myname"
+PL/pgSQL function tg_backlink_set(character,character) line 33 at SQL statement
+PL/pgSQL function tg_backlink_a() line 7 at assignment
 insert into PSlot values ('PS.first.d2', 'PF1_1', '', 'WS.106.1b');
+ERROR:  cannot update table "wslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "update WSlot set backlink = blname where slotname = myname"
+PL/pgSQL function tg_backlink_set(character,character) line 33 at SQL statement
+PL/pgSQL function tg_backlink_a() line 7 at assignment
 insert into PSlot values ('PS.first.d3', 'PF1_1', '', 'WS.106.2a');
+ERROR:  cannot update table "wslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "update WSlot set backlink = blname where slotname = myname"
+PL/pgSQL function tg_backlink_set(character,character) line 33 at SQL statement
+PL/pgSQL function tg_backlink_a() line 7 at assignment
 insert into PSlot values ('PS.first.d4', 'PF1_1', '', 'WS.106.2b');
+ERROR:  cannot update table "wslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "update WSlot set backlink = blname where slotname = myname"
+PL/pgSQL function tg_backlink_set(character,character) line 33 at SQL statement
+PL/pgSQL function tg_backlink_a() line 7 at assignment
 insert into PSlot values ('PS.first.d5', 'PF1_1', '', 'WS.106.3a');
+ERROR:  cannot update table "wslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "update WSlot set backlink = blname where slotname = myname"
+PL/pgSQL function tg_backlink_set(character,character) line 33 at SQL statement
+PL/pgSQL function tg_backlink_a() line 7 at assignment
 insert into PSlot values ('PS.first.d6', 'PF1_1', '', 'WS.106.3b');
+ERROR:  cannot update table "wslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "update WSlot set backlink = blname where slotname = myname"
+PL/pgSQL function tg_backlink_set(character,character) line 33 at SQL statement
+PL/pgSQL function tg_backlink_a() line 7 at assignment
 --
 -- Now we wire the wall connectors 1a-2a in room 001 to the
 -- patchfield. In the second update we make an error, and
 -- correct it after
 --
 update PSlot set backlink = 'WS.001.1a' where slotname = 'PS.base.a1';
+ERROR:  cannot update table "pslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
 update PSlot set backlink = 'WS.001.1b' where slotname = 'PS.base.a3';
+ERROR:  cannot update table "pslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
 select * from WSlot where roomno = '001' order by slotname;
        slotname       |  roomno  |       slotlink       |       backlink       
 ----------------------+----------+----------------------+----------------------
- WS.001.1a            | 001      |                      | PS.base.a1          
- WS.001.1b            | 001      |                      | PS.base.a3          
+ WS.001.1a            | 001      |                      |                     
+ WS.001.1b            | 001      |                      |                     
  WS.001.2a            | 001      |                      |                     
  WS.001.2b            | 001      |                      |                     
  WS.001.3a            | 001      |                      |                     
@@ -1157,21 +1341,23 @@
 select * from PSlot where slotname ~ 'PS.base.a' order by slotname;
        slotname       | pfname |       slotlink       |       backlink       
 ----------------------+--------+----------------------+----------------------
- PS.base.a1           | PF0_1  |                      | WS.001.1a           
+ PS.base.a1           | PF0_1  |                      |                     
  PS.base.a2           | PF0_1  |                      |                     
- PS.base.a3           | PF0_1  |                      | WS.001.1b           
+ PS.base.a3           | PF0_1  |                      |                     
  PS.base.a4           | PF0_1  |                      |                     
  PS.base.a5           | PF0_1  |                      |                     
  PS.base.a6           | PF0_1  |                      |                     
 (6 rows)
 
 update PSlot set backlink = 'WS.001.2a' where slotname = 'PS.base.a3';
+ERROR:  cannot update table "pslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
 select * from WSlot where roomno = '001' order by slotname;
        slotname       |  roomno  |       slotlink       |       backlink       
 ----------------------+----------+----------------------+----------------------
- WS.001.1a            | 001      |                      | PS.base.a1          
+ WS.001.1a            | 001      |                      |                     
  WS.001.1b            | 001      |                      |                     
- WS.001.2a            | 001      |                      | PS.base.a3          
+ WS.001.2a            | 001      |                      |                     
  WS.001.2b            | 001      |                      |                     
  WS.001.3a            | 001      |                      |                     
  WS.001.3b            | 001      |                      |                     
@@ -1180,21 +1366,23 @@
 select * from PSlot where slotname ~ 'PS.base.a' order by slotname;
        slotname       | pfname |       slotlink       |       backlink       
 ----------------------+--------+----------------------+----------------------
- PS.base.a1           | PF0_1  |                      | WS.001.1a           
+ PS.base.a1           | PF0_1  |                      |                     
  PS.base.a2           | PF0_1  |                      |                     
- PS.base.a3           | PF0_1  |                      | WS.001.2a           
+ PS.base.a3           | PF0_1  |                      |                     
  PS.base.a4           | PF0_1  |                      |                     
  PS.base.a5           | PF0_1  |                      |                     
  PS.base.a6           | PF0_1  |                      |                     
 (6 rows)
 
 update PSlot set backlink = 'WS.001.1b' where slotname = 'PS.base.a2';
+ERROR:  cannot update table "pslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
 select * from WSlot where roomno = '001' order by slotname;
        slotname       |  roomno  |       slotlink       |       backlink       
 ----------------------+----------+----------------------+----------------------
- WS.001.1a            | 001      |                      | PS.base.a1          
- WS.001.1b            | 001      |                      | PS.base.a2          
- WS.001.2a            | 001      |                      | PS.base.a3          
+ WS.001.1a            | 001      |                      |                     
+ WS.001.1b            | 001      |                      |                     
+ WS.001.2a            | 001      |                      |                     
  WS.001.2b            | 001      |                      |                     
  WS.001.3a            | 001      |                      |                     
  WS.001.3b            | 001      |                      |                     
@@ -1203,9 +1391,9 @@
 select * from PSlot where slotname ~ 'PS.base.a' order by slotname;
        slotname       | pfname |       slotlink       |       backlink       
 ----------------------+--------+----------------------+----------------------
- PS.base.a1           | PF0_1  |                      | WS.001.1a           
- PS.base.a2           | PF0_1  |                      | WS.001.1b           
- PS.base.a3           | PF0_1  |                      | WS.001.2a           
+ PS.base.a1           | PF0_1  |                      |                     
+ PS.base.a2           | PF0_1  |                      |                     
+ PS.base.a3           | PF0_1  |                      |                     
  PS.base.a4           | PF0_1  |                      |                     
  PS.base.a5           | PF0_1  |                      |                     
  PS.base.a6           | PF0_1  |                      |                     
@@ -1217,73 +1405,81 @@
 -- WSlot and corresponding PSlot point to each other.
 --
 update WSlot set backlink = 'PS.base.a4' where slotname = 'WS.001.2b';
+ERROR:  cannot update table "wslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
 update WSlot set backlink = 'PS.base.a6' where slotname = 'WS.001.3a';
+ERROR:  cannot update table "wslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
 select * from WSlot where roomno = '001' order by slotname;
        slotname       |  roomno  |       slotlink       |       backlink       
 ----------------------+----------+----------------------+----------------------
- WS.001.1a            | 001      |                      | PS.base.a1          
- WS.001.1b            | 001      |                      | PS.base.a2          
- WS.001.2a            | 001      |                      | PS.base.a3          
- WS.001.2b            | 001      |                      | PS.base.a4          
- WS.001.3a            | 001      |                      | PS.base.a6          
+ WS.001.1a            | 001      |                      |                     
+ WS.001.1b            | 001      |                      |                     
+ WS.001.2a            | 001      |                      |                     
+ WS.001.2b            | 001      |                      |                     
+ WS.001.3a            | 001      |                      |                     
  WS.001.3b            | 001      |                      |                     
 (6 rows)
 
 select * from PSlot where slotname ~ 'PS.base.a' order by slotname;
        slotname       | pfname |       slotlink       |       backlink       
 ----------------------+--------+----------------------+----------------------
- PS.base.a1           | PF0_1  |                      | WS.001.1a           
- PS.base.a2           | PF0_1  |                      | WS.001.1b           
- PS.base.a3           | PF0_1  |                      | WS.001.2a           
- PS.base.a4           | PF0_1  |                      | WS.001.2b           
+ PS.base.a1           | PF0_1  |                      |                     
+ PS.base.a2           | PF0_1  |                      |                     
+ PS.base.a3           | PF0_1  |                      |                     
+ PS.base.a4           | PF0_1  |                      |                     
  PS.base.a5           | PF0_1  |                      |                     
- PS.base.a6           | PF0_1  |                      | WS.001.3a           
+ PS.base.a6           | PF0_1  |                      |                     
 (6 rows)
 
 update WSlot set backlink = 'PS.base.a6' where slotname = 'WS.001.3b';
+ERROR:  cannot update table "wslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
 select * from WSlot where roomno = '001' order by slotname;
        slotname       |  roomno  |       slotlink       |       backlink       
 ----------------------+----------+----------------------+----------------------
- WS.001.1a            | 001      |                      | PS.base.a1          
- WS.001.1b            | 001      |                      | PS.base.a2          
- WS.001.2a            | 001      |                      | PS.base.a3          
- WS.001.2b            | 001      |                      | PS.base.a4          
+ WS.001.1a            | 001      |                      |                     
+ WS.001.1b            | 001      |                      |                     
+ WS.001.2a            | 001      |                      |                     
+ WS.001.2b            | 001      |                      |                     
  WS.001.3a            | 001      |                      |                     
- WS.001.3b            | 001      |                      | PS.base.a6          
+ WS.001.3b            | 001      |                      |                     
 (6 rows)
 
 select * from PSlot where slotname ~ 'PS.base.a' order by slotname;
        slotname       | pfname |       slotlink       |       backlink       
 ----------------------+--------+----------------------+----------------------
- PS.base.a1           | PF0_1  |                      | WS.001.1a           
- PS.base.a2           | PF0_1  |                      | WS.001.1b           
- PS.base.a3           | PF0_1  |                      | WS.001.2a           
- PS.base.a4           | PF0_1  |                      | WS.001.2b           
+ PS.base.a1           | PF0_1  |                      |                     
+ PS.base.a2           | PF0_1  |                      |                     
+ PS.base.a3           | PF0_1  |                      |                     
+ PS.base.a4           | PF0_1  |                      |                     
  PS.base.a5           | PF0_1  |                      |                     
- PS.base.a6           | PF0_1  |                      | WS.001.3b           
+ PS.base.a6           | PF0_1  |                      |                     
 (6 rows)
 
 update WSlot set backlink = 'PS.base.a5' where slotname = 'WS.001.3a';
+ERROR:  cannot update table "wslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
 select * from WSlot where roomno = '001' order by slotname;
        slotname       |  roomno  |       slotlink       |       backlink       
 ----------------------+----------+----------------------+----------------------
- WS.001.1a            | 001      |                      | PS.base.a1          
- WS.001.1b            | 001      |                      | PS.base.a2          
- WS.001.2a            | 001      |                      | PS.base.a3          
- WS.001.2b            | 001      |                      | PS.base.a4          
- WS.001.3a            | 001      |                      | PS.base.a5          
- WS.001.3b            | 001      |                      | PS.base.a6          
+ WS.001.1a            | 001      |                      |                     
+ WS.001.1b            | 001      |                      |                     
+ WS.001.2a            | 001      |                      |                     
+ WS.001.2b            | 001      |                      |                     
+ WS.001.3a            | 001      |                      |                     
+ WS.001.3b            | 001      |                      |                     
 (6 rows)
 
 select * from PSlot where slotname ~ 'PS.base.a' order by slotname;
        slotname       | pfname |       slotlink       |       backlink       
 ----------------------+--------+----------------------+----------------------
- PS.base.a1           | PF0_1  |                      | WS.001.1a           
- PS.base.a2           | PF0_1  |                      | WS.001.1b           
- PS.base.a3           | PF0_1  |                      | WS.001.2a           
- PS.base.a4           | PF0_1  |                      | WS.001.2b           
- PS.base.a5           | PF0_1  |                      | WS.001.3a           
- PS.base.a6           | PF0_1  |                      | WS.001.3b           
+ PS.base.a1           | PF0_1  |                      |                     
+ PS.base.a2           | PF0_1  |                      |                     
+ PS.base.a3           | PF0_1  |                      |                     
+ PS.base.a4           | PF0_1  |                      |                     
+ PS.base.a5           | PF0_1  |                      |                     
+ PS.base.a6           | PF0_1  |                      |                     
 (6 rows)
 
 insert into PField values ('PF1_2', 'Phonelines first floor');
@@ -1303,63 +1499,29 @@
 -- Fix the wrong name for patchfield PF0_2
 --
 update PField set name = 'PF0_2' where name = 'PF0_X';
+ERROR:  cannot update table "pfield" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
 select * from PSlot order by slotname;
        slotname       | pfname |       slotlink       |       backlink       
 ----------------------+--------+----------------------+----------------------
- PS.base.a1           | PF0_1  |                      | WS.001.1a           
- PS.base.a2           | PF0_1  |                      | WS.001.1b           
- PS.base.a3           | PF0_1  |                      | WS.001.2a           
- PS.base.a4           | PF0_1  |                      | WS.001.2b           
- PS.base.a5           | PF0_1  |                      | WS.001.3a           
- PS.base.a6           | PF0_1  |                      | WS.001.3b           
- PS.base.b1           | PF0_1  |                      | WS.002.1a           
- PS.base.b2           | PF0_1  |                      | WS.002.1b           
- PS.base.b3           | PF0_1  |                      | WS.002.2a           
- PS.base.b4           | PF0_1  |                      | WS.002.2b           
- PS.base.b5           | PF0_1  |                      | WS.002.3a           
- PS.base.b6           | PF0_1  |                      | WS.002.3b           
- PS.base.c1           | PF0_1  |                      | WS.003.1a           
- PS.base.c2           | PF0_1  |                      | WS.003.1b           
- PS.base.c3           | PF0_1  |                      | WS.003.2a           
- PS.base.c4           | PF0_1  |                      | WS.003.2b           
- PS.base.c5           | PF0_1  |                      | WS.003.3a           
- PS.base.c6           | PF0_1  |                      | WS.003.3b           
- PS.base.ta1          | PF0_2  |                      |                     
- PS.base.ta2          | PF0_2  |                      |                     
- PS.base.ta3          | PF0_2  |                      |                     
- PS.base.ta4          | PF0_2  |                      |                     
- PS.base.ta5          | PF0_2  |                      |                     
- PS.base.ta6          | PF0_2  |                      |                     
- PS.base.tb1          | PF0_2  |                      |                     
- PS.base.tb2          | PF0_2  |                      |                     
- PS.base.tb3          | PF0_2  |                      |                     
- PS.base.tb4          | PF0_2  |                      |                     
- PS.base.tb5          | PF0_2  |                      |                     
- PS.base.tb6          | PF0_2  |                      |                     
- PS.first.a1          | PF1_1  |                      | WS.101.1a           
- PS.first.a2          | PF1_1  |                      | WS.101.1b           
- PS.first.a3          | PF1_1  |                      | WS.101.2a           
- PS.first.a4          | PF1_1  |                      | WS.101.2b           
- PS.first.a5          | PF1_1  |                      | WS.101.3a           
- PS.first.a6          | PF1_1  |                      | WS.101.3b           
- PS.first.b1          | PF1_1  |                      | WS.102.1a           
- PS.first.b2          | PF1_1  |                      | WS.102.1b           
- PS.first.b3          | PF1_1  |                      | WS.102.2a           
- PS.first.b4          | PF1_1  |                      | WS.102.2b           
- PS.first.b5          | PF1_1  |                      | WS.102.3a           
- PS.first.b6          | PF1_1  |                      | WS.102.3b           
- PS.first.c1          | PF1_1  |                      | WS.105.1a           
- PS.first.c2          | PF1_1  |                      | WS.105.1b           
- PS.first.c3          | PF1_1  |                      | WS.105.2a           
- PS.first.c4          | PF1_1  |                      | WS.105.2b           
- PS.first.c5          | PF1_1  |                      | WS.105.3a           
- PS.first.c6          | PF1_1  |                      | WS.105.3b           
- PS.first.d1          | PF1_1  |                      | WS.106.1a           
- PS.first.d2          | PF1_1  |                      | WS.106.1b           
- PS.first.d3          | PF1_1  |                      | WS.106.2a           
- PS.first.d4          | PF1_1  |                      | WS.106.2b           
- PS.first.d5          | PF1_1  |                      | WS.106.3a           
- PS.first.d6          | PF1_1  |                      | WS.106.3b           
+ PS.base.a1           | PF0_1  |                      |                     
+ PS.base.a2           | PF0_1  |                      |                     
+ PS.base.a3           | PF0_1  |                      |                     
+ PS.base.a4           | PF0_1  |                      |                     
+ PS.base.a5           | PF0_1  |                      |                     
+ PS.base.a6           | PF0_1  |                      |                     
+ PS.base.ta1          | PF0_X  |                      |                     
+ PS.base.ta2          | PF0_X  |                      |                     
+ PS.base.ta3          | PF0_X  |                      |                     
+ PS.base.ta4          | PF0_X  |                      |                     
+ PS.base.ta5          | PF0_X  |                      |                     
+ PS.base.ta6          | PF0_X  |                      |                     
+ PS.base.tb1          | PF0_X  |                      |                     
+ PS.base.tb2          | PF0_X  |                      |                     
+ PS.base.tb3          | PF0_X  |                      |                     
+ PS.base.tb4          | PF0_X  |                      |                     
+ PS.base.tb5          | PF0_X  |                      |                     
+ PS.base.tb6          | PF0_X  |                      |                     
  PS.first.ta1         | PF1_2  |                      |                     
  PS.first.ta2         | PF1_2  |                      |                     
  PS.first.ta3         | PF1_2  |                      |                     
@@ -1372,53 +1534,53 @@
  PS.first.tb4         | PF1_2  |                      |                     
  PS.first.tb5         | PF1_2  |                      |                     
  PS.first.tb6         | PF1_2  |                      |                     
-(66 rows)
+(30 rows)
 
 select * from WSlot order by slotname;
        slotname       |  roomno  |       slotlink       |       backlink       
 ----------------------+----------+----------------------+----------------------
- WS.001.1a            | 001      |                      | PS.base.a1          
- WS.001.1b            | 001      |                      | PS.base.a2          
- WS.001.2a            | 001      |                      | PS.base.a3          
- WS.001.2b            | 001      |                      | PS.base.a4          
- WS.001.3a            | 001      |                      | PS.base.a5          
- WS.001.3b            | 001      |                      | PS.base.a6          
- WS.002.1a            | 002      |                      | PS.base.b1          
- WS.002.1b            | 002      |                      | PS.base.b2          
- WS.002.2a            | 002      |                      | PS.base.b3          
- WS.002.2b            | 002      |                      | PS.base.b4          
- WS.002.3a            | 002      |                      | PS.base.b5          
- WS.002.3b            | 002      |                      | PS.base.b6          
- WS.003.1a            | 003      |                      | PS.base.c1          
- WS.003.1b            | 003      |                      | PS.base.c2          
- WS.003.2a            | 003      |                      | PS.base.c3          
- WS.003.2b            | 003      |                      | PS.base.c4          
- WS.003.3a            | 003      |                      | PS.base.c5          
- WS.003.3b            | 003      |                      | PS.base.c6          
- WS.101.1a            | 101      |                      | PS.first.a1         
- WS.101.1b            | 101      |                      | PS.first.a2         
- WS.101.2a            | 101      |                      | PS.first.a3         
- WS.101.2b            | 101      |                      | PS.first.a4         
- WS.101.3a            | 101      |                      | PS.first.a5         
- WS.101.3b            | 101      |                      | PS.first.a6         
- WS.102.1a            | 102      |                      | PS.first.b1         
- WS.102.1b            | 102      |                      | PS.first.b2         
- WS.102.2a            | 102      |                      | PS.first.b3         
- WS.102.2b            | 102      |                      | PS.first.b4         
- WS.102.3a            | 102      |                      | PS.first.b5         
- WS.102.3b            | 102      |                      | PS.first.b6         
- WS.105.1a            | 105      |                      | PS.first.c1         
- WS.105.1b            | 105      |                      | PS.first.c2         
- WS.105.2a            | 105      |                      | PS.first.c3         
- WS.105.2b            | 105      |                      | PS.first.c4         
- WS.105.3a            | 105      |                      | PS.first.c5         
- WS.105.3b            | 105      |                      | PS.first.c6         
- WS.106.1a            | 106      |                      | PS.first.d1         
- WS.106.1b            | 106      |                      | PS.first.d2         
- WS.106.2a            | 106      |                      | PS.first.d3         
- WS.106.2b            | 106      |                      | PS.first.d4         
- WS.106.3a            | 106      |                      | PS.first.d5         
- WS.106.3b            | 106      |                      | PS.first.d6         
+ WS.001.1a            | 001      |                      |                     
+ WS.001.1b            | 001      |                      |                     
+ WS.001.2a            | 001      |                      |                     
+ WS.001.2b            | 001      |                      |                     
+ WS.001.3a            | 001      |                      |                     
+ WS.001.3b            | 001      |                      |                     
+ WS.002.1a            | 002      |                      |                     
+ WS.002.1b            | 002      |                      |                     
+ WS.002.2a            | 002      |                      |                     
+ WS.002.2b            | 002      |                      |                     
+ WS.002.3a            | 002      |                      |                     
+ WS.002.3b            | 002      |                      |                     
+ WS.003.1a            | 003      |                      |                     
+ WS.003.1b            | 003      |                      |                     
+ WS.003.2a            | 003      |                      |                     
+ WS.003.2b            | 003      |                      |                     
+ WS.003.3a            | 003      |                      |                     
+ WS.003.3b            | 003      |                      |                     
+ WS.101.1a            | 101      |                      |                     
+ WS.101.1b            | 101      |                      |                     
+ WS.101.2a            | 101      |                      |                     
+ WS.101.2b            | 101      |                      |                     
+ WS.101.3a            | 101      |                      |                     
+ WS.101.3b            | 101      |                      |                     
+ WS.102.1a            | 102      |                      |                     
+ WS.102.1b            | 102      |                      |                     
+ WS.102.2a            | 102      |                      |                     
+ WS.102.2b            | 102      |                      |                     
+ WS.102.3a            | 102      |                      |                     
+ WS.102.3b            | 102      |                      |                     
+ WS.105.1a            | 105      |                      |                     
+ WS.105.1b            | 105      |                      |                     
+ WS.105.2a            | 105      |                      |                     
+ WS.105.2b            | 105      |                      |                     
+ WS.105.3a            | 105      |                      |                     
+ WS.105.3b            | 105      |                      |                     
+ WS.106.1a            | 106      |                      |                     
+ WS.106.1b            | 106      |                      |                     
+ WS.106.2a            | 106      |                      |                     
+ WS.106.2b            | 106      |                      |                     
+ WS.106.3a            | 106      |                      |                     
+ WS.106.3b            | 106      |                      |                     
 (42 rows)
 
 --
@@ -1428,37 +1590,165 @@
 -- backlink field.
 --
 insert into PLine values ('PL.001', '-0', 'Central call', 'PS.base.ta1');
+ERROR:  cannot update table "pslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "update PSlot set backlink = blname where slotname = myname"
+PL/pgSQL function tg_backlink_set(character,character) line 23 at SQL statement
+PL/pgSQL function tg_backlink_a() line 7 at assignment
 insert into PLine values ('PL.002', '-101', '', 'PS.base.ta2');
+ERROR:  cannot update table "pslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "update PSlot set backlink = blname where slotname = myname"
+PL/pgSQL function tg_backlink_set(character,character) line 23 at SQL statement
+PL/pgSQL function tg_backlink_a() line 7 at assignment
 insert into PLine values ('PL.003', '-102', '', 'PS.base.ta3');
+ERROR:  cannot update table "pslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "update PSlot set backlink = blname where slotname = myname"
+PL/pgSQL function tg_backlink_set(character,character) line 23 at SQL statement
+PL/pgSQL function tg_backlink_a() line 7 at assignment
 insert into PLine values ('PL.004', '-103', '', 'PS.base.ta5');
+ERROR:  cannot update table "pslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "update PSlot set backlink = blname where slotname = myname"
+PL/pgSQL function tg_backlink_set(character,character) line 23 at SQL statement
+PL/pgSQL function tg_backlink_a() line 7 at assignment
 insert into PLine values ('PL.005', '-104', '', 'PS.base.ta6');
+ERROR:  cannot update table "pslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "update PSlot set backlink = blname where slotname = myname"
+PL/pgSQL function tg_backlink_set(character,character) line 23 at SQL statement
+PL/pgSQL function tg_backlink_a() line 7 at assignment
 insert into PLine values ('PL.006', '-106', '', 'PS.base.tb2');
+ERROR:  cannot update table "pslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "update PSlot set backlink = blname where slotname = myname"
+PL/pgSQL function tg_backlink_set(character,character) line 23 at SQL statement
+PL/pgSQL function tg_backlink_a() line 7 at assignment
 insert into PLine values ('PL.007', '-108', '', 'PS.base.tb3');
+ERROR:  cannot update table "pslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "update PSlot set backlink = blname where slotname = myname"
+PL/pgSQL function tg_backlink_set(character,character) line 23 at SQL statement
+PL/pgSQL function tg_backlink_a() line 7 at assignment
 insert into PLine values ('PL.008', '-109', '', 'PS.base.tb4');
+ERROR:  cannot update table "pslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "update PSlot set backlink = blname where slotname = myname"
+PL/pgSQL function tg_backlink_set(character,character) line 23 at SQL statement
+PL/pgSQL function tg_backlink_a() line 7 at assignment
 insert into PLine values ('PL.009', '-121', '', 'PS.base.tb5');
+ERROR:  cannot update table "pslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "update PSlot set backlink = blname where slotname = myname"
+PL/pgSQL function tg_backlink_set(character,character) line 23 at SQL statement
+PL/pgSQL function tg_backlink_a() line 7 at assignment
 insert into PLine values ('PL.010', '-122', '', 'PS.base.tb6');
+ERROR:  cannot update table "pslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "update PSlot set backlink = blname where slotname = myname"
+PL/pgSQL function tg_backlink_set(character,character) line 23 at SQL statement
+PL/pgSQL function tg_backlink_a() line 7 at assignment
 insert into PLine values ('PL.015', '-134', '', 'PS.first.ta1');
+ERROR:  cannot update table "pslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "update PSlot set backlink = blname where slotname = myname"
+PL/pgSQL function tg_backlink_set(character,character) line 23 at SQL statement
+PL/pgSQL function tg_backlink_a() line 7 at assignment
 insert into PLine values ('PL.016', '-137', '', 'PS.first.ta3');
+ERROR:  cannot update table "pslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "update PSlot set backlink = blname where slotname = myname"
+PL/pgSQL function tg_backlink_set(character,character) line 23 at SQL statement
+PL/pgSQL function tg_backlink_a() line 7 at assignment
 insert into PLine values ('PL.017', '-139', '', 'PS.first.ta4');
+ERROR:  cannot update table "pslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "update PSlot set backlink = blname where slotname = myname"
+PL/pgSQL function tg_backlink_set(character,character) line 23 at SQL statement
+PL/pgSQL function tg_backlink_a() line 7 at assignment
 insert into PLine values ('PL.018', '-362', '', 'PS.first.tb1');
+ERROR:  cannot update table "pslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "update PSlot set backlink = blname where slotname = myname"
+PL/pgSQL function tg_backlink_set(character,character) line 23 at SQL statement
+PL/pgSQL function tg_backlink_a() line 7 at assignment
 insert into PLine values ('PL.019', '-363', '', 'PS.first.tb2');
+ERROR:  cannot update table "pslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "update PSlot set backlink = blname where slotname = myname"
+PL/pgSQL function tg_backlink_set(character,character) line 23 at SQL statement
+PL/pgSQL function tg_backlink_a() line 7 at assignment
 insert into PLine values ('PL.020', '-364', '', 'PS.first.tb3');
+ERROR:  cannot update table "pslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "update PSlot set backlink = blname where slotname = myname"
+PL/pgSQL function tg_backlink_set(character,character) line 23 at SQL statement
+PL/pgSQL function tg_backlink_a() line 7 at assignment
 insert into PLine values ('PL.021', '-365', '', 'PS.first.tb5');
+ERROR:  cannot update table "pslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "update PSlot set backlink = blname where slotname = myname"
+PL/pgSQL function tg_backlink_set(character,character) line 23 at SQL statement
+PL/pgSQL function tg_backlink_a() line 7 at assignment
 insert into PLine values ('PL.022', '-367', '', 'PS.first.tb6');
+ERROR:  cannot update table "pslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "update PSlot set backlink = blname where slotname = myname"
+PL/pgSQL function tg_backlink_set(character,character) line 23 at SQL statement
+PL/pgSQL function tg_backlink_a() line 7 at assignment
 insert into PLine values ('PL.028', '-501', 'Fax entrance', 'PS.base.ta2');
+ERROR:  cannot update table "pslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "update PSlot set backlink = blname where slotname = myname"
+PL/pgSQL function tg_backlink_set(character,character) line 23 at SQL statement
+PL/pgSQL function tg_backlink_a() line 7 at assignment
 insert into PLine values ('PL.029', '-502', 'Fax first floor', 'PS.first.ta1');
+ERROR:  cannot update table "pslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "update PSlot set backlink = blname where slotname = myname"
+PL/pgSQL function tg_backlink_set(character,character) line 23 at SQL statement
+PL/pgSQL function tg_backlink_a() line 7 at assignment
 --
 -- Buy some phones, plug them into the wall and patch the
 -- phone lines to the corresponding patchfield slots.
 --
 insert into PHone values ('PH.hc001', 'Hicom standard', 'WS.001.1a');
+ERROR:  cannot update table "wslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "update WSlot set slotlink = blname where slotname = myname"
+PL/pgSQL function tg_slotlink_set(character,character) line 43 at SQL statement
+PL/pgSQL function tg_slotlink_a() line 7 at assignment
 update PSlot set slotlink = 'PS.base.ta1' where slotname = 'PS.base.a1';
+ERROR:  cannot update table "pslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
 insert into PHone values ('PH.hc002', 'Hicom standard', 'WS.002.1a');
+ERROR:  cannot update table "wslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "update WSlot set slotlink = blname where slotname = myname"
+PL/pgSQL function tg_slotlink_set(character,character) line 43 at SQL statement
+PL/pgSQL function tg_slotlink_a() line 7 at assignment
 update PSlot set slotlink = 'PS.base.ta5' where slotname = 'PS.base.b1';
+ERROR:  cannot update table "pslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
 insert into PHone values ('PH.hc003', 'Hicom standard', 'WS.002.2a');
+ERROR:  cannot update table "wslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "update WSlot set slotlink = blname where slotname = myname"
+PL/pgSQL function tg_slotlink_set(character,character) line 43 at SQL statement
+PL/pgSQL function tg_slotlink_a() line 7 at assignment
 update PSlot set slotlink = 'PS.base.tb2' where slotname = 'PS.base.b3';
+ERROR:  cannot update table "pslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
 insert into PHone values ('PH.fax001', 'Canon fax', 'WS.001.2a');
+ERROR:  cannot update table "wslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "update WSlot set slotlink = blname where slotname = myname"
+PL/pgSQL function tg_slotlink_set(character,character) line 43 at SQL statement
+PL/pgSQL function tg_slotlink_a() line 7 at assignment
 update PSlot set slotlink = 'PS.base.ta2' where slotname = 'PS.base.a3';
+ERROR:  cannot update table "pslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
 --
 -- Install a hub at one of the patchfields, plug a computers
 -- ethernet interface into the wall and patch it to the hub.
@@ -1466,49 +1756,32 @@
 insert into Hub values ('base.hub1', 'Patchfield PF0_1 hub', 16);
 insert into System values ('orion', 'PC');
 insert into IFace values ('IF', 'orion', 'eth0', 'WS.002.1b');
+ERROR:  cannot update table "wslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "update WSlot set slotlink = blname where slotname = myname"
+PL/pgSQL function tg_slotlink_set(character,character) line 43 at SQL statement
+PL/pgSQL function tg_slotlink_a() line 7 at assignment
 update PSlot set slotlink = 'HS.base.hub1.1' where slotname = 'PS.base.b2';
+ERROR:  cannot update table "pslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
 --
 -- Now we take a look at the patchfield
 --
 select * from PField_v1 where pfname = 'PF0_1' order by slotname;
- pfname |       slotname       |                         backside                         |                     patch                     
---------+----------------------+----------------------------------------------------------+-----------------------------------------------
- PF0_1  | PS.base.a1           | WS.001.1a in room 001 -> Phone PH.hc001 (Hicom standard) | PS.base.ta1 -> Phone line -0 (Central call)
- PF0_1  | PS.base.a2           | WS.001.1b in room 001 -> -                               | -
- PF0_1  | PS.base.a3           | WS.001.2a in room 001 -> Phone PH.fax001 (Canon fax)     | PS.base.ta2 -> Phone line -501 (Fax entrance)
- PF0_1  | PS.base.a4           | WS.001.2b in room 001 -> -                               | -
- PF0_1  | PS.base.a5           | WS.001.3a in room 001 -> -                               | -
- PF0_1  | PS.base.a6           | WS.001.3b in room 001 -> -                               | -
- PF0_1  | PS.base.b1           | WS.002.1a in room 002 -> Phone PH.hc002 (Hicom standard) | PS.base.ta5 -> Phone line -103
- PF0_1  | PS.base.b2           | WS.002.1b in room 002 -> orion IF eth0 (PC)              | Patchfield PF0_1 hub slot 1
- PF0_1  | PS.base.b3           | WS.002.2a in room 002 -> Phone PH.hc003 (Hicom standard) | PS.base.tb2 -> Phone line -106
- PF0_1  | PS.base.b4           | WS.002.2b in room 002 -> -                               | -
- PF0_1  | PS.base.b5           | WS.002.3a in room 002 -> -                               | -
- PF0_1  | PS.base.b6           | WS.002.3b in room 002 -> -                               | -
- PF0_1  | PS.base.c1           | WS.003.1a in room 003 -> -                               | -
- PF0_1  | PS.base.c2           | WS.003.1b in room 003 -> -                               | -
- PF0_1  | PS.base.c3           | WS.003.2a in room 003 -> -                               | -
- PF0_1  | PS.base.c4           | WS.003.2b in room 003 -> -                               | -
- PF0_1  | PS.base.c5           | WS.003.3a in room 003 -> -                               | -
- PF0_1  | PS.base.c6           | WS.003.3b in room 003 -> -                               | -
-(18 rows)
+ pfname |       slotname       | backside | patch 
+--------+----------------------+----------+-------
+ PF0_1  | PS.base.a1           | -        | -
+ PF0_1  | PS.base.a2           | -        | -
+ PF0_1  | PS.base.a3           | -        | -
+ PF0_1  | PS.base.a4           | -        | -
+ PF0_1  | PS.base.a5           | -        | -
+ PF0_1  | PS.base.a6           | -        | -
+(6 rows)
 
 select * from PField_v1 where pfname = 'PF0_2' order by slotname;
- pfname |       slotname       |            backside            |                                 patch                                  
---------+----------------------+--------------------------------+------------------------------------------------------------------------
- PF0_2  | PS.base.ta1          | Phone line -0 (Central call)   | PS.base.a1 -> WS.001.1a in room 001 -> Phone PH.hc001 (Hicom standard)
- PF0_2  | PS.base.ta2          | Phone line -501 (Fax entrance) | PS.base.a3 -> WS.001.2a in room 001 -> Phone PH.fax001 (Canon fax)
- PF0_2  | PS.base.ta3          | Phone line -102                | -
- PF0_2  | PS.base.ta4          | -                              | -
- PF0_2  | PS.base.ta5          | Phone line -103                | PS.base.b1 -> WS.002.1a in room 002 -> Phone PH.hc002 (Hicom standard)
- PF0_2  | PS.base.ta6          | Phone line -104                | -
- PF0_2  | PS.base.tb1          | -                              | -
- PF0_2  | PS.base.tb2          | Phone line -106                | PS.base.b3 -> WS.002.2a in room 002 -> Phone PH.hc003 (Hicom standard)
- PF0_2  | PS.base.tb3          | Phone line -108                | -
- PF0_2  | PS.base.tb4          | Phone line -109                | -
- PF0_2  | PS.base.tb5          | Phone line -121                | -
- PF0_2  | PS.base.tb6          | Phone line -122                | -
-(12 rows)
+ pfname | slotname | backside | patch 
+--------+----------+----------+-------
+(0 rows)
 
 --
 -- Finally we want errors
@@ -1517,21 +1790,17 @@
 ERROR:  duplicate key value violates unique constraint "pfield_name"
 DETAIL:  Key (name)=(PF1_1) already exists.
 update PSlot set backlink = 'WS.not.there' where slotname = 'PS.base.a1';
-ERROR:  WS.not.there         does not exist
-CONTEXT:  PL/pgSQL function tg_backlink_set(character,character) line 30 at RAISE
-PL/pgSQL function tg_backlink_a() line 17 at assignment
+ERROR:  cannot update table "pslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
 update PSlot set backlink = 'XX.illegal' where slotname = 'PS.base.a1';
-ERROR:  illegal backlink beginning with XX
-CONTEXT:  PL/pgSQL function tg_backlink_set(character,character) line 47 at RAISE
-PL/pgSQL function tg_backlink_a() line 17 at assignment
+ERROR:  cannot update table "pslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
 update PSlot set slotlink = 'PS.not.there' where slotname = 'PS.base.a1';
-ERROR:  PS.not.there         does not exist
-CONTEXT:  PL/pgSQL function tg_slotlink_set(character,character) line 30 at RAISE
-PL/pgSQL function tg_slotlink_a() line 17 at assignment
+ERROR:  cannot update table "pslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
 update PSlot set slotlink = 'XX.illegal' where slotname = 'PS.base.a1';
-ERROR:  illegal slotlink beginning with XX
-CONTEXT:  PL/pgSQL function tg_slotlink_set(character,character) line 77 at RAISE
-PL/pgSQL function tg_slotlink_a() line 17 at assignment
+ERROR:  cannot update table "pslot" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
 insert into HSlot values ('HS', 'base.hub1', 1, '');
 ERROR:  duplicate key value violates unique constraint "hslot_name"
 DETAIL:  Key (slotname)=(HS.base.hub1.1      ) already exists.
@@ -1610,21 +1879,14 @@
   return true;
   end;' language plpgsql;
 select test_found();
- test_found 
-------------
- t
-(1 row)
-
+ERROR:  cannot update table "found_test_tbl" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "update found_test_tbl set a = 100 where a = 1"
+PL/pgSQL function test_found() line 9 at SQL statement
 select * from found_test_tbl;
-  a  
------
-   2
- 100
-   3
-   4
-   5
-   6
-(6 rows)
+ a 
+---
+(0 rows)
 
 --
 -- Test set-returning functions for PL/pgSQL
@@ -1639,15 +1901,9 @@
 	RETURN;
 END;' language plpgsql;
 select * from test_table_func_rec();
-  a  
------
-   2
- 100
-   3
-   4
-   5
-   6
-(6 rows)
+ a 
+---
+(0 rows)
 
 create function test_table_func_row() returns setof found_test_tbl as '
 DECLARE
@@ -1659,15 +1915,9 @@
 	RETURN;
 END;' language plpgsql;
 select * from test_table_func_row();
-  a  
------
-   2
- 100
-   3
-   4
-   5
-   6
-(6 rows)
+ a 
+---
+(0 rows)
 
 create function test_ret_set_scalar(int,int) returns setof int as '
 DECLARE
@@ -5666,8 +5916,8 @@
   REFERENCING NEW TABLE AS new_test OLD TABLE as old_test
   FOR EACH STATEMENT EXECUTE PROCEDURE multi_test_trig();
 UPDATE multi_test SET i = i;
-NOTICE:  count = 1
-NOTICE:  count union = 2
+ERROR:  cannot update table "multi_test" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
 DROP TABLE multi_test;
 DROP FUNCTION multi_test_trig();
 --
diff -U3 /Users/kenaniah/workspace/postgres/src/test/regress/expected/copy2.out /Users/kenaniah/workspace/postgres/src/test/regress/results/copy2.out
--- /Users/kenaniah/workspace/postgres/src/test/regress/expected/copy2.out	2021-10-03 18:09:17.000000000 -0700
+++ /Users/kenaniah/workspace/postgres/src/test/regress/results/copy2.out	2021-10-03 20:08:23.000000000 -0700
@@ -513,153 +513,11 @@
 end $$ language plpgsql immutable;
 alter table check_con_tbl add check (check_con_function(check_con_tbl.*));
 \d+ check_con_tbl
-                               Table "public.check_con_tbl"
- Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
---------+---------+-----------+----------+---------+---------+--------------+-------------
- f1     | integer |           |          |         | plain   |              | 
-Check constraints:
-    "check_con_tbl_check" CHECK (check_con_function(check_con_tbl.*))
+dyld: lazy symbol binding failed: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
 
-copy check_con_tbl from stdin;
-NOTICE:  input = {"f1":1}
-NOTICE:  input = {"f1":null}
-copy check_con_tbl from stdin;
-NOTICE:  input = {"f1":0}
-ERROR:  new row for relation "check_con_tbl" violates check constraint "check_con_tbl_check"
-DETAIL:  Failing row contains (0).
-CONTEXT:  COPY check_con_tbl, line 1: "0"
-select * from check_con_tbl;
- f1 
-----
-  1
-   
-(2 rows)
+dyld: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
 
--- test with RLS enabled.
-CREATE ROLE regress_rls_copy_user;
-CREATE ROLE regress_rls_copy_user_colperms;
-CREATE TABLE rls_t1 (a int, b int, c int);
-COPY rls_t1 (a, b, c) from stdin;
-CREATE POLICY p1 ON rls_t1 FOR SELECT USING (a % 2 = 0);
-ALTER TABLE rls_t1 ENABLE ROW LEVEL SECURITY;
-ALTER TABLE rls_t1 FORCE ROW LEVEL SECURITY;
-GRANT SELECT ON TABLE rls_t1 TO regress_rls_copy_user;
-GRANT SELECT (a, b) ON TABLE rls_t1 TO regress_rls_copy_user_colperms;
--- all columns
-COPY rls_t1 TO stdout;
-1	4	1
-2	3	2
-3	2	3
-4	1	4
-COPY rls_t1 (a, b, c) TO stdout;
-1	4	1
-2	3	2
-3	2	3
-4	1	4
--- subset of columns
-COPY rls_t1 (a) TO stdout;
-1
-2
-3
-4
-COPY rls_t1 (a, b) TO stdout;
-1	4
-2	3
-3	2
-4	1
--- column reordering
-COPY rls_t1 (b, a) TO stdout;
-4	1
-3	2
-2	3
-1	4
-SET SESSION AUTHORIZATION regress_rls_copy_user;
--- all columns
-COPY rls_t1 TO stdout;
-2	3	2
-4	1	4
-COPY rls_t1 (a, b, c) TO stdout;
-2	3	2
-4	1	4
--- subset of columns
-COPY rls_t1 (a) TO stdout;
-2
-4
-COPY rls_t1 (a, b) TO stdout;
-2	3
-4	1
--- column reordering
-COPY rls_t1 (b, a) TO stdout;
-3	2
-1	4
-RESET SESSION AUTHORIZATION;
-SET SESSION AUTHORIZATION regress_rls_copy_user_colperms;
--- attempt all columns (should fail)
-COPY rls_t1 TO stdout;
-ERROR:  permission denied for table rls_t1
-COPY rls_t1 (a, b, c) TO stdout;
-ERROR:  permission denied for table rls_t1
--- try to copy column with no privileges (should fail)
-COPY rls_t1 (c) TO stdout;
-ERROR:  permission denied for table rls_t1
--- subset of columns (should succeed)
-COPY rls_t1 (a) TO stdout;
-2
-4
-COPY rls_t1 (a, b) TO stdout;
-2	3
-4	1
-RESET SESSION AUTHORIZATION;
--- test with INSTEAD OF INSERT trigger on a view
-CREATE TABLE instead_of_insert_tbl(id serial, name text);
-CREATE VIEW instead_of_insert_tbl_view AS SELECT ''::text AS str;
-COPY instead_of_insert_tbl_view FROM stdin; -- fail
-ERROR:  cannot copy to view "instead_of_insert_tbl_view"
-HINT:  To enable copying to a view, provide an INSTEAD OF INSERT trigger.
-CREATE FUNCTION fun_instead_of_insert_tbl() RETURNS trigger AS $$
-BEGIN
-  INSERT INTO instead_of_insert_tbl (name) VALUES (NEW.str);
-  RETURN NULL;
-END;
-$$ LANGUAGE plpgsql;
-CREATE TRIGGER trig_instead_of_insert_tbl_view
-  INSTEAD OF INSERT ON instead_of_insert_tbl_view
-  FOR EACH ROW EXECUTE PROCEDURE fun_instead_of_insert_tbl();
-COPY instead_of_insert_tbl_view FROM stdin;
-SELECT * FROM instead_of_insert_tbl;
- id | name  
-----+-------
-  1 | test1
-(1 row)
-
--- Test of COPY optimization with view using INSTEAD OF INSERT
--- trigger when relation is created in the same transaction as
--- when COPY is executed.
-BEGIN;
-CREATE VIEW instead_of_insert_tbl_view_2 as select ''::text as str;
-CREATE TRIGGER trig_instead_of_insert_tbl_view_2
-  INSTEAD OF INSERT ON instead_of_insert_tbl_view_2
-  FOR EACH ROW EXECUTE PROCEDURE fun_instead_of_insert_tbl();
-COPY instead_of_insert_tbl_view_2 FROM stdin;
-SELECT * FROM instead_of_insert_tbl;
- id | name  
-----+-------
-  1 | test1
-  2 | test1
-(2 rows)
-
-COMMIT;
--- clean up
-DROP TABLE forcetest;
-DROP TABLE vistest;
-DROP FUNCTION truncate_in_subxact();
-DROP TABLE x, y;
-DROP TABLE rls_t1 CASCADE;
-DROP ROLE regress_rls_copy_user;
-DROP ROLE regress_rls_copy_user_colperms;
-DROP FUNCTION fn_x_before();
-DROP FUNCTION fn_x_after();
-DROP TABLE instead_of_insert_tbl;
-DROP VIEW instead_of_insert_tbl_view;
-DROP VIEW instead_of_insert_tbl_view_2;
-DROP FUNCTION fun_instead_of_insert_tbl();
diff -U3 /Users/kenaniah/workspace/postgres/src/test/regress/expected/temp.out /Users/kenaniah/workspace/postgres/src/test/regress/results/temp.out
--- /Users/kenaniah/workspace/postgres/src/test/regress/expected/temp.out	2021-10-03 17:41:49.000000000 -0700
+++ /Users/kenaniah/workspace/postgres/src/test/regress/results/temp.out	2021-10-03 20:08:23.000000000 -0700
@@ -380,13 +380,11 @@
 -- creation is pending, so check after that.  First reset the connection
 -- to remove the temporary namespace.
 \c -
-SET search_path TO 'pg_temp';
-BEGIN;
-SELECT current_schema() ~ 'pg_temp' AS is_temp_schema;
- is_temp_schema 
-----------------
- t
-(1 row)
+dyld: lazy symbol binding failed: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
+
+dyld: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
 
-PREPARE TRANSACTION 'twophase_search';
-ERROR:  cannot PREPARE a transaction that has operated on temporary objects
diff -U3 /Users/kenaniah/workspace/postgres/src/test/regress/expected/domain.out /Users/kenaniah/workspace/postgres/src/test/regress/results/domain.out
--- /Users/kenaniah/workspace/postgres/src/test/regress/expected/domain.out	2021-10-03 17:41:49.000000000 -0700
+++ /Users/kenaniah/workspace/postgres/src/test/regress/results/domain.out	2021-10-03 20:08:23.000000000 -0700
@@ -156,11 +156,13 @@
   testint4arr[1] = testint4arr[1] + 1,
   testint4arr[3] = testint4arr[3] - 1
 where testchar4arr is null;
+ERROR:  cannot update table "domarrtest" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
 select * from domarrtest where testchar4arr is null;
-   testint4arr    | testchar4arr 
-------------------+--------------
- {12,NULL,21}     | 
- {NULL,NULL,NULL} | 
+ testint4arr  | testchar4arr 
+--------------+--------------
+ {11,NULL,22} | 
+              | 
 (2 rows)
 
 drop table domarrtest;
@@ -219,12 +221,14 @@
 (3 rows)
 
 update dcomptable set d1.r = (d1).r + 1 where (d1).i > 0;
+ERROR:  cannot update table "dcomptable" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
 select * from dcomptable;
   d1   
 -------
+ (1,2)
+ (3,4)
  (11,)
- (2,2)
- (4,4)
 (3 rows)
 
 alter domain dcomptype add constraint c1 check ((value).r <= (value).i);
@@ -233,6 +237,8 @@
 select row(2,1)::dcomptype;  -- fail
 ERROR:  value for domain dcomptype violates check constraint "c1"
 insert into dcomptable values (row(1,2)::comptype);
+ERROR:  duplicate key value violates unique constraint "dcomptable_d1_key"
+DETAIL:  Key (d1)=((1,2)) already exists.
 insert into dcomptable values (row(2,1)::comptype);  -- fail
 ERROR:  value for domain dcomptype violates check constraint "c1"
 insert into dcomptable (d1.r) values(99);
@@ -240,864 +246,33 @@
 insert into dcomptable (d1.r, d1.i) values(100, 99);  -- fail
 ERROR:  value for domain dcomptype violates check constraint "c1"
 update dcomptable set d1.r = (d1).r + 1 where (d1).i > 0;  -- fail
-ERROR:  value for domain dcomptype violates check constraint "c1"
+ERROR:  cannot update table "dcomptable" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
 update dcomptable set d1.r = (d1).r - 1, d1.i = (d1).i + 1 where (d1).i > 0;
+ERROR:  cannot update table "dcomptable" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
 select * from dcomptable;
     d1    
 ----------
+ (1,2)
+ (3,4)
  (11,)
  (99,)
- (1,3)
- (3,5)
- (0,3)
- (98,101)
-(6 rows)
+ (99,100)
+(5 rows)
 
 explain (verbose, costs off)
   update dcomptable set d1.r = (d1).r - 1, d1.i = (d1).i + 1 where (d1).i > 0;
-                                          QUERY PLAN                                           
------------------------------------------------------------------------------------------------
- Update on public.dcomptable
-   ->  Seq Scan on public.dcomptable
-         Output: ROW(((d1).r - '1'::double precision), ((d1).i + '1'::double precision)), ctid
-         Filter: ((dcomptable.d1).i > '0'::double precision)
-(4 rows)
-
+ERROR:  cannot update table "dcomptable" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
 create rule silly as on delete to dcomptable do instead
   update dcomptable set d1.r = (d1).r - 1, d1.i = (d1).i + 1 where (d1).i > 0;
 \d+ dcomptable
-                                  Table "public.dcomptable"
- Column |   Type    | Collation | Nullable | Default | Storage  | Stats target | Description 
---------+-----------+-----------+----------+---------+----------+--------------+-------------
- d1     | dcomptype |           |          |         | extended |              | 
-Indexes:
-    "dcomptable_d1_key" UNIQUE CONSTRAINT, btree (d1)
-Rules:
-    silly AS
-    ON DELETE TO dcomptable DO INSTEAD  UPDATE dcomptable SET d1.r = (dcomptable.d1).r - 1::double precision, d1.i = (dcomptable.d1).i + 1::double precision
-  WHERE (dcomptable.d1).i > 0::double precision
-
-drop table dcomptable;
-drop type comptype cascade;
-NOTICE:  drop cascades to type dcomptype
--- check altering and dropping columns used by domain constraints
-create type comptype as (r float8, i float8);
-create domain dcomptype as comptype;
-alter domain dcomptype add constraint c1 check ((value).r > 0);
-comment on constraint c1 on domain dcomptype is 'random commentary';
-select row(0,1)::dcomptype;  -- fail
-ERROR:  value for domain dcomptype violates check constraint "c1"
-alter type comptype alter attribute r type varchar;  -- fail
-ERROR:  operator does not exist: character varying > double precision
-HINT:  No operator matches the given name and argument types. You might need to add explicit type casts.
-alter type comptype alter attribute r type bigint;
-alter type comptype drop attribute r;  -- fail
-ERROR:  cannot drop column r of composite type comptype because other objects depend on it
-DETAIL:  constraint c1 depends on column r of composite type comptype
-HINT:  Use DROP ... CASCADE to drop the dependent objects too.
-alter type comptype drop attribute i;
-select conname, obj_description(oid, 'pg_constraint') from pg_constraint
-  where contypid = 'dcomptype'::regtype;  -- check comment is still there
- conname |  obj_description  
----------+-------------------
- c1      | random commentary
-(1 row)
-
-drop type comptype cascade;
-NOTICE:  drop cascades to type dcomptype
--- Test domains over arrays of composite
-create type comptype as (r float8, i float8);
-create domain dcomptypea as comptype[];
-create table dcomptable (d1 dcomptypea unique);
-insert into dcomptable values (array[row(1,2)]::dcomptypea);
-insert into dcomptable values (array[row(3,4), row(5,6)]::comptype[]);
-insert into dcomptable values (array[row(7,8)::comptype, row(9,10)::comptype]);
-insert into dcomptable values (array[row(1,2)]::dcomptypea);  -- fail on uniqueness
-ERROR:  duplicate key value violates unique constraint "dcomptable_d1_key"
-DETAIL:  Key (d1)=({"(1,2)"}) already exists.
-insert into dcomptable (d1[1]) values(row(9,10));
-insert into dcomptable (d1[1].r) values(11);
-select * from dcomptable;
-         d1         
---------------------
- {"(1,2)"}
- {"(3,4)","(5,6)"}
- {"(7,8)","(9,10)"}
- {"(9,10)"}
- {"(11,)"}
-(5 rows)
-
-select d1[2], d1[1].r, d1[1].i from dcomptable;
-   d1   | r  | i  
---------+----+----
-        |  1 |  2
- (5,6)  |  3 |  4
- (9,10) |  7 |  8
-        |  9 | 10
-        | 11 |   
-(5 rows)
-
-update dcomptable set d1[2] = row(d1[2].i, d1[2].r);
-select * from dcomptable;
-         d1         
---------------------
- {"(1,2)","(,)"}
- {"(3,4)","(6,5)"}
- {"(7,8)","(10,9)"}
- {"(9,10)","(,)"}
- {"(11,)","(,)"}
-(5 rows)
-
-update dcomptable set d1[1].r = d1[1].r + 1 where d1[1].i > 0;
-select * from dcomptable;
-         d1         
---------------------
- {"(11,)","(,)"}
- {"(2,2)","(,)"}
- {"(4,4)","(6,5)"}
- {"(8,8)","(10,9)"}
- {"(10,10)","(,)"}
-(5 rows)
-
-alter domain dcomptypea add constraint c1 check (value[1].r <= value[1].i);
-alter domain dcomptypea add constraint c2 check (value[1].r > value[1].i);  -- fail
-ERROR:  column "d1" of table "dcomptable" contains values that violate the new constraint
-select array[row(2,1)]::dcomptypea;  -- fail
-ERROR:  value for domain dcomptypea violates check constraint "c1"
-insert into dcomptable values (array[row(1,2)]::comptype[]);
-insert into dcomptable values (array[row(2,1)]::comptype[]);  -- fail
-ERROR:  value for domain dcomptypea violates check constraint "c1"
-insert into dcomptable (d1[1].r) values(99);
-insert into dcomptable (d1[1].r, d1[1].i) values(99, 100);
-insert into dcomptable (d1[1].r, d1[1].i) values(100, 99);  -- fail
-ERROR:  value for domain dcomptypea violates check constraint "c1"
-update dcomptable set d1[1].r = d1[1].r + 1 where d1[1].i > 0;  -- fail
-ERROR:  value for domain dcomptypea violates check constraint "c1"
-update dcomptable set d1[1].r = d1[1].r - 1, d1[1].i = d1[1].i + 1
-  where d1[1].i > 0;
-select * from dcomptable;
-         d1         
---------------------
- {"(11,)","(,)"}
- {"(99,)"}
- {"(1,3)","(,)"}
- {"(3,5)","(6,5)"}
- {"(7,9)","(10,9)"}
- {"(9,11)","(,)"}
- {"(0,3)"}
- {"(98,101)"}
-(8 rows)
-
-explain (verbose, costs off)
-  update dcomptable set d1[1].r = d1[1].r - 1, d1[1].i = d1[1].i + 1
-    where d1[1].i > 0;
-                                                   QUERY PLAN                                                   
-----------------------------------------------------------------------------------------------------------------
- Update on public.dcomptable
-   ->  Seq Scan on public.dcomptable
-         Output: (d1[1].r := (d1[1].r - '1'::double precision))[1].i := (d1[1].i + '1'::double precision), ctid
-         Filter: (dcomptable.d1[1].i > '0'::double precision)
-(4 rows)
-
-create rule silly as on delete to dcomptable do instead
-  update dcomptable set d1[1].r = d1[1].r - 1, d1[1].i = d1[1].i + 1
-    where d1[1].i > 0;
-\d+ dcomptable
-                                  Table "public.dcomptable"
- Column |    Type    | Collation | Nullable | Default | Storage  | Stats target | Description 
---------+------------+-----------+----------+---------+----------+--------------+-------------
- d1     | dcomptypea |           |          |         | extended |              | 
-Indexes:
-    "dcomptable_d1_key" UNIQUE CONSTRAINT, btree (d1)
-Rules:
-    silly AS
-    ON DELETE TO dcomptable DO INSTEAD  UPDATE dcomptable SET d1[1].r = dcomptable.d1[1].r - 1::double precision, d1[1].i = dcomptable.d1[1].i + 1::double precision
-  WHERE dcomptable.d1[1].i > 0::double precision
-
-drop table dcomptable;
-drop type comptype cascade;
-NOTICE:  drop cascades to type dcomptypea
--- Test arrays over domains
-create domain posint as int check (value > 0);
-create table pitable (f1 posint[]);
-insert into pitable values(array[42]);
-insert into pitable values(array[-1]);  -- fail
-ERROR:  value for domain posint violates check constraint "posint_check"
-insert into pitable values('{0}');  -- fail
-ERROR:  value for domain posint violates check constraint "posint_check"
-LINE 1: insert into pitable values('{0}');
-                                   ^
-update pitable set f1[1] = f1[1] + 1;
-update pitable set f1[1] = 0;  -- fail
-ERROR:  value for domain posint violates check constraint "posint_check"
-select * from pitable;
-  f1  
-------
- {43}
-(1 row)
-
-drop table pitable;
-create domain vc4 as varchar(4);
-create table vc4table (f1 vc4[]);
-insert into vc4table values(array['too long']);  -- fail
-ERROR:  value too long for type character varying(4)
-insert into vc4table values(array['too long']::vc4[]);  -- cast truncates
-select * from vc4table;
-    f1    
-----------
- {"too "}
-(1 row)
-
-drop table vc4table;
-drop type vc4;
--- You can sort of fake arrays-of-arrays by putting a domain in between
-create domain dposinta as posint[];
-create table dposintatable (f1 dposinta[]);
-insert into dposintatable values(array[array[42]]);  -- fail
-ERROR:  column "f1" is of type dposinta[] but expression is of type integer[]
-LINE 1: insert into dposintatable values(array[array[42]]);
-                                         ^
-HINT:  You will need to rewrite or cast the expression.
-insert into dposintatable values(array[array[42]::posint[]]); -- still fail
-ERROR:  column "f1" is of type dposinta[] but expression is of type posint[]
-LINE 1: insert into dposintatable values(array[array[42]::posint[]])...
-                                         ^
-HINT:  You will need to rewrite or cast the expression.
-insert into dposintatable values(array[array[42]::dposinta]); -- but this works
-select f1, f1[1], (f1[1])[1] from dposintatable;
-    f1    |  f1  | f1 
-----------+------+----
- {"{42}"} | {42} | 42
-(1 row)
-
-select pg_typeof(f1) from dposintatable;
- pg_typeof  
-------------
- dposinta[]
-(1 row)
-
-select pg_typeof(f1[1]) from dposintatable;
- pg_typeof 
------------
- dposinta
-(1 row)
-
-select pg_typeof(f1[1][1]) from dposintatable;
- pg_typeof 
------------
- dposinta
-(1 row)
-
-select pg_typeof((f1[1])[1]) from dposintatable;
- pg_typeof 
------------
- posint
-(1 row)
-
-update dposintatable set f1[2] = array[99];
-select f1, f1[1], (f1[2])[1] from dposintatable;
-       f1        |  f1  | f1 
------------------+------+----
- {"{42}","{99}"} | {42} | 99
-(1 row)
-
--- it'd be nice if you could do something like this, but for now you can't:
-update dposintatable set f1[2][1] = array[97];
-ERROR:  wrong number of array subscripts
--- maybe someday we can make this syntax work:
-update dposintatable set (f1[2])[1] = array[98];
-ERROR:  syntax error at or near "["
-LINE 1: update dposintatable set (f1[2])[1] = array[98];
-                                        ^
-drop table dposintatable;
-drop domain posint cascade;
-NOTICE:  drop cascades to type dposinta
--- Test not-null restrictions
-create domain dnotnull varchar(15) NOT NULL;
-create domain dnull    varchar(15);
-create domain dcheck   varchar(15) NOT NULL CHECK (VALUE = 'a' OR VALUE = 'c' OR VALUE = 'd');
-create table nulltest
-           ( col1 dnotnull
-           , col2 dnotnull NULL  -- NOT NULL in the domain cannot be overridden
-           , col3 dnull    NOT NULL
-           , col4 dnull
-           , col5 dcheck CHECK (col5 IN ('c', 'd'))
-           );
-INSERT INTO nulltest DEFAULT VALUES;
-ERROR:  domain dnotnull does not allow null values
-INSERT INTO nulltest values ('a', 'b', 'c', 'd', 'c');  -- Good
-insert into nulltest values ('a', 'b', 'c', 'd', NULL);
-ERROR:  domain dcheck does not allow null values
-insert into nulltest values ('a', 'b', 'c', 'd', 'a');
-ERROR:  new row for relation "nulltest" violates check constraint "nulltest_col5_check"
-DETAIL:  Failing row contains (a, b, c, d, a).
-INSERT INTO nulltest values (NULL, 'b', 'c', 'd', 'd');
-ERROR:  domain dnotnull does not allow null values
-INSERT INTO nulltest values ('a', NULL, 'c', 'd', 'c');
-ERROR:  domain dnotnull does not allow null values
-INSERT INTO nulltest values ('a', 'b', NULL, 'd', 'c');
-ERROR:  null value in column "col3" of relation "nulltest" violates not-null constraint
-DETAIL:  Failing row contains (a, b, null, d, c).
-INSERT INTO nulltest values ('a', 'b', 'c', NULL, 'd'); -- Good
--- Test copy
-COPY nulltest FROM stdin; --fail
-ERROR:  null value in column "col3" of relation "nulltest" violates not-null constraint
-DETAIL:  Failing row contains (a, b, null, d, d).
-CONTEXT:  COPY nulltest, line 1: "a	b	\N	d	d"
-COPY nulltest FROM stdin; --fail
-ERROR:  domain dcheck does not allow null values
-CONTEXT:  COPY nulltest, line 1, column col5: null input
--- Last row is bad
-COPY nulltest FROM stdin;
-ERROR:  new row for relation "nulltest" violates check constraint "nulltest_col5_check"
-DETAIL:  Failing row contains (a, b, c, null, a).
-CONTEXT:  COPY nulltest, line 3: "a	b	c	\N	a"
-select * from nulltest;
- col1 | col2 | col3 | col4 | col5 
-------+------+------+------+------
- a    | b    | c    | d    | c
- a    | b    | c    |      | d
-(2 rows)
-
--- Test out coerced (casted) constraints
-SELECT cast('1' as dnotnull);
- dnotnull 
-----------
- 1
-(1 row)
-
-SELECT cast(NULL as dnotnull); -- fail
-ERROR:  domain dnotnull does not allow null values
-SELECT cast(cast(NULL as dnull) as dnotnull); -- fail
-ERROR:  domain dnotnull does not allow null values
-SELECT cast(col4 as dnotnull) from nulltest; -- fail
-ERROR:  domain dnotnull does not allow null values
--- cleanup
-drop table nulltest;
-drop domain dnotnull restrict;
-drop domain dnull restrict;
-drop domain dcheck restrict;
-create domain ddef1 int4 DEFAULT 3;
-create domain ddef2 oid DEFAULT '12';
--- Type mixing, function returns int8
-create domain ddef3 text DEFAULT 5;
-create sequence ddef4_seq;
-create domain ddef4 int4 DEFAULT nextval('ddef4_seq');
-create domain ddef5 numeric(8,2) NOT NULL DEFAULT '12.12';
-create table defaulttest
-            ( col1 ddef1
-            , col2 ddef2
-            , col3 ddef3
-            , col4 ddef4 PRIMARY KEY
-            , col5 ddef1 NOT NULL DEFAULT NULL
-            , col6 ddef2 DEFAULT '88'
-            , col7 ddef4 DEFAULT 8000
-            , col8 ddef5
-            );
-insert into defaulttest(col4) values(0); -- fails, col5 defaults to null
-ERROR:  null value in column "col5" of relation "defaulttest" violates not-null constraint
-DETAIL:  Failing row contains (3, 12, 5, 0, null, 88, 8000, 12.12).
-alter table defaulttest alter column col5 drop default;
-insert into defaulttest default values; -- succeeds, inserts domain default
--- We used to treat SET DEFAULT NULL as equivalent to DROP DEFAULT; wrong
-alter table defaulttest alter column col5 set default null;
-insert into defaulttest(col4) values(0); -- fails
-ERROR:  null value in column "col5" of relation "defaulttest" violates not-null constraint
-DETAIL:  Failing row contains (3, 12, 5, 0, null, 88, 8000, 12.12).
-alter table defaulttest alter column col5 drop default;
-insert into defaulttest default values;
-insert into defaulttest default values;
--- Test defaults with copy
-COPY defaulttest(col5) FROM stdin;
-select * from defaulttest;
- col1 | col2 | col3 | col4 | col5 | col6 | col7 | col8  
-------+------+------+------+------+------+------+-------
-    3 |   12 | 5    |    1 |    3 |   88 | 8000 | 12.12
-    3 |   12 | 5    |    2 |    3 |   88 | 8000 | 12.12
-    3 |   12 | 5    |    3 |    3 |   88 | 8000 | 12.12
-    3 |   12 | 5    |    4 |   42 |   88 | 8000 | 12.12
-(4 rows)
-
-drop table defaulttest cascade;
--- Test ALTER DOMAIN .. NOT NULL
-create domain dnotnulltest integer;
-create table domnotnull
-( col1 dnotnulltest
-, col2 dnotnulltest
-);
-insert into domnotnull default values;
-alter domain dnotnulltest set not null; -- fails
-ERROR:  column "col1" of table "domnotnull" contains null values
-update domnotnull set col1 = 5;
-alter domain dnotnulltest set not null; -- fails
-ERROR:  column "col2" of table "domnotnull" contains null values
-update domnotnull set col2 = 6;
-alter domain dnotnulltest set not null;
-update domnotnull set col1 = null; -- fails
-ERROR:  domain dnotnulltest does not allow null values
-alter domain dnotnulltest drop not null;
-update domnotnull set col1 = null;
-drop domain dnotnulltest cascade;
-NOTICE:  drop cascades to 2 other objects
-DETAIL:  drop cascades to column col2 of table domnotnull
-drop cascades to column col1 of table domnotnull
--- Test ALTER DOMAIN .. DEFAULT ..
-create table domdeftest (col1 ddef1);
-insert into domdeftest default values;
-select * from domdeftest;
- col1 
-------
-    3
-(1 row)
-
-alter domain ddef1 set default '42';
-insert into domdeftest default values;
-select * from domdeftest;
- col1 
-------
-    3
-   42
-(2 rows)
-
-alter domain ddef1 drop default;
-insert into domdeftest default values;
-select * from domdeftest;
- col1 
-------
-    3
-   42
-     
-(3 rows)
-
-drop table domdeftest;
--- Test ALTER DOMAIN .. CONSTRAINT ..
-create domain con as integer;
-create table domcontest (col1 con);
-insert into domcontest values (1);
-insert into domcontest values (2);
-alter domain con add constraint t check (VALUE < 1); -- fails
-ERROR:  column "col1" of table "domcontest" contains values that violate the new constraint
-alter domain con add constraint t check (VALUE < 34);
-alter domain con add check (VALUE > 0);
-insert into domcontest values (-5); -- fails
-ERROR:  value for domain con violates check constraint "con_check"
-insert into domcontest values (42); -- fails
-ERROR:  value for domain con violates check constraint "t"
-insert into domcontest values (5);
-alter domain con drop constraint t;
-insert into domcontest values (-5); --fails
-ERROR:  value for domain con violates check constraint "con_check"
-insert into domcontest values (42);
-alter domain con drop constraint nonexistent;
-ERROR:  constraint "nonexistent" of domain "con" does not exist
-alter domain con drop constraint if exists nonexistent;
-NOTICE:  constraint "nonexistent" of domain "con" does not exist, skipping
--- Test ALTER DOMAIN .. CONSTRAINT .. NOT VALID
-create domain things AS INT;
-CREATE TABLE thethings (stuff things);
-INSERT INTO thethings (stuff) VALUES (55);
-ALTER DOMAIN things ADD CONSTRAINT meow CHECK (VALUE < 11);
-ERROR:  column "stuff" of table "thethings" contains values that violate the new constraint
-ALTER DOMAIN things ADD CONSTRAINT meow CHECK (VALUE < 11) NOT VALID;
-ALTER DOMAIN things VALIDATE CONSTRAINT meow;
-ERROR:  column "stuff" of table "thethings" contains values that violate the new constraint
-UPDATE thethings SET stuff = 10;
-ALTER DOMAIN things VALIDATE CONSTRAINT meow;
--- Confirm ALTER DOMAIN with RULES.
-create table domtab (col1 integer);
-create domain dom as integer;
-create view domview as select cast(col1 as dom) from domtab;
-insert into domtab (col1) values (null);
-insert into domtab (col1) values (5);
-select * from domview;
- col1 
-------
-     
-    5
-(2 rows)
-
-alter domain dom set not null;
-select * from domview; -- fail
-ERROR:  domain dom does not allow null values
-alter domain dom drop not null;
-select * from domview;
- col1 
-------
-     
-    5
-(2 rows)
-
-alter domain dom add constraint domchkgt6 check(value > 6);
-select * from domview; --fail
-ERROR:  value for domain dom violates check constraint "domchkgt6"
-alter domain dom drop constraint domchkgt6 restrict;
-select * from domview;
- col1 
-------
-     
-    5
-(2 rows)
-
--- cleanup
-drop domain ddef1 restrict;
-drop domain ddef2 restrict;
-drop domain ddef3 restrict;
-drop domain ddef4 restrict;
-drop domain ddef5 restrict;
-drop sequence ddef4_seq;
--- Test domains over domains
-create domain vchar4 varchar(4);
-create domain dinter vchar4 check (substring(VALUE, 1, 1) = 'x');
-create domain dtop dinter check (substring(VALUE, 2, 1) = '1');
-select 'x123'::dtop;
- dtop 
-------
- x123
-(1 row)
-
-select 'x1234'::dtop; -- explicit coercion should truncate
- dtop 
-------
- x123
-(1 row)
-
-select 'y1234'::dtop; -- fail
-ERROR:  value for domain dtop violates check constraint "dinter_check"
-select 'y123'::dtop; -- fail
-ERROR:  value for domain dtop violates check constraint "dinter_check"
-select 'yz23'::dtop; -- fail
-ERROR:  value for domain dtop violates check constraint "dinter_check"
-select 'xz23'::dtop; -- fail
-ERROR:  value for domain dtop violates check constraint "dtop_check"
-create temp table dtest(f1 dtop);
-insert into dtest values('x123');
-insert into dtest values('x1234'); -- fail, implicit coercion
-ERROR:  value too long for type character varying(4)
-insert into dtest values('y1234'); -- fail, implicit coercion
-ERROR:  value too long for type character varying(4)
-insert into dtest values('y123'); -- fail
-ERROR:  value for domain dtop violates check constraint "dinter_check"
-insert into dtest values('yz23'); -- fail
-ERROR:  value for domain dtop violates check constraint "dinter_check"
-insert into dtest values('xz23'); -- fail
-ERROR:  value for domain dtop violates check constraint "dtop_check"
-drop table dtest;
-drop domain vchar4 cascade;
-NOTICE:  drop cascades to 2 other objects
-DETAIL:  drop cascades to type dinter
-drop cascades to type dtop
--- Make sure that constraints of newly-added domain columns are
--- enforced correctly, even if there's no default value for the new
--- column. Per bug #1433
-create domain str_domain as text not null;
-create table domain_test (a int, b int);
-insert into domain_test values (1, 2);
-insert into domain_test values (1, 2);
--- should fail
-alter table domain_test add column c str_domain;
-ERROR:  domain str_domain does not allow null values
-create domain str_domain2 as text check (value <> 'foo') default 'foo';
--- should fail
-alter table domain_test add column d str_domain2;
-ERROR:  value for domain str_domain2 violates check constraint "str_domain2_check"
--- Check that domain constraints on prepared statement parameters of
--- unknown type are enforced correctly.
-create domain pos_int as int4 check (value > 0) not null;
-prepare s1 as select $1::pos_int = 10 as "is_ten";
-execute s1(10);
- is_ten 
---------
- t
-(1 row)
-
-execute s1(0); -- should fail
-ERROR:  value for domain pos_int violates check constraint "pos_int_check"
-execute s1(NULL); -- should fail
-ERROR:  domain pos_int does not allow null values
--- Check that domain constraints on plpgsql function parameters, results,
--- and local variables are enforced correctly.
-create function doubledecrement(p1 pos_int) returns pos_int as $$
-declare v pos_int;
-begin
-    return p1;
-end$$ language plpgsql;
-select doubledecrement(3); -- fail because of implicit null assignment
-ERROR:  domain pos_int does not allow null values
-CONTEXT:  PL/pgSQL function doubledecrement(pos_int) line 3 during statement block local variable initialization
-create or replace function doubledecrement(p1 pos_int) returns pos_int as $$
-declare v pos_int := 0;
-begin
-    return p1;
-end$$ language plpgsql;
-select doubledecrement(3); -- fail at initialization assignment
-ERROR:  value for domain pos_int violates check constraint "pos_int_check"
-CONTEXT:  PL/pgSQL function doubledecrement(pos_int) line 3 during statement block local variable initialization
-create or replace function doubledecrement(p1 pos_int) returns pos_int as $$
-declare v pos_int := 1;
-begin
-    v := p1 - 1;
-    return v - 1;
-end$$ language plpgsql;
-select doubledecrement(null); -- fail before call
-ERROR:  domain pos_int does not allow null values
-select doubledecrement(0); -- fail before call
-ERROR:  value for domain pos_int violates check constraint "pos_int_check"
-select doubledecrement(1); -- fail at assignment to v
-ERROR:  value for domain pos_int violates check constraint "pos_int_check"
-CONTEXT:  PL/pgSQL function doubledecrement(pos_int) line 4 at assignment
-select doubledecrement(2); -- fail at return
-ERROR:  value for domain pos_int violates check constraint "pos_int_check"
-CONTEXT:  PL/pgSQL function doubledecrement(pos_int) while casting return value to function's return type
-select doubledecrement(3); -- good
- doubledecrement 
------------------
-               1
-(1 row)
-
--- Check that ALTER DOMAIN tests columns of derived types
-create domain posint as int4;
--- Currently, this doesn't work for composite types, but verify it complains
-create type ddtest1 as (f1 posint);
-create table ddtest2(f1 ddtest1);
-insert into ddtest2 values(row(-1));
-alter domain posint add constraint c1 check(value >= 0);
-ERROR:  cannot alter type "posint" because column "ddtest2.f1" uses it
-drop table ddtest2;
--- Likewise for domains within arrays of composite
-create table ddtest2(f1 ddtest1[]);
-insert into ddtest2 values('{(-1)}');
-alter domain posint add constraint c1 check(value >= 0);
-ERROR:  cannot alter type "posint" because column "ddtest2.f1" uses it
-drop table ddtest2;
--- Likewise for domains within domains over composite
-create domain ddtest1d as ddtest1;
-create table ddtest2(f1 ddtest1d);
-insert into ddtest2 values('(-1)');
-alter domain posint add constraint c1 check(value >= 0);
-ERROR:  cannot alter type "posint" because column "ddtest2.f1" uses it
-drop table ddtest2;
-drop domain ddtest1d;
--- Likewise for domains within domains over array of composite
-create domain ddtest1d as ddtest1[];
-create table ddtest2(f1 ddtest1d);
-insert into ddtest2 values('{(-1)}');
-alter domain posint add constraint c1 check(value >= 0);
-ERROR:  cannot alter type "posint" because column "ddtest2.f1" uses it
-drop table ddtest2;
-drop domain ddtest1d;
--- Doesn't work for ranges, either
-create type rposint as range (subtype = posint);
-create table ddtest2(f1 rposint);
-insert into ddtest2 values('(-1,3]');
-alter domain posint add constraint c1 check(value >= 0);
-ERROR:  cannot alter type "posint" because column "ddtest2.f1" uses it
-drop table ddtest2;
-drop type rposint;
-alter domain posint add constraint c1 check(value >= 0);
-create domain posint2 as posint check (value % 2 = 0);
-create table ddtest2(f1 posint2);
-insert into ddtest2 values(11); -- fail
-ERROR:  value for domain posint2 violates check constraint "posint2_check"
-insert into ddtest2 values(-2); -- fail
-ERROR:  value for domain posint2 violates check constraint "c1"
-insert into ddtest2 values(2);
-alter domain posint add constraint c2 check(value >= 10); -- fail
-ERROR:  column "f1" of table "ddtest2" contains values that violate the new constraint
-alter domain posint add constraint c2 check(value > 0); -- OK
-drop table ddtest2;
-drop type ddtest1;
-drop domain posint cascade;
-NOTICE:  drop cascades to type posint2
---
--- Check enforcement of domain-related typmod in plpgsql (bug #5717)
---
-create or replace function array_elem_check(numeric) returns numeric as $$
-declare
-  x numeric(4,2)[1];
-begin
-  x[1] := $1;
-  return x[1];
-end$$ language plpgsql;
-select array_elem_check(121.00);
-ERROR:  numeric field overflow
-DETAIL:  A field with precision 4, scale 2 must round to an absolute value less than 10^2.
-CONTEXT:  PL/pgSQL function array_elem_check(numeric) line 5 at assignment
-select array_elem_check(1.23456);
- array_elem_check 
-------------------
-             1.23
-(1 row)
-
-create domain mynums as numeric(4,2)[1];
-create or replace function array_elem_check(numeric) returns numeric as $$
-declare
-  x mynums;
-begin
-  x[1] := $1;
-  return x[1];
-end$$ language plpgsql;
-select array_elem_check(121.00);
-ERROR:  numeric field overflow
-DETAIL:  A field with precision 4, scale 2 must round to an absolute value less than 10^2.
-CONTEXT:  PL/pgSQL function array_elem_check(numeric) line 5 at assignment
-select array_elem_check(1.23456);
- array_elem_check 
-------------------
-             1.23
-(1 row)
-
-create domain mynums2 as mynums;
-create or replace function array_elem_check(numeric) returns numeric as $$
-declare
-  x mynums2;
-begin
-  x[1] := $1;
-  return x[1];
-end$$ language plpgsql;
-select array_elem_check(121.00);
-ERROR:  numeric field overflow
-DETAIL:  A field with precision 4, scale 2 must round to an absolute value less than 10^2.
-CONTEXT:  PL/pgSQL function array_elem_check(numeric) line 5 at assignment
-select array_elem_check(1.23456);
- array_elem_check 
-------------------
-             1.23
-(1 row)
-
-drop function array_elem_check(numeric);
---
--- Check enforcement of array-level domain constraints
---
-create domain orderedpair as int[2] check (value[1] < value[2]);
-select array[1,2]::orderedpair;
- array 
--------
- {1,2}
-(1 row)
-
-select array[2,1]::orderedpair;  -- fail
-ERROR:  value for domain orderedpair violates check constraint "orderedpair_check"
-create temp table op (f1 orderedpair);
-insert into op values (array[1,2]);
-insert into op values (array[2,1]);  -- fail
-ERROR:  value for domain orderedpair violates check constraint "orderedpair_check"
-update op set f1[2] = 3;
-update op set f1[2] = 0;  -- fail
-ERROR:  value for domain orderedpair violates check constraint "orderedpair_check"
-select * from op;
-  f1   
--------
- {1,3}
-(1 row)
-
-create or replace function array_elem_check(int) returns int as $$
-declare
-  x orderedpair := '{1,2}';
-begin
-  x[2] := $1;
-  return x[2];
-end$$ language plpgsql;
-select array_elem_check(3);
- array_elem_check 
-------------------
-                3
-(1 row)
-
-select array_elem_check(-1);
-ERROR:  value for domain orderedpair violates check constraint "orderedpair_check"
-CONTEXT:  PL/pgSQL function array_elem_check(integer) line 5 at assignment
-drop function array_elem_check(int);
---
--- Check enforcement of changing constraints in plpgsql
---
-create domain di as int;
-create function dom_check(int) returns di as $$
-declare d di;
-begin
-  d := $1::di;
-  return d;
-end
-$$ language plpgsql immutable;
-select dom_check(0);
- dom_check 
------------
-         0
-(1 row)
-
-alter domain di add constraint pos check (value > 0);
-select dom_check(0); -- fail
-ERROR:  value for domain di violates check constraint "pos"
-CONTEXT:  PL/pgSQL function dom_check(integer) line 4 at assignment
-alter domain di drop constraint pos;
-select dom_check(0);
- dom_check 
------------
-         0
-(1 row)
-
--- implicit cast during assignment is a separate code path, test that too
-create or replace function dom_check(int) returns di as $$
-declare d di;
-begin
-  d := $1;
-  return d;
-end
-$$ language plpgsql immutable;
-select dom_check(0);
- dom_check 
------------
-         0
-(1 row)
-
-alter domain di add constraint pos check (value > 0);
-select dom_check(0); -- fail
-ERROR:  value for domain di violates check constraint "pos"
-CONTEXT:  PL/pgSQL function dom_check(integer) line 4 at assignment
-alter domain di drop constraint pos;
-select dom_check(0);
- dom_check 
------------
-         0
-(1 row)
-
-drop function dom_check(int);
-drop domain di;
---
--- Check use of a (non-inline-able) SQL function in a domain constraint;
--- this has caused issues in the past
---
-create function sql_is_distinct_from(anyelement, anyelement)
-returns boolean language sql
-as 'select $1 is distinct from $2 limit 1';
-create domain inotnull int
-  check (sql_is_distinct_from(value, null));
-select 1::inotnull;
- inotnull 
-----------
-        1
-(1 row)
+dyld: lazy symbol binding failed: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
+
+dyld: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
 
-select null::inotnull;
-ERROR:  value for domain inotnull violates check constraint "inotnull_check"
-create table dom_table (x inotnull);
-insert into dom_table values ('1');
-insert into dom_table values (1);
-insert into dom_table values (null);
-ERROR:  value for domain inotnull violates check constraint "inotnull_check"
-drop table dom_table;
-drop domain inotnull;
-drop function sql_is_distinct_from(anyelement, anyelement);
---
--- Renaming
---
-create domain testdomain1 as int;
-alter domain testdomain1 rename to testdomain2;
-alter type testdomain2 rename to testdomain3;  -- alter type also works
-drop domain testdomain3;
---
--- Renaming domain constraints
---
-create domain testdomain1 as int constraint unsigned check (value > 0);
-alter domain testdomain1 rename constraint unsigned to unsigned_foo;
-alter domain testdomain1 drop constraint unsigned_foo;
-drop domain testdomain1;
diff -U3 /Users/kenaniah/workspace/postgres/src/test/regress/expected/conversion.out /Users/kenaniah/workspace/postgres/src/test/regress/results/conversion.out
--- /Users/kenaniah/workspace/postgres/src/test/regress/expected/conversion.out	2021-10-03 18:09:17.000000000 -0700
+++ /Users/kenaniah/workspace/postgres/src/test/regress/results/conversion.out	2021-10-03 20:08:23.000000000 -0700
@@ -4,30 +4,36 @@
 CREATE USER regress_conversion_user WITH NOCREATEDB NOCREATEROLE;
 SET SESSION AUTHORIZATION regress_conversion_user;
 CREATE CONVERSION myconv FOR 'LATIN1' TO 'UTF8' FROM iso8859_1_to_utf8;
+ERROR:  permission denied for schema public
 --
 -- cannot make same name conversion in same schema
 --
 CREATE CONVERSION myconv FOR 'LATIN1' TO 'UTF8' FROM iso8859_1_to_utf8;
-ERROR:  conversion "myconv" already exists
+ERROR:  permission denied for schema public
 --
 -- create default conversion with qualified name
 --
 CREATE DEFAULT CONVERSION public.mydef FOR 'LATIN1' TO 'UTF8' FROM iso8859_1_to_utf8;
+ERROR:  permission denied for schema public
 --
 -- cannot make default conversion with same schema/for_encoding/to_encoding
 --
 CREATE DEFAULT CONVERSION public.mydef2 FOR 'LATIN1' TO 'UTF8' FROM iso8859_1_to_utf8;
-ERROR:  default conversion for LATIN1 to UTF8 already exists
+ERROR:  permission denied for schema public
 -- test comments
 COMMENT ON CONVERSION myconv_bad IS 'foo';
 ERROR:  conversion "myconv_bad" does not exist
 COMMENT ON CONVERSION myconv IS 'bar';
+ERROR:  conversion "myconv" does not exist
 COMMENT ON CONVERSION myconv IS NULL;
+ERROR:  conversion "myconv" does not exist
 --
 -- drop user defined conversion
 --
 DROP CONVERSION myconv;
+ERROR:  conversion "myconv" does not exist
 DROP CONVERSION mydef;
+ERROR:  conversion "mydef" does not exist
 --
 -- Note: the built-in conversions are exercised in opr_sanity.sql,
 -- so there's no need to do that here.
diff -U3 /Users/kenaniah/workspace/postgres/src/test/regress/expected/alter_table.out /Users/kenaniah/workspace/postgres/src/test/regress/results/alter_table.out
--- /Users/kenaniah/workspace/postgres/src/test/regress/expected/alter_table.out	2021-10-03 18:09:17.000000000 -0700
+++ /Users/kenaniah/workspace/postgres/src/test/regress/results/alter_table.out	2021-10-03 20:08:23.000000000 -0700
@@ -105,4387 +105,11 @@
 HINT:  Alter statistics on table column instead.
 ALTER INDEX attmp_idx ALTER COLUMN 2 SET STATISTICS 1000;
 \d+ attmp_idx
-                        Index "public.attmp_idx"
- Column |       Type       | Key? | Definition | Storage | Stats target 
---------+------------------+------+------------+---------+--------------
- a      | integer          | yes  | a          | plain   | 
- expr   | double precision | yes  | (d + e)    | plain   | 1000
- b      | cstring          | yes  | b          | plain   | 
-btree, for table "public.attmp"
+dyld: lazy symbol binding failed: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
+
+dyld: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
 
-ALTER INDEX attmp_idx ALTER COLUMN 3 SET STATISTICS 1000;
-ERROR:  cannot alter statistics on non-expression column "b" of index "attmp_idx"
-HINT:  Alter statistics on table column instead.
-ALTER INDEX attmp_idx ALTER COLUMN 4 SET STATISTICS 1000;
-ERROR:  column number 4 of relation "attmp_idx" does not exist
-ALTER INDEX attmp_idx ALTER COLUMN 2 SET STATISTICS -1;
-DROP TABLE attmp;
---
--- rename - check on both non-temp and temp tables
---
-CREATE TABLE attmp (regtable int);
-CREATE TEMP TABLE attmp (attmptable int);
-ALTER TABLE attmp RENAME TO attmp_new;
-SELECT * FROM attmp;
- regtable 
-----------
-(0 rows)
-
-SELECT * FROM attmp_new;
- attmptable 
-------------
-(0 rows)
-
-ALTER TABLE attmp RENAME TO attmp_new2;
-SELECT * FROM attmp;		-- should fail
-ERROR:  relation "attmp" does not exist
-LINE 1: SELECT * FROM attmp;
-                      ^
-SELECT * FROM attmp_new;
- attmptable 
-------------
-(0 rows)
-
-SELECT * FROM attmp_new2;
- regtable 
-----------
-(0 rows)
-
-DROP TABLE attmp_new;
-DROP TABLE attmp_new2;
--- check rename of partitioned tables and indexes also
-CREATE TABLE part_attmp (a int primary key) partition by range (a);
-CREATE TABLE part_attmp1 PARTITION OF part_attmp FOR VALUES FROM (0) TO (100);
-ALTER INDEX part_attmp_pkey RENAME TO part_attmp_index;
-ALTER INDEX part_attmp1_pkey RENAME TO part_attmp1_index;
-ALTER TABLE part_attmp RENAME TO part_at2tmp;
-ALTER TABLE part_attmp1 RENAME TO part_at2tmp1;
-SET ROLE regress_alter_table_user1;
-ALTER INDEX part_attmp_index RENAME TO fail;
-ERROR:  must be owner of index part_attmp_index
-ALTER INDEX part_attmp1_index RENAME TO fail;
-ERROR:  must be owner of index part_attmp1_index
-ALTER TABLE part_at2tmp RENAME TO fail;
-ERROR:  must be owner of table part_at2tmp
-ALTER TABLE part_at2tmp1 RENAME TO fail;
-ERROR:  must be owner of table part_at2tmp1
-RESET ROLE;
-DROP TABLE part_at2tmp;
---
--- check renaming to a table's array type's autogenerated name
--- (the array type's name should get out of the way)
---
-CREATE TABLE attmp_array (id int);
-CREATE TABLE attmp_array2 (id int);
-SELECT typname FROM pg_type WHERE oid = 'attmp_array[]'::regtype;
-   typname    
---------------
- _attmp_array
-(1 row)
-
-SELECT typname FROM pg_type WHERE oid = 'attmp_array2[]'::regtype;
-    typname    
----------------
- _attmp_array2
-(1 row)
-
-ALTER TABLE attmp_array2 RENAME TO _attmp_array;
-SELECT typname FROM pg_type WHERE oid = 'attmp_array[]'::regtype;
-    typname    
----------------
- __attmp_array
-(1 row)
-
-SELECT typname FROM pg_type WHERE oid = '_attmp_array[]'::regtype;
-    typname     
-----------------
- ___attmp_array
-(1 row)
-
-DROP TABLE _attmp_array;
-DROP TABLE attmp_array;
--- renaming to table's own array type's name is an interesting corner case
-CREATE TABLE attmp_array (id int);
-SELECT typname FROM pg_type WHERE oid = 'attmp_array[]'::regtype;
-   typname    
---------------
- _attmp_array
-(1 row)
-
-ALTER TABLE attmp_array RENAME TO _attmp_array;
-SELECT typname FROM pg_type WHERE oid = '_attmp_array[]'::regtype;
-    typname    
----------------
- __attmp_array
-(1 row)
-
-DROP TABLE _attmp_array;
--- ALTER TABLE ... RENAME on non-table relations
--- renaming indexes (FIXME: this should probably test the index's functionality)
-ALTER INDEX IF EXISTS __onek_unique1 RENAME TO attmp_onek_unique1;
-NOTICE:  relation "__onek_unique1" does not exist, skipping
-ALTER INDEX IF EXISTS __attmp_onek_unique1 RENAME TO onek_unique1;
-NOTICE:  relation "__attmp_onek_unique1" does not exist, skipping
-ALTER INDEX onek_unique1 RENAME TO attmp_onek_unique1;
-ALTER INDEX attmp_onek_unique1 RENAME TO onek_unique1;
-SET ROLE regress_alter_table_user1;
-ALTER INDEX onek_unique1 RENAME TO fail;  -- permission denied
-ERROR:  must be owner of index onek_unique1
-RESET ROLE;
--- renaming views
-CREATE VIEW attmp_view (unique1) AS SELECT unique1 FROM tenk1;
-ALTER TABLE attmp_view RENAME TO attmp_view_new;
-SET ROLE regress_alter_table_user1;
-ALTER VIEW attmp_view_new RENAME TO fail;  -- permission denied
-ERROR:  must be owner of view attmp_view_new
-RESET ROLE;
--- hack to ensure we get an indexscan here
-set enable_seqscan to off;
-set enable_bitmapscan to off;
--- 5 values, sorted
-SELECT unique1 FROM tenk1 WHERE unique1 < 5;
- unique1 
----------
-       0
-       1
-       2
-       3
-       4
-(5 rows)
-
-reset enable_seqscan;
-reset enable_bitmapscan;
-DROP VIEW attmp_view_new;
--- toast-like relation name
-alter table stud_emp rename to pg_toast_stud_emp;
-alter table pg_toast_stud_emp rename to stud_emp;
--- renaming index should rename constraint as well
-ALTER TABLE onek ADD CONSTRAINT onek_unique1_constraint UNIQUE (unique1);
-ALTER INDEX onek_unique1_constraint RENAME TO onek_unique1_constraint_foo;
-ALTER TABLE onek DROP CONSTRAINT onek_unique1_constraint_foo;
--- renaming constraint
-ALTER TABLE onek ADD CONSTRAINT onek_check_constraint CHECK (unique1 >= 0);
-ALTER TABLE onek RENAME CONSTRAINT onek_check_constraint TO onek_check_constraint_foo;
-ALTER TABLE onek DROP CONSTRAINT onek_check_constraint_foo;
--- renaming constraint should rename index as well
-ALTER TABLE onek ADD CONSTRAINT onek_unique1_constraint UNIQUE (unique1);
-DROP INDEX onek_unique1_constraint;  -- to see whether it's there
-ERROR:  cannot drop index onek_unique1_constraint because constraint onek_unique1_constraint on table onek requires it
-HINT:  You can drop constraint onek_unique1_constraint on table onek instead.
-ALTER TABLE onek RENAME CONSTRAINT onek_unique1_constraint TO onek_unique1_constraint_foo;
-DROP INDEX onek_unique1_constraint_foo;  -- to see whether it's there
-ERROR:  cannot drop index onek_unique1_constraint_foo because constraint onek_unique1_constraint_foo on table onek requires it
-HINT:  You can drop constraint onek_unique1_constraint_foo on table onek instead.
-ALTER TABLE onek DROP CONSTRAINT onek_unique1_constraint_foo;
--- renaming constraints vs. inheritance
-CREATE TABLE constraint_rename_test (a int CONSTRAINT con1 CHECK (a > 0), b int, c int);
-\d constraint_rename_test
-       Table "public.constraint_rename_test"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
- b      | integer |           |          | 
- c      | integer |           |          | 
-Check constraints:
-    "con1" CHECK (a > 0)
-
-CREATE TABLE constraint_rename_test2 (a int CONSTRAINT con1 CHECK (a > 0), d int) INHERITS (constraint_rename_test);
-NOTICE:  merging column "a" with inherited definition
-NOTICE:  merging constraint "con1" with inherited definition
-\d constraint_rename_test2
-      Table "public.constraint_rename_test2"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
- b      | integer |           |          | 
- c      | integer |           |          | 
- d      | integer |           |          | 
-Check constraints:
-    "con1" CHECK (a > 0)
-Inherits: constraint_rename_test
-
-ALTER TABLE constraint_rename_test2 RENAME CONSTRAINT con1 TO con1foo; -- fail
-ERROR:  cannot rename inherited constraint "con1"
-ALTER TABLE ONLY constraint_rename_test RENAME CONSTRAINT con1 TO con1foo; -- fail
-ERROR:  inherited constraint "con1" must be renamed in child tables too
-ALTER TABLE constraint_rename_test RENAME CONSTRAINT con1 TO con1foo; -- ok
-\d constraint_rename_test
-       Table "public.constraint_rename_test"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
- b      | integer |           |          | 
- c      | integer |           |          | 
-Check constraints:
-    "con1foo" CHECK (a > 0)
-Number of child tables: 1 (Use \d+ to list them.)
-
-\d constraint_rename_test2
-      Table "public.constraint_rename_test2"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
- b      | integer |           |          | 
- c      | integer |           |          | 
- d      | integer |           |          | 
-Check constraints:
-    "con1foo" CHECK (a > 0)
-Inherits: constraint_rename_test
-
-ALTER TABLE constraint_rename_test ADD CONSTRAINT con2 CHECK (b > 0) NO INHERIT;
-ALTER TABLE ONLY constraint_rename_test RENAME CONSTRAINT con2 TO con2foo; -- ok
-ALTER TABLE constraint_rename_test RENAME CONSTRAINT con2foo TO con2bar; -- ok
-\d constraint_rename_test
-       Table "public.constraint_rename_test"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
- b      | integer |           |          | 
- c      | integer |           |          | 
-Check constraints:
-    "con1foo" CHECK (a > 0)
-    "con2bar" CHECK (b > 0) NO INHERIT
-Number of child tables: 1 (Use \d+ to list them.)
-
-\d constraint_rename_test2
-      Table "public.constraint_rename_test2"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
- b      | integer |           |          | 
- c      | integer |           |          | 
- d      | integer |           |          | 
-Check constraints:
-    "con1foo" CHECK (a > 0)
-Inherits: constraint_rename_test
-
-ALTER TABLE constraint_rename_test ADD CONSTRAINT con3 PRIMARY KEY (a);
-ALTER TABLE constraint_rename_test RENAME CONSTRAINT con3 TO con3foo; -- ok
-\d constraint_rename_test
-       Table "public.constraint_rename_test"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           | not null | 
- b      | integer |           |          | 
- c      | integer |           |          | 
-Indexes:
-    "con3foo" PRIMARY KEY, btree (a)
-Check constraints:
-    "con1foo" CHECK (a > 0)
-    "con2bar" CHECK (b > 0) NO INHERIT
-Number of child tables: 1 (Use \d+ to list them.)
-
-\d constraint_rename_test2
-      Table "public.constraint_rename_test2"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           | not null | 
- b      | integer |           |          | 
- c      | integer |           |          | 
- d      | integer |           |          | 
-Check constraints:
-    "con1foo" CHECK (a > 0)
-Inherits: constraint_rename_test
-
-DROP TABLE constraint_rename_test2;
-DROP TABLE constraint_rename_test;
-ALTER TABLE IF EXISTS constraint_not_exist RENAME CONSTRAINT con3 TO con3foo; -- ok
-NOTICE:  relation "constraint_not_exist" does not exist, skipping
-ALTER TABLE IF EXISTS constraint_rename_test ADD CONSTRAINT con4 UNIQUE (a);
-NOTICE:  relation "constraint_rename_test" does not exist, skipping
--- renaming constraints with cache reset of target relation
-CREATE TABLE constraint_rename_cache (a int,
-  CONSTRAINT chk_a CHECK (a > 0),
-  PRIMARY KEY (a));
-ALTER TABLE constraint_rename_cache
-  RENAME CONSTRAINT chk_a TO chk_a_new;
-ALTER TABLE constraint_rename_cache
-  RENAME CONSTRAINT constraint_rename_cache_pkey TO constraint_rename_pkey_new;
-CREATE TABLE like_constraint_rename_cache
-  (LIKE constraint_rename_cache INCLUDING ALL);
-\d like_constraint_rename_cache
-    Table "public.like_constraint_rename_cache"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           | not null | 
-Indexes:
-    "like_constraint_rename_cache_pkey" PRIMARY KEY, btree (a)
-Check constraints:
-    "chk_a_new" CHECK (a > 0)
-
-DROP TABLE constraint_rename_cache;
-DROP TABLE like_constraint_rename_cache;
--- FOREIGN KEY CONSTRAINT adding TEST
-CREATE TABLE attmp2 (a int primary key);
-CREATE TABLE attmp3 (a int, b int);
-CREATE TABLE attmp4 (a int, b int, unique(a,b));
-CREATE TABLE attmp5 (a int, b int);
--- Insert rows into attmp2 (pktable)
-INSERT INTO attmp2 values (1);
-INSERT INTO attmp2 values (2);
-INSERT INTO attmp2 values (3);
-INSERT INTO attmp2 values (4);
--- Insert rows into attmp3
-INSERT INTO attmp3 values (1,10);
-INSERT INTO attmp3 values (1,20);
-INSERT INTO attmp3 values (5,50);
--- Try (and fail) to add constraint due to invalid source columns
-ALTER TABLE attmp3 add constraint attmpconstr foreign key(c) references attmp2 match full;
-ERROR:  column "c" referenced in foreign key constraint does not exist
--- Try (and fail) to add constraint due to invalid destination columns explicitly given
-ALTER TABLE attmp3 add constraint attmpconstr foreign key(a) references attmp2(b) match full;
-ERROR:  column "b" referenced in foreign key constraint does not exist
--- Try (and fail) to add constraint due to invalid data
-ALTER TABLE attmp3 add constraint attmpconstr foreign key (a) references attmp2 match full;
-ERROR:  insert or update on table "attmp3" violates foreign key constraint "attmpconstr"
-DETAIL:  Key (a)=(5) is not present in table "attmp2".
--- Delete failing row
-DELETE FROM attmp3 where a=5;
--- Try (and succeed)
-ALTER TABLE attmp3 add constraint attmpconstr foreign key (a) references attmp2 match full;
-ALTER TABLE attmp3 drop constraint attmpconstr;
-INSERT INTO attmp3 values (5,50);
--- Try NOT VALID and then VALIDATE CONSTRAINT, but fails. Delete failure then re-validate
-ALTER TABLE attmp3 add constraint attmpconstr foreign key (a) references attmp2 match full NOT VALID;
-ALTER TABLE attmp3 validate constraint attmpconstr;
-ERROR:  insert or update on table "attmp3" violates foreign key constraint "attmpconstr"
-DETAIL:  Key (a)=(5) is not present in table "attmp2".
--- Delete failing row
-DELETE FROM attmp3 where a=5;
--- Try (and succeed) and repeat to show it works on already valid constraint
-ALTER TABLE attmp3 validate constraint attmpconstr;
-ALTER TABLE attmp3 validate constraint attmpconstr;
--- Try a non-verified CHECK constraint
-ALTER TABLE attmp3 ADD CONSTRAINT b_greater_than_ten CHECK (b > 10); -- fail
-ERROR:  check constraint "b_greater_than_ten" of relation "attmp3" is violated by some row
-ALTER TABLE attmp3 ADD CONSTRAINT b_greater_than_ten CHECK (b > 10) NOT VALID; -- succeeds
-ALTER TABLE attmp3 VALIDATE CONSTRAINT b_greater_than_ten; -- fails
-ERROR:  check constraint "b_greater_than_ten" of relation "attmp3" is violated by some row
-DELETE FROM attmp3 WHERE NOT b > 10;
-ALTER TABLE attmp3 VALIDATE CONSTRAINT b_greater_than_ten; -- succeeds
-ALTER TABLE attmp3 VALIDATE CONSTRAINT b_greater_than_ten; -- succeeds
--- Test inherited NOT VALID CHECK constraints
-select * from attmp3;
- a | b  
----+----
- 1 | 20
-(1 row)
-
-CREATE TABLE attmp6 () INHERITS (attmp3);
-CREATE TABLE attmp7 () INHERITS (attmp3);
-INSERT INTO attmp6 VALUES (6, 30), (7, 16);
-ALTER TABLE attmp3 ADD CONSTRAINT b_le_20 CHECK (b <= 20) NOT VALID;
-ALTER TABLE attmp3 VALIDATE CONSTRAINT b_le_20;	-- fails
-ERROR:  check constraint "b_le_20" of relation "attmp6" is violated by some row
-DELETE FROM attmp6 WHERE b > 20;
-ALTER TABLE attmp3 VALIDATE CONSTRAINT b_le_20;	-- succeeds
--- An already validated constraint must not be revalidated
-CREATE FUNCTION boo(int) RETURNS int IMMUTABLE STRICT LANGUAGE plpgsql AS $$ BEGIN RAISE NOTICE 'boo: %', $1; RETURN $1; END; $$;
-INSERT INTO attmp7 VALUES (8, 18);
-ALTER TABLE attmp7 ADD CONSTRAINT identity CHECK (b = boo(b));
-NOTICE:  boo: 18
-ALTER TABLE attmp3 ADD CONSTRAINT IDENTITY check (b = boo(b)) NOT VALID;
-NOTICE:  merging constraint "identity" with inherited definition
-ALTER TABLE attmp3 VALIDATE CONSTRAINT identity;
-NOTICE:  boo: 20
-NOTICE:  boo: 16
--- A NO INHERIT constraint should not be looked for in children during VALIDATE CONSTRAINT
-create table parent_noinh_convalid (a int);
-create table child_noinh_convalid () inherits (parent_noinh_convalid);
-insert into parent_noinh_convalid values (1);
-insert into child_noinh_convalid values (1);
-alter table parent_noinh_convalid add constraint check_a_is_2 check (a = 2) no inherit not valid;
--- fail, because of the row in parent
-alter table parent_noinh_convalid validate constraint check_a_is_2;
-ERROR:  check constraint "check_a_is_2" of relation "parent_noinh_convalid" is violated by some row
-delete from only parent_noinh_convalid;
--- ok (parent itself contains no violating rows)
-alter table parent_noinh_convalid validate constraint check_a_is_2;
-select convalidated from pg_constraint where conrelid = 'parent_noinh_convalid'::regclass and conname = 'check_a_is_2';
- convalidated 
---------------
- t
-(1 row)
-
--- cleanup
-drop table parent_noinh_convalid, child_noinh_convalid;
--- Try (and fail) to create constraint from attmp5(a) to attmp4(a) - unique constraint on
--- attmp4 is a,b
-ALTER TABLE attmp5 add constraint attmpconstr foreign key(a) references attmp4(a) match full;
-ERROR:  there is no unique constraint matching given keys for referenced table "attmp4"
-DROP TABLE attmp7;
-DROP TABLE attmp6;
-DROP TABLE attmp5;
-DROP TABLE attmp4;
-DROP TABLE attmp3;
-DROP TABLE attmp2;
--- NOT VALID with plan invalidation -- ensure we don't use a constraint for
--- exclusion until validated
-set constraint_exclusion TO 'partition';
-create table nv_parent (d date, check (false) no inherit not valid);
--- not valid constraint added at creation time should automatically become valid
-\d nv_parent
-            Table "public.nv_parent"
- Column | Type | Collation | Nullable | Default 
---------+------+-----------+----------+---------
- d      | date |           |          | 
-Check constraints:
-    "nv_parent_check" CHECK (false) NO INHERIT
-
-create table nv_child_2010 () inherits (nv_parent);
-create table nv_child_2011 () inherits (nv_parent);
-alter table nv_child_2010 add check (d between '2010-01-01'::date and '2010-12-31'::date) not valid;
-alter table nv_child_2011 add check (d between '2011-01-01'::date and '2011-12-31'::date) not valid;
-explain (costs off) select * from nv_parent where d between '2011-08-01' and '2011-08-31';
-                                QUERY PLAN                                 
----------------------------------------------------------------------------
- Append
-   ->  Seq Scan on nv_parent nv_parent_1
-         Filter: ((d >= '08-01-2011'::date) AND (d <= '08-31-2011'::date))
-   ->  Seq Scan on nv_child_2010 nv_parent_2
-         Filter: ((d >= '08-01-2011'::date) AND (d <= '08-31-2011'::date))
-   ->  Seq Scan on nv_child_2011 nv_parent_3
-         Filter: ((d >= '08-01-2011'::date) AND (d <= '08-31-2011'::date))
-(7 rows)
-
-create table nv_child_2009 (check (d between '2009-01-01'::date and '2009-12-31'::date)) inherits (nv_parent);
-explain (costs off) select * from nv_parent where d between '2011-08-01'::date and '2011-08-31'::date;
-                                QUERY PLAN                                 
----------------------------------------------------------------------------
- Append
-   ->  Seq Scan on nv_parent nv_parent_1
-         Filter: ((d >= '08-01-2011'::date) AND (d <= '08-31-2011'::date))
-   ->  Seq Scan on nv_child_2010 nv_parent_2
-         Filter: ((d >= '08-01-2011'::date) AND (d <= '08-31-2011'::date))
-   ->  Seq Scan on nv_child_2011 nv_parent_3
-         Filter: ((d >= '08-01-2011'::date) AND (d <= '08-31-2011'::date))
-(7 rows)
-
-explain (costs off) select * from nv_parent where d between '2009-08-01'::date and '2009-08-31'::date;
-                                QUERY PLAN                                 
----------------------------------------------------------------------------
- Append
-   ->  Seq Scan on nv_parent nv_parent_1
-         Filter: ((d >= '08-01-2009'::date) AND (d <= '08-31-2009'::date))
-   ->  Seq Scan on nv_child_2010 nv_parent_2
-         Filter: ((d >= '08-01-2009'::date) AND (d <= '08-31-2009'::date))
-   ->  Seq Scan on nv_child_2011 nv_parent_3
-         Filter: ((d >= '08-01-2009'::date) AND (d <= '08-31-2009'::date))
-   ->  Seq Scan on nv_child_2009 nv_parent_4
-         Filter: ((d >= '08-01-2009'::date) AND (d <= '08-31-2009'::date))
-(9 rows)
-
--- after validation, the constraint should be used
-alter table nv_child_2011 VALIDATE CONSTRAINT nv_child_2011_d_check;
-explain (costs off) select * from nv_parent where d between '2009-08-01'::date and '2009-08-31'::date;
-                                QUERY PLAN                                 
----------------------------------------------------------------------------
- Append
-   ->  Seq Scan on nv_parent nv_parent_1
-         Filter: ((d >= '08-01-2009'::date) AND (d <= '08-31-2009'::date))
-   ->  Seq Scan on nv_child_2010 nv_parent_2
-         Filter: ((d >= '08-01-2009'::date) AND (d <= '08-31-2009'::date))
-   ->  Seq Scan on nv_child_2009 nv_parent_3
-         Filter: ((d >= '08-01-2009'::date) AND (d <= '08-31-2009'::date))
-(7 rows)
-
--- add an inherited NOT VALID constraint
-alter table nv_parent add check (d between '2001-01-01'::date and '2099-12-31'::date) not valid;
-\d nv_child_2009
-          Table "public.nv_child_2009"
- Column | Type | Collation | Nullable | Default 
---------+------+-----------+----------+---------
- d      | date |           |          | 
-Check constraints:
-    "nv_child_2009_d_check" CHECK (d >= '01-01-2009'::date AND d <= '12-31-2009'::date)
-    "nv_parent_d_check" CHECK (d >= '01-01-2001'::date AND d <= '12-31-2099'::date) NOT VALID
-Inherits: nv_parent
-
--- we leave nv_parent and children around to help test pg_dump logic
--- Foreign key adding test with mixed types
--- Note: these tables are TEMP to avoid name conflicts when this test
--- is run in parallel with foreign_key.sql.
-CREATE TEMP TABLE PKTABLE (ptest1 int PRIMARY KEY);
-INSERT INTO PKTABLE VALUES(42);
-CREATE TEMP TABLE FKTABLE (ftest1 inet);
--- This next should fail, because int=inet does not exist
-ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1) references pktable;
-ERROR:  foreign key constraint "fktable_ftest1_fkey" cannot be implemented
-DETAIL:  Key columns "ftest1" and "ptest1" are of incompatible types: inet and integer.
--- This should also fail for the same reason, but here we
--- give the column name
-ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1) references pktable(ptest1);
-ERROR:  foreign key constraint "fktable_ftest1_fkey" cannot be implemented
-DETAIL:  Key columns "ftest1" and "ptest1" are of incompatible types: inet and integer.
-DROP TABLE FKTABLE;
--- This should succeed, even though they are different types,
--- because int=int8 exists and is a member of the integer opfamily
-CREATE TEMP TABLE FKTABLE (ftest1 int8);
-ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1) references pktable;
--- Check it actually works
-INSERT INTO FKTABLE VALUES(42);		-- should succeed
-INSERT INTO FKTABLE VALUES(43);		-- should fail
-ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_ftest1_fkey"
-DETAIL:  Key (ftest1)=(43) is not present in table "pktable".
-DROP TABLE FKTABLE;
--- This should fail, because we'd have to cast numeric to int which is
--- not an implicit coercion (or use numeric=numeric, but that's not part
--- of the integer opfamily)
-CREATE TEMP TABLE FKTABLE (ftest1 numeric);
-ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1) references pktable;
-ERROR:  foreign key constraint "fktable_ftest1_fkey" cannot be implemented
-DETAIL:  Key columns "ftest1" and "ptest1" are of incompatible types: numeric and integer.
-DROP TABLE FKTABLE;
-DROP TABLE PKTABLE;
--- On the other hand, this should work because int implicitly promotes to
--- numeric, and we allow promotion on the FK side
-CREATE TEMP TABLE PKTABLE (ptest1 numeric PRIMARY KEY);
-INSERT INTO PKTABLE VALUES(42);
-CREATE TEMP TABLE FKTABLE (ftest1 int);
-ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1) references pktable;
--- Check it actually works
-INSERT INTO FKTABLE VALUES(42);		-- should succeed
-INSERT INTO FKTABLE VALUES(43);		-- should fail
-ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_ftest1_fkey"
-DETAIL:  Key (ftest1)=(43) is not present in table "pktable".
-DROP TABLE FKTABLE;
-DROP TABLE PKTABLE;
-CREATE TEMP TABLE PKTABLE (ptest1 int, ptest2 inet,
-                           PRIMARY KEY(ptest1, ptest2));
--- This should fail, because we just chose really odd types
-CREATE TEMP TABLE FKTABLE (ftest1 cidr, ftest2 timestamp);
-ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1, ftest2) references pktable;
-ERROR:  foreign key constraint "fktable_ftest1_ftest2_fkey" cannot be implemented
-DETAIL:  Key columns "ftest1" and "ptest1" are of incompatible types: cidr and integer.
-DROP TABLE FKTABLE;
--- Again, so should this...
-CREATE TEMP TABLE FKTABLE (ftest1 cidr, ftest2 timestamp);
-ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1, ftest2)
-     references pktable(ptest1, ptest2);
-ERROR:  foreign key constraint "fktable_ftest1_ftest2_fkey" cannot be implemented
-DETAIL:  Key columns "ftest1" and "ptest1" are of incompatible types: cidr and integer.
-DROP TABLE FKTABLE;
--- This fails because we mixed up the column ordering
-CREATE TEMP TABLE FKTABLE (ftest1 int, ftest2 inet);
-ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1, ftest2)
-     references pktable(ptest2, ptest1);
-ERROR:  foreign key constraint "fktable_ftest1_ftest2_fkey" cannot be implemented
-DETAIL:  Key columns "ftest1" and "ptest2" are of incompatible types: integer and inet.
--- As does this...
-ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest2, ftest1)
-     references pktable(ptest1, ptest2);
-ERROR:  foreign key constraint "fktable_ftest2_ftest1_fkey" cannot be implemented
-DETAIL:  Key columns "ftest2" and "ptest1" are of incompatible types: inet and integer.
-DROP TABLE FKTABLE;
-DROP TABLE PKTABLE;
--- Test that ALTER CONSTRAINT updates trigger deferrability properly
-CREATE TEMP TABLE PKTABLE (ptest1 int primary key);
-CREATE TEMP TABLE FKTABLE (ftest1 int);
-ALTER TABLE FKTABLE ADD CONSTRAINT fknd FOREIGN KEY(ftest1) REFERENCES pktable
-  ON DELETE CASCADE ON UPDATE NO ACTION NOT DEFERRABLE;
-ALTER TABLE FKTABLE ADD CONSTRAINT fkdd FOREIGN KEY(ftest1) REFERENCES pktable
-  ON DELETE CASCADE ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
-ALTER TABLE FKTABLE ADD CONSTRAINT fkdi FOREIGN KEY(ftest1) REFERENCES pktable
-  ON DELETE CASCADE ON UPDATE NO ACTION DEFERRABLE INITIALLY IMMEDIATE;
-ALTER TABLE FKTABLE ADD CONSTRAINT fknd2 FOREIGN KEY(ftest1) REFERENCES pktable
-  ON DELETE CASCADE ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
-ALTER TABLE FKTABLE ALTER CONSTRAINT fknd2 NOT DEFERRABLE;
-ALTER TABLE FKTABLE ADD CONSTRAINT fkdd2 FOREIGN KEY(ftest1) REFERENCES pktable
-  ON DELETE CASCADE ON UPDATE NO ACTION NOT DEFERRABLE;
-ALTER TABLE FKTABLE ALTER CONSTRAINT fkdd2 DEFERRABLE INITIALLY DEFERRED;
-ALTER TABLE FKTABLE ADD CONSTRAINT fkdi2 FOREIGN KEY(ftest1) REFERENCES pktable
-  ON DELETE CASCADE ON UPDATE NO ACTION NOT DEFERRABLE;
-ALTER TABLE FKTABLE ALTER CONSTRAINT fkdi2 DEFERRABLE INITIALLY IMMEDIATE;
-SELECT conname, tgfoid::regproc, tgtype, tgdeferrable, tginitdeferred
-FROM pg_trigger JOIN pg_constraint con ON con.oid = tgconstraint
-WHERE tgrelid = 'pktable'::regclass
-ORDER BY 1,2,3;
- conname |         tgfoid         | tgtype | tgdeferrable | tginitdeferred 
----------+------------------------+--------+--------------+----------------
- fkdd    | "RI_FKey_cascade_del"  |      9 | f            | f
- fkdd    | "RI_FKey_noaction_upd" |     17 | t            | t
- fkdd2   | "RI_FKey_cascade_del"  |      9 | f            | f
- fkdd2   | "RI_FKey_noaction_upd" |     17 | t            | t
- fkdi    | "RI_FKey_cascade_del"  |      9 | f            | f
- fkdi    | "RI_FKey_noaction_upd" |     17 | t            | f
- fkdi2   | "RI_FKey_cascade_del"  |      9 | f            | f
- fkdi2   | "RI_FKey_noaction_upd" |     17 | t            | f
- fknd    | "RI_FKey_cascade_del"  |      9 | f            | f
- fknd    | "RI_FKey_noaction_upd" |     17 | f            | f
- fknd2   | "RI_FKey_cascade_del"  |      9 | f            | f
- fknd2   | "RI_FKey_noaction_upd" |     17 | f            | f
-(12 rows)
-
-SELECT conname, tgfoid::regproc, tgtype, tgdeferrable, tginitdeferred
-FROM pg_trigger JOIN pg_constraint con ON con.oid = tgconstraint
-WHERE tgrelid = 'fktable'::regclass
-ORDER BY 1,2,3;
- conname |       tgfoid        | tgtype | tgdeferrable | tginitdeferred 
----------+---------------------+--------+--------------+----------------
- fkdd    | "RI_FKey_check_ins" |      5 | t            | t
- fkdd    | "RI_FKey_check_upd" |     17 | t            | t
- fkdd2   | "RI_FKey_check_ins" |      5 | t            | t
- fkdd2   | "RI_FKey_check_upd" |     17 | t            | t
- fkdi    | "RI_FKey_check_ins" |      5 | t            | f
- fkdi    | "RI_FKey_check_upd" |     17 | t            | f
- fkdi2   | "RI_FKey_check_ins" |      5 | t            | f
- fkdi2   | "RI_FKey_check_upd" |     17 | t            | f
- fknd    | "RI_FKey_check_ins" |      5 | f            | f
- fknd    | "RI_FKey_check_upd" |     17 | f            | f
- fknd2   | "RI_FKey_check_ins" |      5 | f            | f
- fknd2   | "RI_FKey_check_upd" |     17 | f            | f
-(12 rows)
-
--- temp tables should go away by themselves, need not drop them.
--- test check constraint adding
-create table atacc1 ( test int );
--- add a check constraint
-alter table atacc1 add constraint atacc_test1 check (test>3);
--- should fail
-insert into atacc1 (test) values (2);
-ERROR:  new row for relation "atacc1" violates check constraint "atacc_test1"
-DETAIL:  Failing row contains (2).
--- should succeed
-insert into atacc1 (test) values (4);
-drop table atacc1;
--- let's do one where the check fails when added
-create table atacc1 ( test int );
--- insert a soon to be failing row
-insert into atacc1 (test) values (2);
--- add a check constraint (fails)
-alter table atacc1 add constraint atacc_test1 check (test>3);
-ERROR:  check constraint "atacc_test1" of relation "atacc1" is violated by some row
-insert into atacc1 (test) values (4);
-drop table atacc1;
--- let's do one where the check fails because the column doesn't exist
-create table atacc1 ( test int );
--- add a check constraint (fails)
-alter table atacc1 add constraint atacc_test1 check (test1>3);
-ERROR:  column "test1" does not exist
-HINT:  Perhaps you meant to reference the column "atacc1.test".
-drop table atacc1;
--- something a little more complicated
-create table atacc1 ( test int, test2 int, test3 int);
--- add a check constraint (fails)
-alter table atacc1 add constraint atacc_test1 check (test+test2<test3*4);
--- should fail
-insert into atacc1 (test,test2,test3) values (4,4,2);
-ERROR:  new row for relation "atacc1" violates check constraint "atacc_test1"
-DETAIL:  Failing row contains (4, 4, 2).
--- should succeed
-insert into atacc1 (test,test2,test3) values (4,4,5);
-drop table atacc1;
--- lets do some naming tests
-create table atacc1 (test int check (test>3), test2 int);
-alter table atacc1 add check (test2>test);
--- should fail for $2
-insert into atacc1 (test2, test) values (3, 4);
-ERROR:  new row for relation "atacc1" violates check constraint "atacc1_check"
-DETAIL:  Failing row contains (4, 3).
-drop table atacc1;
--- inheritance related tests
-create table atacc1 (test int);
-create table atacc2 (test2 int);
-create table atacc3 (test3 int) inherits (atacc1, atacc2);
-alter table atacc2 add constraint foo check (test2>0);
--- fail and then succeed on atacc2
-insert into atacc2 (test2) values (-3);
-ERROR:  new row for relation "atacc2" violates check constraint "foo"
-DETAIL:  Failing row contains (-3).
-insert into atacc2 (test2) values (3);
--- fail and then succeed on atacc3
-insert into atacc3 (test2) values (-3);
-ERROR:  new row for relation "atacc3" violates check constraint "foo"
-DETAIL:  Failing row contains (null, -3, null).
-insert into atacc3 (test2) values (3);
-drop table atacc3;
-drop table atacc2;
-drop table atacc1;
--- same things with one created with INHERIT
-create table atacc1 (test int);
-create table atacc2 (test2 int);
-create table atacc3 (test3 int) inherits (atacc1, atacc2);
-alter table atacc3 no inherit atacc2;
--- fail
-alter table atacc3 no inherit atacc2;
-ERROR:  relation "atacc2" is not a parent of relation "atacc3"
--- make sure it really isn't a child
-insert into atacc3 (test2) values (3);
-select test2 from atacc2;
- test2 
--------
-(0 rows)
-
--- fail due to missing constraint
-alter table atacc2 add constraint foo check (test2>0);
-alter table atacc3 inherit atacc2;
-ERROR:  child table is missing constraint "foo"
--- fail due to missing column
-alter table atacc3 rename test2 to testx;
-alter table atacc3 inherit atacc2;
-ERROR:  child table is missing column "test2"
--- fail due to mismatched data type
-alter table atacc3 add test2 bool;
-alter table atacc3 inherit atacc2;
-ERROR:  child table "atacc3" has different type for column "test2"
-alter table atacc3 drop test2;
--- succeed
-alter table atacc3 add test2 int;
-update atacc3 set test2 = 4 where test2 is null;
-alter table atacc3 add constraint foo check (test2>0);
-alter table atacc3 inherit atacc2;
--- fail due to duplicates and circular inheritance
-alter table atacc3 inherit atacc2;
-ERROR:  relation "atacc2" would be inherited from more than once
-alter table atacc2 inherit atacc3;
-ERROR:  circular inheritance not allowed
-DETAIL:  "atacc3" is already a child of "atacc2".
-alter table atacc2 inherit atacc2;
-ERROR:  circular inheritance not allowed
-DETAIL:  "atacc2" is already a child of "atacc2".
--- test that we really are a child now (should see 4 not 3 and cascade should go through)
-select test2 from atacc2;
- test2 
--------
-     4
-(1 row)
-
-drop table atacc2 cascade;
-NOTICE:  drop cascades to table atacc3
-drop table atacc1;
--- adding only to a parent is allowed as of 9.2
-create table atacc1 (test int);
-create table atacc2 (test2 int) inherits (atacc1);
--- ok:
-alter table atacc1 add constraint foo check (test>0) no inherit;
--- check constraint is not there on child
-insert into atacc2 (test) values (-3);
--- check constraint is there on parent
-insert into atacc1 (test) values (-3);
-ERROR:  new row for relation "atacc1" violates check constraint "foo"
-DETAIL:  Failing row contains (-3).
-insert into atacc1 (test) values (3);
--- fail, violating row:
-alter table atacc2 add constraint foo check (test>0) no inherit;
-ERROR:  check constraint "foo" of relation "atacc2" is violated by some row
-drop table atacc2;
-drop table atacc1;
--- test unique constraint adding
-create table atacc1 ( test int ) ;
--- add a unique constraint
-alter table atacc1 add constraint atacc_test1 unique (test);
--- insert first value
-insert into atacc1 (test) values (2);
--- should fail
-insert into atacc1 (test) values (2);
-ERROR:  duplicate key value violates unique constraint "atacc_test1"
-DETAIL:  Key (test)=(2) already exists.
--- should succeed
-insert into atacc1 (test) values (4);
--- try to create duplicates via alter table using - should fail
-alter table atacc1 alter column test type integer using 0;
-ERROR:  could not create unique index "atacc_test1"
-DETAIL:  Key (test)=(0) is duplicated.
-drop table atacc1;
--- let's do one where the unique constraint fails when added
-create table atacc1 ( test int );
--- insert soon to be failing rows
-insert into atacc1 (test) values (2);
-insert into atacc1 (test) values (2);
--- add a unique constraint (fails)
-alter table atacc1 add constraint atacc_test1 unique (test);
-ERROR:  could not create unique index "atacc_test1"
-DETAIL:  Key (test)=(2) is duplicated.
-insert into atacc1 (test) values (3);
-drop table atacc1;
--- let's do one where the unique constraint fails
--- because the column doesn't exist
-create table atacc1 ( test int );
--- add a unique constraint (fails)
-alter table atacc1 add constraint atacc_test1 unique (test1);
-ERROR:  column "test1" named in key does not exist
-drop table atacc1;
--- something a little more complicated
-create table atacc1 ( test int, test2 int);
--- add a unique constraint
-alter table atacc1 add constraint atacc_test1 unique (test, test2);
--- insert initial value
-insert into atacc1 (test,test2) values (4,4);
--- should fail
-insert into atacc1 (test,test2) values (4,4);
-ERROR:  duplicate key value violates unique constraint "atacc_test1"
-DETAIL:  Key (test, test2)=(4, 4) already exists.
--- should all succeed
-insert into atacc1 (test,test2) values (4,5);
-insert into atacc1 (test,test2) values (5,4);
-insert into atacc1 (test,test2) values (5,5);
-drop table atacc1;
--- lets do some naming tests
-create table atacc1 (test int, test2 int, unique(test));
-alter table atacc1 add unique (test2);
--- should fail for @@ second one @@
-insert into atacc1 (test2, test) values (3, 3);
-insert into atacc1 (test2, test) values (2, 3);
-ERROR:  duplicate key value violates unique constraint "atacc1_test_key"
-DETAIL:  Key (test)=(3) already exists.
-drop table atacc1;
--- test primary key constraint adding
-create table atacc1 ( id serial, test int) ;
--- add a primary key constraint
-alter table atacc1 add constraint atacc_test1 primary key (test);
--- insert first value
-insert into atacc1 (test) values (2);
--- should fail
-insert into atacc1 (test) values (2);
-ERROR:  duplicate key value violates unique constraint "atacc_test1"
-DETAIL:  Key (test)=(2) already exists.
--- should succeed
-insert into atacc1 (test) values (4);
--- inserting NULL should fail
-insert into atacc1 (test) values(NULL);
-ERROR:  null value in column "test" of relation "atacc1" violates not-null constraint
-DETAIL:  Failing row contains (4, null).
--- try adding a second primary key (should fail)
-alter table atacc1 add constraint atacc_oid1 primary key(id);
-ERROR:  multiple primary keys for table "atacc1" are not allowed
--- drop first primary key constraint
-alter table atacc1 drop constraint atacc_test1 restrict;
--- try adding a primary key on oid (should succeed)
-alter table atacc1 add constraint atacc_oid1 primary key(id);
-drop table atacc1;
--- let's do one where the primary key constraint fails when added
-create table atacc1 ( test int );
--- insert soon to be failing rows
-insert into atacc1 (test) values (2);
-insert into atacc1 (test) values (2);
--- add a primary key (fails)
-alter table atacc1 add constraint atacc_test1 primary key (test);
-ERROR:  could not create unique index "atacc_test1"
-DETAIL:  Key (test)=(2) is duplicated.
-insert into atacc1 (test) values (3);
-drop table atacc1;
--- let's do another one where the primary key constraint fails when added
-create table atacc1 ( test int );
--- insert soon to be failing row
-insert into atacc1 (test) values (NULL);
--- add a primary key (fails)
-alter table atacc1 add constraint atacc_test1 primary key (test);
-ERROR:  column "test" of relation "atacc1" contains null values
-insert into atacc1 (test) values (3);
-drop table atacc1;
--- let's do one where the primary key constraint fails
--- because the column doesn't exist
-create table atacc1 ( test int );
--- add a primary key constraint (fails)
-alter table atacc1 add constraint atacc_test1 primary key (test1);
-ERROR:  column "test1" of relation "atacc1" does not exist
-drop table atacc1;
--- adding a new column as primary key to a non-empty table.
--- should fail unless the column has a non-null default value.
-create table atacc1 ( test int );
-insert into atacc1 (test) values (0);
--- add a primary key column without a default (fails).
-alter table atacc1 add column test2 int primary key;
-ERROR:  column "test2" of relation "atacc1" contains null values
--- now add a primary key column with a default (succeeds).
-alter table atacc1 add column test2 int default 0 primary key;
-drop table atacc1;
--- this combination used to have order-of-execution problems (bug #15580)
-create table atacc1 (a int);
-insert into atacc1 values(1);
-alter table atacc1
-  add column b float8 not null default random(),
-  add primary key(a);
-drop table atacc1;
--- additionally, we've seen issues with foreign key validation not being
--- properly delayed until after a table rewrite.  Check that works ok.
-create table atacc1 (a int primary key);
-alter table atacc1 add constraint atacc1_fkey foreign key (a) references atacc1 (a) not valid;
-alter table atacc1 validate constraint atacc1_fkey, alter a type bigint;
-drop table atacc1;
--- we've also seen issues with check constraints being validated at the wrong
--- time when there's a pending table rewrite.
-create table atacc1 (a bigint, b int);
-insert into atacc1 values(1,1);
-alter table atacc1 add constraint atacc1_chk check(b = 1) not valid;
-alter table atacc1 validate constraint atacc1_chk, alter a type int;
-drop table atacc1;
--- same as above, but ensure the constraint violation is detected
-create table atacc1 (a bigint, b int);
-insert into atacc1 values(1,2);
-alter table atacc1 add constraint atacc1_chk check(b = 1) not valid;
-alter table atacc1 validate constraint atacc1_chk, alter a type int;
-ERROR:  check constraint "atacc1_chk" of relation "atacc1" is violated by some row
-drop table atacc1;
--- something a little more complicated
-create table atacc1 ( test int, test2 int);
--- add a primary key constraint
-alter table atacc1 add constraint atacc_test1 primary key (test, test2);
--- try adding a second primary key - should fail
-alter table atacc1 add constraint atacc_test2 primary key (test);
-ERROR:  multiple primary keys for table "atacc1" are not allowed
--- insert initial value
-insert into atacc1 (test,test2) values (4,4);
--- should fail
-insert into atacc1 (test,test2) values (4,4);
-ERROR:  duplicate key value violates unique constraint "atacc_test1"
-DETAIL:  Key (test, test2)=(4, 4) already exists.
-insert into atacc1 (test,test2) values (NULL,3);
-ERROR:  null value in column "test" of relation "atacc1" violates not-null constraint
-DETAIL:  Failing row contains (null, 3).
-insert into atacc1 (test,test2) values (3, NULL);
-ERROR:  null value in column "test2" of relation "atacc1" violates not-null constraint
-DETAIL:  Failing row contains (3, null).
-insert into atacc1 (test,test2) values (NULL,NULL);
-ERROR:  null value in column "test" of relation "atacc1" violates not-null constraint
-DETAIL:  Failing row contains (null, null).
--- should all succeed
-insert into atacc1 (test,test2) values (4,5);
-insert into atacc1 (test,test2) values (5,4);
-insert into atacc1 (test,test2) values (5,5);
-drop table atacc1;
--- lets do some naming tests
-create table atacc1 (test int, test2 int, primary key(test));
--- only first should succeed
-insert into atacc1 (test2, test) values (3, 3);
-insert into atacc1 (test2, test) values (2, 3);
-ERROR:  duplicate key value violates unique constraint "atacc1_pkey"
-DETAIL:  Key (test)=(3) already exists.
-insert into atacc1 (test2, test) values (1, NULL);
-ERROR:  null value in column "test" of relation "atacc1" violates not-null constraint
-DETAIL:  Failing row contains (null, 1).
-drop table atacc1;
--- alter table / alter column [set/drop] not null tests
--- try altering system catalogs, should fail
-alter table pg_class alter column relname drop not null;
-ERROR:  permission denied: "pg_class" is a system catalog
-alter table pg_class alter relname set not null;
-ERROR:  permission denied: "pg_class" is a system catalog
--- try altering non-existent table, should fail
-alter table non_existent alter column bar set not null;
-ERROR:  relation "non_existent" does not exist
-alter table non_existent alter column bar drop not null;
-ERROR:  relation "non_existent" does not exist
--- test setting columns to null and not null and vice versa
--- test checking for null values and primary key
-create table atacc1 (test int not null);
-alter table atacc1 add constraint "atacc1_pkey" primary key (test);
-alter table atacc1 alter column test drop not null;
-ERROR:  column "test" is in a primary key
-alter table atacc1 drop constraint "atacc1_pkey";
-alter table atacc1 alter column test drop not null;
-insert into atacc1 values (null);
-alter table atacc1 alter test set not null;
-ERROR:  column "test" of relation "atacc1" contains null values
-delete from atacc1;
-alter table atacc1 alter test set not null;
--- try altering a non-existent column, should fail
-alter table atacc1 alter bar set not null;
-ERROR:  column "bar" of relation "atacc1" does not exist
-alter table atacc1 alter bar drop not null;
-ERROR:  column "bar" of relation "atacc1" does not exist
--- try creating a view and altering that, should fail
-create view myview as select * from atacc1;
-alter table myview alter column test drop not null;
-ERROR:  ALTER action ALTER COLUMN ... DROP NOT NULL cannot be performed on relation "myview"
-DETAIL:  This operation is not supported for views.
-alter table myview alter column test set not null;
-ERROR:  ALTER action ALTER COLUMN ... SET NOT NULL cannot be performed on relation "myview"
-DETAIL:  This operation is not supported for views.
-drop view myview;
-drop table atacc1;
--- set not null verified by constraints
-create table atacc1 (test_a int, test_b int);
-insert into atacc1 values (null, 1);
--- constraint not cover all values, should fail
-alter table atacc1 add constraint atacc1_constr_or check(test_a is not null or test_b < 10);
-alter table atacc1 alter test_a set not null;
-ERROR:  column "test_a" of relation "atacc1" contains null values
-alter table atacc1 drop constraint atacc1_constr_or;
--- not valid constraint, should fail
-alter table atacc1 add constraint atacc1_constr_invalid check(test_a is not null) not valid;
-alter table atacc1 alter test_a set not null;
-ERROR:  column "test_a" of relation "atacc1" contains null values
-alter table atacc1 drop constraint atacc1_constr_invalid;
--- with valid constraint
-update atacc1 set test_a = 1;
-alter table atacc1 add constraint atacc1_constr_a_valid check(test_a is not null);
-alter table atacc1 alter test_a set not null;
-delete from atacc1;
-insert into atacc1 values (2, null);
-alter table atacc1 alter test_a drop not null;
--- test multiple set not null at same time
--- test_a checked by atacc1_constr_a_valid, test_b should fail by table scan
-alter table atacc1 alter test_a set not null, alter test_b set not null;
-ERROR:  column "test_b" of relation "atacc1" contains null values
--- commands order has no importance
-alter table atacc1 alter test_b set not null, alter test_a set not null;
-ERROR:  column "test_b" of relation "atacc1" contains null values
--- valid one by table scan, one by check constraints
-update atacc1 set test_b = 1;
-alter table atacc1 alter test_b set not null, alter test_a set not null;
-alter table atacc1 alter test_a drop not null, alter test_b drop not null;
--- both column has check constraints
-alter table atacc1 add constraint atacc1_constr_b_valid check(test_b is not null);
-alter table atacc1 alter test_b set not null, alter test_a set not null;
-drop table atacc1;
--- test inheritance
-create table parent (a int);
-create table child (b varchar(255)) inherits (parent);
-alter table parent alter a set not null;
-insert into parent values (NULL);
-ERROR:  null value in column "a" of relation "parent" violates not-null constraint
-DETAIL:  Failing row contains (null).
-insert into child (a, b) values (NULL, 'foo');
-ERROR:  null value in column "a" of relation "child" violates not-null constraint
-DETAIL:  Failing row contains (null, foo).
-alter table parent alter a drop not null;
-insert into parent values (NULL);
-insert into child (a, b) values (NULL, 'foo');
-alter table only parent alter a set not null;
-ERROR:  column "a" of relation "parent" contains null values
-alter table child alter a set not null;
-ERROR:  column "a" of relation "child" contains null values
-delete from parent;
-alter table only parent alter a set not null;
-insert into parent values (NULL);
-ERROR:  null value in column "a" of relation "parent" violates not-null constraint
-DETAIL:  Failing row contains (null).
-alter table child alter a set not null;
-insert into child (a, b) values (NULL, 'foo');
-ERROR:  null value in column "a" of relation "child" violates not-null constraint
-DETAIL:  Failing row contains (null, foo).
-delete from child;
-alter table child alter a set not null;
-insert into child (a, b) values (NULL, 'foo');
-ERROR:  null value in column "a" of relation "child" violates not-null constraint
-DETAIL:  Failing row contains (null, foo).
-drop table child;
-drop table parent;
--- test setting and removing default values
-create table def_test (
-	c1	int4 default 5,
-	c2	text default 'initial_default'
-);
-insert into def_test default values;
-alter table def_test alter column c1 drop default;
-insert into def_test default values;
-alter table def_test alter column c2 drop default;
-insert into def_test default values;
-alter table def_test alter column c1 set default 10;
-alter table def_test alter column c2 set default 'new_default';
-insert into def_test default values;
-select * from def_test;
- c1 |       c2        
-----+-----------------
-  5 | initial_default
-    | initial_default
-    | 
- 10 | new_default
-(4 rows)
-
--- set defaults to an incorrect type: this should fail
-alter table def_test alter column c1 set default 'wrong_datatype';
-ERROR:  invalid input syntax for type integer: "wrong_datatype"
-alter table def_test alter column c2 set default 20;
--- set defaults on a non-existent column: this should fail
-alter table def_test alter column c3 set default 30;
-ERROR:  column "c3" of relation "def_test" does not exist
--- set defaults on views: we need to create a view, add a rule
--- to allow insertions into it, and then alter the view to add
--- a default
-create view def_view_test as select * from def_test;
-create rule def_view_test_ins as
-	on insert to def_view_test
-	do instead insert into def_test select new.*;
-insert into def_view_test default values;
-alter table def_view_test alter column c1 set default 45;
-insert into def_view_test default values;
-alter table def_view_test alter column c2 set default 'view_default';
-insert into def_view_test default values;
-select * from def_view_test;
- c1 |       c2        
-----+-----------------
-  5 | initial_default
-    | initial_default
-    | 
- 10 | new_default
-    | 
- 45 | 
- 45 | view_default
-(7 rows)
-
-drop rule def_view_test_ins on def_view_test;
-drop view def_view_test;
-drop table def_test;
--- alter table / drop column tests
--- try altering system catalogs, should fail
-alter table pg_class drop column relname;
-ERROR:  permission denied: "pg_class" is a system catalog
--- try altering non-existent table, should fail
-alter table nosuchtable drop column bar;
-ERROR:  relation "nosuchtable" does not exist
--- test dropping columns
-create table atacc1 (a int4 not null, b int4, c int4 not null, d int4);
-insert into atacc1 values (1, 2, 3, 4);
-alter table atacc1 drop a;
-alter table atacc1 drop a;
-ERROR:  column "a" of relation "atacc1" does not exist
--- SELECTs
-select * from atacc1;
- b | c | d 
----+---+---
- 2 | 3 | 4
-(1 row)
-
-select * from atacc1 order by a;
-ERROR:  column "a" does not exist
-LINE 1: select * from atacc1 order by a;
-                                      ^
-select * from atacc1 order by "........pg.dropped.1........";
-ERROR:  column "........pg.dropped.1........" does not exist
-LINE 1: select * from atacc1 order by "........pg.dropped.1........"...
-                                      ^
-select * from atacc1 group by a;
-ERROR:  column "a" does not exist
-LINE 1: select * from atacc1 group by a;
-                                      ^
-select * from atacc1 group by "........pg.dropped.1........";
-ERROR:  column "........pg.dropped.1........" does not exist
-LINE 1: select * from atacc1 group by "........pg.dropped.1........"...
-                                      ^
-select atacc1.* from atacc1;
- b | c | d 
----+---+---
- 2 | 3 | 4
-(1 row)
-
-select a from atacc1;
-ERROR:  column "a" does not exist
-LINE 1: select a from atacc1;
-               ^
-select atacc1.a from atacc1;
-ERROR:  column atacc1.a does not exist
-LINE 1: select atacc1.a from atacc1;
-               ^
-select b,c,d from atacc1;
- b | c | d 
----+---+---
- 2 | 3 | 4
-(1 row)
-
-select a,b,c,d from atacc1;
-ERROR:  column "a" does not exist
-LINE 1: select a,b,c,d from atacc1;
-               ^
-select * from atacc1 where a = 1;
-ERROR:  column "a" does not exist
-LINE 1: select * from atacc1 where a = 1;
-                                   ^
-select "........pg.dropped.1........" from atacc1;
-ERROR:  column "........pg.dropped.1........" does not exist
-LINE 1: select "........pg.dropped.1........" from atacc1;
-               ^
-select atacc1."........pg.dropped.1........" from atacc1;
-ERROR:  column atacc1.........pg.dropped.1........ does not exist
-LINE 1: select atacc1."........pg.dropped.1........" from atacc1;
-               ^
-select "........pg.dropped.1........",b,c,d from atacc1;
-ERROR:  column "........pg.dropped.1........" does not exist
-LINE 1: select "........pg.dropped.1........",b,c,d from atacc1;
-               ^
-select * from atacc1 where "........pg.dropped.1........" = 1;
-ERROR:  column "........pg.dropped.1........" does not exist
-LINE 1: select * from atacc1 where "........pg.dropped.1........" = ...
-                                   ^
--- UPDATEs
-update atacc1 set a = 3;
-ERROR:  column "a" of relation "atacc1" does not exist
-LINE 1: update atacc1 set a = 3;
-                          ^
-update atacc1 set b = 2 where a = 3;
-ERROR:  column "a" does not exist
-LINE 1: update atacc1 set b = 2 where a = 3;
-                                      ^
-update atacc1 set "........pg.dropped.1........" = 3;
-ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist
-LINE 1: update atacc1 set "........pg.dropped.1........" = 3;
-                          ^
-update atacc1 set b = 2 where "........pg.dropped.1........" = 3;
-ERROR:  column "........pg.dropped.1........" does not exist
-LINE 1: update atacc1 set b = 2 where "........pg.dropped.1........"...
-                                      ^
--- INSERTs
-insert into atacc1 values (10, 11, 12, 13);
-ERROR:  INSERT has more expressions than target columns
-LINE 1: insert into atacc1 values (10, 11, 12, 13);
-                                               ^
-insert into atacc1 values (default, 11, 12, 13);
-ERROR:  INSERT has more expressions than target columns
-LINE 1: insert into atacc1 values (default, 11, 12, 13);
-                                                    ^
-insert into atacc1 values (11, 12, 13);
-insert into atacc1 (a) values (10);
-ERROR:  column "a" of relation "atacc1" does not exist
-LINE 1: insert into atacc1 (a) values (10);
-                            ^
-insert into atacc1 (a) values (default);
-ERROR:  column "a" of relation "atacc1" does not exist
-LINE 1: insert into atacc1 (a) values (default);
-                            ^
-insert into atacc1 (a,b,c,d) values (10,11,12,13);
-ERROR:  column "a" of relation "atacc1" does not exist
-LINE 1: insert into atacc1 (a,b,c,d) values (10,11,12,13);
-                            ^
-insert into atacc1 (a,b,c,d) values (default,11,12,13);
-ERROR:  column "a" of relation "atacc1" does not exist
-LINE 1: insert into atacc1 (a,b,c,d) values (default,11,12,13);
-                            ^
-insert into atacc1 (b,c,d) values (11,12,13);
-insert into atacc1 ("........pg.dropped.1........") values (10);
-ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist
-LINE 1: insert into atacc1 ("........pg.dropped.1........") values (...
-                            ^
-insert into atacc1 ("........pg.dropped.1........") values (default);
-ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist
-LINE 1: insert into atacc1 ("........pg.dropped.1........") values (...
-                            ^
-insert into atacc1 ("........pg.dropped.1........",b,c,d) values (10,11,12,13);
-ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist
-LINE 1: insert into atacc1 ("........pg.dropped.1........",b,c,d) va...
-                            ^
-insert into atacc1 ("........pg.dropped.1........",b,c,d) values (default,11,12,13);
-ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist
-LINE 1: insert into atacc1 ("........pg.dropped.1........",b,c,d) va...
-                            ^
--- DELETEs
-delete from atacc1 where a = 3;
-ERROR:  column "a" does not exist
-LINE 1: delete from atacc1 where a = 3;
-                                 ^
-delete from atacc1 where "........pg.dropped.1........" = 3;
-ERROR:  column "........pg.dropped.1........" does not exist
-LINE 1: delete from atacc1 where "........pg.dropped.1........" = 3;
-                                 ^
-delete from atacc1;
--- try dropping a non-existent column, should fail
-alter table atacc1 drop bar;
-ERROR:  column "bar" of relation "atacc1" does not exist
--- try removing an oid column, should succeed (as it's nonexistent)
-alter table atacc1 SET WITHOUT OIDS;
--- try adding an oid column, should fail (not supported)
-alter table atacc1 SET WITH OIDS;
-ERROR:  syntax error at or near "WITH"
-LINE 1: alter table atacc1 SET WITH OIDS;
-                               ^
--- try dropping the xmin column, should fail
-alter table atacc1 drop xmin;
-ERROR:  cannot drop system column "xmin"
--- try creating a view and altering that, should fail
-create view myview as select * from atacc1;
-select * from myview;
- b | c | d 
----+---+---
-(0 rows)
-
-alter table myview drop d;
-ERROR:  ALTER action DROP COLUMN cannot be performed on relation "myview"
-DETAIL:  This operation is not supported for views.
-drop view myview;
--- test some commands to make sure they fail on the dropped column
-analyze atacc1(a);
-ERROR:  column "a" of relation "atacc1" does not exist
-analyze atacc1("........pg.dropped.1........");
-ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist
-vacuum analyze atacc1(a);
-ERROR:  column "a" of relation "atacc1" does not exist
-vacuum analyze atacc1("........pg.dropped.1........");
-ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist
-comment on column atacc1.a is 'testing';
-ERROR:  column "a" of relation "atacc1" does not exist
-comment on column atacc1."........pg.dropped.1........" is 'testing';
-ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist
-alter table atacc1 alter a set storage plain;
-ERROR:  column "a" of relation "atacc1" does not exist
-alter table atacc1 alter "........pg.dropped.1........" set storage plain;
-ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist
-alter table atacc1 alter a set statistics 0;
-ERROR:  column "a" of relation "atacc1" does not exist
-alter table atacc1 alter "........pg.dropped.1........" set statistics 0;
-ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist
-alter table atacc1 alter a set default 3;
-ERROR:  column "a" of relation "atacc1" does not exist
-alter table atacc1 alter "........pg.dropped.1........" set default 3;
-ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist
-alter table atacc1 alter a drop default;
-ERROR:  column "a" of relation "atacc1" does not exist
-alter table atacc1 alter "........pg.dropped.1........" drop default;
-ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist
-alter table atacc1 alter a set not null;
-ERROR:  column "a" of relation "atacc1" does not exist
-alter table atacc1 alter "........pg.dropped.1........" set not null;
-ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist
-alter table atacc1 alter a drop not null;
-ERROR:  column "a" of relation "atacc1" does not exist
-alter table atacc1 alter "........pg.dropped.1........" drop not null;
-ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist
-alter table atacc1 rename a to x;
-ERROR:  column "a" does not exist
-alter table atacc1 rename "........pg.dropped.1........" to x;
-ERROR:  column "........pg.dropped.1........" does not exist
-alter table atacc1 add primary key(a);
-ERROR:  column "a" of relation "atacc1" does not exist
-alter table atacc1 add primary key("........pg.dropped.1........");
-ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist
-alter table atacc1 add unique(a);
-ERROR:  column "a" named in key does not exist
-alter table atacc1 add unique("........pg.dropped.1........");
-ERROR:  column "........pg.dropped.1........" named in key does not exist
-alter table atacc1 add check (a > 3);
-ERROR:  column "a" does not exist
-alter table atacc1 add check ("........pg.dropped.1........" > 3);
-ERROR:  column "........pg.dropped.1........" does not exist
-create table atacc2 (id int4 unique);
-alter table atacc1 add foreign key (a) references atacc2(id);
-ERROR:  column "a" referenced in foreign key constraint does not exist
-alter table atacc1 add foreign key ("........pg.dropped.1........") references atacc2(id);
-ERROR:  column "........pg.dropped.1........" referenced in foreign key constraint does not exist
-alter table atacc2 add foreign key (id) references atacc1(a);
-ERROR:  column "a" referenced in foreign key constraint does not exist
-alter table atacc2 add foreign key (id) references atacc1("........pg.dropped.1........");
-ERROR:  column "........pg.dropped.1........" referenced in foreign key constraint does not exist
-drop table atacc2;
-create index "testing_idx" on atacc1(a);
-ERROR:  column "a" does not exist
-create index "testing_idx" on atacc1("........pg.dropped.1........");
-ERROR:  column "........pg.dropped.1........" does not exist
--- test create as and select into
-insert into atacc1 values (21, 22, 23);
-create table attest1 as select * from atacc1;
-select * from attest1;
- b  | c  | d  
-----+----+----
- 21 | 22 | 23
-(1 row)
-
-drop table attest1;
-select * into attest2 from atacc1;
-select * from attest2;
- b  | c  | d  
-----+----+----
- 21 | 22 | 23
-(1 row)
-
-drop table attest2;
--- try dropping all columns
-alter table atacc1 drop c;
-alter table atacc1 drop d;
-alter table atacc1 drop b;
-select * from atacc1;
---
-(1 row)
-
-drop table atacc1;
--- test constraint error reporting in presence of dropped columns
-create table atacc1 (id serial primary key, value int check (value < 10));
-insert into atacc1(value) values (100);
-ERROR:  new row for relation "atacc1" violates check constraint "atacc1_value_check"
-DETAIL:  Failing row contains (1, 100).
-alter table atacc1 drop column value;
-alter table atacc1 add column value int check (value < 10);
-insert into atacc1(value) values (100);
-ERROR:  new row for relation "atacc1" violates check constraint "atacc1_value_check"
-DETAIL:  Failing row contains (2, 100).
-insert into atacc1(id, value) values (null, 0);
-ERROR:  null value in column "id" of relation "atacc1" violates not-null constraint
-DETAIL:  Failing row contains (null, 0).
-drop table atacc1;
--- test inheritance
-create table parent (a int, b int, c int);
-insert into parent values (1, 2, 3);
-alter table parent drop a;
-create table child (d varchar(255)) inherits (parent);
-insert into child values (12, 13, 'testing');
-select * from parent;
- b  | c  
-----+----
-  2 |  3
- 12 | 13
-(2 rows)
-
-select * from child;
- b  | c  |    d    
-----+----+---------
- 12 | 13 | testing
-(1 row)
-
-alter table parent drop c;
-select * from parent;
- b  
-----
-  2
- 12
-(2 rows)
-
-select * from child;
- b  |    d    
-----+---------
- 12 | testing
-(1 row)
-
-drop table child;
-drop table parent;
--- check error cases for inheritance column merging
-create table parent (a float8, b numeric(10,4), c text collate "C");
-create table child (a float4) inherits (parent); -- fail
-NOTICE:  merging column "a" with inherited definition
-ERROR:  column "a" has a type conflict
-DETAIL:  double precision versus real
-create table child (b decimal(10,7)) inherits (parent); -- fail
-NOTICE:  moving and merging column "b" with inherited definition
-DETAIL:  User-specified column moved to the position of the inherited column.
-ERROR:  column "b" has a type conflict
-DETAIL:  numeric(10,4) versus numeric(10,7)
-create table child (c text collate "POSIX") inherits (parent); -- fail
-NOTICE:  moving and merging column "c" with inherited definition
-DETAIL:  User-specified column moved to the position of the inherited column.
-ERROR:  column "c" has a collation conflict
-DETAIL:  "C" versus "POSIX"
-create table child (a double precision, b decimal(10,4)) inherits (parent);
-NOTICE:  merging column "a" with inherited definition
-NOTICE:  merging column "b" with inherited definition
-drop table child;
-drop table parent;
--- test copy in/out
-create table attest (a int4, b int4, c int4);
-insert into attest values (1,2,3);
-alter table attest drop a;
-copy attest to stdout;
-2	3
-copy attest(a) to stdout;
-ERROR:  column "a" of relation "attest" does not exist
-copy attest("........pg.dropped.1........") to stdout;
-ERROR:  column "........pg.dropped.1........" of relation "attest" does not exist
-copy attest from stdin;
-ERROR:  extra data after last expected column
-CONTEXT:  COPY attest, line 1: "10	11	12"
-select * from attest;
- b | c 
----+---
- 2 | 3
-(1 row)
-
-copy attest from stdin;
-select * from attest;
- b  | c  
-----+----
-  2 |  3
- 21 | 22
-(2 rows)
-
-copy attest(a) from stdin;
-ERROR:  column "a" of relation "attest" does not exist
-copy attest("........pg.dropped.1........") from stdin;
-ERROR:  column "........pg.dropped.1........" of relation "attest" does not exist
-copy attest(b,c) from stdin;
-select * from attest;
- b  | c  
-----+----
-  2 |  3
- 21 | 22
- 31 | 32
-(3 rows)
-
-drop table attest;
--- test inheritance
-create table dropColumn (a int, b int, e int);
-create table dropColumnChild (c int) inherits (dropColumn);
-create table dropColumnAnother (d int) inherits (dropColumnChild);
--- these two should fail
-alter table dropColumnchild drop column a;
-ERROR:  cannot drop inherited column "a"
-alter table only dropColumnChild drop column b;
-ERROR:  cannot drop inherited column "b"
--- these three should work
-alter table only dropColumn drop column e;
-alter table dropColumnChild drop column c;
-alter table dropColumn drop column a;
-create table renameColumn (a int);
-create table renameColumnChild (b int) inherits (renameColumn);
-create table renameColumnAnother (c int) inherits (renameColumnChild);
--- these three should fail
-alter table renameColumnChild rename column a to d;
-ERROR:  cannot rename inherited column "a"
-alter table only renameColumnChild rename column a to d;
-ERROR:  inherited column "a" must be renamed in child tables too
-alter table only renameColumn rename column a to d;
-ERROR:  inherited column "a" must be renamed in child tables too
--- these should work
-alter table renameColumn rename column a to d;
-alter table renameColumnChild rename column b to a;
--- these should work
-alter table if exists doesnt_exist_tab rename column a to d;
-NOTICE:  relation "doesnt_exist_tab" does not exist, skipping
-alter table if exists doesnt_exist_tab rename column b to a;
-NOTICE:  relation "doesnt_exist_tab" does not exist, skipping
--- this should work
-alter table renameColumn add column w int;
--- this should fail
-alter table only renameColumn add column x int;
-ERROR:  column must be added to child tables too
--- Test corner cases in dropping of inherited columns
-create table p1 (f1 int, f2 int);
-create table c1 (f1 int not null) inherits(p1);
-NOTICE:  merging column "f1" with inherited definition
--- should be rejected since c1.f1 is inherited
-alter table c1 drop column f1;
-ERROR:  cannot drop inherited column "f1"
--- should work
-alter table p1 drop column f1;
--- c1.f1 is still there, but no longer inherited
-select f1 from c1;
- f1 
-----
-(0 rows)
-
-alter table c1 drop column f1;
-select f1 from c1;
-ERROR:  column "f1" does not exist
-LINE 1: select f1 from c1;
-               ^
-HINT:  Perhaps you meant to reference the column "c1.f2".
-drop table p1 cascade;
-NOTICE:  drop cascades to table c1
-create table p1 (f1 int, f2 int);
-create table c1 () inherits(p1);
--- should be rejected since c1.f1 is inherited
-alter table c1 drop column f1;
-ERROR:  cannot drop inherited column "f1"
-alter table p1 drop column f1;
--- c1.f1 is dropped now, since there is no local definition for it
-select f1 from c1;
-ERROR:  column "f1" does not exist
-LINE 1: select f1 from c1;
-               ^
-HINT:  Perhaps you meant to reference the column "c1.f2".
-drop table p1 cascade;
-NOTICE:  drop cascades to table c1
-create table p1 (f1 int, f2 int);
-create table c1 () inherits(p1);
--- should be rejected since c1.f1 is inherited
-alter table c1 drop column f1;
-ERROR:  cannot drop inherited column "f1"
-alter table only p1 drop column f1;
--- c1.f1 is NOT dropped, but must now be considered non-inherited
-alter table c1 drop column f1;
-drop table p1 cascade;
-NOTICE:  drop cascades to table c1
-create table p1 (f1 int, f2 int);
-create table c1 (f1 int not null) inherits(p1);
-NOTICE:  merging column "f1" with inherited definition
--- should be rejected since c1.f1 is inherited
-alter table c1 drop column f1;
-ERROR:  cannot drop inherited column "f1"
-alter table only p1 drop column f1;
--- c1.f1 is still there, but no longer inherited
-alter table c1 drop column f1;
-drop table p1 cascade;
-NOTICE:  drop cascades to table c1
-create table p1(id int, name text);
-create table p2(id2 int, name text, height int);
-create table c1(age int) inherits(p1,p2);
-NOTICE:  merging multiple inherited definitions of column "name"
-create table gc1() inherits (c1);
-select relname, attname, attinhcount, attislocal
-from pg_class join pg_attribute on (pg_class.oid = pg_attribute.attrelid)
-where relname in ('p1','p2','c1','gc1') and attnum > 0 and not attisdropped
-order by relname, attnum;
- relname | attname | attinhcount | attislocal 
----------+---------+-------------+------------
- c1      | id      |           1 | f
- c1      | name    |           2 | f
- c1      | id2     |           1 | f
- c1      | height  |           1 | f
- c1      | age     |           0 | t
- gc1     | id      |           1 | f
- gc1     | name    |           1 | f
- gc1     | id2     |           1 | f
- gc1     | height  |           1 | f
- gc1     | age     |           1 | f
- p1      | id      |           0 | t
- p1      | name    |           0 | t
- p2      | id2     |           0 | t
- p2      | name    |           0 | t
- p2      | height  |           0 | t
-(15 rows)
-
--- should work
-alter table only p1 drop column name;
--- should work. Now c1.name is local and inhcount is 0.
-alter table p2 drop column name;
--- should be rejected since its inherited
-alter table gc1 drop column name;
-ERROR:  cannot drop inherited column "name"
--- should work, and drop gc1.name along
-alter table c1 drop column name;
--- should fail: column does not exist
-alter table gc1 drop column name;
-ERROR:  column "name" of relation "gc1" does not exist
--- should work and drop the attribute in all tables
-alter table p2 drop column height;
--- IF EXISTS test
-create table dropColumnExists ();
-alter table dropColumnExists drop column non_existing; --fail
-ERROR:  column "non_existing" of relation "dropcolumnexists" does not exist
-alter table dropColumnExists drop column if exists non_existing; --succeed
-NOTICE:  column "non_existing" of relation "dropcolumnexists" does not exist, skipping
-select relname, attname, attinhcount, attislocal
-from pg_class join pg_attribute on (pg_class.oid = pg_attribute.attrelid)
-where relname in ('p1','p2','c1','gc1') and attnum > 0 and not attisdropped
-order by relname, attnum;
- relname | attname | attinhcount | attislocal 
----------+---------+-------------+------------
- c1      | id      |           1 | f
- c1      | id2     |           1 | f
- c1      | age     |           0 | t
- gc1     | id      |           1 | f
- gc1     | id2     |           1 | f
- gc1     | age     |           1 | f
- p1      | id      |           0 | t
- p2      | id2     |           0 | t
-(8 rows)
-
-drop table p1, p2 cascade;
-NOTICE:  drop cascades to 2 other objects
-DETAIL:  drop cascades to table c1
-drop cascades to table gc1
--- test attinhcount tracking with merged columns
-create table depth0();
-create table depth1(c text) inherits (depth0);
-create table depth2() inherits (depth1);
-alter table depth0 add c text;
-NOTICE:  merging definition of column "c" for child "depth1"
-select attrelid::regclass, attname, attinhcount, attislocal
-from pg_attribute
-where attnum > 0 and attrelid::regclass in ('depth0', 'depth1', 'depth2')
-order by attrelid::regclass::text, attnum;
- attrelid | attname | attinhcount | attislocal 
-----------+---------+-------------+------------
- depth0   | c       |           0 | t
- depth1   | c       |           1 | t
- depth2   | c       |           1 | f
-(3 rows)
-
--- test renumbering of child-table columns in inherited operations
-create table p1 (f1 int);
-create table c1 (f2 text, f3 int) inherits (p1);
-alter table p1 add column a1 int check (a1 > 0);
-alter table p1 add column f2 text;
-NOTICE:  merging definition of column "f2" for child "c1"
-insert into p1 values (1,2,'abc');
-insert into c1 values(11,'xyz',33,0); -- should fail
-ERROR:  new row for relation "c1" violates check constraint "p1_a1_check"
-DETAIL:  Failing row contains (11, xyz, 33, 0).
-insert into c1 values(11,'xyz',33,22);
-select * from p1;
- f1 | a1 | f2  
-----+----+-----
-  1 |  2 | abc
- 11 | 22 | xyz
-(2 rows)
-
-update p1 set a1 = a1 + 1, f2 = upper(f2);
-select * from p1;
- f1 | a1 | f2  
-----+----+-----
-  1 |  3 | ABC
- 11 | 23 | XYZ
-(2 rows)
-
-drop table p1 cascade;
-NOTICE:  drop cascades to table c1
--- test that operations with a dropped column do not try to reference
--- its datatype
-create domain mytype as text;
-create temp table foo (f1 text, f2 mytype, f3 text);
-insert into foo values('bb','cc','dd');
-select * from foo;
- f1 | f2 | f3 
-----+----+----
- bb | cc | dd
-(1 row)
-
-drop domain mytype cascade;
-NOTICE:  drop cascades to column f2 of table foo
-select * from foo;
- f1 | f3 
-----+----
- bb | dd
-(1 row)
-
-insert into foo values('qq','rr');
-select * from foo;
- f1 | f3 
-----+----
- bb | dd
- qq | rr
-(2 rows)
-
-update foo set f3 = 'zz';
-select * from foo;
- f1 | f3 
-----+----
- bb | zz
- qq | zz
-(2 rows)
-
-select f3,max(f1) from foo group by f3;
- f3 | max 
-----+-----
- zz | qq
-(1 row)
-
--- Simple tests for alter table column type
-alter table foo alter f1 TYPE integer; -- fails
-ERROR:  column "f1" cannot be cast automatically to type integer
-HINT:  You might need to specify "USING f1::integer".
-alter table foo alter f1 TYPE varchar(10);
-create table anothertab (atcol1 serial8, atcol2 boolean,
-	constraint anothertab_chk check (atcol1 <= 3));
-insert into anothertab (atcol1, atcol2) values (default, true);
-insert into anothertab (atcol1, atcol2) values (default, false);
-select * from anothertab;
- atcol1 | atcol2 
---------+--------
-      1 | t
-      2 | f
-(2 rows)
-
-alter table anothertab alter column atcol1 type boolean; -- fails
-ERROR:  column "atcol1" cannot be cast automatically to type boolean
-HINT:  You might need to specify "USING atcol1::boolean".
-alter table anothertab alter column atcol1 type boolean using atcol1::int; -- fails
-ERROR:  result of USING clause for column "atcol1" cannot be cast automatically to type boolean
-HINT:  You might need to add an explicit cast.
-alter table anothertab alter column atcol1 type integer;
-select * from anothertab;
- atcol1 | atcol2 
---------+--------
-      1 | t
-      2 | f
-(2 rows)
-
-insert into anothertab (atcol1, atcol2) values (45, null); -- fails
-ERROR:  new row for relation "anothertab" violates check constraint "anothertab_chk"
-DETAIL:  Failing row contains (45, null).
-insert into anothertab (atcol1, atcol2) values (default, null);
-select * from anothertab;
- atcol1 | atcol2 
---------+--------
-      1 | t
-      2 | f
-      3 | 
-(3 rows)
-
-alter table anothertab alter column atcol2 type text
-      using case when atcol2 is true then 'IT WAS TRUE'
-                 when atcol2 is false then 'IT WAS FALSE'
-                 else 'IT WAS NULL!' end;
-select * from anothertab;
- atcol1 |    atcol2    
---------+--------------
-      1 | IT WAS TRUE
-      2 | IT WAS FALSE
-      3 | IT WAS NULL!
-(3 rows)
-
-alter table anothertab alter column atcol1 type boolean
-        using case when atcol1 % 2 = 0 then true else false end; -- fails
-ERROR:  default for column "atcol1" cannot be cast automatically to type boolean
-alter table anothertab alter column atcol1 drop default;
-alter table anothertab alter column atcol1 type boolean
-        using case when atcol1 % 2 = 0 then true else false end; -- fails
-ERROR:  operator does not exist: boolean <= integer
-HINT:  No operator matches the given name and argument types. You might need to add explicit type casts.
-alter table anothertab drop constraint anothertab_chk;
-alter table anothertab drop constraint anothertab_chk; -- fails
-ERROR:  constraint "anothertab_chk" of relation "anothertab" does not exist
-alter table anothertab drop constraint IF EXISTS anothertab_chk; -- succeeds
-NOTICE:  constraint "anothertab_chk" of relation "anothertab" does not exist, skipping
-alter table anothertab alter column atcol1 type boolean
-        using case when atcol1 % 2 = 0 then true else false end;
-select * from anothertab;
- atcol1 |    atcol2    
---------+--------------
- f      | IT WAS TRUE
- t      | IT WAS FALSE
- f      | IT WAS NULL!
-(3 rows)
-
-drop table anothertab;
--- Test index handling in alter table column type (cf. bugs #15835, #15865)
-create table anothertab(f1 int primary key, f2 int unique,
-                        f3 int, f4 int, f5 int);
-alter table anothertab
-  add exclude using btree (f3 with =);
-alter table anothertab
-  add exclude using btree (f4 with =) where (f4 is not null);
-alter table anothertab
-  add exclude using btree (f4 with =) where (f5 > 0);
-alter table anothertab
-  add unique(f1,f4);
-create index on anothertab(f2,f3);
-create unique index on anothertab(f4);
-\d anothertab
-             Table "public.anothertab"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- f1     | integer |           | not null | 
- f2     | integer |           |          | 
- f3     | integer |           |          | 
- f4     | integer |           |          | 
- f5     | integer |           |          | 
-Indexes:
-    "anothertab_pkey" PRIMARY KEY, btree (f1)
-    "anothertab_f1_f4_key" UNIQUE CONSTRAINT, btree (f1, f4)
-    "anothertab_f2_f3_idx" btree (f2, f3)
-    "anothertab_f2_key" UNIQUE CONSTRAINT, btree (f2)
-    "anothertab_f3_excl" EXCLUDE USING btree (f3 WITH =)
-    "anothertab_f4_excl" EXCLUDE USING btree (f4 WITH =) WHERE (f4 IS NOT NULL)
-    "anothertab_f4_excl1" EXCLUDE USING btree (f4 WITH =) WHERE (f5 > 0)
-    "anothertab_f4_idx" UNIQUE, btree (f4)
-
-alter table anothertab alter column f1 type bigint;
-alter table anothertab
-  alter column f2 type bigint,
-  alter column f3 type bigint,
-  alter column f4 type bigint;
-alter table anothertab alter column f5 type bigint;
-\d anothertab
-            Table "public.anothertab"
- Column |  Type  | Collation | Nullable | Default 
---------+--------+-----------+----------+---------
- f1     | bigint |           | not null | 
- f2     | bigint |           |          | 
- f3     | bigint |           |          | 
- f4     | bigint |           |          | 
- f5     | bigint |           |          | 
-Indexes:
-    "anothertab_pkey" PRIMARY KEY, btree (f1)
-    "anothertab_f1_f4_key" UNIQUE CONSTRAINT, btree (f1, f4)
-    "anothertab_f2_f3_idx" btree (f2, f3)
-    "anothertab_f2_key" UNIQUE CONSTRAINT, btree (f2)
-    "anothertab_f3_excl" EXCLUDE USING btree (f3 WITH =)
-    "anothertab_f4_excl" EXCLUDE USING btree (f4 WITH =) WHERE (f4 IS NOT NULL)
-    "anothertab_f4_excl1" EXCLUDE USING btree (f4 WITH =) WHERE (f5 > 0)
-    "anothertab_f4_idx" UNIQUE, btree (f4)
-
-drop table anothertab;
--- test that USING expressions are parsed before column alter type / drop steps
-create table another (f1 int, f2 text, f3 text);
-insert into another values(1, 'one', 'uno');
-insert into another values(2, 'two', 'due');
-insert into another values(3, 'three', 'tre');
-select * from another;
- f1 |  f2   | f3  
-----+-------+-----
-  1 | one   | uno
-  2 | two   | due
-  3 | three | tre
-(3 rows)
-
-alter table another
-  alter f1 type text using f2 || ' and ' || f3 || ' more',
-  alter f2 type bigint using f1 * 10,
-  drop column f3;
-select * from another;
-         f1         | f2 
---------------------+----
- one and uno more   | 10
- two and due more   | 20
- three and tre more | 30
-(3 rows)
-
-drop table another;
--- Create an index that skips WAL, then perform a SET DATA TYPE that skips
--- rewriting the index.
-begin;
-create table skip_wal_skip_rewrite_index (c varchar(10) primary key);
-alter table skip_wal_skip_rewrite_index alter c type varchar(20);
-commit;
--- table's row type
-create table tab1 (a int, b text);
-create table tab2 (x int, y tab1);
-alter table tab1 alter column b type varchar; -- fails
-ERROR:  cannot alter table "tab1" because column "tab2.y" uses its row type
--- Alter column type that's part of a partitioned index
-create table at_partitioned (a int, b text) partition by range (a);
-create table at_part_1 partition of at_partitioned for values from (0) to (1000);
-insert into at_partitioned values (512, '0.123');
-create table at_part_2 (b text, a int);
-insert into at_part_2 values ('1.234', 1024);
-create index on at_partitioned (b);
-create index on at_partitioned (a);
-\d at_part_1
-             Table "public.at_part_1"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
- b      | text    |           |          | 
-Partition of: at_partitioned FOR VALUES FROM (0) TO (1000)
-Indexes:
-    "at_part_1_a_idx" btree (a)
-    "at_part_1_b_idx" btree (b)
-
-\d at_part_2
-             Table "public.at_part_2"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- b      | text    |           |          | 
- a      | integer |           |          | 
-
-alter table at_partitioned attach partition at_part_2 for values from (1000) to (2000);
-\d at_part_2
-             Table "public.at_part_2"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- b      | text    |           |          | 
- a      | integer |           |          | 
-Partition of: at_partitioned FOR VALUES FROM (1000) TO (2000)
-Indexes:
-    "at_part_2_a_idx" btree (a)
-    "at_part_2_b_idx" btree (b)
-
-alter table at_partitioned alter column b type numeric using b::numeric;
-\d at_part_1
-             Table "public.at_part_1"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
- b      | numeric |           |          | 
-Partition of: at_partitioned FOR VALUES FROM (0) TO (1000)
-Indexes:
-    "at_part_1_a_idx" btree (a)
-    "at_part_1_b_idx" btree (b)
-
-\d at_part_2
-             Table "public.at_part_2"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- b      | numeric |           |          | 
- a      | integer |           |          | 
-Partition of: at_partitioned FOR VALUES FROM (1000) TO (2000)
-Indexes:
-    "at_part_2_a_idx" btree (a)
-    "at_part_2_b_idx" btree (b)
-
-drop table at_partitioned;
--- Alter column type when no table rewrite is required
--- Also check that comments are preserved
-create table at_partitioned(id int, name varchar(64), unique (id, name))
-  partition by hash(id);
-comment on constraint at_partitioned_id_name_key on at_partitioned is 'parent constraint';
-comment on index at_partitioned_id_name_key is 'parent index';
-create table at_partitioned_0 partition of at_partitioned
-  for values with (modulus 2, remainder 0);
-comment on constraint at_partitioned_0_id_name_key on at_partitioned_0 is 'child 0 constraint';
-comment on index at_partitioned_0_id_name_key is 'child 0 index';
-create table at_partitioned_1 partition of at_partitioned
-  for values with (modulus 2, remainder 1);
-comment on constraint at_partitioned_1_id_name_key on at_partitioned_1 is 'child 1 constraint';
-comment on index at_partitioned_1_id_name_key is 'child 1 index';
-insert into at_partitioned values(1, 'foo');
-insert into at_partitioned values(3, 'bar');
-create temp table old_oids as
-  select relname, oid as oldoid, relfilenode as oldfilenode
-  from pg_class where relname like 'at_partitioned%';
-select relname,
-  c.oid = oldoid as orig_oid,
-  case relfilenode
-    when 0 then 'none'
-    when c.oid then 'own'
-    when oldfilenode then 'orig'
-    else 'OTHER'
-    end as storage,
-  obj_description(c.oid, 'pg_class') as desc
-  from pg_class c left join old_oids using (relname)
-  where relname like 'at_partitioned%'
-  order by relname;
-           relname            | orig_oid | storage |     desc      
-------------------------------+----------+---------+---------------
- at_partitioned               | t        | none    | 
- at_partitioned_0             | t        | own     | 
- at_partitioned_0_id_name_key | t        | own     | child 0 index
- at_partitioned_1             | t        | own     | 
- at_partitioned_1_id_name_key | t        | own     | child 1 index
- at_partitioned_id_name_key   | t        | none    | parent index
-(6 rows)
-
-select conname, obj_description(oid, 'pg_constraint') as desc
-  from pg_constraint where conname like 'at_partitioned%'
-  order by conname;
-           conname            |        desc        
-------------------------------+--------------------
- at_partitioned_0_id_name_key | child 0 constraint
- at_partitioned_1_id_name_key | child 1 constraint
- at_partitioned_id_name_key   | parent constraint
-(3 rows)
-
-alter table at_partitioned alter column name type varchar(127);
--- Note: these tests currently show the wrong behavior for comments :-(
-select relname,
-  c.oid = oldoid as orig_oid,
-  case relfilenode
-    when 0 then 'none'
-    when c.oid then 'own'
-    when oldfilenode then 'orig'
-    else 'OTHER'
-    end as storage,
-  obj_description(c.oid, 'pg_class') as desc
-  from pg_class c left join old_oids using (relname)
-  where relname like 'at_partitioned%'
-  order by relname;
-           relname            | orig_oid | storage |     desc     
-------------------------------+----------+---------+--------------
- at_partitioned               | t        | none    | 
- at_partitioned_0             | t        | own     | 
- at_partitioned_0_id_name_key | f        | own     | parent index
- at_partitioned_1             | t        | own     | 
- at_partitioned_1_id_name_key | f        | own     | parent index
- at_partitioned_id_name_key   | f        | none    | parent index
-(6 rows)
-
-select conname, obj_description(oid, 'pg_constraint') as desc
-  from pg_constraint where conname like 'at_partitioned%'
-  order by conname;
-           conname            |       desc        
-------------------------------+-------------------
- at_partitioned_0_id_name_key | 
- at_partitioned_1_id_name_key | 
- at_partitioned_id_name_key   | parent constraint
-(3 rows)
-
--- Don't remove this DROP, it exposes bug #15672
-drop table at_partitioned;
--- disallow recursive containment of row types
-create temp table recur1 (f1 int);
-alter table recur1 add column f2 recur1; -- fails
-ERROR:  composite type recur1 cannot be made a member of itself
-alter table recur1 add column f2 recur1[]; -- fails
-ERROR:  composite type recur1 cannot be made a member of itself
-create domain array_of_recur1 as recur1[];
-alter table recur1 add column f2 array_of_recur1; -- fails
-ERROR:  composite type recur1 cannot be made a member of itself
-create temp table recur2 (f1 int, f2 recur1);
-alter table recur1 add column f2 recur2; -- fails
-ERROR:  composite type recur1 cannot be made a member of itself
-alter table recur1 add column f2 int;
-alter table recur1 alter column f2 type recur2; -- fails
-ERROR:  composite type recur1 cannot be made a member of itself
--- SET STORAGE may need to add a TOAST table
-create table test_storage (a text);
-alter table test_storage alter a set storage plain;
-alter table test_storage add b int default 0; -- rewrite table to remove its TOAST table
-alter table test_storage alter a set storage extended; -- re-add TOAST table
-select reltoastrelid <> 0 as has_toast_table
-from pg_class
-where oid = 'test_storage'::regclass;
- has_toast_table 
------------------
- t
-(1 row)
-
--- test that SET STORAGE propagates to index correctly
-create index test_storage_idx on test_storage (b, a);
-alter table test_storage alter column a set storage external;
-\d+ test_storage
-                                Table "public.test_storage"
- Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
---------+---------+-----------+----------+---------+----------+--------------+-------------
- a      | text    |           |          |         | external |              | 
- b      | integer |           |          | 0       | plain    |              | 
-Indexes:
-    "test_storage_idx" btree (b, a)
-
-\d+ test_storage_idx
-                Index "public.test_storage_idx"
- Column |  Type   | Key? | Definition | Storage  | Stats target 
---------+---------+------+------------+----------+--------------
- b      | integer | yes  | b          | plain    | 
- a      | text    | yes  | a          | external | 
-btree, for table "public.test_storage"
-
--- ALTER COLUMN TYPE with a check constraint and a child table (bug #13779)
-CREATE TABLE test_inh_check (a float check (a > 10.2), b float);
-CREATE TABLE test_inh_check_child() INHERITS(test_inh_check);
-\d test_inh_check
-               Table "public.test_inh_check"
- Column |       Type       | Collation | Nullable | Default 
---------+------------------+-----------+----------+---------
- a      | double precision |           |          | 
- b      | double precision |           |          | 
-Check constraints:
-    "test_inh_check_a_check" CHECK (a > 10.2::double precision)
-Number of child tables: 1 (Use \d+ to list them.)
-
-\d test_inh_check_child
-            Table "public.test_inh_check_child"
- Column |       Type       | Collation | Nullable | Default 
---------+------------------+-----------+----------+---------
- a      | double precision |           |          | 
- b      | double precision |           |          | 
-Check constraints:
-    "test_inh_check_a_check" CHECK (a > 10.2::double precision)
-Inherits: test_inh_check
-
-select relname, conname, coninhcount, conislocal, connoinherit
-  from pg_constraint c, pg_class r
-  where relname like 'test_inh_check%' and c.conrelid = r.oid
-  order by 1, 2;
-       relname        |        conname         | coninhcount | conislocal | connoinherit 
-----------------------+------------------------+-------------+------------+--------------
- test_inh_check       | test_inh_check_a_check |           0 | t          | f
- test_inh_check_child | test_inh_check_a_check |           1 | f          | f
-(2 rows)
-
-ALTER TABLE test_inh_check ALTER COLUMN a TYPE numeric;
-\d test_inh_check
-               Table "public.test_inh_check"
- Column |       Type       | Collation | Nullable | Default 
---------+------------------+-----------+----------+---------
- a      | numeric          |           |          | 
- b      | double precision |           |          | 
-Check constraints:
-    "test_inh_check_a_check" CHECK (a::double precision > 10.2::double precision)
-Number of child tables: 1 (Use \d+ to list them.)
-
-\d test_inh_check_child
-            Table "public.test_inh_check_child"
- Column |       Type       | Collation | Nullable | Default 
---------+------------------+-----------+----------+---------
- a      | numeric          |           |          | 
- b      | double precision |           |          | 
-Check constraints:
-    "test_inh_check_a_check" CHECK (a::double precision > 10.2::double precision)
-Inherits: test_inh_check
-
-select relname, conname, coninhcount, conislocal, connoinherit
-  from pg_constraint c, pg_class r
-  where relname like 'test_inh_check%' and c.conrelid = r.oid
-  order by 1, 2;
-       relname        |        conname         | coninhcount | conislocal | connoinherit 
-----------------------+------------------------+-------------+------------+--------------
- test_inh_check       | test_inh_check_a_check |           0 | t          | f
- test_inh_check_child | test_inh_check_a_check |           1 | f          | f
-(2 rows)
-
--- also try noinherit, local, and local+inherited cases
-ALTER TABLE test_inh_check ADD CONSTRAINT bnoinherit CHECK (b > 100) NO INHERIT;
-ALTER TABLE test_inh_check_child ADD CONSTRAINT blocal CHECK (b < 1000);
-ALTER TABLE test_inh_check_child ADD CONSTRAINT bmerged CHECK (b > 1);
-ALTER TABLE test_inh_check ADD CONSTRAINT bmerged CHECK (b > 1);
-NOTICE:  merging constraint "bmerged" with inherited definition
-\d test_inh_check
-               Table "public.test_inh_check"
- Column |       Type       | Collation | Nullable | Default 
---------+------------------+-----------+----------+---------
- a      | numeric          |           |          | 
- b      | double precision |           |          | 
-Check constraints:
-    "bmerged" CHECK (b > 1::double precision)
-    "bnoinherit" CHECK (b > 100::double precision) NO INHERIT
-    "test_inh_check_a_check" CHECK (a::double precision > 10.2::double precision)
-Number of child tables: 1 (Use \d+ to list them.)
-
-\d test_inh_check_child
-            Table "public.test_inh_check_child"
- Column |       Type       | Collation | Nullable | Default 
---------+------------------+-----------+----------+---------
- a      | numeric          |           |          | 
- b      | double precision |           |          | 
-Check constraints:
-    "blocal" CHECK (b < 1000::double precision)
-    "bmerged" CHECK (b > 1::double precision)
-    "test_inh_check_a_check" CHECK (a::double precision > 10.2::double precision)
-Inherits: test_inh_check
-
-select relname, conname, coninhcount, conislocal, connoinherit
-  from pg_constraint c, pg_class r
-  where relname like 'test_inh_check%' and c.conrelid = r.oid
-  order by 1, 2;
-       relname        |        conname         | coninhcount | conislocal | connoinherit 
-----------------------+------------------------+-------------+------------+--------------
- test_inh_check       | bmerged                |           0 | t          | f
- test_inh_check       | bnoinherit             |           0 | t          | t
- test_inh_check       | test_inh_check_a_check |           0 | t          | f
- test_inh_check_child | blocal                 |           0 | t          | f
- test_inh_check_child | bmerged                |           1 | t          | f
- test_inh_check_child | test_inh_check_a_check |           1 | f          | f
-(6 rows)
-
-ALTER TABLE test_inh_check ALTER COLUMN b TYPE numeric;
-NOTICE:  merging constraint "bmerged" with inherited definition
-\d test_inh_check
-           Table "public.test_inh_check"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | numeric |           |          | 
- b      | numeric |           |          | 
-Check constraints:
-    "bmerged" CHECK (b::double precision > 1::double precision)
-    "bnoinherit" CHECK (b::double precision > 100::double precision) NO INHERIT
-    "test_inh_check_a_check" CHECK (a::double precision > 10.2::double precision)
-Number of child tables: 1 (Use \d+ to list them.)
-
-\d test_inh_check_child
-        Table "public.test_inh_check_child"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | numeric |           |          | 
- b      | numeric |           |          | 
-Check constraints:
-    "blocal" CHECK (b::double precision < 1000::double precision)
-    "bmerged" CHECK (b::double precision > 1::double precision)
-    "test_inh_check_a_check" CHECK (a::double precision > 10.2::double precision)
-Inherits: test_inh_check
-
-select relname, conname, coninhcount, conislocal, connoinherit
-  from pg_constraint c, pg_class r
-  where relname like 'test_inh_check%' and c.conrelid = r.oid
-  order by 1, 2;
-       relname        |        conname         | coninhcount | conislocal | connoinherit 
-----------------------+------------------------+-------------+------------+--------------
- test_inh_check       | bmerged                |           0 | t          | f
- test_inh_check       | bnoinherit             |           0 | t          | t
- test_inh_check       | test_inh_check_a_check |           0 | t          | f
- test_inh_check_child | blocal                 |           0 | t          | f
- test_inh_check_child | bmerged                |           1 | t          | f
- test_inh_check_child | test_inh_check_a_check |           1 | f          | f
-(6 rows)
-
--- ALTER COLUMN TYPE with different schema in children
--- Bug at https://postgr.es/m/20170102225618.GA10071@telsasoft.com
-CREATE TABLE test_type_diff (f1 int);
-CREATE TABLE test_type_diff_c (extra smallint) INHERITS (test_type_diff);
-ALTER TABLE test_type_diff ADD COLUMN f2 int;
-INSERT INTO test_type_diff_c VALUES (1, 2, 3);
-ALTER TABLE test_type_diff ALTER COLUMN f2 TYPE bigint USING f2::bigint;
-CREATE TABLE test_type_diff2 (int_two int2, int_four int4, int_eight int8);
-CREATE TABLE test_type_diff2_c1 (int_four int4, int_eight int8, int_two int2);
-CREATE TABLE test_type_diff2_c2 (int_eight int8, int_two int2, int_four int4);
-CREATE TABLE test_type_diff2_c3 (int_two int2, int_four int4, int_eight int8);
-ALTER TABLE test_type_diff2_c1 INHERIT test_type_diff2;
-ALTER TABLE test_type_diff2_c2 INHERIT test_type_diff2;
-ALTER TABLE test_type_diff2_c3 INHERIT test_type_diff2;
-INSERT INTO test_type_diff2_c1 VALUES (1, 2, 3);
-INSERT INTO test_type_diff2_c2 VALUES (4, 5, 6);
-INSERT INTO test_type_diff2_c3 VALUES (7, 8, 9);
-ALTER TABLE test_type_diff2 ALTER COLUMN int_four TYPE int8 USING int_four::int8;
--- whole-row references are disallowed
-ALTER TABLE test_type_diff2 ALTER COLUMN int_four TYPE int4 USING (pg_column_size(test_type_diff2));
-ERROR:  cannot convert whole-row table reference
-DETAIL:  USING expression contains a whole-row table reference.
--- check for rollback of ANALYZE corrupting table property flags (bug #11638)
-CREATE TABLE check_fk_presence_1 (id int PRIMARY KEY, t text);
-CREATE TABLE check_fk_presence_2 (id int REFERENCES check_fk_presence_1, t text);
-BEGIN;
-ALTER TABLE check_fk_presence_2 DROP CONSTRAINT check_fk_presence_2_id_fkey;
-ANALYZE check_fk_presence_2;
-ROLLBACK;
-\d check_fk_presence_2
-        Table "public.check_fk_presence_2"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- id     | integer |           |          | 
- t      | text    |           |          | 
-Foreign-key constraints:
-    "check_fk_presence_2_id_fkey" FOREIGN KEY (id) REFERENCES check_fk_presence_1(id)
-
-DROP TABLE check_fk_presence_1, check_fk_presence_2;
--- check column addition within a view (bug #14876)
-create table at_base_table(id int, stuff text);
-insert into at_base_table values (23, 'skidoo');
-create view at_view_1 as select * from at_base_table bt;
-create view at_view_2 as select *, to_json(v1) as j from at_view_1 v1;
-\d+ at_view_1
-                          View "public.at_view_1"
- Column |  Type   | Collation | Nullable | Default | Storage  | Description 
---------+---------+-----------+----------+---------+----------+-------------
- id     | integer |           |          |         | plain    | 
- stuff  | text    |           |          |         | extended | 
-View definition:
- SELECT bt.id,
-    bt.stuff
-   FROM at_base_table bt;
-
-\d+ at_view_2
-                          View "public.at_view_2"
- Column |  Type   | Collation | Nullable | Default | Storage  | Description 
---------+---------+-----------+----------+---------+----------+-------------
- id     | integer |           |          |         | plain    | 
- stuff  | text    |           |          |         | extended | 
- j      | json    |           |          |         | extended | 
-View definition:
- SELECT v1.id,
-    v1.stuff,
-    to_json(v1.*) AS j
-   FROM at_view_1 v1;
-
-explain (verbose, costs off) select * from at_view_2;
-                        QUERY PLAN                        
-----------------------------------------------------------
- Seq Scan on public.at_base_table bt
-   Output: bt.id, bt.stuff, to_json(ROW(bt.id, bt.stuff))
-(2 rows)
-
-select * from at_view_2;
- id | stuff  |             j              
-----+--------+----------------------------
- 23 | skidoo | {"id":23,"stuff":"skidoo"}
-(1 row)
-
-create or replace view at_view_1 as select *, 2+2 as more from at_base_table bt;
-\d+ at_view_1
-                          View "public.at_view_1"
- Column |  Type   | Collation | Nullable | Default | Storage  | Description 
---------+---------+-----------+----------+---------+----------+-------------
- id     | integer |           |          |         | plain    | 
- stuff  | text    |           |          |         | extended | 
- more   | integer |           |          |         | plain    | 
-View definition:
- SELECT bt.id,
-    bt.stuff,
-    2 + 2 AS more
-   FROM at_base_table bt;
-
-\d+ at_view_2
-                          View "public.at_view_2"
- Column |  Type   | Collation | Nullable | Default | Storage  | Description 
---------+---------+-----------+----------+---------+----------+-------------
- id     | integer |           |          |         | plain    | 
- stuff  | text    |           |          |         | extended | 
- j      | json    |           |          |         | extended | 
-View definition:
- SELECT v1.id,
-    v1.stuff,
-    to_json(v1.*) AS j
-   FROM at_view_1 v1;
-
-explain (verbose, costs off) select * from at_view_2;
-                           QUERY PLAN                           
-----------------------------------------------------------------
- Seq Scan on public.at_base_table bt
-   Output: bt.id, bt.stuff, to_json(ROW(bt.id, bt.stuff, NULL))
-(2 rows)
-
-select * from at_view_2;
- id | stuff  |                   j                    
-----+--------+----------------------------------------
- 23 | skidoo | {"id":23,"stuff":"skidoo","more":null}
-(1 row)
-
-drop view at_view_2;
-drop view at_view_1;
-drop table at_base_table;
--- check adding a column not iself requiring a rewrite, together with
--- a column requiring a default (bug #16038)
--- ensure that rewrites aren't silently optimized away, removing the
--- value of the test
-CREATE FUNCTION check_ddl_rewrite(p_tablename regclass, p_ddl text)
-RETURNS boolean
-LANGUAGE plpgsql AS $$
-DECLARE
-    v_relfilenode oid;
-BEGIN
-    v_relfilenode := relfilenode FROM pg_class WHERE oid = p_tablename;
-
-    EXECUTE p_ddl;
-
-    RETURN v_relfilenode <> (SELECT relfilenode FROM pg_class WHERE oid = p_tablename);
-END;
-$$;
-CREATE TABLE rewrite_test(col text);
-INSERT INTO rewrite_test VALUES ('something');
-INSERT INTO rewrite_test VALUES (NULL);
--- empty[12] don't need rewrite, but notempty[12]_rewrite will force one
-SELECT check_ddl_rewrite('rewrite_test', $$
-  ALTER TABLE rewrite_test
-      ADD COLUMN empty1 text,
-      ADD COLUMN notempty1_rewrite serial;
-$$);
- check_ddl_rewrite 
--------------------
- t
-(1 row)
-
-SELECT check_ddl_rewrite('rewrite_test', $$
-    ALTER TABLE rewrite_test
-        ADD COLUMN notempty2_rewrite serial,
-        ADD COLUMN empty2 text;
-$$);
- check_ddl_rewrite 
--------------------
- t
-(1 row)
-
--- also check that fast defaults cause no problem, first without rewrite
-SELECT check_ddl_rewrite('rewrite_test', $$
-    ALTER TABLE rewrite_test
-        ADD COLUMN empty3 text,
-        ADD COLUMN notempty3_norewrite int default 42;
-$$);
- check_ddl_rewrite 
--------------------
- f
-(1 row)
-
-SELECT check_ddl_rewrite('rewrite_test', $$
-    ALTER TABLE rewrite_test
-        ADD COLUMN notempty4_norewrite int default 42,
-        ADD COLUMN empty4 text;
-$$);
- check_ddl_rewrite 
--------------------
- f
-(1 row)
-
--- then with rewrite
-SELECT check_ddl_rewrite('rewrite_test', $$
-    ALTER TABLE rewrite_test
-        ADD COLUMN empty5 text,
-        ADD COLUMN notempty5_norewrite int default 42,
-        ADD COLUMN notempty5_rewrite serial;
-$$);
- check_ddl_rewrite 
--------------------
- t
-(1 row)
-
-SELECT check_ddl_rewrite('rewrite_test', $$
-    ALTER TABLE rewrite_test
-        ADD COLUMN notempty6_rewrite serial,
-        ADD COLUMN empty6 text,
-        ADD COLUMN notempty6_norewrite int default 42;
-$$);
- check_ddl_rewrite 
--------------------
- t
-(1 row)
-
--- cleanup
-DROP FUNCTION check_ddl_rewrite(regclass, text);
-DROP TABLE rewrite_test;
---
--- lock levels
---
-drop type lockmodes;
-ERROR:  type "lockmodes" does not exist
-create type lockmodes as enum (
- 'SIReadLock'
-,'AccessShareLock'
-,'RowShareLock'
-,'RowExclusiveLock'
-,'ShareUpdateExclusiveLock'
-,'ShareLock'
-,'ShareRowExclusiveLock'
-,'ExclusiveLock'
-,'AccessExclusiveLock'
-);
-drop view my_locks;
-ERROR:  view "my_locks" does not exist
-create or replace view my_locks as
-select case when c.relname like 'pg_toast%' then 'pg_toast' else c.relname end, max(mode::lockmodes) as max_lockmode
-from pg_locks l join pg_class c on l.relation = c.oid
-where virtualtransaction = (
-        select virtualtransaction
-        from pg_locks
-        where transactionid = pg_current_xact_id()::xid)
-and locktype = 'relation'
-and relnamespace != (select oid from pg_namespace where nspname = 'pg_catalog')
-and c.relname != 'my_locks'
-group by c.relname;
-create table alterlock (f1 int primary key, f2 text);
-insert into alterlock values (1, 'foo');
-create table alterlock2 (f3 int primary key, f1 int);
-insert into alterlock2 values (1, 1);
-begin; alter table alterlock alter column f2 set statistics 150;
-select * from my_locks order by 1;
-  relname  |       max_lockmode       
------------+--------------------------
- alterlock | ShareUpdateExclusiveLock
-(1 row)
-
-rollback;
-begin; alter table alterlock cluster on alterlock_pkey;
-select * from my_locks order by 1;
-    relname     |       max_lockmode       
-----------------+--------------------------
- alterlock      | ShareUpdateExclusiveLock
- alterlock_pkey | ShareUpdateExclusiveLock
-(2 rows)
-
-commit;
-begin; alter table alterlock set without cluster;
-select * from my_locks order by 1;
-  relname  |       max_lockmode       
------------+--------------------------
- alterlock | ShareUpdateExclusiveLock
-(1 row)
-
-commit;
-begin; alter table alterlock set (fillfactor = 100);
-select * from my_locks order by 1;
-  relname  |       max_lockmode       
------------+--------------------------
- alterlock | ShareUpdateExclusiveLock
- pg_toast  | ShareUpdateExclusiveLock
-(2 rows)
-
-commit;
-begin; alter table alterlock reset (fillfactor);
-select * from my_locks order by 1;
-  relname  |       max_lockmode       
------------+--------------------------
- alterlock | ShareUpdateExclusiveLock
- pg_toast  | ShareUpdateExclusiveLock
-(2 rows)
-
-commit;
-begin; alter table alterlock set (toast.autovacuum_enabled = off);
-select * from my_locks order by 1;
-  relname  |       max_lockmode       
------------+--------------------------
- alterlock | ShareUpdateExclusiveLock
- pg_toast  | ShareUpdateExclusiveLock
-(2 rows)
-
-commit;
-begin; alter table alterlock set (autovacuum_enabled = off);
-select * from my_locks order by 1;
-  relname  |       max_lockmode       
------------+--------------------------
- alterlock | ShareUpdateExclusiveLock
- pg_toast  | ShareUpdateExclusiveLock
-(2 rows)
-
-commit;
-begin; alter table alterlock alter column f2 set (n_distinct = 1);
-select * from my_locks order by 1;
-  relname  |       max_lockmode       
------------+--------------------------
- alterlock | ShareUpdateExclusiveLock
-(1 row)
-
-rollback;
--- test that mixing options with different lock levels works as expected
-begin; alter table alterlock set (autovacuum_enabled = off, fillfactor = 80);
-select * from my_locks order by 1;
-  relname  |       max_lockmode       
------------+--------------------------
- alterlock | ShareUpdateExclusiveLock
- pg_toast  | ShareUpdateExclusiveLock
-(2 rows)
-
-commit;
-begin; alter table alterlock alter column f2 set storage extended;
-select * from my_locks order by 1;
-  relname  |    max_lockmode     
------------+---------------------
- alterlock | AccessExclusiveLock
-(1 row)
-
-rollback;
-begin; alter table alterlock alter column f2 set default 'x';
-select * from my_locks order by 1;
-  relname  |    max_lockmode     
------------+---------------------
- alterlock | AccessExclusiveLock
-(1 row)
-
-rollback;
-begin;
-create trigger ttdummy
-	before delete or update on alterlock
-	for each row
-	execute procedure
-	ttdummy (1, 1);
-select * from my_locks order by 1;
-  relname  |     max_lockmode      
------------+-----------------------
- alterlock | ShareRowExclusiveLock
-(1 row)
-
-rollback;
-begin;
-select * from my_locks order by 1;
- relname | max_lockmode 
----------+--------------
-(0 rows)
-
-alter table alterlock2 add foreign key (f1) references alterlock (f1);
-select * from my_locks order by 1;
-     relname     |     max_lockmode      
------------------+-----------------------
- alterlock       | ShareRowExclusiveLock
- alterlock2      | ShareRowExclusiveLock
- alterlock2_pkey | AccessShareLock
- alterlock_pkey  | AccessShareLock
-(4 rows)
-
-rollback;
-begin;
-alter table alterlock2
-add constraint alterlock2nv foreign key (f1) references alterlock (f1) NOT VALID;
-select * from my_locks order by 1;
-  relname   |     max_lockmode      
-------------+-----------------------
- alterlock  | ShareRowExclusiveLock
- alterlock2 | ShareRowExclusiveLock
-(2 rows)
-
-commit;
-begin;
-alter table alterlock2 validate constraint alterlock2nv;
-select * from my_locks order by 1;
-     relname     |       max_lockmode       
------------------+--------------------------
- alterlock       | RowShareLock
- alterlock2      | ShareUpdateExclusiveLock
- alterlock2_pkey | AccessShareLock
- alterlock_pkey  | AccessShareLock
-(4 rows)
-
-rollback;
-create or replace view my_locks as
-select case when c.relname like 'pg_toast%' then 'pg_toast' else c.relname end, max(mode::lockmodes) as max_lockmode
-from pg_locks l join pg_class c on l.relation = c.oid
-where virtualtransaction = (
-        select virtualtransaction
-        from pg_locks
-        where transactionid = pg_current_xact_id()::xid)
-and locktype = 'relation'
-and relnamespace != (select oid from pg_namespace where nspname = 'pg_catalog')
-and c.relname = 'my_locks'
-group by c.relname;
--- raise exception
-alter table my_locks set (autovacuum_enabled = false);
-ERROR:  unrecognized parameter "autovacuum_enabled"
-alter view my_locks set (autovacuum_enabled = false);
-ERROR:  unrecognized parameter "autovacuum_enabled"
-alter table my_locks reset (autovacuum_enabled);
-alter view my_locks reset (autovacuum_enabled);
-begin;
-alter view my_locks set (security_barrier=off);
-select * from my_locks order by 1;
- relname  |    max_lockmode     
-----------+---------------------
- my_locks | AccessExclusiveLock
-(1 row)
-
-alter view my_locks reset (security_barrier);
-rollback;
--- this test intentionally applies the ALTER TABLE command against a view, but
--- uses a view option so we expect this to succeed. This form of SQL is
--- accepted for historical reasons, as shown in the docs for ALTER VIEW
-begin;
-alter table my_locks set (security_barrier=off);
-select * from my_locks order by 1;
- relname  |    max_lockmode     
-----------+---------------------
- my_locks | AccessExclusiveLock
-(1 row)
-
-alter table my_locks reset (security_barrier);
-rollback;
--- cleanup
-drop table alterlock2;
-drop table alterlock;
-drop view my_locks;
-drop type lockmodes;
---
--- alter function
---
-create function test_strict(text) returns text as
-    'select coalesce($1, ''got passed a null'');'
-    language sql returns null on null input;
-select test_strict(NULL);
- test_strict 
--------------
- 
-(1 row)
-
-alter function test_strict(text) called on null input;
-select test_strict(NULL);
-    test_strict    
--------------------
- got passed a null
-(1 row)
-
-create function non_strict(text) returns text as
-    'select coalesce($1, ''got passed a null'');'
-    language sql called on null input;
-select non_strict(NULL);
-    non_strict     
--------------------
- got passed a null
-(1 row)
-
-alter function non_strict(text) returns null on null input;
-select non_strict(NULL);
- non_strict 
-------------
- 
-(1 row)
-
---
--- alter object set schema
---
-create schema alter1;
-create schema alter2;
-create table alter1.t1(f1 serial primary key, f2 int check (f2 > 0));
-create view alter1.v1 as select * from alter1.t1;
-create function alter1.plus1(int) returns int as 'select $1+1' language sql;
-create domain alter1.posint integer check (value > 0);
-create type alter1.ctype as (f1 int, f2 text);
-create function alter1.same(alter1.ctype, alter1.ctype) returns boolean language sql
-as 'select $1.f1 is not distinct from $2.f1 and $1.f2 is not distinct from $2.f2';
-create operator alter1.=(procedure = alter1.same, leftarg  = alter1.ctype, rightarg = alter1.ctype);
-create operator class alter1.ctype_hash_ops default for type alter1.ctype using hash as
-  operator 1 alter1.=(alter1.ctype, alter1.ctype);
-create conversion alter1.latin1_to_utf8 for 'latin1' to 'utf8' from iso8859_1_to_utf8;
-create text search parser alter1.prs(start = prsd_start, gettoken = prsd_nexttoken, end = prsd_end, lextypes = prsd_lextype);
-create text search configuration alter1.cfg(parser = alter1.prs);
-create text search template alter1.tmpl(init = dsimple_init, lexize = dsimple_lexize);
-create text search dictionary alter1.dict(template = alter1.tmpl);
-insert into alter1.t1(f2) values(11);
-insert into alter1.t1(f2) values(12);
-alter table alter1.t1 set schema alter1; -- no-op, same schema
-alter table alter1.t1 set schema alter2;
-alter table alter1.v1 set schema alter2;
-alter function alter1.plus1(int) set schema alter2;
-alter domain alter1.posint set schema alter2;
-alter operator class alter1.ctype_hash_ops using hash set schema alter2;
-alter operator family alter1.ctype_hash_ops using hash set schema alter2;
-alter operator alter1.=(alter1.ctype, alter1.ctype) set schema alter2;
-alter function alter1.same(alter1.ctype, alter1.ctype) set schema alter2;
-alter type alter1.ctype set schema alter1; -- no-op, same schema
-alter type alter1.ctype set schema alter2;
-alter conversion alter1.latin1_to_utf8 set schema alter2;
-alter text search parser alter1.prs set schema alter2;
-alter text search configuration alter1.cfg set schema alter2;
-alter text search template alter1.tmpl set schema alter2;
-alter text search dictionary alter1.dict set schema alter2;
--- this should succeed because nothing is left in alter1
-drop schema alter1;
-insert into alter2.t1(f2) values(13);
-insert into alter2.t1(f2) values(14);
-select * from alter2.t1;
- f1 | f2 
-----+----
-  1 | 11
-  2 | 12
-  3 | 13
-  4 | 14
-(4 rows)
-
-select * from alter2.v1;
- f1 | f2 
-----+----
-  1 | 11
-  2 | 12
-  3 | 13
-  4 | 14
-(4 rows)
-
-select alter2.plus1(41);
- plus1 
--------
-    42
-(1 row)
-
--- clean up
-drop schema alter2 cascade;
-NOTICE:  drop cascades to 13 other objects
-DETAIL:  drop cascades to table alter2.t1
-drop cascades to view alter2.v1
-drop cascades to function alter2.plus1(integer)
-drop cascades to type alter2.posint
-drop cascades to type alter2.ctype
-drop cascades to function alter2.same(alter2.ctype,alter2.ctype)
-drop cascades to operator alter2.=(alter2.ctype,alter2.ctype)
-drop cascades to operator family alter2.ctype_hash_ops for access method hash
-drop cascades to conversion alter2.latin1_to_utf8
-drop cascades to text search parser alter2.prs
-drop cascades to text search configuration alter2.cfg
-drop cascades to text search template alter2.tmpl
-drop cascades to text search dictionary alter2.dict
---
--- composite types
---
-CREATE TYPE test_type AS (a int);
-\d test_type
-         Composite type "public.test_type"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
-
-ALTER TYPE nosuchtype ADD ATTRIBUTE b text; -- fails
-ERROR:  relation "nosuchtype" does not exist
-ALTER TYPE test_type ADD ATTRIBUTE b text;
-\d test_type
-         Composite type "public.test_type"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
- b      | text    |           |          | 
-
-ALTER TYPE test_type ADD ATTRIBUTE b text; -- fails
-ERROR:  column "b" of relation "test_type" already exists
-ALTER TYPE test_type ALTER ATTRIBUTE b SET DATA TYPE varchar;
-\d test_type
-              Composite type "public.test_type"
- Column |       Type        | Collation | Nullable | Default 
---------+-------------------+-----------+----------+---------
- a      | integer           |           |          | 
- b      | character varying |           |          | 
-
-ALTER TYPE test_type ALTER ATTRIBUTE b SET DATA TYPE integer;
-\d test_type
-         Composite type "public.test_type"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
- b      | integer |           |          | 
-
-ALTER TYPE test_type DROP ATTRIBUTE b;
-\d test_type
-         Composite type "public.test_type"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
-
-ALTER TYPE test_type DROP ATTRIBUTE c; -- fails
-ERROR:  column "c" of relation "test_type" does not exist
-ALTER TYPE test_type DROP ATTRIBUTE IF EXISTS c;
-NOTICE:  column "c" of relation "test_type" does not exist, skipping
-ALTER TYPE test_type DROP ATTRIBUTE a, ADD ATTRIBUTE d boolean;
-\d test_type
-         Composite type "public.test_type"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- d      | boolean |           |          | 
-
-ALTER TYPE test_type RENAME ATTRIBUTE a TO aa;
-ERROR:  column "a" does not exist
-ALTER TYPE test_type RENAME ATTRIBUTE d TO dd;
-\d test_type
-         Composite type "public.test_type"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- dd     | boolean |           |          | 
-
-DROP TYPE test_type;
-CREATE TYPE test_type1 AS (a int, b text);
-CREATE TABLE test_tbl1 (x int, y test_type1);
-ALTER TYPE test_type1 ALTER ATTRIBUTE b TYPE varchar; -- fails
-ERROR:  cannot alter type "test_type1" because column "test_tbl1.y" uses it
-CREATE TYPE test_type2 AS (a int, b text);
-CREATE TABLE test_tbl2 OF test_type2;
-CREATE TABLE test_tbl2_subclass () INHERITS (test_tbl2);
-\d test_type2
-        Composite type "public.test_type2"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
- b      | text    |           |          | 
-
-\d test_tbl2
-             Table "public.test_tbl2"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
- b      | text    |           |          | 
-Number of child tables: 1 (Use \d+ to list them.)
-Typed table of type: test_type2
-
-ALTER TYPE test_type2 ADD ATTRIBUTE c text; -- fails
-ERROR:  cannot alter type "test_type2" because it is the type of a typed table
-HINT:  Use ALTER ... CASCADE to alter the typed tables too.
-ALTER TYPE test_type2 ADD ATTRIBUTE c text CASCADE;
-\d test_type2
-        Composite type "public.test_type2"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
- b      | text    |           |          | 
- c      | text    |           |          | 
-
-\d test_tbl2
-             Table "public.test_tbl2"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
- b      | text    |           |          | 
- c      | text    |           |          | 
-Number of child tables: 1 (Use \d+ to list them.)
-Typed table of type: test_type2
-
-ALTER TYPE test_type2 ALTER ATTRIBUTE b TYPE varchar; -- fails
-ERROR:  cannot alter type "test_type2" because it is the type of a typed table
-HINT:  Use ALTER ... CASCADE to alter the typed tables too.
-ALTER TYPE test_type2 ALTER ATTRIBUTE b TYPE varchar CASCADE;
-\d test_type2
-             Composite type "public.test_type2"
- Column |       Type        | Collation | Nullable | Default 
---------+-------------------+-----------+----------+---------
- a      | integer           |           |          | 
- b      | character varying |           |          | 
- c      | text              |           |          | 
-
-\d test_tbl2
-                  Table "public.test_tbl2"
- Column |       Type        | Collation | Nullable | Default 
---------+-------------------+-----------+----------+---------
- a      | integer           |           |          | 
- b      | character varying |           |          | 
- c      | text              |           |          | 
-Number of child tables: 1 (Use \d+ to list them.)
-Typed table of type: test_type2
-
-ALTER TYPE test_type2 DROP ATTRIBUTE b; -- fails
-ERROR:  cannot alter type "test_type2" because it is the type of a typed table
-HINT:  Use ALTER ... CASCADE to alter the typed tables too.
-ALTER TYPE test_type2 DROP ATTRIBUTE b CASCADE;
-\d test_type2
-        Composite type "public.test_type2"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
- c      | text    |           |          | 
-
-\d test_tbl2
-             Table "public.test_tbl2"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
- c      | text    |           |          | 
-Number of child tables: 1 (Use \d+ to list them.)
-Typed table of type: test_type2
-
-ALTER TYPE test_type2 RENAME ATTRIBUTE a TO aa; -- fails
-ERROR:  cannot alter type "test_type2" because it is the type of a typed table
-HINT:  Use ALTER ... CASCADE to alter the typed tables too.
-ALTER TYPE test_type2 RENAME ATTRIBUTE a TO aa CASCADE;
-\d test_type2
-        Composite type "public.test_type2"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- aa     | integer |           |          | 
- c      | text    |           |          | 
-
-\d test_tbl2
-             Table "public.test_tbl2"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- aa     | integer |           |          | 
- c      | text    |           |          | 
-Number of child tables: 1 (Use \d+ to list them.)
-Typed table of type: test_type2
-
-\d test_tbl2_subclass
-         Table "public.test_tbl2_subclass"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- aa     | integer |           |          | 
- c      | text    |           |          | 
-Inherits: test_tbl2
-
-DROP TABLE test_tbl2_subclass;
-CREATE TYPE test_typex AS (a int, b text);
-CREATE TABLE test_tblx (x int, y test_typex check ((y).a > 0));
-ALTER TYPE test_typex DROP ATTRIBUTE a; -- fails
-ERROR:  cannot drop column a of composite type test_typex because other objects depend on it
-DETAIL:  constraint test_tblx_y_check on table test_tblx depends on column a of composite type test_typex
-HINT:  Use DROP ... CASCADE to drop the dependent objects too.
-ALTER TYPE test_typex DROP ATTRIBUTE a CASCADE;
-NOTICE:  drop cascades to constraint test_tblx_y_check on table test_tblx
-\d test_tblx
-               Table "public.test_tblx"
- Column |    Type    | Collation | Nullable | Default 
---------+------------+-----------+----------+---------
- x      | integer    |           |          | 
- y      | test_typex |           |          | 
-
-DROP TABLE test_tblx;
-DROP TYPE test_typex;
--- This test isn't that interesting on its own, but the purpose is to leave
--- behind a table to test pg_upgrade with. The table has a composite type
--- column in it, and the composite type has a dropped attribute.
-CREATE TYPE test_type3 AS (a int);
-CREATE TABLE test_tbl3 (c) AS SELECT '(1)'::test_type3;
-ALTER TYPE test_type3 DROP ATTRIBUTE a, ADD ATTRIBUTE b int;
-CREATE TYPE test_type_empty AS ();
-DROP TYPE test_type_empty;
---
--- typed tables: OF / NOT OF
---
-CREATE TYPE tt_t0 AS (z inet, x int, y numeric(8,2));
-ALTER TYPE tt_t0 DROP ATTRIBUTE z;
-CREATE TABLE tt0 (x int NOT NULL, y numeric(8,2));	-- OK
-CREATE TABLE tt1 (x int, y bigint);					-- wrong base type
-CREATE TABLE tt2 (x int, y numeric(9,2));			-- wrong typmod
-CREATE TABLE tt3 (y numeric(8,2), x int);			-- wrong column order
-CREATE TABLE tt4 (x int);							-- too few columns
-CREATE TABLE tt5 (x int, y numeric(8,2), z int);	-- too few columns
-CREATE TABLE tt6 () INHERITS (tt0);					-- can't have a parent
-CREATE TABLE tt7 (x int, q text, y numeric(8,2));
-ALTER TABLE tt7 DROP q;								-- OK
-ALTER TABLE tt0 OF tt_t0;
-ALTER TABLE tt1 OF tt_t0;
-ERROR:  table "tt1" has different type for column "y"
-ALTER TABLE tt2 OF tt_t0;
-ERROR:  table "tt2" has different type for column "y"
-ALTER TABLE tt3 OF tt_t0;
-ERROR:  table has column "y" where type requires "x"
-ALTER TABLE tt4 OF tt_t0;
-ERROR:  table is missing column "y"
-ALTER TABLE tt5 OF tt_t0;
-ERROR:  table has extra column "z"
-ALTER TABLE tt6 OF tt_t0;
-ERROR:  typed tables cannot inherit
-ALTER TABLE tt7 OF tt_t0;
-CREATE TYPE tt_t1 AS (x int, y numeric(8,2));
-ALTER TABLE tt7 OF tt_t1;			-- reassign an already-typed table
-ALTER TABLE tt7 NOT OF;
-\d tt7
-                   Table "public.tt7"
- Column |     Type     | Collation | Nullable | Default 
---------+--------------+-----------+----------+---------
- x      | integer      |           |          | 
- y      | numeric(8,2) |           |          | 
-
--- make sure we can drop a constraint on the parent but it remains on the child
-CREATE TABLE test_drop_constr_parent (c text CHECK (c IS NOT NULL));
-CREATE TABLE test_drop_constr_child () INHERITS (test_drop_constr_parent);
-ALTER TABLE ONLY test_drop_constr_parent DROP CONSTRAINT "test_drop_constr_parent_c_check";
--- should fail
-INSERT INTO test_drop_constr_child (c) VALUES (NULL);
-ERROR:  new row for relation "test_drop_constr_child" violates check constraint "test_drop_constr_parent_c_check"
-DETAIL:  Failing row contains (null).
-DROP TABLE test_drop_constr_parent CASCADE;
-NOTICE:  drop cascades to table test_drop_constr_child
---
--- IF EXISTS test
---
-ALTER TABLE IF EXISTS tt8 ADD COLUMN f int;
-NOTICE:  relation "tt8" does not exist, skipping
-ALTER TABLE IF EXISTS tt8 ADD CONSTRAINT xxx PRIMARY KEY(f);
-NOTICE:  relation "tt8" does not exist, skipping
-ALTER TABLE IF EXISTS tt8 ADD CHECK (f BETWEEN 0 AND 10);
-NOTICE:  relation "tt8" does not exist, skipping
-ALTER TABLE IF EXISTS tt8 ALTER COLUMN f SET DEFAULT 0;
-NOTICE:  relation "tt8" does not exist, skipping
-ALTER TABLE IF EXISTS tt8 RENAME COLUMN f TO f1;
-NOTICE:  relation "tt8" does not exist, skipping
-ALTER TABLE IF EXISTS tt8 SET SCHEMA alter2;
-NOTICE:  relation "tt8" does not exist, skipping
-CREATE TABLE tt8(a int);
-CREATE SCHEMA alter2;
-ALTER TABLE IF EXISTS tt8 ADD COLUMN f int;
-ALTER TABLE IF EXISTS tt8 ADD CONSTRAINT xxx PRIMARY KEY(f);
-ALTER TABLE IF EXISTS tt8 ADD CHECK (f BETWEEN 0 AND 10);
-ALTER TABLE IF EXISTS tt8 ALTER COLUMN f SET DEFAULT 0;
-ALTER TABLE IF EXISTS tt8 RENAME COLUMN f TO f1;
-ALTER TABLE IF EXISTS tt8 SET SCHEMA alter2;
-\d alter2.tt8
-                Table "alter2.tt8"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
- f1     | integer |           | not null | 0
-Indexes:
-    "xxx" PRIMARY KEY, btree (f1)
-Check constraints:
-    "tt8_f_check" CHECK (f1 >= 0 AND f1 <= 10)
-
-DROP TABLE alter2.tt8;
-DROP SCHEMA alter2;
---
--- Check conflicts between index and CHECK constraint names
---
-CREATE TABLE tt9(c integer);
-ALTER TABLE tt9 ADD CHECK(c > 1);
-ALTER TABLE tt9 ADD CHECK(c > 2);  -- picks nonconflicting name
-ALTER TABLE tt9 ADD CONSTRAINT foo CHECK(c > 3);
-ALTER TABLE tt9 ADD CONSTRAINT foo CHECK(c > 4);  -- fail, dup name
-ERROR:  constraint "foo" for relation "tt9" already exists
-ALTER TABLE tt9 ADD UNIQUE(c);
-ALTER TABLE tt9 ADD UNIQUE(c);  -- picks nonconflicting name
-ALTER TABLE tt9 ADD CONSTRAINT tt9_c_key UNIQUE(c);  -- fail, dup name
-ERROR:  relation "tt9_c_key" already exists
-ALTER TABLE tt9 ADD CONSTRAINT foo UNIQUE(c);  -- fail, dup name
-ERROR:  constraint "foo" for relation "tt9" already exists
-ALTER TABLE tt9 ADD CONSTRAINT tt9_c_key CHECK(c > 5);  -- fail, dup name
-ERROR:  constraint "tt9_c_key" for relation "tt9" already exists
-ALTER TABLE tt9 ADD CONSTRAINT tt9_c_key2 CHECK(c > 6);
-ALTER TABLE tt9 ADD UNIQUE(c);  -- picks nonconflicting name
-\d tt9
-                Table "public.tt9"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- c      | integer |           |          | 
-Indexes:
-    "tt9_c_key" UNIQUE CONSTRAINT, btree (c)
-    "tt9_c_key1" UNIQUE CONSTRAINT, btree (c)
-    "tt9_c_key3" UNIQUE CONSTRAINT, btree (c)
-Check constraints:
-    "foo" CHECK (c > 3)
-    "tt9_c_check" CHECK (c > 1)
-    "tt9_c_check1" CHECK (c > 2)
-    "tt9_c_key2" CHECK (c > 6)
-
-DROP TABLE tt9;
--- Check that comments on constraints and indexes are not lost at ALTER TABLE.
-CREATE TABLE comment_test (
-  id int,
-  positive_col int CHECK (positive_col > 0),
-  indexed_col int,
-  CONSTRAINT comment_test_pk PRIMARY KEY (id));
-CREATE INDEX comment_test_index ON comment_test(indexed_col);
-COMMENT ON COLUMN comment_test.id IS 'Column ''id'' on comment_test';
-COMMENT ON INDEX comment_test_index IS 'Simple index on comment_test';
-COMMENT ON CONSTRAINT comment_test_positive_col_check ON comment_test IS 'CHECK constraint on comment_test.positive_col';
-COMMENT ON CONSTRAINT comment_test_pk ON comment_test IS 'PRIMARY KEY constraint of comment_test';
-COMMENT ON INDEX comment_test_pk IS 'Index backing the PRIMARY KEY of comment_test';
-SELECT col_description('comment_test'::regclass, 1) as comment;
-           comment           
------------------------------
- Column 'id' on comment_test
-(1 row)
-
-SELECT indexrelid::regclass::text as index, obj_description(indexrelid, 'pg_class') as comment FROM pg_index where indrelid = 'comment_test'::regclass ORDER BY 1, 2;
-       index        |                    comment                    
---------------------+-----------------------------------------------
- comment_test_index | Simple index on comment_test
- comment_test_pk    | Index backing the PRIMARY KEY of comment_test
-(2 rows)
-
-SELECT conname as constraint, obj_description(oid, 'pg_constraint') as comment FROM pg_constraint where conrelid = 'comment_test'::regclass ORDER BY 1, 2;
-           constraint            |                    comment                    
----------------------------------+-----------------------------------------------
- comment_test_pk                 | PRIMARY KEY constraint of comment_test
- comment_test_positive_col_check | CHECK constraint on comment_test.positive_col
-(2 rows)
-
--- Change the datatype of all the columns. ALTER TABLE is optimized to not
--- rebuild an index if the new data type is binary compatible with the old
--- one. Check do a dummy ALTER TABLE that doesn't change the datatype
--- first, to test that no-op codepath, and another one that does.
-ALTER TABLE comment_test ALTER COLUMN indexed_col SET DATA TYPE int;
-ALTER TABLE comment_test ALTER COLUMN indexed_col SET DATA TYPE text;
-ALTER TABLE comment_test ALTER COLUMN id SET DATA TYPE int;
-ALTER TABLE comment_test ALTER COLUMN id SET DATA TYPE text;
-ALTER TABLE comment_test ALTER COLUMN positive_col SET DATA TYPE int;
-ALTER TABLE comment_test ALTER COLUMN positive_col SET DATA TYPE bigint;
--- Check that the comments are intact.
-SELECT col_description('comment_test'::regclass, 1) as comment;
-           comment           
------------------------------
- Column 'id' on comment_test
-(1 row)
-
-SELECT indexrelid::regclass::text as index, obj_description(indexrelid, 'pg_class') as comment FROM pg_index where indrelid = 'comment_test'::regclass ORDER BY 1, 2;
-       index        |                    comment                    
---------------------+-----------------------------------------------
- comment_test_index | Simple index on comment_test
- comment_test_pk    | Index backing the PRIMARY KEY of comment_test
-(2 rows)
-
-SELECT conname as constraint, obj_description(oid, 'pg_constraint') as comment FROM pg_constraint where conrelid = 'comment_test'::regclass ORDER BY 1, 2;
-           constraint            |                    comment                    
----------------------------------+-----------------------------------------------
- comment_test_pk                 | PRIMARY KEY constraint of comment_test
- comment_test_positive_col_check | CHECK constraint on comment_test.positive_col
-(2 rows)
-
--- Check compatibility for foreign keys and comments. This is done
--- separately as rebuilding the column type of the parent leads
--- to an error and would reduce the test scope.
-CREATE TABLE comment_test_child (
-  id text CONSTRAINT comment_test_child_fk REFERENCES comment_test);
-CREATE INDEX comment_test_child_fk ON comment_test_child(id);
-COMMENT ON COLUMN comment_test_child.id IS 'Column ''id'' on comment_test_child';
-COMMENT ON INDEX comment_test_child_fk IS 'Index backing the FOREIGN KEY of comment_test_child';
-COMMENT ON CONSTRAINT comment_test_child_fk ON comment_test_child IS 'FOREIGN KEY constraint of comment_test_child';
--- Change column type of parent
-ALTER TABLE comment_test ALTER COLUMN id SET DATA TYPE text;
-ALTER TABLE comment_test ALTER COLUMN id SET DATA TYPE int USING id::integer;
-ERROR:  foreign key constraint "comment_test_child_fk" cannot be implemented
-DETAIL:  Key columns "id" and "id" are of incompatible types: text and integer.
--- Comments should be intact
-SELECT col_description('comment_test_child'::regclass, 1) as comment;
-              comment              
------------------------------------
- Column 'id' on comment_test_child
-(1 row)
-
-SELECT indexrelid::regclass::text as index, obj_description(indexrelid, 'pg_class') as comment FROM pg_index where indrelid = 'comment_test_child'::regclass ORDER BY 1, 2;
-         index         |                       comment                       
------------------------+-----------------------------------------------------
- comment_test_child_fk | Index backing the FOREIGN KEY of comment_test_child
-(1 row)
-
-SELECT conname as constraint, obj_description(oid, 'pg_constraint') as comment FROM pg_constraint where conrelid = 'comment_test_child'::regclass ORDER BY 1, 2;
-      constraint       |                   comment                    
------------------------+----------------------------------------------
- comment_test_child_fk | FOREIGN KEY constraint of comment_test_child
-(1 row)
-
--- Check that we map relation oids to filenodes and back correctly.  Only
--- display bad mappings so the test output doesn't change all the time.  A
--- filenode function call can return NULL for a relation dropped concurrently
--- with the call's surrounding query, so ignore a NULL mapped_oid for
--- relations that no longer exist after all calls finish.
-CREATE TEMP TABLE filenode_mapping AS
-SELECT
-    oid, mapped_oid, reltablespace, relfilenode, relname
-FROM pg_class,
-    pg_filenode_relation(reltablespace, pg_relation_filenode(oid)) AS mapped_oid
-WHERE relkind IN ('r', 'i', 'S', 't', 'm') AND mapped_oid IS DISTINCT FROM oid;
-SELECT m.* FROM filenode_mapping m LEFT JOIN pg_class c ON c.oid = m.oid
-WHERE c.oid IS NOT NULL OR m.mapped_oid IS NOT NULL;
- oid | mapped_oid | reltablespace | relfilenode | relname 
------+------------+---------------+-------------+---------
-(0 rows)
-
--- Checks on creating and manipulation of user defined relations in
--- pg_catalog.
-SHOW allow_system_table_mods;
- allow_system_table_mods 
--------------------------
- off
-(1 row)
-
--- disallowed because of search_path issues with pg_dump
-CREATE TABLE pg_catalog.new_system_table();
-ERROR:  permission denied to create "pg_catalog.new_system_table"
-DETAIL:  System catalog modifications are currently disallowed.
--- instead create in public first, move to catalog
-CREATE TABLE new_system_table(id serial primary key, othercol text);
-ALTER TABLE new_system_table SET SCHEMA pg_catalog;
-ALTER TABLE new_system_table SET SCHEMA public;
-ALTER TABLE new_system_table SET SCHEMA pg_catalog;
--- will be ignored -- already there:
-ALTER TABLE new_system_table SET SCHEMA pg_catalog;
-ALTER TABLE new_system_table RENAME TO old_system_table;
-CREATE INDEX old_system_table__othercol ON old_system_table (othercol);
-INSERT INTO old_system_table(othercol) VALUES ('somedata'), ('otherdata');
-UPDATE old_system_table SET id = -id;
-DELETE FROM old_system_table WHERE othercol = 'somedata';
-TRUNCATE old_system_table;
-ALTER TABLE old_system_table DROP CONSTRAINT new_system_table_pkey;
-ALTER TABLE old_system_table DROP COLUMN othercol;
-DROP TABLE old_system_table;
--- set logged
-CREATE UNLOGGED TABLE unlogged1(f1 SERIAL PRIMARY KEY, f2 TEXT);
--- check relpersistence of an unlogged table
-SELECT relname, relkind, relpersistence FROM pg_class WHERE relname ~ '^unlogged1'
-UNION ALL
-SELECT 'toast table', t.relkind, t.relpersistence FROM pg_class r JOIN pg_class t ON t.oid = r.reltoastrelid WHERE r.relname ~ '^unlogged1'
-UNION ALL
-SELECT 'toast index', ri.relkind, ri.relpersistence FROM pg_class r join pg_class t ON t.oid = r.reltoastrelid JOIN pg_index i ON i.indrelid = t.oid JOIN pg_class ri ON ri.oid = i.indexrelid WHERE r.relname ~ '^unlogged1'
-ORDER BY relname;
-     relname      | relkind | relpersistence 
-------------------+---------+----------------
- toast index      | i       | u
- toast table      | t       | u
- unlogged1        | r       | u
- unlogged1_f1_seq | S       | p
- unlogged1_pkey   | i       | u
-(5 rows)
-
-CREATE UNLOGGED TABLE unlogged2(f1 SERIAL PRIMARY KEY, f2 INTEGER REFERENCES unlogged1); -- foreign key
-CREATE UNLOGGED TABLE unlogged3(f1 SERIAL PRIMARY KEY, f2 INTEGER REFERENCES unlogged3); -- self-referencing foreign key
-ALTER TABLE unlogged3 SET LOGGED; -- skip self-referencing foreign key
-ALTER TABLE unlogged2 SET LOGGED; -- fails because a foreign key to an unlogged table exists
-ERROR:  could not change table "unlogged2" to logged because it references unlogged table "unlogged1"
-ALTER TABLE unlogged1 SET LOGGED;
--- check relpersistence of an unlogged table after changing to permanent
-SELECT relname, relkind, relpersistence FROM pg_class WHERE relname ~ '^unlogged1'
-UNION ALL
-SELECT 'toast table', t.relkind, t.relpersistence FROM pg_class r JOIN pg_class t ON t.oid = r.reltoastrelid WHERE r.relname ~ '^unlogged1'
-UNION ALL
-SELECT 'toast index', ri.relkind, ri.relpersistence FROM pg_class r join pg_class t ON t.oid = r.reltoastrelid JOIN pg_index i ON i.indrelid = t.oid JOIN pg_class ri ON ri.oid = i.indexrelid WHERE r.relname ~ '^unlogged1'
-ORDER BY relname;
-     relname      | relkind | relpersistence 
-------------------+---------+----------------
- toast index      | i       | p
- toast table      | t       | p
- unlogged1        | r       | p
- unlogged1_f1_seq | S       | p
- unlogged1_pkey   | i       | p
-(5 rows)
-
-ALTER TABLE unlogged1 SET LOGGED; -- silently do nothing
-DROP TABLE unlogged3;
-DROP TABLE unlogged2;
-DROP TABLE unlogged1;
--- set unlogged
-CREATE TABLE logged1(f1 SERIAL PRIMARY KEY, f2 TEXT);
--- check relpersistence of a permanent table
-SELECT relname, relkind, relpersistence FROM pg_class WHERE relname ~ '^logged1'
-UNION ALL
-SELECT 'toast table', t.relkind, t.relpersistence FROM pg_class r JOIN pg_class t ON t.oid = r.reltoastrelid WHERE r.relname ~ '^logged1'
-UNION ALL
-SELECT 'toast index', ri.relkind, ri.relpersistence FROM pg_class r join pg_class t ON t.oid = r.reltoastrelid JOIN pg_index i ON i.indrelid = t.oid JOIN pg_class ri ON ri.oid = i.indexrelid WHERE r.relname ~ '^logged1'
-ORDER BY relname;
-    relname     | relkind | relpersistence 
-----------------+---------+----------------
- logged1        | r       | p
- logged1_f1_seq | S       | p
- logged1_pkey   | i       | p
- toast index    | i       | p
- toast table    | t       | p
-(5 rows)
-
-CREATE TABLE logged2(f1 SERIAL PRIMARY KEY, f2 INTEGER REFERENCES logged1); -- foreign key
-CREATE TABLE logged3(f1 SERIAL PRIMARY KEY, f2 INTEGER REFERENCES logged3); -- self-referencing foreign key
-ALTER TABLE logged1 SET UNLOGGED; -- fails because a foreign key from a permanent table exists
-ERROR:  could not change table "logged1" to unlogged because it references logged table "logged2"
-ALTER TABLE logged3 SET UNLOGGED; -- skip self-referencing foreign key
-ALTER TABLE logged2 SET UNLOGGED;
-ALTER TABLE logged1 SET UNLOGGED;
--- check relpersistence of a permanent table after changing to unlogged
-SELECT relname, relkind, relpersistence FROM pg_class WHERE relname ~ '^logged1'
-UNION ALL
-SELECT 'toast table', t.relkind, t.relpersistence FROM pg_class r JOIN pg_class t ON t.oid = r.reltoastrelid WHERE r.relname ~ '^logged1'
-UNION ALL
-SELECT 'toast index', ri.relkind, ri.relpersistence FROM pg_class r join pg_class t ON t.oid = r.reltoastrelid JOIN pg_index i ON i.indrelid = t.oid JOIN pg_class ri ON ri.oid = i.indexrelid WHERE r.relname ~ '^logged1'
-ORDER BY relname;
-    relname     | relkind | relpersistence 
-----------------+---------+----------------
- logged1        | r       | u
- logged1_f1_seq | S       | p
- logged1_pkey   | i       | u
- toast index    | i       | u
- toast table    | t       | u
-(5 rows)
-
-ALTER TABLE logged1 SET UNLOGGED; -- silently do nothing
-DROP TABLE logged3;
-DROP TABLE logged2;
-DROP TABLE logged1;
--- test ADD COLUMN IF NOT EXISTS
-CREATE TABLE test_add_column(c1 integer);
-\d test_add_column
-          Table "public.test_add_column"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- c1     | integer |           |          | 
-
-ALTER TABLE test_add_column
-	ADD COLUMN c2 integer;
-\d test_add_column
-          Table "public.test_add_column"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- c1     | integer |           |          | 
- c2     | integer |           |          | 
-
-ALTER TABLE test_add_column
-	ADD COLUMN c2 integer; -- fail because c2 already exists
-ERROR:  column "c2" of relation "test_add_column" already exists
-ALTER TABLE ONLY test_add_column
-	ADD COLUMN c2 integer; -- fail because c2 already exists
-ERROR:  column "c2" of relation "test_add_column" already exists
-\d test_add_column
-          Table "public.test_add_column"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- c1     | integer |           |          | 
- c2     | integer |           |          | 
-
-ALTER TABLE test_add_column
-	ADD COLUMN IF NOT EXISTS c2 integer; -- skipping because c2 already exists
-NOTICE:  column "c2" of relation "test_add_column" already exists, skipping
-ALTER TABLE ONLY test_add_column
-	ADD COLUMN IF NOT EXISTS c2 integer; -- skipping because c2 already exists
-NOTICE:  column "c2" of relation "test_add_column" already exists, skipping
-\d test_add_column
-          Table "public.test_add_column"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- c1     | integer |           |          | 
- c2     | integer |           |          | 
-
-ALTER TABLE test_add_column
-	ADD COLUMN c2 integer, -- fail because c2 already exists
-	ADD COLUMN c3 integer primary key;
-ERROR:  column "c2" of relation "test_add_column" already exists
-\d test_add_column
-          Table "public.test_add_column"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- c1     | integer |           |          | 
- c2     | integer |           |          | 
-
-ALTER TABLE test_add_column
-	ADD COLUMN IF NOT EXISTS c2 integer, -- skipping because c2 already exists
-	ADD COLUMN c3 integer primary key;
-NOTICE:  column "c2" of relation "test_add_column" already exists, skipping
-\d test_add_column
-          Table "public.test_add_column"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- c1     | integer |           |          | 
- c2     | integer |           |          | 
- c3     | integer |           | not null | 
-Indexes:
-    "test_add_column_pkey" PRIMARY KEY, btree (c3)
-
-ALTER TABLE test_add_column
-	ADD COLUMN IF NOT EXISTS c2 integer, -- skipping because c2 already exists
-	ADD COLUMN IF NOT EXISTS c3 integer primary key; -- skipping because c3 already exists
-NOTICE:  column "c2" of relation "test_add_column" already exists, skipping
-NOTICE:  column "c3" of relation "test_add_column" already exists, skipping
-\d test_add_column
-          Table "public.test_add_column"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- c1     | integer |           |          | 
- c2     | integer |           |          | 
- c3     | integer |           | not null | 
-Indexes:
-    "test_add_column_pkey" PRIMARY KEY, btree (c3)
-
-ALTER TABLE test_add_column
-	ADD COLUMN IF NOT EXISTS c2 integer, -- skipping because c2 already exists
-	ADD COLUMN IF NOT EXISTS c3 integer, -- skipping because c3 already exists
-	ADD COLUMN c4 integer REFERENCES test_add_column;
-NOTICE:  column "c2" of relation "test_add_column" already exists, skipping
-NOTICE:  column "c3" of relation "test_add_column" already exists, skipping
-\d test_add_column
-          Table "public.test_add_column"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- c1     | integer |           |          | 
- c2     | integer |           |          | 
- c3     | integer |           | not null | 
- c4     | integer |           |          | 
-Indexes:
-    "test_add_column_pkey" PRIMARY KEY, btree (c3)
-Foreign-key constraints:
-    "test_add_column_c4_fkey" FOREIGN KEY (c4) REFERENCES test_add_column(c3)
-Referenced by:
-    TABLE "test_add_column" CONSTRAINT "test_add_column_c4_fkey" FOREIGN KEY (c4) REFERENCES test_add_column(c3)
-
-ALTER TABLE test_add_column
-	ADD COLUMN IF NOT EXISTS c4 integer REFERENCES test_add_column;
-NOTICE:  column "c4" of relation "test_add_column" already exists, skipping
-\d test_add_column
-          Table "public.test_add_column"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- c1     | integer |           |          | 
- c2     | integer |           |          | 
- c3     | integer |           | not null | 
- c4     | integer |           |          | 
-Indexes:
-    "test_add_column_pkey" PRIMARY KEY, btree (c3)
-Foreign-key constraints:
-    "test_add_column_c4_fkey" FOREIGN KEY (c4) REFERENCES test_add_column(c3)
-Referenced by:
-    TABLE "test_add_column" CONSTRAINT "test_add_column_c4_fkey" FOREIGN KEY (c4) REFERENCES test_add_column(c3)
-
-ALTER TABLE test_add_column
-	ADD COLUMN IF NOT EXISTS c5 SERIAL CHECK (c5 > 8);
-\d test_add_column
-                            Table "public.test_add_column"
- Column |  Type   | Collation | Nullable |                   Default                   
---------+---------+-----------+----------+---------------------------------------------
- c1     | integer |           |          | 
- c2     | integer |           |          | 
- c3     | integer |           | not null | 
- c4     | integer |           |          | 
- c5     | integer |           | not null | nextval('test_add_column_c5_seq'::regclass)
-Indexes:
-    "test_add_column_pkey" PRIMARY KEY, btree (c3)
-Check constraints:
-    "test_add_column_c5_check" CHECK (c5 > 8)
-Foreign-key constraints:
-    "test_add_column_c4_fkey" FOREIGN KEY (c4) REFERENCES test_add_column(c3)
-Referenced by:
-    TABLE "test_add_column" CONSTRAINT "test_add_column_c4_fkey" FOREIGN KEY (c4) REFERENCES test_add_column(c3)
-
-ALTER TABLE test_add_column
-	ADD COLUMN IF NOT EXISTS c5 SERIAL CHECK (c5 > 10);
-NOTICE:  column "c5" of relation "test_add_column" already exists, skipping
-\d test_add_column*
-                            Table "public.test_add_column"
- Column |  Type   | Collation | Nullable |                   Default                   
---------+---------+-----------+----------+---------------------------------------------
- c1     | integer |           |          | 
- c2     | integer |           |          | 
- c3     | integer |           | not null | 
- c4     | integer |           |          | 
- c5     | integer |           | not null | nextval('test_add_column_c5_seq'::regclass)
-Indexes:
-    "test_add_column_pkey" PRIMARY KEY, btree (c3)
-Check constraints:
-    "test_add_column_c5_check" CHECK (c5 > 8)
-Foreign-key constraints:
-    "test_add_column_c4_fkey" FOREIGN KEY (c4) REFERENCES test_add_column(c3)
-Referenced by:
-    TABLE "test_add_column" CONSTRAINT "test_add_column_c4_fkey" FOREIGN KEY (c4) REFERENCES test_add_column(c3)
-
-               Sequence "public.test_add_column_c5_seq"
-  Type   | Start | Minimum |  Maximum   | Increment | Cycles? | Cache 
----------+-------+---------+------------+-----------+---------+-------
- integer |     1 |       1 | 2147483647 |         1 | no      |     1
-Owned by: public.test_add_column.c5
-
- Index "public.test_add_column_pkey"
- Column |  Type   | Key? | Definition 
---------+---------+------+------------
- c3     | integer | yes  | c3
-primary key, btree, for table "public.test_add_column"
-
-DROP TABLE test_add_column;
-\d test_add_column*
--- assorted cases with multiple ALTER TABLE steps
-CREATE TABLE ataddindex(f1 INT);
-INSERT INTO ataddindex VALUES (42), (43);
-CREATE UNIQUE INDEX ataddindexi0 ON ataddindex(f1);
-ALTER TABLE ataddindex
-  ADD PRIMARY KEY USING INDEX ataddindexi0,
-  ALTER f1 TYPE BIGINT;
-\d ataddindex
-            Table "public.ataddindex"
- Column |  Type  | Collation | Nullable | Default 
---------+--------+-----------+----------+---------
- f1     | bigint |           | not null | 
-Indexes:
-    "ataddindexi0" PRIMARY KEY, btree (f1)
-
-DROP TABLE ataddindex;
-CREATE TABLE ataddindex(f1 VARCHAR(10));
-INSERT INTO ataddindex(f1) VALUES ('foo'), ('a');
-ALTER TABLE ataddindex
-  ALTER f1 SET DATA TYPE TEXT,
-  ADD EXCLUDE ((f1 LIKE 'a') WITH =);
-\d ataddindex
-           Table "public.ataddindex"
- Column | Type | Collation | Nullable | Default 
---------+------+-----------+----------+---------
- f1     | text |           |          | 
-Indexes:
-    "ataddindex_expr_excl" EXCLUDE USING btree ((f1 ~~ 'a'::text) WITH =)
-
-DROP TABLE ataddindex;
-CREATE TABLE ataddindex(id int, ref_id int);
-ALTER TABLE ataddindex
-  ADD PRIMARY KEY (id),
-  ADD FOREIGN KEY (ref_id) REFERENCES ataddindex;
-\d ataddindex
-             Table "public.ataddindex"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- id     | integer |           | not null | 
- ref_id | integer |           |          | 
-Indexes:
-    "ataddindex_pkey" PRIMARY KEY, btree (id)
-Foreign-key constraints:
-    "ataddindex_ref_id_fkey" FOREIGN KEY (ref_id) REFERENCES ataddindex(id)
-Referenced by:
-    TABLE "ataddindex" CONSTRAINT "ataddindex_ref_id_fkey" FOREIGN KEY (ref_id) REFERENCES ataddindex(id)
-
-DROP TABLE ataddindex;
-CREATE TABLE ataddindex(id int, ref_id int);
-ALTER TABLE ataddindex
-  ADD UNIQUE (id),
-  ADD FOREIGN KEY (ref_id) REFERENCES ataddindex (id);
-\d ataddindex
-             Table "public.ataddindex"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- id     | integer |           |          | 
- ref_id | integer |           |          | 
-Indexes:
-    "ataddindex_id_key" UNIQUE CONSTRAINT, btree (id)
-Foreign-key constraints:
-    "ataddindex_ref_id_fkey" FOREIGN KEY (ref_id) REFERENCES ataddindex(id)
-Referenced by:
-    TABLE "ataddindex" CONSTRAINT "ataddindex_ref_id_fkey" FOREIGN KEY (ref_id) REFERENCES ataddindex(id)
-
-DROP TABLE ataddindex;
--- unsupported constraint types for partitioned tables
-CREATE TABLE partitioned (
-	a int,
-	b int
-) PARTITION BY RANGE (a, (a+b+1));
-ALTER TABLE partitioned ADD EXCLUDE USING gist (a WITH &&);
-ERROR:  exclusion constraints are not supported on partitioned tables
-LINE 1: ALTER TABLE partitioned ADD EXCLUDE USING gist (a WITH &&);
-                                    ^
--- cannot drop column that is part of the partition key
-ALTER TABLE partitioned DROP COLUMN a;
-ERROR:  cannot drop column "a" because it is part of the partition key of relation "partitioned"
-ALTER TABLE partitioned ALTER COLUMN a TYPE char(5);
-ERROR:  cannot alter column "a" because it is part of the partition key of relation "partitioned"
-ALTER TABLE partitioned DROP COLUMN b;
-ERROR:  cannot drop column "b" because it is part of the partition key of relation "partitioned"
-ALTER TABLE partitioned ALTER COLUMN b TYPE char(5);
-ERROR:  cannot alter column "b" because it is part of the partition key of relation "partitioned"
--- partitioned table cannot participate in regular inheritance
-CREATE TABLE nonpartitioned (
-	a int,
-	b int
-);
-ALTER TABLE partitioned INHERIT nonpartitioned;
-ERROR:  cannot change inheritance of partitioned table
-ALTER TABLE nonpartitioned INHERIT partitioned;
-ERROR:  cannot inherit from partitioned table "partitioned"
--- cannot add NO INHERIT constraint to partitioned tables
-ALTER TABLE partitioned ADD CONSTRAINT chk_a CHECK (a > 0) NO INHERIT;
-ERROR:  cannot add NO INHERIT constraint to partitioned table "partitioned"
-DROP TABLE partitioned, nonpartitioned;
---
--- ATTACH PARTITION
---
--- check that target table is partitioned
-CREATE TABLE unparted (
-	a int
-);
-CREATE TABLE fail_part (like unparted);
-ALTER TABLE unparted ATTACH PARTITION fail_part FOR VALUES IN ('a');
-ERROR:  table "unparted" is not partitioned
-DROP TABLE unparted, fail_part;
--- check that partition bound is compatible
-CREATE TABLE list_parted (
-	a int NOT NULL,
-	b char(2) COLLATE "C",
-	CONSTRAINT check_a CHECK (a > 0)
-) PARTITION BY LIST (a);
-CREATE TABLE fail_part (LIKE list_parted);
-ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES FROM (1) TO (10);
-ERROR:  invalid bound specification for a list partition
-LINE 1: ...list_parted ATTACH PARTITION fail_part FOR VALUES FROM (1) T...
-                                                             ^
-DROP TABLE fail_part;
--- check that the table being attached exists
-ALTER TABLE list_parted ATTACH PARTITION nonexistent FOR VALUES IN (1);
-ERROR:  relation "nonexistent" does not exist
--- check ownership of the source table
-CREATE ROLE regress_test_me;
-CREATE ROLE regress_test_not_me;
-CREATE TABLE not_owned_by_me (LIKE list_parted);
-ALTER TABLE not_owned_by_me OWNER TO regress_test_not_me;
-SET SESSION AUTHORIZATION regress_test_me;
-CREATE TABLE owned_by_me (
-	a int
-) PARTITION BY LIST (a);
-ALTER TABLE owned_by_me ATTACH PARTITION not_owned_by_me FOR VALUES IN (1);
-ERROR:  must be owner of table not_owned_by_me
-RESET SESSION AUTHORIZATION;
-DROP TABLE owned_by_me, not_owned_by_me;
-DROP ROLE regress_test_not_me;
-DROP ROLE regress_test_me;
--- check that the table being attached is not part of regular inheritance
-CREATE TABLE parent (LIKE list_parted);
-CREATE TABLE child () INHERITS (parent);
-ALTER TABLE list_parted ATTACH PARTITION child FOR VALUES IN (1);
-ERROR:  cannot attach inheritance child as partition
-ALTER TABLE list_parted ATTACH PARTITION parent FOR VALUES IN (1);
-ERROR:  cannot attach inheritance parent as partition
-DROP TABLE parent CASCADE;
-NOTICE:  drop cascades to table child
--- check any TEMP-ness
-CREATE TEMP TABLE temp_parted (a int) PARTITION BY LIST (a);
-CREATE TABLE perm_part (a int);
-ALTER TABLE temp_parted ATTACH PARTITION perm_part FOR VALUES IN (1);
-ERROR:  cannot attach a permanent relation as partition of temporary relation "temp_parted"
-DROP TABLE temp_parted, perm_part;
--- check that the table being attached is not a typed table
-CREATE TYPE mytype AS (a int);
-CREATE TABLE fail_part OF mytype;
-ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1);
-ERROR:  cannot attach a typed table as partition
-DROP TYPE mytype CASCADE;
-NOTICE:  drop cascades to table fail_part
--- check that the table being attached has only columns present in the parent
-CREATE TABLE fail_part (like list_parted, c int);
-ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1);
-ERROR:  table "fail_part" contains column "c" not found in parent "list_parted"
-DETAIL:  The new partition may contain only the columns present in parent.
-DROP TABLE fail_part;
--- check that the table being attached has every column of the parent
-CREATE TABLE fail_part (a int NOT NULL);
-ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1);
-ERROR:  child table is missing column "b"
-DROP TABLE fail_part;
--- check that columns match in type, collation and NOT NULL status
-CREATE TABLE fail_part (
-	b char(3),
-	a int NOT NULL
-);
-ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1);
-ERROR:  child table "fail_part" has different type for column "b"
-ALTER TABLE fail_part ALTER b TYPE char (2) COLLATE "POSIX";
-ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1);
-ERROR:  child table "fail_part" has different collation for column "b"
-DROP TABLE fail_part;
--- check that the table being attached has all constraints of the parent
-CREATE TABLE fail_part (
-	b char(2) COLLATE "C",
-	a int NOT NULL
-);
-ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1);
-ERROR:  child table is missing constraint "check_a"
--- check that the constraint matches in definition with parent's constraint
-ALTER TABLE fail_part ADD CONSTRAINT check_a CHECK (a >= 0);
-ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1);
-ERROR:  child table "fail_part" has different definition for check constraint "check_a"
-DROP TABLE fail_part;
--- check the attributes and constraints after partition is attached
-CREATE TABLE part_1 (
-	a int NOT NULL,
-	b char(2) COLLATE "C",
-	CONSTRAINT check_a CHECK (a > 0)
-);
-ALTER TABLE list_parted ATTACH PARTITION part_1 FOR VALUES IN (1);
--- attislocal and conislocal are always false for merged attributes and constraints respectively.
-SELECT attislocal, attinhcount FROM pg_attribute WHERE attrelid = 'part_1'::regclass AND attnum > 0;
- attislocal | attinhcount 
-------------+-------------
- f          |           1
- f          |           1
-(2 rows)
-
-SELECT conislocal, coninhcount FROM pg_constraint WHERE conrelid = 'part_1'::regclass AND conname = 'check_a';
- conislocal | coninhcount 
-------------+-------------
- f          |           1
-(1 row)
-
--- check that the new partition won't overlap with an existing partition
-CREATE TABLE fail_part (LIKE part_1 INCLUDING CONSTRAINTS);
-ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1);
-ERROR:  partition "fail_part" would overlap partition "part_1"
-LINE 1: ...LE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1);
-                                                                    ^
-DROP TABLE fail_part;
--- check that an existing table can be attached as a default partition
-CREATE TABLE def_part (LIKE list_parted INCLUDING CONSTRAINTS);
-ALTER TABLE list_parted ATTACH PARTITION def_part DEFAULT;
--- check attaching default partition fails if a default partition already
--- exists
-CREATE TABLE fail_def_part (LIKE part_1 INCLUDING CONSTRAINTS);
-ALTER TABLE list_parted ATTACH PARTITION fail_def_part DEFAULT;
-ERROR:  partition "fail_def_part" conflicts with existing default partition "def_part"
-LINE 1: ...ER TABLE list_parted ATTACH PARTITION fail_def_part DEFAULT;
-                                                               ^
--- check validation when attaching list partitions
-CREATE TABLE list_parted2 (
-	a int,
-	b char
-) PARTITION BY LIST (a);
--- check that violating rows are correctly reported
-CREATE TABLE part_2 (LIKE list_parted2);
-INSERT INTO part_2 VALUES (3, 'a');
-ALTER TABLE list_parted2 ATTACH PARTITION part_2 FOR VALUES IN (2);
-ERROR:  partition constraint of relation "part_2" is violated by some row
--- should be ok after deleting the bad row
-DELETE FROM part_2;
-ALTER TABLE list_parted2 ATTACH PARTITION part_2 FOR VALUES IN (2);
--- check partition cannot be attached if default has some row for its values
-CREATE TABLE list_parted2_def PARTITION OF list_parted2 DEFAULT;
-INSERT INTO list_parted2_def VALUES (11, 'z');
-CREATE TABLE part_3 (LIKE list_parted2);
-ALTER TABLE list_parted2 ATTACH PARTITION part_3 FOR VALUES IN (11);
-ERROR:  updated partition constraint for default partition "list_parted2_def" would be violated by some row
--- should be ok after deleting the bad row
-DELETE FROM list_parted2_def WHERE a = 11;
-ALTER TABLE list_parted2 ATTACH PARTITION part_3 FOR VALUES IN (11);
--- adding constraints that describe the desired partition constraint
--- (or more restrictive) will help skip the validation scan
-CREATE TABLE part_3_4 (
-	LIKE list_parted2,
-	CONSTRAINT check_a CHECK (a IN (3))
-);
--- however, if a list partition does not accept nulls, there should be
--- an explicit NOT NULL constraint on the partition key column for the
--- validation scan to be skipped;
-ALTER TABLE list_parted2 ATTACH PARTITION part_3_4 FOR VALUES IN (3, 4);
--- adding a NOT NULL constraint will cause the scan to be skipped
-ALTER TABLE list_parted2 DETACH PARTITION part_3_4;
-ALTER TABLE part_3_4 ALTER a SET NOT NULL;
-ALTER TABLE list_parted2 ATTACH PARTITION part_3_4 FOR VALUES IN (3, 4);
--- check if default partition scan skipped
-ALTER TABLE list_parted2_def ADD CONSTRAINT check_a CHECK (a IN (5, 6));
-CREATE TABLE part_55_66 PARTITION OF list_parted2 FOR VALUES IN (55, 66);
--- check validation when attaching range partitions
-CREATE TABLE range_parted (
-	a int,
-	b int
-) PARTITION BY RANGE (a, b);
--- check that violating rows are correctly reported
-CREATE TABLE part1 (
-	a int NOT NULL CHECK (a = 1),
-	b int NOT NULL CHECK (b >= 1 AND b <= 10)
-);
-INSERT INTO part1 VALUES (1, 10);
--- Remember the TO bound is exclusive
-ALTER TABLE range_parted ATTACH PARTITION part1 FOR VALUES FROM (1, 1) TO (1, 10);
-ERROR:  partition constraint of relation "part1" is violated by some row
--- should be ok after deleting the bad row
-DELETE FROM part1;
-ALTER TABLE range_parted ATTACH PARTITION part1 FOR VALUES FROM (1, 1) TO (1, 10);
--- adding constraints that describe the desired partition constraint
--- (or more restrictive) will help skip the validation scan
-CREATE TABLE part2 (
-	a int NOT NULL CHECK (a = 1),
-	b int NOT NULL CHECK (b >= 10 AND b < 18)
-);
-ALTER TABLE range_parted ATTACH PARTITION part2 FOR VALUES FROM (1, 10) TO (1, 20);
--- Create default partition
-CREATE TABLE partr_def1 PARTITION OF range_parted DEFAULT;
--- Only one default partition is allowed, hence, following should give error
-CREATE TABLE partr_def2 (LIKE part1 INCLUDING CONSTRAINTS);
-ALTER TABLE range_parted ATTACH PARTITION partr_def2 DEFAULT;
-ERROR:  partition "partr_def2" conflicts with existing default partition "partr_def1"
-LINE 1: ...LTER TABLE range_parted ATTACH PARTITION partr_def2 DEFAULT;
-                                                               ^
--- Overlapping partitions cannot be attached, hence, following should give error
-INSERT INTO partr_def1 VALUES (2, 10);
-CREATE TABLE part3 (LIKE range_parted);
-ALTER TABLE range_parted ATTACH partition part3 FOR VALUES FROM (2, 10) TO (2, 20);
-ERROR:  updated partition constraint for default partition "partr_def1" would be violated by some row
--- Attaching partitions should be successful when there are no overlapping rows
-ALTER TABLE range_parted ATTACH partition part3 FOR VALUES FROM (3, 10) TO (3, 20);
--- check that leaf partitions are scanned when attaching a partitioned
--- table
-CREATE TABLE part_5 (
-	LIKE list_parted2
-) PARTITION BY LIST (b);
--- check that violating rows are correctly reported
-CREATE TABLE part_5_a PARTITION OF part_5 FOR VALUES IN ('a');
-INSERT INTO part_5_a (a, b) VALUES (6, 'a');
-ALTER TABLE list_parted2 ATTACH PARTITION part_5 FOR VALUES IN (5);
-ERROR:  partition constraint of relation "part_5_a" is violated by some row
--- delete the faulting row and also add a constraint to skip the scan
-DELETE FROM part_5_a WHERE a NOT IN (3);
-ALTER TABLE part_5 ADD CONSTRAINT check_a CHECK (a IS NOT NULL AND a = 5);
-ALTER TABLE list_parted2 ATTACH PARTITION part_5 FOR VALUES IN (5);
-ALTER TABLE list_parted2 DETACH PARTITION part_5;
-ALTER TABLE part_5 DROP CONSTRAINT check_a;
--- scan should again be skipped, even though NOT NULL is now a column property
-ALTER TABLE part_5 ADD CONSTRAINT check_a CHECK (a IN (5)), ALTER a SET NOT NULL;
-ALTER TABLE list_parted2 ATTACH PARTITION part_5 FOR VALUES IN (5);
--- Check the case where attnos of the partitioning columns in the table being
--- attached differs from the parent.  It should not affect the constraint-
--- checking logic that allows to skip the scan.
-CREATE TABLE part_6 (
-	c int,
-	LIKE list_parted2,
-	CONSTRAINT check_a CHECK (a IS NOT NULL AND a = 6)
-);
-ALTER TABLE part_6 DROP c;
-ALTER TABLE list_parted2 ATTACH PARTITION part_6 FOR VALUES IN (6);
--- Similar to above, but the table being attached is a partitioned table
--- whose partition has still different attnos for the root partitioning
--- columns.
-CREATE TABLE part_7 (
-	LIKE list_parted2,
-	CONSTRAINT check_a CHECK (a IS NOT NULL AND a = 7)
-) PARTITION BY LIST (b);
-CREATE TABLE part_7_a_null (
-	c int,
-	d int,
-	e int,
-	LIKE list_parted2,  -- 'a' will have attnum = 4
-	CONSTRAINT check_b CHECK (b IS NULL OR b = 'a'),
-	CONSTRAINT check_a CHECK (a IS NOT NULL AND a = 7)
-);
-ALTER TABLE part_7_a_null DROP c, DROP d, DROP e;
-ALTER TABLE part_7 ATTACH PARTITION part_7_a_null FOR VALUES IN ('a', null);
-ALTER TABLE list_parted2 ATTACH PARTITION part_7 FOR VALUES IN (7);
--- Same example, but check this time that the constraint correctly detects
--- violating rows
-ALTER TABLE list_parted2 DETACH PARTITION part_7;
-ALTER TABLE part_7 DROP CONSTRAINT check_a; -- thusly, scan won't be skipped
-INSERT INTO part_7 (a, b) VALUES (8, null), (9, 'a');
-SELECT tableoid::regclass, a, b FROM part_7 order by a;
-   tableoid    | a | b 
----------------+---+---
- part_7_a_null | 8 | 
- part_7_a_null | 9 | a
-(2 rows)
-
-ALTER TABLE list_parted2 ATTACH PARTITION part_7 FOR VALUES IN (7);
-ERROR:  partition constraint of relation "part_7_a_null" is violated by some row
--- check that leaf partitions of default partition are scanned when
--- attaching a partitioned table.
-ALTER TABLE part_5 DROP CONSTRAINT check_a;
-CREATE TABLE part5_def PARTITION OF part_5 DEFAULT PARTITION BY LIST(a);
-CREATE TABLE part5_def_p1 PARTITION OF part5_def FOR VALUES IN (5);
-INSERT INTO part5_def_p1 VALUES (5, 'y');
-CREATE TABLE part5_p1 (LIKE part_5);
-ALTER TABLE part_5 ATTACH PARTITION part5_p1 FOR VALUES IN ('y');
-ERROR:  updated partition constraint for default partition "part5_def_p1" would be violated by some row
--- should be ok after deleting the bad row
-DELETE FROM part5_def_p1 WHERE b = 'y';
-ALTER TABLE part_5 ATTACH PARTITION part5_p1 FOR VALUES IN ('y');
--- check that the table being attached is not already a partition
-ALTER TABLE list_parted2 ATTACH PARTITION part_2 FOR VALUES IN (2);
-ERROR:  "part_2" is already a partition
--- check that circular inheritance is not allowed
-ALTER TABLE part_5 ATTACH PARTITION list_parted2 FOR VALUES IN ('b');
-ERROR:  circular inheritance not allowed
-DETAIL:  "part_5" is already a child of "list_parted2".
-ALTER TABLE list_parted2 ATTACH PARTITION list_parted2 FOR VALUES IN (0);
-ERROR:  circular inheritance not allowed
-DETAIL:  "list_parted2" is already a child of "list_parted2".
--- If a partitioned table being created or an existing table being attached
--- as a partition does not have a constraint that would allow validation scan
--- to be skipped, but an individual partition does, then the partition's
--- validation scan is skipped.
-CREATE TABLE quuux (a int, b text) PARTITION BY LIST (a);
-CREATE TABLE quuux_default PARTITION OF quuux DEFAULT PARTITION BY LIST (b);
-CREATE TABLE quuux_default1 PARTITION OF quuux_default (
-	CONSTRAINT check_1 CHECK (a IS NOT NULL AND a = 1)
-) FOR VALUES IN ('b');
-CREATE TABLE quuux1 (a int, b text);
-ALTER TABLE quuux ATTACH PARTITION quuux1 FOR VALUES IN (1); -- validate!
-CREATE TABLE quuux2 (a int, b text);
-ALTER TABLE quuux ATTACH PARTITION quuux2 FOR VALUES IN (2); -- skip validation
-DROP TABLE quuux1, quuux2;
--- should validate for quuux1, but not for quuux2
-CREATE TABLE quuux1 PARTITION OF quuux FOR VALUES IN (1);
-CREATE TABLE quuux2 PARTITION OF quuux FOR VALUES IN (2);
-DROP TABLE quuux;
--- check validation when attaching hash partitions
--- Use hand-rolled hash functions and operator class to get predictable result
--- on different machines. part_test_int4_ops is defined in insert.sql.
--- check that the new partition won't overlap with an existing partition
-CREATE TABLE hash_parted (
-	a int,
-	b int
-) PARTITION BY HASH (a part_test_int4_ops);
-CREATE TABLE hpart_1 PARTITION OF hash_parted FOR VALUES WITH (MODULUS 4, REMAINDER 0);
-CREATE TABLE fail_part (LIKE hpart_1);
-ALTER TABLE hash_parted ATTACH PARTITION fail_part FOR VALUES WITH (MODULUS 8, REMAINDER 4);
-ERROR:  partition "fail_part" would overlap partition "hpart_1"
-LINE 1: ...hash_parted ATTACH PARTITION fail_part FOR VALUES WITH (MODU...
-                                                             ^
-ALTER TABLE hash_parted ATTACH PARTITION fail_part FOR VALUES WITH (MODULUS 8, REMAINDER 0);
-ERROR:  partition "fail_part" would overlap partition "hpart_1"
-LINE 1: ...hash_parted ATTACH PARTITION fail_part FOR VALUES WITH (MODU...
-                                                             ^
-DROP TABLE fail_part;
--- check validation when attaching hash partitions
--- check that violating rows are correctly reported
-CREATE TABLE hpart_2 (LIKE hash_parted);
-INSERT INTO hpart_2 VALUES (3, 0);
-ALTER TABLE hash_parted ATTACH PARTITION hpart_2 FOR VALUES WITH (MODULUS 4, REMAINDER 1);
-ERROR:  partition constraint of relation "hpart_2" is violated by some row
--- should be ok after deleting the bad row
-DELETE FROM hpart_2;
-ALTER TABLE hash_parted ATTACH PARTITION hpart_2 FOR VALUES WITH (MODULUS 4, REMAINDER 1);
--- check that leaf partitions are scanned when attaching a partitioned
--- table
-CREATE TABLE hpart_5 (
-	LIKE hash_parted
-) PARTITION BY LIST (b);
--- check that violating rows are correctly reported
-CREATE TABLE hpart_5_a PARTITION OF hpart_5 FOR VALUES IN ('1', '2', '3');
-INSERT INTO hpart_5_a (a, b) VALUES (7, 1);
-ALTER TABLE hash_parted ATTACH PARTITION hpart_5 FOR VALUES WITH (MODULUS 4, REMAINDER 2);
-ERROR:  partition constraint of relation "hpart_5_a" is violated by some row
--- should be ok after deleting the bad row
-DELETE FROM hpart_5_a;
-ALTER TABLE hash_parted ATTACH PARTITION hpart_5 FOR VALUES WITH (MODULUS 4, REMAINDER 2);
--- check that the table being attach is with valid modulus and remainder value
-CREATE TABLE fail_part(LIKE hash_parted);
-ALTER TABLE hash_parted ATTACH PARTITION fail_part FOR VALUES WITH (MODULUS 0, REMAINDER 1);
-ERROR:  modulus for hash partition must be an integer value greater than zero
-ALTER TABLE hash_parted ATTACH PARTITION fail_part FOR VALUES WITH (MODULUS 8, REMAINDER 8);
-ERROR:  remainder for hash partition must be less than modulus
-ALTER TABLE hash_parted ATTACH PARTITION fail_part FOR VALUES WITH (MODULUS 3, REMAINDER 2);
-ERROR:  every hash partition modulus must be a factor of the next larger modulus
-DETAIL:  The new modulus 3 is not a factor of 4, the modulus of existing partition "hpart_1".
-DROP TABLE fail_part;
---
--- DETACH PARTITION
---
--- check that the table is partitioned at all
-CREATE TABLE regular_table (a int);
-ALTER TABLE regular_table DETACH PARTITION any_name;
-ERROR:  table "regular_table" is not partitioned
-DROP TABLE regular_table;
--- check that the partition being detached exists at all
-ALTER TABLE list_parted2 DETACH PARTITION part_4;
-ERROR:  relation "part_4" does not exist
-ALTER TABLE hash_parted DETACH PARTITION hpart_4;
-ERROR:  relation "hpart_4" does not exist
--- check that the partition being detached is actually a partition of the parent
-CREATE TABLE not_a_part (a int);
-ALTER TABLE list_parted2 DETACH PARTITION not_a_part;
-ERROR:  relation "not_a_part" is not a partition of relation "list_parted2"
-ALTER TABLE list_parted2 DETACH PARTITION part_1;
-ERROR:  relation "part_1" is not a partition of relation "list_parted2"
-ALTER TABLE hash_parted DETACH PARTITION not_a_part;
-ERROR:  relation "not_a_part" is not a partition of relation "hash_parted"
-DROP TABLE not_a_part;
--- check that, after being detached, attinhcount/coninhcount is dropped to 0 and
--- attislocal/conislocal is set to true
-ALTER TABLE list_parted2 DETACH PARTITION part_3_4;
-SELECT attinhcount, attislocal FROM pg_attribute WHERE attrelid = 'part_3_4'::regclass AND attnum > 0;
- attinhcount | attislocal 
--------------+------------
-           0 | t
-           0 | t
-(2 rows)
-
-SELECT coninhcount, conislocal FROM pg_constraint WHERE conrelid = 'part_3_4'::regclass AND conname = 'check_a';
- coninhcount | conislocal 
--------------+------------
-           0 | t
-(1 row)
-
-DROP TABLE part_3_4;
--- check that a detached partition is not dropped on dropping a partitioned table
-CREATE TABLE range_parted2 (
-    a int
-) PARTITION BY RANGE(a);
-CREATE TABLE part_rp PARTITION OF range_parted2 FOR VALUES FROM (0) to (100);
-ALTER TABLE range_parted2 DETACH PARTITION part_rp;
-DROP TABLE range_parted2;
-SELECT * from part_rp;
- a 
----
-(0 rows)
-
-DROP TABLE part_rp;
--- concurrent detach
-CREATE TABLE range_parted2 (
-	a int
-) PARTITION BY RANGE(a);
-CREATE TABLE part_rp PARTITION OF range_parted2 FOR VALUES FROM (0) to (100);
-BEGIN;
--- doesn't work in a partition block
-ALTER TABLE range_parted2 DETACH PARTITION part_rp CONCURRENTLY;
-ERROR:  ALTER TABLE ... DETACH CONCURRENTLY cannot run inside a transaction block
-COMMIT;
-CREATE TABLE part_rpd PARTITION OF range_parted2 DEFAULT;
--- doesn't work if there's a default partition
-ALTER TABLE range_parted2 DETACH PARTITION part_rp CONCURRENTLY;
-ERROR:  cannot detach partitions concurrently when a default partition exists
--- doesn't work for the default partition
-ALTER TABLE range_parted2 DETACH PARTITION part_rpd CONCURRENTLY;
-ERROR:  cannot detach partitions concurrently when a default partition exists
-DROP TABLE part_rpd;
--- works fine
-ALTER TABLE range_parted2 DETACH PARTITION part_rp CONCURRENTLY;
-\d+ range_parted2
-                         Partitioned table "public.range_parted2"
- Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
---------+---------+-----------+----------+---------+---------+--------------+-------------
- a      | integer |           |          |         | plain   |              | 
-Partition key: RANGE (a)
-Number of partitions: 0
-
--- constraint should be created
-\d part_rp
-              Table "public.part_rp"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
-Check constraints:
-    "part_rp_a_check" CHECK (a IS NOT NULL AND a >= 0 AND a < 100)
-
-CREATE TABLE part_rp100 PARTITION OF range_parted2 (CHECK (a>=123 AND a<133 AND a IS NOT NULL)) FOR VALUES FROM (100) to (200);
-ALTER TABLE range_parted2 DETACH PARTITION part_rp100 CONCURRENTLY;
--- redundant constraint should not be created
-\d part_rp100
-             Table "public.part_rp100"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
-Check constraints:
-    "part_rp100_a_check" CHECK (a >= 123 AND a < 133 AND a IS NOT NULL)
-
-DROP TABLE range_parted2;
--- Check ALTER TABLE commands for partitioned tables and partitions
--- cannot add/drop column to/from *only* the parent
-ALTER TABLE ONLY list_parted2 ADD COLUMN c int;
-ERROR:  column must be added to child tables too
-ALTER TABLE ONLY list_parted2 DROP COLUMN b;
-ERROR:  cannot drop column from only the partitioned table when partitions exist
-HINT:  Do not specify the ONLY keyword.
--- cannot add a column to partition or drop an inherited one
-ALTER TABLE part_2 ADD COLUMN c text;
-ERROR:  cannot add column to a partition
-ALTER TABLE part_2 DROP COLUMN b;
-ERROR:  cannot drop inherited column "b"
--- Nor rename, alter type
-ALTER TABLE part_2 RENAME COLUMN b to c;
-ERROR:  cannot rename inherited column "b"
-ALTER TABLE part_2 ALTER COLUMN b TYPE text;
-ERROR:  cannot alter inherited column "b"
--- cannot add/drop NOT NULL or check constraints to *only* the parent, when
--- partitions exist
-ALTER TABLE ONLY list_parted2 ALTER b SET NOT NULL;
-ERROR:  constraint must be added to child tables too
-DETAIL:  Column "b" of relation "part_2" is not already NOT NULL.
-HINT:  Do not specify the ONLY keyword.
-ALTER TABLE ONLY list_parted2 ADD CONSTRAINT check_b CHECK (b <> 'zz');
-ERROR:  constraint must be added to child tables too
-ALTER TABLE list_parted2 ALTER b SET NOT NULL;
-ALTER TABLE ONLY list_parted2 ALTER b DROP NOT NULL;
-ERROR:  cannot remove constraint from only the partitioned table when partitions exist
-HINT:  Do not specify the ONLY keyword.
-ALTER TABLE list_parted2 ADD CONSTRAINT check_b CHECK (b <> 'zz');
-ALTER TABLE ONLY list_parted2 DROP CONSTRAINT check_b;
-ERROR:  cannot remove constraint from only the partitioned table when partitions exist
-HINT:  Do not specify the ONLY keyword.
--- It's alright though, if no partitions are yet created
-CREATE TABLE parted_no_parts (a int) PARTITION BY LIST (a);
-ALTER TABLE ONLY parted_no_parts ALTER a SET NOT NULL;
-ALTER TABLE ONLY parted_no_parts ADD CONSTRAINT check_a CHECK (a > 0);
-ALTER TABLE ONLY parted_no_parts ALTER a DROP NOT NULL;
-ALTER TABLE ONLY parted_no_parts DROP CONSTRAINT check_a;
-DROP TABLE parted_no_parts;
--- cannot drop inherited NOT NULL or check constraints from partition
-ALTER TABLE list_parted2 ALTER b SET NOT NULL, ADD CONSTRAINT check_a2 CHECK (a > 0);
-ALTER TABLE part_2 ALTER b DROP NOT NULL;
-ERROR:  column "b" is marked NOT NULL in parent table
-ALTER TABLE part_2 DROP CONSTRAINT check_a2;
-ERROR:  cannot drop inherited constraint "check_a2" of relation "part_2"
--- Doesn't make sense to add NO INHERIT constraints on partitioned tables
-ALTER TABLE list_parted2 add constraint check_b2 check (b <> 'zz') NO INHERIT;
-ERROR:  cannot add NO INHERIT constraint to partitioned table "list_parted2"
--- check that a partition cannot participate in regular inheritance
-CREATE TABLE inh_test () INHERITS (part_2);
-ERROR:  cannot inherit from partition "part_2"
-CREATE TABLE inh_test (LIKE part_2);
-ALTER TABLE inh_test INHERIT part_2;
-ERROR:  cannot inherit from a partition
-ALTER TABLE part_2 INHERIT inh_test;
-ERROR:  cannot change inheritance of a partition
--- cannot drop or alter type of partition key columns of lower level
--- partitioned tables; for example, part_5, which is list_parted2's
--- partition, is partitioned on b;
-ALTER TABLE list_parted2 DROP COLUMN b;
-ERROR:  cannot drop column "b" because it is part of the partition key of relation "part_5"
-ALTER TABLE list_parted2 ALTER COLUMN b TYPE text;
-ERROR:  cannot alter column "b" because it is part of the partition key of relation "part_5"
--- dropping non-partition key columns should be allowed on the parent table.
-ALTER TABLE list_parted DROP COLUMN b;
-SELECT * FROM list_parted;
- a 
----
-(0 rows)
-
--- cleanup
-DROP TABLE list_parted, list_parted2, range_parted;
-DROP TABLE fail_def_part;
-DROP TABLE hash_parted;
--- more tests for certain multi-level partitioning scenarios
-create table p (a int, b int) partition by range (a, b);
-create table p1 (b int, a int not null) partition by range (b);
-create table p11 (like p1);
-alter table p11 drop a;
-alter table p11 add a int;
-alter table p11 drop a;
-alter table p11 add a int not null;
--- attnum for key attribute 'a' is different in p, p1, and p11
-select attrelid::regclass, attname, attnum
-from pg_attribute
-where attname = 'a'
- and (attrelid = 'p'::regclass
-   or attrelid = 'p1'::regclass
-   or attrelid = 'p11'::regclass)
-order by attrelid::regclass::text;
- attrelid | attname | attnum 
-----------+---------+--------
- p        | a       |      1
- p1       | a       |      2
- p11      | a       |      4
-(3 rows)
-
-alter table p1 attach partition p11 for values from (2) to (5);
-insert into p1 (a, b) values (2, 3);
--- check that partition validation scan correctly detects violating rows
-alter table p attach partition p1 for values from (1, 2) to (1, 10);
-ERROR:  partition constraint of relation "p11" is violated by some row
--- cleanup
-drop table p;
-drop table p1;
--- validate constraint on partitioned tables should only scan leaf partitions
-create table parted_validate_test (a int) partition by list (a);
-create table parted_validate_test_1 partition of parted_validate_test for values in (0, 1);
-alter table parted_validate_test add constraint parted_validate_test_chka check (a > 0) not valid;
-alter table parted_validate_test validate constraint parted_validate_test_chka;
-drop table parted_validate_test;
--- test alter column options
-CREATE TABLE attmp(i integer);
-INSERT INTO attmp VALUES (1);
-ALTER TABLE attmp ALTER COLUMN i SET (n_distinct = 1, n_distinct_inherited = 2);
-ALTER TABLE attmp ALTER COLUMN i RESET (n_distinct_inherited);
-ANALYZE attmp;
-DROP TABLE attmp;
-DROP USER regress_alter_table_user1;
--- check that violating rows are correctly reported when attaching as the
--- default partition
-create table defpart_attach_test (a int) partition by list (a);
-create table defpart_attach_test1 partition of defpart_attach_test for values in (1);
-create table defpart_attach_test_d (b int, a int);
-alter table defpart_attach_test_d drop b;
-insert into defpart_attach_test_d values (1), (2);
--- error because its constraint as the default partition would be violated
--- by the row containing 1
-alter table defpart_attach_test attach partition defpart_attach_test_d default;
-ERROR:  partition constraint of relation "defpart_attach_test_d" is violated by some row
-delete from defpart_attach_test_d where a = 1;
-alter table defpart_attach_test_d add check (a > 1);
--- should be attached successfully and without needing to be scanned
-alter table defpart_attach_test attach partition defpart_attach_test_d default;
--- check that attaching a partition correctly reports any rows in the default
--- partition that should not be there for the new partition to be attached
--- successfully
-create table defpart_attach_test_2 (like defpart_attach_test_d);
-alter table defpart_attach_test attach partition defpart_attach_test_2 for values in (2);
-ERROR:  updated partition constraint for default partition "defpart_attach_test_d" would be violated by some row
-drop table defpart_attach_test;
--- check combinations of temporary and permanent relations when attaching
--- partitions.
-create table perm_part_parent (a int) partition by list (a);
-create temp table temp_part_parent (a int) partition by list (a);
-create table perm_part_child (a int);
-create temp table temp_part_child (a int);
-alter table temp_part_parent attach partition perm_part_child default; -- error
-ERROR:  cannot attach a permanent relation as partition of temporary relation "temp_part_parent"
-alter table perm_part_parent attach partition temp_part_child default; -- error
-ERROR:  cannot attach a temporary relation as partition of permanent relation "perm_part_parent"
-alter table temp_part_parent attach partition temp_part_child default; -- ok
-drop table perm_part_parent cascade;
-drop table temp_part_parent cascade;
--- check that attaching partitions to a table while it is being used is
--- prevented
-create table tab_part_attach (a int) partition by list (a);
-create or replace function func_part_attach() returns trigger
-  language plpgsql as $$
-  begin
-    execute 'create table tab_part_attach_1 (a int)';
-    execute 'alter table tab_part_attach attach partition tab_part_attach_1 for values in (1)';
-    return null;
-  end $$;
-create trigger trig_part_attach before insert on tab_part_attach
-  for each statement execute procedure func_part_attach();
-insert into tab_part_attach values (1);
-ERROR:  cannot ALTER TABLE "tab_part_attach" because it is being used by active queries in this session
-CONTEXT:  SQL statement "alter table tab_part_attach attach partition tab_part_attach_1 for values in (1)"
-PL/pgSQL function func_part_attach() line 4 at EXECUTE
-drop table tab_part_attach;
-drop function func_part_attach();
--- test case where the partitioning operator is a SQL function whose
--- evaluation results in the table's relcache being rebuilt partway through
--- the execution of an ATTACH PARTITION command
-create function at_test_sql_partop (int4, int4) returns int language sql
-as $$ select case when $1 = $2 then 0 when $1 > $2 then 1 else -1 end; $$;
-create operator class at_test_sql_partop for type int4 using btree as
-    operator 1 < (int4, int4), operator 2 <= (int4, int4),
-    operator 3 = (int4, int4), operator 4 >= (int4, int4),
-    operator 5 > (int4, int4), function 1 at_test_sql_partop(int4, int4);
-create table at_test_sql_partop (a int) partition by range (a at_test_sql_partop);
-create table at_test_sql_partop_1 (a int);
-alter table at_test_sql_partop attach partition at_test_sql_partop_1 for values from (0) to (10);
-drop table at_test_sql_partop;
-drop operator class at_test_sql_partop using btree;
-drop function at_test_sql_partop;
-/* Test case for bug #16242 */
--- We create a parent and child where the child has missing
--- non-null attribute values, and arrange to pass them through
--- tuple conversion from the child to the parent tupdesc
-create table bar1 (a integer, b integer not null default 1)
-  partition by range (a);
-create table bar2 (a integer);
-insert into bar2 values (1);
-alter table bar2 add column b integer not null default 1;
--- (at this point bar2 contains tuple with natts=1)
-alter table bar1 attach partition bar2 default;
--- this works:
-select * from bar1;
- a | b 
----+---
- 1 | 1
-(1 row)
-
--- this exercises tuple conversion:
-create function xtrig()
-  returns trigger language plpgsql
-as $$
-  declare
-    r record;
-  begin
-    for r in select * from old loop
-      raise info 'a=%, b=%', r.a, r.b;
-    end loop;
-    return NULL;
-  end;
-$$;
-create trigger xtrig
-  after update on bar1
-  referencing old table as old
-  for each statement execute procedure xtrig();
-update bar1 set a = a + 1;
-INFO:  a=1, b=1
-/* End test case for bug #16242 */
--- Test that ALTER TABLE rewrite preserves a clustered index
--- for normal indexes and indexes on constraints.
-create table alttype_cluster (a int);
-alter table alttype_cluster add primary key (a);
-create index alttype_cluster_ind on alttype_cluster (a);
-alter table alttype_cluster cluster on alttype_cluster_ind;
--- Normal index remains clustered.
-select indexrelid::regclass, indisclustered from pg_index
-  where indrelid = 'alttype_cluster'::regclass
-  order by indexrelid::regclass::text;
-      indexrelid      | indisclustered 
-----------------------+----------------
- alttype_cluster_ind  | t
- alttype_cluster_pkey | f
-(2 rows)
-
-alter table alttype_cluster alter a type bigint;
-select indexrelid::regclass, indisclustered from pg_index
-  where indrelid = 'alttype_cluster'::regclass
-  order by indexrelid::regclass::text;
-      indexrelid      | indisclustered 
-----------------------+----------------
- alttype_cluster_ind  | t
- alttype_cluster_pkey | f
-(2 rows)
-
--- Constraint index remains clustered.
-alter table alttype_cluster cluster on alttype_cluster_pkey;
-select indexrelid::regclass, indisclustered from pg_index
-  where indrelid = 'alttype_cluster'::regclass
-  order by indexrelid::regclass::text;
-      indexrelid      | indisclustered 
-----------------------+----------------
- alttype_cluster_ind  | f
- alttype_cluster_pkey | t
-(2 rows)
-
-alter table alttype_cluster alter a type int;
-select indexrelid::regclass, indisclustered from pg_index
-  where indrelid = 'alttype_cluster'::regclass
-  order by indexrelid::regclass::text;
-      indexrelid      | indisclustered 
-----------------------+----------------
- alttype_cluster_ind  | f
- alttype_cluster_pkey | t
-(2 rows)
-
-drop table alttype_cluster;
diff -U3 /Users/kenaniah/workspace/postgres/src/test/regress/expected/sequence.out /Users/kenaniah/workspace/postgres/src/test/regress/results/sequence.out
--- /Users/kenaniah/workspace/postgres/src/test/regress/expected/sequence.out	2021-10-03 18:09:17.000000000 -0700
+++ /Users/kenaniah/workspace/postgres/src/test/regress/results/sequence.out	2021-10-03 20:08:23.000000000 -0700
@@ -537,289 +537,11 @@
 (1 row)
 
 \d sequence_test4
-                       Sequence "public.sequence_test4"
-  Type  | Start |       Minimum        | Maximum | Increment | Cycles? | Cache 
---------+-------+----------------------+---------+-----------+---------+-------
- bigint |    -1 | -9223372036854775808 |      -1 |        -1 | no      |     1
+dyld: lazy symbol binding failed: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
+
+dyld: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
 
-\d serialtest2_f2_seq
-                 Sequence "public.serialtest2_f2_seq"
-  Type   | Start | Minimum |  Maximum   | Increment | Cycles? | Cache 
----------+-------+---------+------------+-----------+---------+-------
- integer |     1 |       1 | 2147483647 |         1 | no      |     1
-Owned by: public.serialtest2.f2
-
--- Test comments
-COMMENT ON SEQUENCE asdf IS 'won''t work';
-ERROR:  relation "asdf" does not exist
-COMMENT ON SEQUENCE sequence_test2 IS 'will work';
-COMMENT ON SEQUENCE sequence_test2 IS NULL;
--- Test lastval()
-CREATE SEQUENCE seq;
-SELECT nextval('seq');
- nextval 
----------
-       1
-(1 row)
-
-SELECT lastval();
- lastval 
----------
-       1
-(1 row)
-
-SELECT setval('seq', 99);
- setval 
---------
-     99
-(1 row)
-
-SELECT lastval();
- lastval 
----------
-      99
-(1 row)
-
-DISCARD SEQUENCES;
-SELECT lastval();
-ERROR:  lastval is not yet defined in this session
-CREATE SEQUENCE seq2;
-SELECT nextval('seq2');
- nextval 
----------
-       1
-(1 row)
-
-SELECT lastval();
- lastval 
----------
-       1
-(1 row)
-
-DROP SEQUENCE seq2;
--- should fail
-SELECT lastval();
-ERROR:  lastval is not yet defined in this session
--- Test sequences in read-only transactions
-CREATE TEMPORARY SEQUENCE sequence_test_temp1;
-START TRANSACTION READ ONLY;
-SELECT nextval('sequence_test_temp1');  -- ok
- nextval 
----------
-       1
-(1 row)
-
-SELECT nextval('sequence_test2');  -- error
-ERROR:  cannot execute nextval() in a read-only transaction
-ROLLBACK;
-START TRANSACTION READ ONLY;
-SELECT setval('sequence_test_temp1', 1);  -- ok
- setval 
---------
-      1
-(1 row)
-
-SELECT setval('sequence_test2', 1);  -- error
-ERROR:  cannot execute setval() in a read-only transaction
-ROLLBACK;
--- privileges tests
-CREATE USER regress_seq_user;
--- nextval
-BEGIN;
-SET LOCAL SESSION AUTHORIZATION regress_seq_user;
-CREATE SEQUENCE seq3;
-REVOKE ALL ON seq3 FROM regress_seq_user;
-GRANT SELECT ON seq3 TO regress_seq_user;
-SELECT nextval('seq3');
-ERROR:  permission denied for sequence seq3
-ROLLBACK;
-BEGIN;
-SET LOCAL SESSION AUTHORIZATION regress_seq_user;
-CREATE SEQUENCE seq3;
-REVOKE ALL ON seq3 FROM regress_seq_user;
-GRANT UPDATE ON seq3 TO regress_seq_user;
-SELECT nextval('seq3');
- nextval 
----------
-       1
-(1 row)
-
-ROLLBACK;
-BEGIN;
-SET LOCAL SESSION AUTHORIZATION regress_seq_user;
-CREATE SEQUENCE seq3;
-REVOKE ALL ON seq3 FROM regress_seq_user;
-GRANT USAGE ON seq3 TO regress_seq_user;
-SELECT nextval('seq3');
- nextval 
----------
-       1
-(1 row)
-
-ROLLBACK;
--- currval
-BEGIN;
-SET LOCAL SESSION AUTHORIZATION regress_seq_user;
-CREATE SEQUENCE seq3;
-SELECT nextval('seq3');
- nextval 
----------
-       1
-(1 row)
-
-REVOKE ALL ON seq3 FROM regress_seq_user;
-GRANT SELECT ON seq3 TO regress_seq_user;
-SELECT currval('seq3');
- currval 
----------
-       1
-(1 row)
-
-ROLLBACK;
-BEGIN;
-SET LOCAL SESSION AUTHORIZATION regress_seq_user;
-CREATE SEQUENCE seq3;
-SELECT nextval('seq3');
- nextval 
----------
-       1
-(1 row)
-
-REVOKE ALL ON seq3 FROM regress_seq_user;
-GRANT UPDATE ON seq3 TO regress_seq_user;
-SELECT currval('seq3');
-ERROR:  permission denied for sequence seq3
-ROLLBACK;
-BEGIN;
-SET LOCAL SESSION AUTHORIZATION regress_seq_user;
-CREATE SEQUENCE seq3;
-SELECT nextval('seq3');
- nextval 
----------
-       1
-(1 row)
-
-REVOKE ALL ON seq3 FROM regress_seq_user;
-GRANT USAGE ON seq3 TO regress_seq_user;
-SELECT currval('seq3');
- currval 
----------
-       1
-(1 row)
-
-ROLLBACK;
--- lastval
-BEGIN;
-SET LOCAL SESSION AUTHORIZATION regress_seq_user;
-CREATE SEQUENCE seq3;
-SELECT nextval('seq3');
- nextval 
----------
-       1
-(1 row)
-
-REVOKE ALL ON seq3 FROM regress_seq_user;
-GRANT SELECT ON seq3 TO regress_seq_user;
-SELECT lastval();
- lastval 
----------
-       1
-(1 row)
-
-ROLLBACK;
-BEGIN;
-SET LOCAL SESSION AUTHORIZATION regress_seq_user;
-CREATE SEQUENCE seq3;
-SELECT nextval('seq3');
- nextval 
----------
-       1
-(1 row)
-
-REVOKE ALL ON seq3 FROM regress_seq_user;
-GRANT UPDATE ON seq3 TO regress_seq_user;
-SELECT lastval();
-ERROR:  permission denied for sequence seq3
-ROLLBACK;
-BEGIN;
-SET LOCAL SESSION AUTHORIZATION regress_seq_user;
-CREATE SEQUENCE seq3;
-SELECT nextval('seq3');
- nextval 
----------
-       1
-(1 row)
-
-REVOKE ALL ON seq3 FROM regress_seq_user;
-GRANT USAGE ON seq3 TO regress_seq_user;
-SELECT lastval();
- lastval 
----------
-       1
-(1 row)
-
-ROLLBACK;
--- setval
-BEGIN;
-SET LOCAL SESSION AUTHORIZATION regress_seq_user;
-CREATE SEQUENCE seq3;
-REVOKE ALL ON seq3 FROM regress_seq_user;
-SAVEPOINT save;
-SELECT setval('seq3', 5);
-ERROR:  permission denied for sequence seq3
-ROLLBACK TO save;
-GRANT UPDATE ON seq3 TO regress_seq_user;
-SELECT setval('seq3', 5);
- setval 
---------
-      5
-(1 row)
-
-SELECT nextval('seq3');
- nextval 
----------
-       6
-(1 row)
-
-ROLLBACK;
--- ALTER SEQUENCE
-BEGIN;
-SET LOCAL SESSION AUTHORIZATION regress_seq_user;
-ALTER SEQUENCE sequence_test2 START WITH 1;
-ERROR:  must be owner of sequence sequence_test2
-ROLLBACK;
--- Sequences should get wiped out as well:
-DROP TABLE serialTest1, serialTest2;
--- Make sure sequences are gone:
-SELECT * FROM information_schema.sequences WHERE sequence_name IN
-  ('sequence_test2', 'serialtest2_f2_seq', 'serialtest2_f3_seq',
-   'serialtest2_f4_seq', 'serialtest2_f5_seq', 'serialtest2_f6_seq')
-  ORDER BY sequence_name ASC;
- sequence_catalog | sequence_schema | sequence_name  | data_type | numeric_precision | numeric_precision_radix | numeric_scale | start_value | minimum_value | maximum_value | increment | cycle_option 
-------------------+-----------------+----------------+-----------+-------------------+-------------------------+---------------+-------------+---------------+---------------+-----------+--------------
- regression       | public          | sequence_test2 | bigint    |                64 |                       2 |             0 | 32          | 5             | 36            | 4         | YES
-(1 row)
-
-DROP USER regress_seq_user;
-DROP SEQUENCE seq;
--- cache tests
-CREATE SEQUENCE test_seq1 CACHE 10;
-SELECT nextval('test_seq1');
- nextval 
----------
-       1
-(1 row)
-
-SELECT nextval('test_seq1');
- nextval 
----------
-       2
-(1 row)
-
-SELECT nextval('test_seq1');
- nextval 
----------
-       3
-(1 row)
-
-DROP SEQUENCE test_seq1;
diff -U3 /Users/kenaniah/workspace/postgres/src/test/regress/expected/polymorphism.out /Users/kenaniah/workspace/postgres/src/test/regress/results/polymorphism.out
--- /Users/kenaniah/workspace/postgres/src/test/regress/expected/polymorphism.out	2021-10-03 17:41:49.000000000 -0700
+++ /Users/kenaniah/workspace/postgres/src/test/regress/results/polymorphism.out	2021-10-03 20:08:23.000000000 -0700
@@ -1177,922 +1177,11 @@
 
 -- verify it lists properly
 \df dfunc
-                                          List of functions
- Schema | Name  | Result data type |                    Argument data types                    | Type 
---------+-------+------------------+-----------------------------------------------------------+------
- public | dfunc | integer          | a integer DEFAULT 1, OUT sum integer, b integer DEFAULT 2 | func
-(1 row)
+dyld: lazy symbol binding failed: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
+
+dyld: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
 
-drop function dfunc(int, int);
--- check implicit coercion
-create function dfunc(a int DEFAULT 1.0, int DEFAULT '-1') returns int as $$
-  select $1 + $2;
-$$ language sql;
-select dfunc();
- dfunc 
--------
-     0
-(1 row)
-
-create function dfunc(a text DEFAULT 'Hello', b text DEFAULT 'World') returns text as $$
-  select $1 || ', ' || $2;
-$$ language sql;
-select dfunc();  -- fail: which dfunc should be called? int or text
-ERROR:  function dfunc() is not unique
-LINE 1: select dfunc();
-               ^
-HINT:  Could not choose a best candidate function. You might need to add explicit type casts.
-select dfunc('Hi');  -- ok
-   dfunc   
------------
- Hi, World
-(1 row)
-
-select dfunc('Hi', 'City');  -- ok
-  dfunc   
-----------
- Hi, City
-(1 row)
-
-select dfunc(0);  -- ok
- dfunc 
--------
-    -1
-(1 row)
-
-select dfunc(10, 20);  -- ok
- dfunc 
--------
-    30
-(1 row)
-
-drop function dfunc(int, int);
-drop function dfunc(text, text);
-create function dfunc(int = 1, int = 2) returns int as $$
-  select 2;
-$$ language sql;
-create function dfunc(int = 1, int = 2, int = 3, int = 4) returns int as $$
-  select 4;
-$$ language sql;
--- Now, dfunc(nargs = 2) and dfunc(nargs = 4) are ambiguous when called
--- with 0 to 2 arguments.
-select dfunc();  -- fail
-ERROR:  function dfunc() is not unique
-LINE 1: select dfunc();
-               ^
-HINT:  Could not choose a best candidate function. You might need to add explicit type casts.
-select dfunc(1);  -- fail
-ERROR:  function dfunc(integer) is not unique
-LINE 1: select dfunc(1);
-               ^
-HINT:  Could not choose a best candidate function. You might need to add explicit type casts.
-select dfunc(1, 2);  -- fail
-ERROR:  function dfunc(integer, integer) is not unique
-LINE 1: select dfunc(1, 2);
-               ^
-HINT:  Could not choose a best candidate function. You might need to add explicit type casts.
-select dfunc(1, 2, 3);  -- ok
- dfunc 
--------
-     4
-(1 row)
-
-select dfunc(1, 2, 3, 4);  -- ok
- dfunc 
--------
-     4
-(1 row)
-
-drop function dfunc(int, int);
-drop function dfunc(int, int, int, int);
--- default values are not allowed for output parameters
-create function dfunc(out int = 20) returns int as $$
-  select 1;
-$$ language sql;
-ERROR:  only input parameters can have default values
--- polymorphic parameter test
-create function dfunc(anyelement = 'World'::text) returns text as $$
-  select 'Hello, ' || $1::text;
-$$ language sql;
-select dfunc();
-    dfunc     
---------------
- Hello, World
-(1 row)
-
-select dfunc(0);
-  dfunc   
-----------
- Hello, 0
-(1 row)
-
-select dfunc(to_date('20081215','YYYYMMDD'));
-       dfunc       
--------------------
- Hello, 12-15-2008
-(1 row)
-
-select dfunc('City'::text);
-    dfunc    
--------------
- Hello, City
-(1 row)
-
-drop function dfunc(anyelement);
--- check defaults for variadics
-create function dfunc(a variadic int[]) returns int as
-$$ select array_upper($1, 1) $$ language sql;
-select dfunc();  -- fail
-ERROR:  function dfunc() does not exist
-LINE 1: select dfunc();
-               ^
-HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
-select dfunc(10);
- dfunc 
--------
-     1
-(1 row)
-
-select dfunc(10,20);
- dfunc 
--------
-     2
-(1 row)
-
-create or replace function dfunc(a variadic int[] default array[]::int[]) returns int as
-$$ select array_upper($1, 1) $$ language sql;
-select dfunc();  -- now ok
- dfunc 
--------
-      
-(1 row)
-
-select dfunc(10);
- dfunc 
--------
-     1
-(1 row)
-
-select dfunc(10,20);
- dfunc 
--------
-     2
-(1 row)
-
--- can't remove the default once it exists
-create or replace function dfunc(a variadic int[]) returns int as
-$$ select array_upper($1, 1) $$ language sql;
-ERROR:  cannot remove parameter defaults from existing function
-HINT:  Use DROP FUNCTION dfunc(integer[]) first.
-\df dfunc
-                                     List of functions
- Schema | Name  | Result data type |               Argument data types               | Type 
---------+-------+------------------+-------------------------------------------------+------
- public | dfunc | integer          | VARIADIC a integer[] DEFAULT ARRAY[]::integer[] | func
-(1 row)
-
-drop function dfunc(a variadic int[]);
--- Ambiguity should be reported only if there's not a better match available
-create function dfunc(int = 1, int = 2, int = 3) returns int as $$
-  select 3;
-$$ language sql;
-create function dfunc(int = 1, int = 2) returns int as $$
-  select 2;
-$$ language sql;
-create function dfunc(text) returns text as $$
-  select $1;
-$$ language sql;
--- dfunc(narg=2) and dfunc(narg=3) are ambiguous
-select dfunc(1);  -- fail
-ERROR:  function dfunc(integer) is not unique
-LINE 1: select dfunc(1);
-               ^
-HINT:  Could not choose a best candidate function. You might need to add explicit type casts.
--- but this works since the ambiguous functions aren't preferred anyway
-select dfunc('Hi');
- dfunc 
--------
- Hi
-(1 row)
-
-drop function dfunc(int, int, int);
-drop function dfunc(int, int);
-drop function dfunc(text);
---
--- Tests for named- and mixed-notation function calling
---
-create function dfunc(a int, b int, c int = 0, d int = 0)
-  returns table (a int, b int, c int, d int) as $$
-  select $1, $2, $3, $4;
-$$ language sql;
-select (dfunc(10,20,30)).*;
- a  | b  | c  | d 
-----+----+----+---
- 10 | 20 | 30 | 0
-(1 row)
-
-select (dfunc(a := 10, b := 20, c := 30)).*;
- a  | b  | c  | d 
-----+----+----+---
- 10 | 20 | 30 | 0
-(1 row)
-
-select * from dfunc(a := 10, b := 20);
- a  | b  | c | d 
-----+----+---+---
- 10 | 20 | 0 | 0
-(1 row)
-
-select * from dfunc(b := 10, a := 20);
- a  | b  | c | d 
-----+----+---+---
- 20 | 10 | 0 | 0
-(1 row)
-
-select * from dfunc(0);  -- fail
-ERROR:  function dfunc(integer) does not exist
-LINE 1: select * from dfunc(0);
-                      ^
-HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
-select * from dfunc(1,2);
- a | b | c | d 
----+---+---+---
- 1 | 2 | 0 | 0
-(1 row)
-
-select * from dfunc(1,2,c := 3);
- a | b | c | d 
----+---+---+---
- 1 | 2 | 3 | 0
-(1 row)
-
-select * from dfunc(1,2,d := 3);
- a | b | c | d 
----+---+---+---
- 1 | 2 | 0 | 3
-(1 row)
-
-select * from dfunc(x := 20, b := 10, x := 30);  -- fail, duplicate name
-ERROR:  argument name "x" used more than once
-LINE 1: select * from dfunc(x := 20, b := 10, x := 30);
-                                              ^
-select * from dfunc(10, b := 20, 30);  -- fail, named args must be last
-ERROR:  positional argument cannot follow named argument
-LINE 1: select * from dfunc(10, b := 20, 30);
-                                         ^
-select * from dfunc(x := 10, b := 20, c := 30);  -- fail, unknown param
-ERROR:  function dfunc(x => integer, b => integer, c => integer) does not exist
-LINE 1: select * from dfunc(x := 10, b := 20, c := 30);
-                      ^
-HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
-select * from dfunc(10, 10, a := 20);  -- fail, a overlaps positional parameter
-ERROR:  function dfunc(integer, integer, a => integer) does not exist
-LINE 1: select * from dfunc(10, 10, a := 20);
-                      ^
-HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
-select * from dfunc(1,c := 2,d := 3); -- fail, no value for b
-ERROR:  function dfunc(integer, c => integer, d => integer) does not exist
-LINE 1: select * from dfunc(1,c := 2,d := 3);
-                      ^
-HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
-drop function dfunc(int, int, int, int);
--- test with different parameter types
-create function dfunc(a varchar, b numeric, c date = current_date)
-  returns table (a varchar, b numeric, c date) as $$
-  select $1, $2, $3;
-$$ language sql;
-select (dfunc('Hello World', 20, '2009-07-25'::date)).*;
-      a      | b  |     c      
--------------+----+------------
- Hello World | 20 | 07-25-2009
-(1 row)
-
-select * from dfunc('Hello World', 20, '2009-07-25'::date);
-      a      | b  |     c      
--------------+----+------------
- Hello World | 20 | 07-25-2009
-(1 row)
-
-select * from dfunc(c := '2009-07-25'::date, a := 'Hello World', b := 20);
-      a      | b  |     c      
--------------+----+------------
- Hello World | 20 | 07-25-2009
-(1 row)
-
-select * from dfunc('Hello World', b := 20, c := '2009-07-25'::date);
-      a      | b  |     c      
--------------+----+------------
- Hello World | 20 | 07-25-2009
-(1 row)
-
-select * from dfunc('Hello World', c := '2009-07-25'::date, b := 20);
-      a      | b  |     c      
--------------+----+------------
- Hello World | 20 | 07-25-2009
-(1 row)
-
-select * from dfunc('Hello World', c := 20, b := '2009-07-25'::date);  -- fail
-ERROR:  function dfunc(unknown, c => integer, b => date) does not exist
-LINE 1: select * from dfunc('Hello World', c := 20, b := '2009-07-25...
-                      ^
-HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
-drop function dfunc(varchar, numeric, date);
--- test out parameters with named params
-create function dfunc(a varchar = 'def a', out _a varchar, c numeric = NULL, out _c numeric)
-returns record as $$
-  select $1, $2;
-$$ language sql;
-select (dfunc()).*;
-  _a   | _c 
--------+----
- def a |   
-(1 row)
-
-select * from dfunc();
-  _a   | _c 
--------+----
- def a |   
-(1 row)
-
-select * from dfunc('Hello', 100);
-  _a   | _c  
--------+-----
- Hello | 100
-(1 row)
-
-select * from dfunc(a := 'Hello', c := 100);
-  _a   | _c  
--------+-----
- Hello | 100
-(1 row)
-
-select * from dfunc(c := 100, a := 'Hello');
-  _a   | _c  
--------+-----
- Hello | 100
-(1 row)
-
-select * from dfunc('Hello');
-  _a   | _c 
--------+----
- Hello |   
-(1 row)
-
-select * from dfunc('Hello', c := 100);
-  _a   | _c  
--------+-----
- Hello | 100
-(1 row)
-
-select * from dfunc(c := 100);
-  _a   | _c  
--------+-----
- def a | 100
-(1 row)
-
--- fail, can no longer change an input parameter's name
-create or replace function dfunc(a varchar = 'def a', out _a varchar, x numeric = NULL, out _c numeric)
-returns record as $$
-  select $1, $2;
-$$ language sql;
-ERROR:  cannot change name of input parameter "c"
-HINT:  Use DROP FUNCTION dfunc(character varying,numeric) first.
-create or replace function dfunc(a varchar = 'def a', out _a varchar, numeric = NULL, out _c numeric)
-returns record as $$
-  select $1, $2;
-$$ language sql;
-ERROR:  cannot change name of input parameter "c"
-HINT:  Use DROP FUNCTION dfunc(character varying,numeric) first.
-drop function dfunc(varchar, numeric);
---fail, named parameters are not unique
-create function testpolym(a int, a int) returns int as $$ select 1;$$ language sql;
-ERROR:  parameter name "a" used more than once
-create function testpolym(int, out a int, out a int) returns int as $$ select 1;$$ language sql;
-ERROR:  parameter name "a" used more than once
-create function testpolym(out a int, inout a int) returns int as $$ select 1;$$ language sql;
-ERROR:  parameter name "a" used more than once
-create function testpolym(a int, inout a int) returns int as $$ select 1;$$ language sql;
-ERROR:  parameter name "a" used more than once
--- valid
-create function testpolym(a int, out a int) returns int as $$ select $1;$$ language sql;
-select testpolym(37);
- testpolym 
------------
-        37
-(1 row)
-
-drop function testpolym(int);
-create function testpolym(a int) returns table(a int) as $$ select $1;$$ language sql;
-select * from testpolym(37);
- a  
-----
- 37
-(1 row)
-
-drop function testpolym(int);
--- test polymorphic params and defaults
-create function dfunc(a anyelement, b anyelement = null, flag bool = true)
-returns anyelement as $$
-  select case when $3 then $1 else $2 end;
-$$ language sql;
-select dfunc(1,2);
- dfunc 
--------
-     1
-(1 row)
-
-select dfunc('a'::text, 'b'); -- positional notation with default
- dfunc 
--------
- a
-(1 row)
-
-select dfunc(a := 1, b := 2);
- dfunc 
--------
-     1
-(1 row)
-
-select dfunc(a := 'a'::text, b := 'b');
- dfunc 
--------
- a
-(1 row)
-
-select dfunc(a := 'a'::text, b := 'b', flag := false); -- named notation
- dfunc 
--------
- b
-(1 row)
-
-select dfunc(b := 'b'::text, a := 'a'); -- named notation with default
- dfunc 
--------
- a
-(1 row)
-
-select dfunc(a := 'a'::text, flag := true); -- named notation with default
- dfunc 
--------
- a
-(1 row)
-
-select dfunc(a := 'a'::text, flag := false); -- named notation with default
- dfunc 
--------
- 
-(1 row)
-
-select dfunc(b := 'b'::text, a := 'a', flag := true); -- named notation
- dfunc 
--------
- a
-(1 row)
-
-select dfunc('a'::text, 'b', false); -- full positional notation
- dfunc 
--------
- b
-(1 row)
-
-select dfunc('a'::text, 'b', flag := false); -- mixed notation
- dfunc 
--------
- b
-(1 row)
-
-select dfunc('a'::text, 'b', true); -- full positional notation
- dfunc 
--------
- a
-(1 row)
-
-select dfunc('a'::text, 'b', flag := true); -- mixed notation
- dfunc 
--------
- a
-(1 row)
-
--- ansi/sql syntax
-select dfunc(a => 1, b => 2);
- dfunc 
--------
-     1
-(1 row)
-
-select dfunc(a => 'a'::text, b => 'b');
- dfunc 
--------
- a
-(1 row)
-
-select dfunc(a => 'a'::text, b => 'b', flag => false); -- named notation
- dfunc 
--------
- b
-(1 row)
-
-select dfunc(b => 'b'::text, a => 'a'); -- named notation with default
- dfunc 
--------
- a
-(1 row)
-
-select dfunc(a => 'a'::text, flag => true); -- named notation with default
- dfunc 
--------
- a
-(1 row)
-
-select dfunc(a => 'a'::text, flag => false); -- named notation with default
- dfunc 
--------
- 
-(1 row)
-
-select dfunc(b => 'b'::text, a => 'a', flag => true); -- named notation
- dfunc 
--------
- a
-(1 row)
-
-select dfunc('a'::text, 'b', false); -- full positional notation
- dfunc 
--------
- b
-(1 row)
-
-select dfunc('a'::text, 'b', flag => false); -- mixed notation
- dfunc 
--------
- b
-(1 row)
-
-select dfunc('a'::text, 'b', true); -- full positional notation
- dfunc 
--------
- a
-(1 row)
-
-select dfunc('a'::text, 'b', flag => true); -- mixed notation
- dfunc 
--------
- a
-(1 row)
-
--- this tests lexer edge cases around =>
-select dfunc(a =>-1);
- dfunc 
--------
-    -1
-(1 row)
-
-select dfunc(a =>+1);
- dfunc 
--------
-     1
-(1 row)
-
-select dfunc(a =>/**/1);
- dfunc 
--------
-     1
-(1 row)
-
-select dfunc(a =>--comment to be removed by psql
-  1);
- dfunc 
--------
-     1
-(1 row)
-
--- need DO to protect the -- from psql
-do $$
-  declare r integer;
-  begin
-    select dfunc(a=>-- comment
-      1) into r;
-    raise info 'r = %', r;
-  end;
-$$;
-INFO:  r = 1
--- check reverse-listing of named-arg calls
-CREATE VIEW dfview AS
-   SELECT q1, q2,
-     dfunc(q1,q2, flag := q1>q2) as c3,
-     dfunc(q1, flag := q1<q2, b := q2) as c4
-     FROM int8_tbl;
-select * from dfview;
-        q1        |        q2         |        c3        |        c4         
-------------------+-------------------+------------------+-------------------
-              123 |               456 |              456 |               123
-              123 |  4567890123456789 | 4567890123456789 |               123
- 4567890123456789 |               123 | 4567890123456789 |               123
- 4567890123456789 |  4567890123456789 | 4567890123456789 |  4567890123456789
- 4567890123456789 | -4567890123456789 | 4567890123456789 | -4567890123456789
-(5 rows)
-
-\d+ dfview
-                           View "public.dfview"
- Column |  Type  | Collation | Nullable | Default | Storage | Description 
---------+--------+-----------+----------+---------+---------+-------------
- q1     | bigint |           |          |         | plain   | 
- q2     | bigint |           |          |         | plain   | 
- c3     | bigint |           |          |         | plain   | 
- c4     | bigint |           |          |         | plain   | 
-View definition:
- SELECT int8_tbl.q1,
-    int8_tbl.q2,
-    dfunc(int8_tbl.q1, int8_tbl.q2, flag => int8_tbl.q1 > int8_tbl.q2) AS c3,
-    dfunc(int8_tbl.q1, flag => int8_tbl.q1 < int8_tbl.q2, b => int8_tbl.q2) AS c4
-   FROM int8_tbl;
-
-drop view dfview;
-drop function dfunc(anyelement, anyelement, bool);
---
--- Tests for ANYCOMPATIBLE polymorphism family
---
-create function anyctest(anycompatible, anycompatible)
-returns anycompatible as $$
-  select greatest($1, $2)
-$$ language sql;
-select x, pg_typeof(x) from anyctest(11, 12) x;
- x  | pg_typeof 
-----+-----------
- 12 | integer
-(1 row)
-
-select x, pg_typeof(x) from anyctest(11, 12.3) x;
-  x   | pg_typeof 
-------+-----------
- 12.3 | numeric
-(1 row)
-
-select x, pg_typeof(x) from anyctest(11, point(1,2)) x;  -- fail
-ERROR:  function anyctest(integer, point) does not exist
-LINE 1: select x, pg_typeof(x) from anyctest(11, point(1,2)) x;
-                                    ^
-HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
-select x, pg_typeof(x) from anyctest('11', '12.3') x;  -- defaults to text
-  x   | pg_typeof 
-------+-----------
- 12.3 | text
-(1 row)
-
-drop function anyctest(anycompatible, anycompatible);
-create function anyctest(anycompatible, anycompatible)
-returns anycompatiblearray as $$
-  select array[$1, $2]
-$$ language sql;
-select x, pg_typeof(x) from anyctest(11, 12) x;
-    x    | pg_typeof 
----------+-----------
- {11,12} | integer[]
-(1 row)
-
-select x, pg_typeof(x) from anyctest(11, 12.3) x;
-     x     | pg_typeof 
------------+-----------
- {11,12.3} | numeric[]
-(1 row)
-
-select x, pg_typeof(x) from anyctest(11, array[1,2]) x;  -- fail
-ERROR:  function anyctest(integer, integer[]) does not exist
-LINE 1: select x, pg_typeof(x) from anyctest(11, array[1,2]) x;
-                                    ^
-HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
-drop function anyctest(anycompatible, anycompatible);
-create function anyctest(anycompatible, anycompatiblearray)
-returns anycompatiblearray as $$
-  select array[$1] || $2
-$$ language sql;
-select x, pg_typeof(x) from anyctest(11, array[12]) x;
-    x    | pg_typeof 
----------+-----------
- {11,12} | integer[]
-(1 row)
-
-select x, pg_typeof(x) from anyctest(11, array[12.3]) x;
-     x     | pg_typeof 
------------+-----------
- {11,12.3} | numeric[]
-(1 row)
-
-select x, pg_typeof(x) from anyctest(12.3, array[13]) x;
-     x     | pg_typeof 
------------+-----------
- {12.3,13} | numeric[]
-(1 row)
-
-select x, pg_typeof(x) from anyctest(12.3, '{13,14.4}') x;
-       x        | pg_typeof 
-----------------+-----------
- {12.3,13,14.4} | numeric[]
-(1 row)
-
-select x, pg_typeof(x) from anyctest(11, array[point(1,2)]) x;  -- fail
-ERROR:  function anyctest(integer, point[]) does not exist
-LINE 1: select x, pg_typeof(x) from anyctest(11, array[point(1,2)]) ...
-                                    ^
-HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
-select x, pg_typeof(x) from anyctest(11, 12) x;  -- fail
-ERROR:  function anyctest(integer, integer) does not exist
-LINE 1: select x, pg_typeof(x) from anyctest(11, 12) x;
-                                    ^
-HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
-drop function anyctest(anycompatible, anycompatiblearray);
-create function anyctest(anycompatible, anycompatiblerange)
-returns anycompatiblerange as $$
-  select $2
-$$ language sql;
-select x, pg_typeof(x) from anyctest(11, int4range(4,7)) x;
-   x   | pg_typeof 
--------+-----------
- [4,7) | int4range
-(1 row)
-
-select x, pg_typeof(x) from anyctest(11, numrange(4,7)) x;
-   x   | pg_typeof 
--------+-----------
- [4,7) | numrange
-(1 row)
-
-select x, pg_typeof(x) from anyctest(11, 12) x;  -- fail
-ERROR:  function anyctest(integer, integer) does not exist
-LINE 1: select x, pg_typeof(x) from anyctest(11, 12) x;
-                                    ^
-HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
-select x, pg_typeof(x) from anyctest(11.2, int4range(4,7)) x;  -- fail
-ERROR:  function anyctest(numeric, int4range) does not exist
-LINE 1: select x, pg_typeof(x) from anyctest(11.2, int4range(4,7)) x...
-                                    ^
-HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
-select x, pg_typeof(x) from anyctest(11.2, '[4,7)') x;  -- fail
-ERROR:  could not determine polymorphic type anycompatiblerange because input has type unknown
-drop function anyctest(anycompatible, anycompatiblerange);
-create function anyctest(anycompatiblerange, anycompatiblerange)
-returns anycompatible as $$
-  select lower($1) + upper($2)
-$$ language sql;
-select x, pg_typeof(x) from anyctest(int4range(11,12), int4range(4,7)) x;
- x  | pg_typeof 
-----+-----------
- 18 | integer
-(1 row)
-
-select x, pg_typeof(x) from anyctest(int4range(11,12), numrange(4,7)) x; -- fail
-ERROR:  function anyctest(int4range, numrange) does not exist
-LINE 1: select x, pg_typeof(x) from anyctest(int4range(11,12), numra...
-                                    ^
-HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
-drop function anyctest(anycompatiblerange, anycompatiblerange);
--- fail, can't infer result type:
-create function anyctest(anycompatible)
-returns anycompatiblerange as $$
-  select $1
-$$ language sql;
-ERROR:  cannot determine result data type
-DETAIL:  A result of type anycompatiblerange requires at least one input of type anycompatiblerange or anycompatiblemultirange.
-create function anyctest(anycompatible, anycompatiblemultirange)
-returns anycompatiblemultirange as $$
-  select $2
-$$ language sql;
-select x, pg_typeof(x) from anyctest(11, multirange(int4range(4,7))) x;
-    x    |   pg_typeof    
----------+----------------
- {[4,7)} | int4multirange
-(1 row)
-
-select x, pg_typeof(x) from anyctest(11, multirange(numrange(4,7))) x;
-    x    |   pg_typeof   
----------+---------------
- {[4,7)} | nummultirange
-(1 row)
-
-select x, pg_typeof(x) from anyctest(11, 12) x;  -- fail
-ERROR:  function anyctest(integer, integer) does not exist
-LINE 1: select x, pg_typeof(x) from anyctest(11, 12) x;
-                                    ^
-HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
-select x, pg_typeof(x) from anyctest(11.2, multirange(int4range(4,7))) x;  -- fail
-ERROR:  function anyctest(numeric, int4multirange) does not exist
-LINE 1: select x, pg_typeof(x) from anyctest(11.2, multirange(int4ra...
-                                    ^
-HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
-select x, pg_typeof(x) from anyctest(11.2, '{[4,7)}') x;  -- fail
-ERROR:  could not determine polymorphic type anycompatiblemultirange because input has type unknown
-drop function anyctest(anycompatible, anycompatiblemultirange);
-create function anyctest(anycompatiblemultirange, anycompatiblemultirange)
-returns anycompatible as $$
-  select lower($1) + upper($2)
-$$ language sql;
-select x, pg_typeof(x) from anyctest(multirange(int4range(11,12)), multirange(int4range(4,7))) x;
- x  | pg_typeof 
-----+-----------
- 18 | integer
-(1 row)
-
-select x, pg_typeof(x) from anyctest(multirange(int4range(11,12)), multirange(numrange(4,7))) x; -- fail
-ERROR:  function anyctest(int4multirange, nummultirange) does not exist
-LINE 1: select x, pg_typeof(x) from anyctest(multirange(int4range(11...
-                                    ^
-HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
-drop function anyctest(anycompatiblemultirange, anycompatiblemultirange);
--- fail, can't infer result type:
-create function anyctest(anycompatible)
-returns anycompatiblemultirange as $$
-  select $1
-$$ language sql;
-ERROR:  cannot determine result data type
-DETAIL:  A result of type anycompatiblemultirange requires at least one input of type anycompatiblerange or anycompatiblemultirange.
-create function anyctest(anycompatiblenonarray, anycompatiblenonarray)
-returns anycompatiblearray as $$
-  select array[$1, $2]
-$$ language sql;
-select x, pg_typeof(x) from anyctest(11, 12) x;
-    x    | pg_typeof 
----------+-----------
- {11,12} | integer[]
-(1 row)
-
-select x, pg_typeof(x) from anyctest(11, 12.3) x;
-     x     | pg_typeof 
------------+-----------
- {11,12.3} | numeric[]
-(1 row)
-
-select x, pg_typeof(x) from anyctest(array[11], array[1,2]) x;  -- fail
-ERROR:  function anyctest(integer[], integer[]) does not exist
-LINE 1: select x, pg_typeof(x) from anyctest(array[11], array[1,2]) ...
-                                    ^
-HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
-drop function anyctest(anycompatiblenonarray, anycompatiblenonarray);
-create function anyctest(a anyelement, b anyarray,
-                         c anycompatible, d anycompatible)
-returns anycompatiblearray as $$
-  select array[c, d]
-$$ language sql;
-select x, pg_typeof(x) from anyctest(11, array[1, 2], 42, 34.5) x;
-     x     | pg_typeof 
------------+-----------
- {42,34.5} | numeric[]
-(1 row)
-
-select x, pg_typeof(x) from anyctest(11, array[1, 2], point(1,2), point(3,4)) x;
-         x         | pg_typeof 
--------------------+-----------
- {"(1,2)","(3,4)"} | point[]
-(1 row)
-
-select x, pg_typeof(x) from anyctest(11, '{1,2}', point(1,2), '(3,4)') x;
-         x         | pg_typeof 
--------------------+-----------
- {"(1,2)","(3,4)"} | point[]
-(1 row)
-
-select x, pg_typeof(x) from anyctest(11, array[1, 2.2], 42, 34.5) x;  -- fail
-ERROR:  function anyctest(integer, numeric[], integer, numeric) does not exist
-LINE 1: select x, pg_typeof(x) from anyctest(11, array[1, 2.2], 42, ...
-                                    ^
-HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
-drop function anyctest(a anyelement, b anyarray,
-                       c anycompatible, d anycompatible);
-create function anyctest(variadic anycompatiblearray)
-returns anycompatiblearray as $$
-  select $1
-$$ language sql;
-select x, pg_typeof(x) from anyctest(11, 12) x;
-    x    | pg_typeof 
----------+-----------
- {11,12} | integer[]
-(1 row)
-
-select x, pg_typeof(x) from anyctest(11, 12.2) x;
-     x     | pg_typeof 
------------+-----------
- {11,12.2} | numeric[]
-(1 row)
-
-select x, pg_typeof(x) from anyctest(11, '12') x;
-    x    | pg_typeof 
----------+-----------
- {11,12} | integer[]
-(1 row)
-
-select x, pg_typeof(x) from anyctest(11, '12.2') x;  -- fail
-ERROR:  invalid input syntax for type integer: "12.2"
-LINE 1: select x, pg_typeof(x) from anyctest(11, '12.2') x;
-                                                 ^
-select x, pg_typeof(x) from anyctest(variadic array[11, 12]) x;
-    x    | pg_typeof 
----------+-----------
- {11,12} | integer[]
-(1 row)
-
-select x, pg_typeof(x) from anyctest(variadic array[11, 12.2]) x;
-     x     | pg_typeof 
------------+-----------
- {11,12.2} | numeric[]
-(1 row)
-
-drop function anyctest(variadic anycompatiblearray);
diff -U3 /Users/kenaniah/workspace/postgres/src/test/regress/expected/largeobject.out /Users/kenaniah/workspace/postgres/src/test/regress/results/largeobject.out
--- /Users/kenaniah/workspace/postgres/src/test/regress/expected/largeobject.out	2021-10-03 20:08:03.000000000 -0700
+++ /Users/kenaniah/workspace/postgres/src/test/regress/results/largeobject.out	2021-10-03 20:08:23.000000000 -0700
@@ -37,6 +37,8 @@
 -- The return value is a file descriptor-like value which remains valid for the
 -- transaction.
 UPDATE lotest_stash_values SET fd = lo_open(loid, CAST(x'20000' | x'40000' AS integer));
+ERROR:  cannot update table "lotest_stash_values" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
 -- loread/lowrite names are wonky, different from other functions which are lo_*
 -- lowrite(fd integer, data bytea) returns integer
 -- the integer is the number of bytes written
@@ -71,19 +73,11 @@
 
          -- William Wordsworth
 ') FROM lotest_stash_values;
- lowrite 
----------
-     848
-(1 row)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 -- lo_close(fd integer) returns integer
 -- return value is 0 for success, or <0 for error (actually only -1, but...)
 SELECT lo_close(fd) FROM lotest_stash_values;
- lo_close 
-----------
-        0
-(1 row)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 END;
 -- Copy to another large object.
 -- Note: we intentionally don't remove the object created here;
@@ -95,6 +89,8 @@
 -- Read out a portion
 BEGIN;
 UPDATE lotest_stash_values SET fd=lo_open(loid, CAST(x'20000' | x'40000' AS integer));
+ERROR:  cannot update table "lotest_stash_values" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
 -- lo_lseek(fd integer, offset integer, whence integer) returns integer
 -- offset is in bytes, whence is one of three values:
 --  SEEK_SET (= 0) meaning relative to beginning
@@ -102,55 +98,23 @@
 --  SEEK_END (= 2) meaning relative to end (offset better be negative)
 -- returns current position in file
 SELECT lo_lseek(fd, 104, 0) FROM lotest_stash_values;
- lo_lseek 
-----------
-      104
-(1 row)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 -- loread/lowrite names are wonky, different from other functions which are lo_*
 -- loread(fd integer, len integer) returns bytea
 SELECT loread(fd, 28) FROM lotest_stash_values;
-            loread            
-------------------------------
- A host, of golden daffodils;
-(1 row)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 SELECT lo_lseek(fd, -19, 1) FROM lotest_stash_values;
- lo_lseek 
-----------
-      113
-(1 row)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 SELECT lowrite(fd, 'n') FROM lotest_stash_values;
- lowrite 
----------
-       1
-(1 row)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 SELECT lo_tell(fd) FROM lotest_stash_values;
- lo_tell 
----------
-     114
-(1 row)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 SELECT lo_lseek(fd, -744, 2) FROM lotest_stash_values;
- lo_lseek 
-----------
-      104
-(1 row)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 SELECT loread(fd, 28) FROM lotest_stash_values;
-            loread            
-------------------------------
- A host, on golden daffodils;
-(1 row)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 SELECT lo_close(fd) FROM lotest_stash_values;
- lo_close 
-----------
-        0
-(1 row)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 END;
 -- Test resource management
 BEGIN;
@@ -164,148 +128,60 @@
 -- Test truncation.
 BEGIN;
 UPDATE lotest_stash_values SET fd=lo_open(loid, CAST(x'20000' | x'40000' AS integer));
+ERROR:  cannot update table "lotest_stash_values" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
 SELECT lo_truncate(fd, 11) FROM lotest_stash_values;
- lo_truncate 
--------------
-           0
-(1 row)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 SELECT loread(fd, 15) FROM lotest_stash_values;
-     loread     
-----------------
- \012I wandered
-(1 row)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 SELECT lo_truncate(fd, 10000) FROM lotest_stash_values;
- lo_truncate 
--------------
-           0
-(1 row)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 SELECT loread(fd, 10) FROM lotest_stash_values;
-                  loread                  
-------------------------------------------
- \000\000\000\000\000\000\000\000\000\000
-(1 row)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 SELECT lo_lseek(fd, 0, 2) FROM lotest_stash_values;
- lo_lseek 
-----------
-    10000
-(1 row)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 SELECT lo_tell(fd) FROM lotest_stash_values;
- lo_tell 
----------
-   10000
-(1 row)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 SELECT lo_truncate(fd, 5000) FROM lotest_stash_values;
- lo_truncate 
--------------
-           0
-(1 row)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 SELECT lo_lseek(fd, 0, 2) FROM lotest_stash_values;
- lo_lseek 
-----------
-     5000
-(1 row)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 SELECT lo_tell(fd) FROM lotest_stash_values;
- lo_tell 
----------
-    5000
-(1 row)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 SELECT lo_close(fd) FROM lotest_stash_values;
- lo_close 
-----------
-        0
-(1 row)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 END;
 -- Test 64-bit large object functions.
 BEGIN;
 UPDATE lotest_stash_values SET fd = lo_open(loid, CAST(x'20000' | x'40000' AS integer));
+ERROR:  cannot update table "lotest_stash_values" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
 SELECT lo_lseek64(fd, 4294967296, 0) FROM lotest_stash_values;
- lo_lseek64 
-------------
- 4294967296
-(1 row)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 SELECT lowrite(fd, 'offset:4GB') FROM lotest_stash_values;
- lowrite 
----------
-      10
-(1 row)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 SELECT lo_tell64(fd) FROM lotest_stash_values;
- lo_tell64  
-------------
- 4294967306
-(1 row)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 SELECT lo_lseek64(fd, -10, 1) FROM lotest_stash_values;
- lo_lseek64 
-------------
- 4294967296
-(1 row)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 SELECT lo_tell64(fd) FROM lotest_stash_values;
- lo_tell64  
-------------
- 4294967296
-(1 row)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 SELECT loread(fd, 10) FROM lotest_stash_values;
-   loread   
-------------
- offset:4GB
-(1 row)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 SELECT lo_truncate64(fd, 5000000000) FROM lotest_stash_values;
- lo_truncate64 
----------------
-             0
-(1 row)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 SELECT lo_lseek64(fd, 0, 2) FROM lotest_stash_values;
- lo_lseek64 
-------------
- 5000000000
-(1 row)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 SELECT lo_tell64(fd) FROM lotest_stash_values;
- lo_tell64  
-------------
- 5000000000
-(1 row)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 SELECT lo_truncate64(fd, 3000000000) FROM lotest_stash_values;
- lo_truncate64 
----------------
-             0
-(1 row)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 SELECT lo_lseek64(fd, 0, 2) FROM lotest_stash_values;
- lo_lseek64 
-------------
- 3000000000
-(1 row)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 SELECT lo_tell64(fd) FROM lotest_stash_values;
- lo_tell64  
-------------
- 3000000000
-(1 row)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 SELECT lo_close(fd) FROM lotest_stash_values;
- lo_close 
-----------
-        0
-(1 row)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 END;
 -- lo_unlink(lobjId oid) returns integer
 -- return value appears to always be 1
@@ -319,65 +195,31 @@
 INSERT INTO lotest_stash_values (loid) SELECT lo_import('/Users/kenaniah/workspace/postgres/src/test/regress/data/tenk.data');
 BEGIN;
 UPDATE lotest_stash_values SET fd=lo_open(loid, CAST(x'20000' | x'40000' AS integer));
+ERROR:  cannot update table "lotest_stash_values" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
 -- verify length of large object
 SELECT lo_lseek(fd, 0, 2) FROM lotest_stash_values;
- lo_lseek 
-----------
-   670800
-(1 row)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 -- with the default BLCKSZ, LOBLKSIZE = 2048, so this positions us for a block
 -- edge case
 SELECT lo_lseek(fd, 2030, 0) FROM lotest_stash_values;
- lo_lseek 
-----------
-     2030
-(1 row)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 -- this should get half of the value from page 0 and half from page 1 of the
 -- large object
 SELECT loread(fd, 36) FROM lotest_stash_values;
-                             loread                              
------------------------------------------------------------------
- AAA\011FBAAAA\011VVVVxx\0122513\01132\0111\0111\0113\01113\0111
-(1 row)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 SELECT lo_tell(fd) FROM lotest_stash_values;
- lo_tell 
----------
-    2066
-(1 row)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 SELECT lo_lseek(fd, -26, 1) FROM lotest_stash_values;
- lo_lseek 
-----------
-     2040
-(1 row)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 SELECT lowrite(fd, 'abcdefghijklmnop') FROM lotest_stash_values;
- lowrite 
----------
-      16
-(1 row)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 SELECT lo_lseek(fd, 2030, 0) FROM lotest_stash_values;
- lo_lseek 
-----------
-     2030
-(1 row)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 SELECT loread(fd, 36) FROM lotest_stash_values;
-                       loread                        
------------------------------------------------------
- AAA\011FBAAAAabcdefghijklmnop1\0111\0113\01113\0111
-(1 row)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 SELECT lo_close(fd) FROM lotest_stash_values;
- lo_close 
-----------
-        0
-(1 row)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 END;
 SELECT lo_export(loid, '/Users/kenaniah/workspace/postgres/src/test/regress/results/lotest.txt') FROM lotest_stash_values;
  lo_export 
diff -U3 /Users/kenaniah/workspace/postgres/src/test/regress/expected/with.out /Users/kenaniah/workspace/postgres/src/test/regress/results/with.out
--- /Users/kenaniah/workspace/postgres/src/test/regress/expected/with.out	2021-10-03 18:09:17.000000000 -0700
+++ /Users/kenaniah/workspace/postgres/src/test/regress/results/with.out	2021-10-03 20:08:23.000000000 -0700
@@ -434,2734 +434,11 @@
 )
 SELECT sum(n) FROM t;
 \d+ sums_1_100
-                         View "public.sums_1_100"
- Column |  Type  | Collation | Nullable | Default | Storage | Description 
---------+--------+-----------+----------+---------+---------+-------------
- sum    | bigint |           |          |         | plain   | 
-View definition:
- WITH RECURSIVE t(n) AS (
-         VALUES (1)
-        UNION ALL
-         SELECT t_1.n + 1
-           FROM t t_1
-          WHERE t_1.n < 100
-        )
- SELECT sum(t.n) AS sum
-   FROM t;
+dyld: lazy symbol binding failed: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
+
+dyld: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
 
--- corner case in which sub-WITH gets initialized first
-with recursive q as (
-      select * from department
-    union all
-      (with x as (select * from q)
-       select * from x)
-    )
-select * from q limit 24;
- id | parent_department | name 
-----+-------------------+------
-  0 |                   | ROOT
-  1 |                 0 | A
-  2 |                 1 | B
-  3 |                 2 | C
-  4 |                 2 | D
-  5 |                 0 | E
-  6 |                 4 | F
-  7 |                 5 | G
-  0 |                   | ROOT
-  1 |                 0 | A
-  2 |                 1 | B
-  3 |                 2 | C
-  4 |                 2 | D
-  5 |                 0 | E
-  6 |                 4 | F
-  7 |                 5 | G
-  0 |                   | ROOT
-  1 |                 0 | A
-  2 |                 1 | B
-  3 |                 2 | C
-  4 |                 2 | D
-  5 |                 0 | E
-  6 |                 4 | F
-  7 |                 5 | G
-(24 rows)
-
-with recursive q as (
-      select * from department
-    union all
-      (with recursive x as (
-           select * from department
-         union all
-           (select * from q union all select * from x)
-        )
-       select * from x)
-    )
-select * from q limit 32;
- id | parent_department | name 
-----+-------------------+------
-  0 |                   | ROOT
-  1 |                 0 | A
-  2 |                 1 | B
-  3 |                 2 | C
-  4 |                 2 | D
-  5 |                 0 | E
-  6 |                 4 | F
-  7 |                 5 | G
-  0 |                   | ROOT
-  1 |                 0 | A
-  2 |                 1 | B
-  3 |                 2 | C
-  4 |                 2 | D
-  5 |                 0 | E
-  6 |                 4 | F
-  7 |                 5 | G
-  0 |                   | ROOT
-  1 |                 0 | A
-  2 |                 1 | B
-  3 |                 2 | C
-  4 |                 2 | D
-  5 |                 0 | E
-  6 |                 4 | F
-  7 |                 5 | G
-  0 |                   | ROOT
-  1 |                 0 | A
-  2 |                 1 | B
-  3 |                 2 | C
-  4 |                 2 | D
-  5 |                 0 | E
-  6 |                 4 | F
-  7 |                 5 | G
-(32 rows)
-
--- recursive term has sub-UNION
-WITH RECURSIVE t(i,j) AS (
-	VALUES (1,2)
-	UNION ALL
-	SELECT t2.i, t.j+1 FROM
-		(SELECT 2 AS i UNION ALL SELECT 3 AS i) AS t2
-		JOIN t ON (t2.i = t.i+1))
-	SELECT * FROM t;
- i | j 
----+---
- 1 | 2
- 2 | 3
- 3 | 4
-(3 rows)
-
---
--- different tree example
---
-CREATE TEMPORARY TABLE tree(
-    id INTEGER PRIMARY KEY,
-    parent_id INTEGER REFERENCES tree(id)
-);
-INSERT INTO tree
-VALUES (1, NULL), (2, 1), (3,1), (4,2), (5,2), (6,2), (7,3), (8,3),
-       (9,4), (10,4), (11,7), (12,7), (13,7), (14, 9), (15,11), (16,11);
---
--- get all paths from "second level" nodes to leaf nodes
---
-WITH RECURSIVE t(id, path) AS (
-    VALUES(1,ARRAY[]::integer[])
-UNION ALL
-    SELECT tree.id, t.path || tree.id
-    FROM tree JOIN t ON (tree.parent_id = t.id)
-)
-SELECT t1.*, t2.* FROM t AS t1 JOIN t AS t2 ON
-	(t1.path[1] = t2.path[1] AND
-	array_upper(t1.path,1) = 1 AND
-	array_upper(t2.path,1) > 1)
-	ORDER BY t1.id, t2.id;
- id | path | id |    path     
-----+------+----+-------------
-  2 | {2}  |  4 | {2,4}
-  2 | {2}  |  5 | {2,5}
-  2 | {2}  |  6 | {2,6}
-  2 | {2}  |  9 | {2,4,9}
-  2 | {2}  | 10 | {2,4,10}
-  2 | {2}  | 14 | {2,4,9,14}
-  3 | {3}  |  7 | {3,7}
-  3 | {3}  |  8 | {3,8}
-  3 | {3}  | 11 | {3,7,11}
-  3 | {3}  | 12 | {3,7,12}
-  3 | {3}  | 13 | {3,7,13}
-  3 | {3}  | 15 | {3,7,11,15}
-  3 | {3}  | 16 | {3,7,11,16}
-(13 rows)
-
--- just count 'em
-WITH RECURSIVE t(id, path) AS (
-    VALUES(1,ARRAY[]::integer[])
-UNION ALL
-    SELECT tree.id, t.path || tree.id
-    FROM tree JOIN t ON (tree.parent_id = t.id)
-)
-SELECT t1.id, count(t2.*) FROM t AS t1 JOIN t AS t2 ON
-	(t1.path[1] = t2.path[1] AND
-	array_upper(t1.path,1) = 1 AND
-	array_upper(t2.path,1) > 1)
-	GROUP BY t1.id
-	ORDER BY t1.id;
- id | count 
-----+-------
-  2 |     6
-  3 |     7
-(2 rows)
-
--- this variant tickled a whole-row-variable bug in 8.4devel
-WITH RECURSIVE t(id, path) AS (
-    VALUES(1,ARRAY[]::integer[])
-UNION ALL
-    SELECT tree.id, t.path || tree.id
-    FROM tree JOIN t ON (tree.parent_id = t.id)
-)
-SELECT t1.id, t2.path, t2 FROM t AS t1 JOIN t AS t2 ON
-(t1.id=t2.id);
- id |    path     |         t2         
-----+-------------+--------------------
-  1 | {}          | (1,{})
-  2 | {2}         | (2,{2})
-  3 | {3}         | (3,{3})
-  4 | {2,4}       | (4,"{2,4}")
-  5 | {2,5}       | (5,"{2,5}")
-  6 | {2,6}       | (6,"{2,6}")
-  7 | {3,7}       | (7,"{3,7}")
-  8 | {3,8}       | (8,"{3,8}")
-  9 | {2,4,9}     | (9,"{2,4,9}")
- 10 | {2,4,10}    | (10,"{2,4,10}")
- 11 | {3,7,11}    | (11,"{3,7,11}")
- 12 | {3,7,12}    | (12,"{3,7,12}")
- 13 | {3,7,13}    | (13,"{3,7,13}")
- 14 | {2,4,9,14}  | (14,"{2,4,9,14}")
- 15 | {3,7,11,15} | (15,"{3,7,11,15}")
- 16 | {3,7,11,16} | (16,"{3,7,11,16}")
-(16 rows)
-
--- SEARCH clause
-create temp table graph0( f int, t int, label text );
-insert into graph0 values
-	(1, 2, 'arc 1 -> 2'),
-	(1, 3, 'arc 1 -> 3'),
-	(2, 3, 'arc 2 -> 3'),
-	(1, 4, 'arc 1 -> 4'),
-	(4, 5, 'arc 4 -> 5');
-explain (verbose, costs off)
-with recursive search_graph(f, t, label) as (
-	select * from graph0 g
-	union all
-	select g.*
-	from graph0 g, search_graph sg
-	where g.f = sg.t
-) search depth first by f, t set seq
-select * from search_graph order by seq;
-                                          QUERY PLAN                                          
-----------------------------------------------------------------------------------------------
- Sort
-   Output: search_graph.f, search_graph.t, search_graph.label, search_graph.seq
-   Sort Key: search_graph.seq
-   CTE search_graph
-     ->  Recursive Union
-           ->  Seq Scan on pg_temp.graph0 g
-                 Output: g.f, g.t, g.label, ARRAY[ROW(g.f, g.t)]
-           ->  Merge Join
-                 Output: g_1.f, g_1.t, g_1.label, array_cat(sg.seq, ARRAY[ROW(g_1.f, g_1.t)])
-                 Merge Cond: (g_1.f = sg.t)
-                 ->  Sort
-                       Output: g_1.f, g_1.t, g_1.label
-                       Sort Key: g_1.f
-                       ->  Seq Scan on pg_temp.graph0 g_1
-                             Output: g_1.f, g_1.t, g_1.label
-                 ->  Sort
-                       Output: sg.seq, sg.t
-                       Sort Key: sg.t
-                       ->  WorkTable Scan on search_graph sg
-                             Output: sg.seq, sg.t
-   ->  CTE Scan on search_graph
-         Output: search_graph.f, search_graph.t, search_graph.label, search_graph.seq
-(22 rows)
-
-with recursive search_graph(f, t, label) as (
-	select * from graph0 g
-	union all
-	select g.*
-	from graph0 g, search_graph sg
-	where g.f = sg.t
-) search depth first by f, t set seq
-select * from search_graph order by seq;
- f | t |   label    |        seq        
----+---+------------+-------------------
- 1 | 2 | arc 1 -> 2 | {"(1,2)"}
- 2 | 3 | arc 2 -> 3 | {"(1,2)","(2,3)"}
- 1 | 3 | arc 1 -> 3 | {"(1,3)"}
- 1 | 4 | arc 1 -> 4 | {"(1,4)"}
- 4 | 5 | arc 4 -> 5 | {"(1,4)","(4,5)"}
- 2 | 3 | arc 2 -> 3 | {"(2,3)"}
- 4 | 5 | arc 4 -> 5 | {"(4,5)"}
-(7 rows)
-
-with recursive search_graph(f, t, label) as (
-	select * from graph0 g
-	union distinct
-	select g.*
-	from graph0 g, search_graph sg
-	where g.f = sg.t
-) search depth first by f, t set seq
-select * from search_graph order by seq;
- f | t |   label    |        seq        
----+---+------------+-------------------
- 1 | 2 | arc 1 -> 2 | {"(1,2)"}
- 2 | 3 | arc 2 -> 3 | {"(1,2)","(2,3)"}
- 1 | 3 | arc 1 -> 3 | {"(1,3)"}
- 1 | 4 | arc 1 -> 4 | {"(1,4)"}
- 4 | 5 | arc 4 -> 5 | {"(1,4)","(4,5)"}
- 2 | 3 | arc 2 -> 3 | {"(2,3)"}
- 4 | 5 | arc 4 -> 5 | {"(4,5)"}
-(7 rows)
-
-explain (verbose, costs off)
-with recursive search_graph(f, t, label) as (
-	select * from graph0 g
-	union all
-	select g.*
-	from graph0 g, search_graph sg
-	where g.f = sg.t
-) search breadth first by f, t set seq
-select * from search_graph order by seq;
-                                           QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
- Sort
-   Output: search_graph.f, search_graph.t, search_graph.label, search_graph.seq
-   Sort Key: search_graph.seq
-   CTE search_graph
-     ->  Recursive Union
-           ->  Seq Scan on pg_temp.graph0 g
-                 Output: g.f, g.t, g.label, ROW('0'::bigint, g.f, g.t)
-           ->  Merge Join
-                 Output: g_1.f, g_1.t, g_1.label, ROW(int8inc((sg.seq)."*DEPTH*"), g_1.f, g_1.t)
-                 Merge Cond: (g_1.f = sg.t)
-                 ->  Sort
-                       Output: g_1.f, g_1.t, g_1.label
-                       Sort Key: g_1.f
-                       ->  Seq Scan on pg_temp.graph0 g_1
-                             Output: g_1.f, g_1.t, g_1.label
-                 ->  Sort
-                       Output: sg.seq, sg.t
-                       Sort Key: sg.t
-                       ->  WorkTable Scan on search_graph sg
-                             Output: sg.seq, sg.t
-   ->  CTE Scan on search_graph
-         Output: search_graph.f, search_graph.t, search_graph.label, search_graph.seq
-(22 rows)
-
-with recursive search_graph(f, t, label) as (
-	select * from graph0 g
-	union all
-	select g.*
-	from graph0 g, search_graph sg
-	where g.f = sg.t
-) search breadth first by f, t set seq
-select * from search_graph order by seq;
- f | t |   label    |   seq   
----+---+------------+---------
- 1 | 2 | arc 1 -> 2 | (0,1,2)
- 1 | 3 | arc 1 -> 3 | (0,1,3)
- 1 | 4 | arc 1 -> 4 | (0,1,4)
- 2 | 3 | arc 2 -> 3 | (0,2,3)
- 4 | 5 | arc 4 -> 5 | (0,4,5)
- 2 | 3 | arc 2 -> 3 | (1,2,3)
- 4 | 5 | arc 4 -> 5 | (1,4,5)
-(7 rows)
-
-with recursive search_graph(f, t, label) as (
-	select * from graph0 g
-	union distinct
-	select g.*
-	from graph0 g, search_graph sg
-	where g.f = sg.t
-) search breadth first by f, t set seq
-select * from search_graph order by seq;
- f | t |   label    |   seq   
----+---+------------+---------
- 1 | 2 | arc 1 -> 2 | (0,1,2)
- 1 | 3 | arc 1 -> 3 | (0,1,3)
- 1 | 4 | arc 1 -> 4 | (0,1,4)
- 2 | 3 | arc 2 -> 3 | (0,2,3)
- 4 | 5 | arc 4 -> 5 | (0,4,5)
- 2 | 3 | arc 2 -> 3 | (1,2,3)
- 4 | 5 | arc 4 -> 5 | (1,4,5)
-(7 rows)
-
--- various syntax errors
-with recursive search_graph(f, t, label) as (
-	select * from graph0 g
-	union all
-	select g.*
-	from graph0 g, search_graph sg
-	where g.f = sg.t
-) search depth first by foo, tar set seq
-select * from search_graph;
-ERROR:  search column "foo" not in WITH query column list
-LINE 7: ) search depth first by foo, tar set seq
-          ^
-with recursive search_graph(f, t, label) as (
-	select * from graph0 g
-	union all
-	select g.*
-	from graph0 g, search_graph sg
-	where g.f = sg.t
-) search depth first by f, t set label
-select * from search_graph;
-ERROR:  search sequence column name "label" already used in WITH query column list
-LINE 7: ) search depth first by f, t set label
-          ^
-with recursive search_graph(f, t, label) as (
-	select * from graph0 g
-	union all
-	select g.*
-	from graph0 g, search_graph sg
-	where g.f = sg.t
-) search depth first by f, t, f set seq
-select * from search_graph;
-ERROR:  search column "f" specified more than once
-LINE 7: ) search depth first by f, t, f set seq
-          ^
-with recursive search_graph(f, t, label) as (
-	select * from graph0 g
-	union all
-	select * from graph0 g
-	union all
-	select g.*
-	from graph0 g, search_graph sg
-	where g.f = sg.t
-) search depth first by f, t set seq
-select * from search_graph order by seq;
-ERROR:  with a SEARCH or CYCLE clause, the left side of the UNION must be a SELECT
-with recursive search_graph(f, t, label) as (
-	select * from graph0 g
-	union all
-	(select * from graph0 g
-	union all
-	select g.*
-	from graph0 g, search_graph sg
-	where g.f = sg.t)
-) search depth first by f, t set seq
-select * from search_graph order by seq;
-ERROR:  with a SEARCH or CYCLE clause, the right side of the UNION must be a SELECT
--- test ruleutils and view expansion
-create temp view v_search as
-with recursive search_graph(f, t, label) as (
-	select * from graph0 g
-	union all
-	select g.*
-	from graph0 g, search_graph sg
-	where g.f = sg.t
-) search depth first by f, t set seq
-select f, t, label from search_graph;
-select pg_get_viewdef('v_search');
-                 pg_get_viewdef                 
-------------------------------------------------
-  WITH RECURSIVE search_graph(f, t, label) AS (+
-          SELECT g.f,                          +
-             g.t,                              +
-             g.label                           +
-            FROM graph0 g                      +
-         UNION ALL                             +
-          SELECT g.f,                          +
-             g.t,                              +
-             g.label                           +
-            FROM graph0 g,                     +
-             search_graph sg                   +
-           WHERE (g.f = sg.t)                  +
-         ) SEARCH DEPTH FIRST BY f, t SET seq  +
-  SELECT search_graph.f,                       +
-     search_graph.t,                           +
-     search_graph.label                        +
-    FROM search_graph;
-(1 row)
-
-select * from v_search;
- f | t |   label    
----+---+------------
- 1 | 2 | arc 1 -> 2
- 1 | 3 | arc 1 -> 3
- 2 | 3 | arc 2 -> 3
- 1 | 4 | arc 1 -> 4
- 4 | 5 | arc 4 -> 5
- 2 | 3 | arc 2 -> 3
- 4 | 5 | arc 4 -> 5
-(7 rows)
-
---
--- test cycle detection
---
-create temp table graph( f int, t int, label text );
-insert into graph values
-	(1, 2, 'arc 1 -> 2'),
-	(1, 3, 'arc 1 -> 3'),
-	(2, 3, 'arc 2 -> 3'),
-	(1, 4, 'arc 1 -> 4'),
-	(4, 5, 'arc 4 -> 5'),
-	(5, 1, 'arc 5 -> 1');
-with recursive search_graph(f, t, label, is_cycle, path) as (
-	select *, false, array[row(g.f, g.t)] from graph g
-	union all
-	select g.*, row(g.f, g.t) = any(path), path || row(g.f, g.t)
-	from graph g, search_graph sg
-	where g.f = sg.t and not is_cycle
-)
-select * from search_graph;
- f | t |   label    | is_cycle |                   path                    
----+---+------------+----------+-------------------------------------------
- 1 | 2 | arc 1 -> 2 | f        | {"(1,2)"}
- 1 | 3 | arc 1 -> 3 | f        | {"(1,3)"}
- 2 | 3 | arc 2 -> 3 | f        | {"(2,3)"}
- 1 | 4 | arc 1 -> 4 | f        | {"(1,4)"}
- 4 | 5 | arc 4 -> 5 | f        | {"(4,5)"}
- 5 | 1 | arc 5 -> 1 | f        | {"(5,1)"}
- 1 | 2 | arc 1 -> 2 | f        | {"(5,1)","(1,2)"}
- 1 | 3 | arc 1 -> 3 | f        | {"(5,1)","(1,3)"}
- 1 | 4 | arc 1 -> 4 | f        | {"(5,1)","(1,4)"}
- 2 | 3 | arc 2 -> 3 | f        | {"(1,2)","(2,3)"}
- 4 | 5 | arc 4 -> 5 | f        | {"(1,4)","(4,5)"}
- 5 | 1 | arc 5 -> 1 | f        | {"(4,5)","(5,1)"}
- 1 | 2 | arc 1 -> 2 | f        | {"(4,5)","(5,1)","(1,2)"}
- 1 | 3 | arc 1 -> 3 | f        | {"(4,5)","(5,1)","(1,3)"}
- 1 | 4 | arc 1 -> 4 | f        | {"(4,5)","(5,1)","(1,4)"}
- 2 | 3 | arc 2 -> 3 | f        | {"(5,1)","(1,2)","(2,3)"}
- 4 | 5 | arc 4 -> 5 | f        | {"(5,1)","(1,4)","(4,5)"}
- 5 | 1 | arc 5 -> 1 | f        | {"(1,4)","(4,5)","(5,1)"}
- 1 | 2 | arc 1 -> 2 | f        | {"(1,4)","(4,5)","(5,1)","(1,2)"}
- 1 | 3 | arc 1 -> 3 | f        | {"(1,4)","(4,5)","(5,1)","(1,3)"}
- 1 | 4 | arc 1 -> 4 | t        | {"(1,4)","(4,5)","(5,1)","(1,4)"}
- 2 | 3 | arc 2 -> 3 | f        | {"(4,5)","(5,1)","(1,2)","(2,3)"}
- 4 | 5 | arc 4 -> 5 | t        | {"(4,5)","(5,1)","(1,4)","(4,5)"}
- 5 | 1 | arc 5 -> 1 | t        | {"(5,1)","(1,4)","(4,5)","(5,1)"}
- 2 | 3 | arc 2 -> 3 | f        | {"(1,4)","(4,5)","(5,1)","(1,2)","(2,3)"}
-(25 rows)
-
--- UNION DISTINCT exercises row type hashing support
-with recursive search_graph(f, t, label, is_cycle, path) as (
-	select *, false, array[row(g.f, g.t)] from graph g
-	union distinct
-	select g.*, row(g.f, g.t) = any(path), path || row(g.f, g.t)
-	from graph g, search_graph sg
-	where g.f = sg.t and not is_cycle
-)
-select * from search_graph;
- f | t |   label    | is_cycle |                   path                    
----+---+------------+----------+-------------------------------------------
- 1 | 2 | arc 1 -> 2 | f        | {"(1,2)"}
- 1 | 3 | arc 1 -> 3 | f        | {"(1,3)"}
- 2 | 3 | arc 2 -> 3 | f        | {"(2,3)"}
- 1 | 4 | arc 1 -> 4 | f        | {"(1,4)"}
- 4 | 5 | arc 4 -> 5 | f        | {"(4,5)"}
- 5 | 1 | arc 5 -> 1 | f        | {"(5,1)"}
- 1 | 2 | arc 1 -> 2 | f        | {"(5,1)","(1,2)"}
- 1 | 3 | arc 1 -> 3 | f        | {"(5,1)","(1,3)"}
- 1 | 4 | arc 1 -> 4 | f        | {"(5,1)","(1,4)"}
- 2 | 3 | arc 2 -> 3 | f        | {"(1,2)","(2,3)"}
- 4 | 5 | arc 4 -> 5 | f        | {"(1,4)","(4,5)"}
- 5 | 1 | arc 5 -> 1 | f        | {"(4,5)","(5,1)"}
- 1 | 2 | arc 1 -> 2 | f        | {"(4,5)","(5,1)","(1,2)"}
- 1 | 3 | arc 1 -> 3 | f        | {"(4,5)","(5,1)","(1,3)"}
- 1 | 4 | arc 1 -> 4 | f        | {"(4,5)","(5,1)","(1,4)"}
- 2 | 3 | arc 2 -> 3 | f        | {"(5,1)","(1,2)","(2,3)"}
- 4 | 5 | arc 4 -> 5 | f        | {"(5,1)","(1,4)","(4,5)"}
- 5 | 1 | arc 5 -> 1 | f        | {"(1,4)","(4,5)","(5,1)"}
- 1 | 2 | arc 1 -> 2 | f        | {"(1,4)","(4,5)","(5,1)","(1,2)"}
- 1 | 3 | arc 1 -> 3 | f        | {"(1,4)","(4,5)","(5,1)","(1,3)"}
- 1 | 4 | arc 1 -> 4 | t        | {"(1,4)","(4,5)","(5,1)","(1,4)"}
- 2 | 3 | arc 2 -> 3 | f        | {"(4,5)","(5,1)","(1,2)","(2,3)"}
- 4 | 5 | arc 4 -> 5 | t        | {"(4,5)","(5,1)","(1,4)","(4,5)"}
- 5 | 1 | arc 5 -> 1 | t        | {"(5,1)","(1,4)","(4,5)","(5,1)"}
- 2 | 3 | arc 2 -> 3 | f        | {"(1,4)","(4,5)","(5,1)","(1,2)","(2,3)"}
-(25 rows)
-
--- ordering by the path column has same effect as SEARCH DEPTH FIRST
-with recursive search_graph(f, t, label, is_cycle, path) as (
-	select *, false, array[row(g.f, g.t)] from graph g
-	union all
-	select g.*, row(g.f, g.t) = any(path), path || row(g.f, g.t)
-	from graph g, search_graph sg
-	where g.f = sg.t and not is_cycle
-)
-select * from search_graph order by path;
- f | t |   label    | is_cycle |                   path                    
----+---+------------+----------+-------------------------------------------
- 1 | 2 | arc 1 -> 2 | f        | {"(1,2)"}
- 2 | 3 | arc 2 -> 3 | f        | {"(1,2)","(2,3)"}
- 1 | 3 | arc 1 -> 3 | f        | {"(1,3)"}
- 1 | 4 | arc 1 -> 4 | f        | {"(1,4)"}
- 4 | 5 | arc 4 -> 5 | f        | {"(1,4)","(4,5)"}
- 5 | 1 | arc 5 -> 1 | f        | {"(1,4)","(4,5)","(5,1)"}
- 1 | 2 | arc 1 -> 2 | f        | {"(1,4)","(4,5)","(5,1)","(1,2)"}
- 2 | 3 | arc 2 -> 3 | f        | {"(1,4)","(4,5)","(5,1)","(1,2)","(2,3)"}
- 1 | 3 | arc 1 -> 3 | f        | {"(1,4)","(4,5)","(5,1)","(1,3)"}
- 1 | 4 | arc 1 -> 4 | t        | {"(1,4)","(4,5)","(5,1)","(1,4)"}
- 2 | 3 | arc 2 -> 3 | f        | {"(2,3)"}
- 4 | 5 | arc 4 -> 5 | f        | {"(4,5)"}
- 5 | 1 | arc 5 -> 1 | f        | {"(4,5)","(5,1)"}
- 1 | 2 | arc 1 -> 2 | f        | {"(4,5)","(5,1)","(1,2)"}
- 2 | 3 | arc 2 -> 3 | f        | {"(4,5)","(5,1)","(1,2)","(2,3)"}
- 1 | 3 | arc 1 -> 3 | f        | {"(4,5)","(5,1)","(1,3)"}
- 1 | 4 | arc 1 -> 4 | f        | {"(4,5)","(5,1)","(1,4)"}
- 4 | 5 | arc 4 -> 5 | t        | {"(4,5)","(5,1)","(1,4)","(4,5)"}
- 5 | 1 | arc 5 -> 1 | f        | {"(5,1)"}
- 1 | 2 | arc 1 -> 2 | f        | {"(5,1)","(1,2)"}
- 2 | 3 | arc 2 -> 3 | f        | {"(5,1)","(1,2)","(2,3)"}
- 1 | 3 | arc 1 -> 3 | f        | {"(5,1)","(1,3)"}
- 1 | 4 | arc 1 -> 4 | f        | {"(5,1)","(1,4)"}
- 4 | 5 | arc 4 -> 5 | f        | {"(5,1)","(1,4)","(4,5)"}
- 5 | 1 | arc 5 -> 1 | t        | {"(5,1)","(1,4)","(4,5)","(5,1)"}
-(25 rows)
-
--- CYCLE clause
-explain (verbose, costs off)
-with recursive search_graph(f, t, label) as (
-	select * from graph g
-	union all
-	select g.*
-	from graph g, search_graph sg
-	where g.f = sg.t
-) cycle f, t set is_cycle using path
-select * from search_graph;
-                                                                              QUERY PLAN                                                                               
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
- CTE Scan on search_graph
-   Output: search_graph.f, search_graph.t, search_graph.label, search_graph.is_cycle, search_graph.path
-   CTE search_graph
-     ->  Recursive Union
-           ->  Seq Scan on pg_temp.graph g
-                 Output: g.f, g.t, g.label, false, ARRAY[ROW(g.f, g.t)]
-           ->  Merge Join
-                 Output: g_1.f, g_1.t, g_1.label, CASE WHEN (ROW(g_1.f, g_1.t) = ANY (sg.path)) THEN true ELSE false END, array_cat(sg.path, ARRAY[ROW(g_1.f, g_1.t)])
-                 Merge Cond: (g_1.f = sg.t)
-                 ->  Sort
-                       Output: g_1.f, g_1.t, g_1.label
-                       Sort Key: g_1.f
-                       ->  Seq Scan on pg_temp.graph g_1
-                             Output: g_1.f, g_1.t, g_1.label
-                 ->  Sort
-                       Output: sg.path, sg.t
-                       Sort Key: sg.t
-                       ->  WorkTable Scan on search_graph sg
-                             Output: sg.path, sg.t
-                             Filter: (NOT sg.is_cycle)
-(20 rows)
-
-with recursive search_graph(f, t, label) as (
-	select * from graph g
-	union all
-	select g.*
-	from graph g, search_graph sg
-	where g.f = sg.t
-) cycle f, t set is_cycle using path
-select * from search_graph;
- f | t |   label    | is_cycle |                   path                    
----+---+------------+----------+-------------------------------------------
- 1 | 2 | arc 1 -> 2 | f        | {"(1,2)"}
- 1 | 3 | arc 1 -> 3 | f        | {"(1,3)"}
- 2 | 3 | arc 2 -> 3 | f        | {"(2,3)"}
- 1 | 4 | arc 1 -> 4 | f        | {"(1,4)"}
- 4 | 5 | arc 4 -> 5 | f        | {"(4,5)"}
- 5 | 1 | arc 5 -> 1 | f        | {"(5,1)"}
- 1 | 2 | arc 1 -> 2 | f        | {"(5,1)","(1,2)"}
- 1 | 3 | arc 1 -> 3 | f        | {"(5,1)","(1,3)"}
- 1 | 4 | arc 1 -> 4 | f        | {"(5,1)","(1,4)"}
- 2 | 3 | arc 2 -> 3 | f        | {"(1,2)","(2,3)"}
- 4 | 5 | arc 4 -> 5 | f        | {"(1,4)","(4,5)"}
- 5 | 1 | arc 5 -> 1 | f        | {"(4,5)","(5,1)"}
- 1 | 2 | arc 1 -> 2 | f        | {"(4,5)","(5,1)","(1,2)"}
- 1 | 3 | arc 1 -> 3 | f        | {"(4,5)","(5,1)","(1,3)"}
- 1 | 4 | arc 1 -> 4 | f        | {"(4,5)","(5,1)","(1,4)"}
- 2 | 3 | arc 2 -> 3 | f        | {"(5,1)","(1,2)","(2,3)"}
- 4 | 5 | arc 4 -> 5 | f        | {"(5,1)","(1,4)","(4,5)"}
- 5 | 1 | arc 5 -> 1 | f        | {"(1,4)","(4,5)","(5,1)"}
- 1 | 2 | arc 1 -> 2 | f        | {"(1,4)","(4,5)","(5,1)","(1,2)"}
- 1 | 3 | arc 1 -> 3 | f        | {"(1,4)","(4,5)","(5,1)","(1,3)"}
- 1 | 4 | arc 1 -> 4 | t        | {"(1,4)","(4,5)","(5,1)","(1,4)"}
- 2 | 3 | arc 2 -> 3 | f        | {"(4,5)","(5,1)","(1,2)","(2,3)"}
- 4 | 5 | arc 4 -> 5 | t        | {"(4,5)","(5,1)","(1,4)","(4,5)"}
- 5 | 1 | arc 5 -> 1 | t        | {"(5,1)","(1,4)","(4,5)","(5,1)"}
- 2 | 3 | arc 2 -> 3 | f        | {"(1,4)","(4,5)","(5,1)","(1,2)","(2,3)"}
-(25 rows)
-
-with recursive search_graph(f, t, label) as (
-	select * from graph g
-	union distinct
-	select g.*
-	from graph g, search_graph sg
-	where g.f = sg.t
-) cycle f, t set is_cycle to 'Y' default 'N' using path
-select * from search_graph;
- f | t |   label    | is_cycle |                   path                    
----+---+------------+----------+-------------------------------------------
- 1 | 2 | arc 1 -> 2 | N        | {"(1,2)"}
- 1 | 3 | arc 1 -> 3 | N        | {"(1,3)"}
- 2 | 3 | arc 2 -> 3 | N        | {"(2,3)"}
- 1 | 4 | arc 1 -> 4 | N        | {"(1,4)"}
- 4 | 5 | arc 4 -> 5 | N        | {"(4,5)"}
- 5 | 1 | arc 5 -> 1 | N        | {"(5,1)"}
- 1 | 2 | arc 1 -> 2 | N        | {"(5,1)","(1,2)"}
- 1 | 3 | arc 1 -> 3 | N        | {"(5,1)","(1,3)"}
- 1 | 4 | arc 1 -> 4 | N        | {"(5,1)","(1,4)"}
- 2 | 3 | arc 2 -> 3 | N        | {"(1,2)","(2,3)"}
- 4 | 5 | arc 4 -> 5 | N        | {"(1,4)","(4,5)"}
- 5 | 1 | arc 5 -> 1 | N        | {"(4,5)","(5,1)"}
- 1 | 2 | arc 1 -> 2 | N        | {"(4,5)","(5,1)","(1,2)"}
- 1 | 3 | arc 1 -> 3 | N        | {"(4,5)","(5,1)","(1,3)"}
- 1 | 4 | arc 1 -> 4 | N        | {"(4,5)","(5,1)","(1,4)"}
- 2 | 3 | arc 2 -> 3 | N        | {"(5,1)","(1,2)","(2,3)"}
- 4 | 5 | arc 4 -> 5 | N        | {"(5,1)","(1,4)","(4,5)"}
- 5 | 1 | arc 5 -> 1 | N        | {"(1,4)","(4,5)","(5,1)"}
- 1 | 2 | arc 1 -> 2 | N        | {"(1,4)","(4,5)","(5,1)","(1,2)"}
- 1 | 3 | arc 1 -> 3 | N        | {"(1,4)","(4,5)","(5,1)","(1,3)"}
- 1 | 4 | arc 1 -> 4 | Y        | {"(1,4)","(4,5)","(5,1)","(1,4)"}
- 2 | 3 | arc 2 -> 3 | N        | {"(4,5)","(5,1)","(1,2)","(2,3)"}
- 4 | 5 | arc 4 -> 5 | Y        | {"(4,5)","(5,1)","(1,4)","(4,5)"}
- 5 | 1 | arc 5 -> 1 | Y        | {"(5,1)","(1,4)","(4,5)","(5,1)"}
- 2 | 3 | arc 2 -> 3 | N        | {"(1,4)","(4,5)","(5,1)","(1,2)","(2,3)"}
-(25 rows)
-
--- multiple CTEs
-with recursive
-graph(f, t, label) as (
-  values (1, 2, 'arc 1 -> 2'),
-         (1, 3, 'arc 1 -> 3'),
-         (2, 3, 'arc 2 -> 3'),
-         (1, 4, 'arc 1 -> 4'),
-         (4, 5, 'arc 4 -> 5'),
-         (5, 1, 'arc 5 -> 1')
-),
-search_graph(f, t, label) as (
-        select * from graph g
-        union all
-        select g.*
-        from graph g, search_graph sg
-        where g.f = sg.t
-) cycle f, t set is_cycle to true default false using path
-select f, t, label from search_graph;
- f | t |   label    
----+---+------------
- 1 | 2 | arc 1 -> 2
- 1 | 3 | arc 1 -> 3
- 2 | 3 | arc 2 -> 3
- 1 | 4 | arc 1 -> 4
- 4 | 5 | arc 4 -> 5
- 5 | 1 | arc 5 -> 1
- 2 | 3 | arc 2 -> 3
- 4 | 5 | arc 4 -> 5
- 5 | 1 | arc 5 -> 1
- 1 | 4 | arc 1 -> 4
- 1 | 3 | arc 1 -> 3
- 1 | 2 | arc 1 -> 2
- 5 | 1 | arc 5 -> 1
- 1 | 4 | arc 1 -> 4
- 1 | 3 | arc 1 -> 3
- 1 | 2 | arc 1 -> 2
- 4 | 5 | arc 4 -> 5
- 2 | 3 | arc 2 -> 3
- 1 | 4 | arc 1 -> 4
- 1 | 3 | arc 1 -> 3
- 1 | 2 | arc 1 -> 2
- 4 | 5 | arc 4 -> 5
- 2 | 3 | arc 2 -> 3
- 5 | 1 | arc 5 -> 1
- 2 | 3 | arc 2 -> 3
-(25 rows)
-
--- star expansion
-with recursive a as (
-	select 1 as b
-	union all
-	select * from a
-) cycle b set c using p
-select * from a;
- b | c |     p     
----+---+-----------
- 1 | f | {(1)}
- 1 | t | {(1),(1)}
-(2 rows)
-
--- search+cycle
-with recursive search_graph(f, t, label) as (
-	select * from graph g
-	union all
-	select g.*
-	from graph g, search_graph sg
-	where g.f = sg.t
-) search depth first by f, t set seq
-  cycle f, t set is_cycle using path
-select * from search_graph;
- f | t |   label    |                    seq                    | is_cycle |                   path                    
----+---+------------+-------------------------------------------+----------+-------------------------------------------
- 1 | 2 | arc 1 -> 2 | {"(1,2)"}                                 | f        | {"(1,2)"}
- 1 | 3 | arc 1 -> 3 | {"(1,3)"}                                 | f        | {"(1,3)"}
- 2 | 3 | arc 2 -> 3 | {"(2,3)"}                                 | f        | {"(2,3)"}
- 1 | 4 | arc 1 -> 4 | {"(1,4)"}                                 | f        | {"(1,4)"}
- 4 | 5 | arc 4 -> 5 | {"(4,5)"}                                 | f        | {"(4,5)"}
- 5 | 1 | arc 5 -> 1 | {"(5,1)"}                                 | f        | {"(5,1)"}
- 1 | 2 | arc 1 -> 2 | {"(5,1)","(1,2)"}                         | f        | {"(5,1)","(1,2)"}
- 1 | 3 | arc 1 -> 3 | {"(5,1)","(1,3)"}                         | f        | {"(5,1)","(1,3)"}
- 1 | 4 | arc 1 -> 4 | {"(5,1)","(1,4)"}                         | f        | {"(5,1)","(1,4)"}
- 2 | 3 | arc 2 -> 3 | {"(1,2)","(2,3)"}                         | f        | {"(1,2)","(2,3)"}
- 4 | 5 | arc 4 -> 5 | {"(1,4)","(4,5)"}                         | f        | {"(1,4)","(4,5)"}
- 5 | 1 | arc 5 -> 1 | {"(4,5)","(5,1)"}                         | f        | {"(4,5)","(5,1)"}
- 1 | 2 | arc 1 -> 2 | {"(4,5)","(5,1)","(1,2)"}                 | f        | {"(4,5)","(5,1)","(1,2)"}
- 1 | 3 | arc 1 -> 3 | {"(4,5)","(5,1)","(1,3)"}                 | f        | {"(4,5)","(5,1)","(1,3)"}
- 1 | 4 | arc 1 -> 4 | {"(4,5)","(5,1)","(1,4)"}                 | f        | {"(4,5)","(5,1)","(1,4)"}
- 2 | 3 | arc 2 -> 3 | {"(5,1)","(1,2)","(2,3)"}                 | f        | {"(5,1)","(1,2)","(2,3)"}
- 4 | 5 | arc 4 -> 5 | {"(5,1)","(1,4)","(4,5)"}                 | f        | {"(5,1)","(1,4)","(4,5)"}
- 5 | 1 | arc 5 -> 1 | {"(1,4)","(4,5)","(5,1)"}                 | f        | {"(1,4)","(4,5)","(5,1)"}
- 1 | 2 | arc 1 -> 2 | {"(1,4)","(4,5)","(5,1)","(1,2)"}         | f        | {"(1,4)","(4,5)","(5,1)","(1,2)"}
- 1 | 3 | arc 1 -> 3 | {"(1,4)","(4,5)","(5,1)","(1,3)"}         | f        | {"(1,4)","(4,5)","(5,1)","(1,3)"}
- 1 | 4 | arc 1 -> 4 | {"(1,4)","(4,5)","(5,1)","(1,4)"}         | t        | {"(1,4)","(4,5)","(5,1)","(1,4)"}
- 2 | 3 | arc 2 -> 3 | {"(4,5)","(5,1)","(1,2)","(2,3)"}         | f        | {"(4,5)","(5,1)","(1,2)","(2,3)"}
- 4 | 5 | arc 4 -> 5 | {"(4,5)","(5,1)","(1,4)","(4,5)"}         | t        | {"(4,5)","(5,1)","(1,4)","(4,5)"}
- 5 | 1 | arc 5 -> 1 | {"(5,1)","(1,4)","(4,5)","(5,1)"}         | t        | {"(5,1)","(1,4)","(4,5)","(5,1)"}
- 2 | 3 | arc 2 -> 3 | {"(1,4)","(4,5)","(5,1)","(1,2)","(2,3)"} | f        | {"(1,4)","(4,5)","(5,1)","(1,2)","(2,3)"}
-(25 rows)
-
-with recursive search_graph(f, t, label) as (
-	select * from graph g
-	union all
-	select g.*
-	from graph g, search_graph sg
-	where g.f = sg.t
-) search breadth first by f, t set seq
-  cycle f, t set is_cycle using path
-select * from search_graph;
- f | t |   label    |   seq   | is_cycle |                   path                    
----+---+------------+---------+----------+-------------------------------------------
- 1 | 2 | arc 1 -> 2 | (0,1,2) | f        | {"(1,2)"}
- 1 | 3 | arc 1 -> 3 | (0,1,3) | f        | {"(1,3)"}
- 2 | 3 | arc 2 -> 3 | (0,2,3) | f        | {"(2,3)"}
- 1 | 4 | arc 1 -> 4 | (0,1,4) | f        | {"(1,4)"}
- 4 | 5 | arc 4 -> 5 | (0,4,5) | f        | {"(4,5)"}
- 5 | 1 | arc 5 -> 1 | (0,5,1) | f        | {"(5,1)"}
- 1 | 2 | arc 1 -> 2 | (1,1,2) | f        | {"(5,1)","(1,2)"}
- 1 | 3 | arc 1 -> 3 | (1,1,3) | f        | {"(5,1)","(1,3)"}
- 1 | 4 | arc 1 -> 4 | (1,1,4) | f        | {"(5,1)","(1,4)"}
- 2 | 3 | arc 2 -> 3 | (1,2,3) | f        | {"(1,2)","(2,3)"}
- 4 | 5 | arc 4 -> 5 | (1,4,5) | f        | {"(1,4)","(4,5)"}
- 5 | 1 | arc 5 -> 1 | (1,5,1) | f        | {"(4,5)","(5,1)"}
- 1 | 2 | arc 1 -> 2 | (2,1,2) | f        | {"(4,5)","(5,1)","(1,2)"}
- 1 | 3 | arc 1 -> 3 | (2,1,3) | f        | {"(4,5)","(5,1)","(1,3)"}
- 1 | 4 | arc 1 -> 4 | (2,1,4) | f        | {"(4,5)","(5,1)","(1,4)"}
- 2 | 3 | arc 2 -> 3 | (2,2,3) | f        | {"(5,1)","(1,2)","(2,3)"}
- 4 | 5 | arc 4 -> 5 | (2,4,5) | f        | {"(5,1)","(1,4)","(4,5)"}
- 5 | 1 | arc 5 -> 1 | (2,5,1) | f        | {"(1,4)","(4,5)","(5,1)"}
- 1 | 2 | arc 1 -> 2 | (3,1,2) | f        | {"(1,4)","(4,5)","(5,1)","(1,2)"}
- 1 | 3 | arc 1 -> 3 | (3,1,3) | f        | {"(1,4)","(4,5)","(5,1)","(1,3)"}
- 1 | 4 | arc 1 -> 4 | (3,1,4) | t        | {"(1,4)","(4,5)","(5,1)","(1,4)"}
- 2 | 3 | arc 2 -> 3 | (3,2,3) | f        | {"(4,5)","(5,1)","(1,2)","(2,3)"}
- 4 | 5 | arc 4 -> 5 | (3,4,5) | t        | {"(4,5)","(5,1)","(1,4)","(4,5)"}
- 5 | 1 | arc 5 -> 1 | (3,5,1) | t        | {"(5,1)","(1,4)","(4,5)","(5,1)"}
- 2 | 3 | arc 2 -> 3 | (4,2,3) | f        | {"(1,4)","(4,5)","(5,1)","(1,2)","(2,3)"}
-(25 rows)
-
--- various syntax errors
-with recursive search_graph(f, t, label) as (
-	select * from graph g
-	union all
-	select g.*
-	from graph g, search_graph sg
-	where g.f = sg.t
-) cycle foo, tar set is_cycle using path
-select * from search_graph;
-ERROR:  cycle column "foo" not in WITH query column list
-LINE 7: ) cycle foo, tar set is_cycle using path
-          ^
-with recursive search_graph(f, t, label) as (
-	select * from graph g
-	union all
-	select g.*
-	from graph g, search_graph sg
-	where g.f = sg.t
-) cycle f, t set is_cycle to true default 55 using path
-select * from search_graph;
-ERROR:  CYCLE types boolean and integer cannot be matched
-LINE 7: ) cycle f, t set is_cycle to true default 55 using path
-                                                  ^
-with recursive search_graph(f, t, label) as (
-	select * from graph g
-	union all
-	select g.*
-	from graph g, search_graph sg
-	where g.f = sg.t
-) cycle f, t set is_cycle to point '(1,1)' default point '(0,0)' using path
-select * from search_graph;
-ERROR:  could not identify an equality operator for type point
-with recursive search_graph(f, t, label) as (
-	select * from graph g
-	union all
-	select g.*
-	from graph g, search_graph sg
-	where g.f = sg.t
-) cycle f, t set label to true default false using path
-select * from search_graph;
-ERROR:  cycle mark column name "label" already used in WITH query column list
-LINE 7: ) cycle f, t set label to true default false using path
-          ^
-with recursive search_graph(f, t, label) as (
-	select * from graph g
-	union all
-	select g.*
-	from graph g, search_graph sg
-	where g.f = sg.t
-) cycle f, t set is_cycle to true default false using label
-select * from search_graph;
-ERROR:  cycle path column name "label" already used in WITH query column list
-LINE 7: ) cycle f, t set is_cycle to true default false using label
-          ^
-with recursive search_graph(f, t, label) as (
-	select * from graph g
-	union all
-	select g.*
-	from graph g, search_graph sg
-	where g.f = sg.t
-) cycle f, t set foo to true default false using foo
-select * from search_graph;
-ERROR:  cycle mark column name and cycle path column name are the same
-LINE 7: ) cycle f, t set foo to true default false using foo
-          ^
-with recursive search_graph(f, t, label) as (
-	select * from graph g
-	union all
-	select g.*
-	from graph g, search_graph sg
-	where g.f = sg.t
-) cycle f, t, f set is_cycle to true default false using path
-select * from search_graph;
-ERROR:  cycle column "f" specified more than once
-LINE 7: ) cycle f, t, f set is_cycle to true default false using pat...
-          ^
-with recursive search_graph(f, t, label) as (
-	select * from graph g
-	union all
-	select g.*
-	from graph g, search_graph sg
-	where g.f = sg.t
-) search depth first by f, t set foo
-  cycle f, t set foo to true default false using path
-select * from search_graph;
-ERROR:  search sequence column name and cycle mark column name are the same
-LINE 7: ) search depth first by f, t set foo
-          ^
-with recursive search_graph(f, t, label) as (
-	select * from graph g
-	union all
-	select g.*
-	from graph g, search_graph sg
-	where g.f = sg.t
-) search depth first by f, t set foo
-  cycle f, t set is_cycle to true default false using foo
-select * from search_graph;
-ERROR:  search sequence column name and cycle path column name are the same
-LINE 7: ) search depth first by f, t set foo
-          ^
--- test ruleutils and view expansion
-create temp view v_cycle1 as
-with recursive search_graph(f, t, label) as (
-	select * from graph g
-	union all
-	select g.*
-	from graph g, search_graph sg
-	where g.f = sg.t
-) cycle f, t set is_cycle using path
-select f, t, label from search_graph;
-create temp view v_cycle2 as
-with recursive search_graph(f, t, label) as (
-	select * from graph g
-	union all
-	select g.*
-	from graph g, search_graph sg
-	where g.f = sg.t
-) cycle f, t set is_cycle to 'Y' default 'N' using path
-select f, t, label from search_graph;
-select pg_get_viewdef('v_cycle1');
-                 pg_get_viewdef                 
-------------------------------------------------
-  WITH RECURSIVE search_graph(f, t, label) AS (+
-          SELECT g.f,                          +
-             g.t,                              +
-             g.label                           +
-            FROM graph g                       +
-         UNION ALL                             +
-          SELECT g.f,                          +
-             g.t,                              +
-             g.label                           +
-            FROM graph g,                      +
-             search_graph sg                   +
-           WHERE (g.f = sg.t)                  +
-         ) CYCLE f, t SET is_cycle USING path  +
-  SELECT search_graph.f,                       +
-     search_graph.t,                           +
-     search_graph.label                        +
-    FROM search_graph;
-(1 row)
-
-select pg_get_viewdef('v_cycle2');
-                               pg_get_viewdef                                
------------------------------------------------------------------------------
-  WITH RECURSIVE search_graph(f, t, label) AS (                             +
-          SELECT g.f,                                                       +
-             g.t,                                                           +
-             g.label                                                        +
-            FROM graph g                                                    +
-         UNION ALL                                                          +
-          SELECT g.f,                                                       +
-             g.t,                                                           +
-             g.label                                                        +
-            FROM graph g,                                                   +
-             search_graph sg                                                +
-           WHERE (g.f = sg.t)                                               +
-         ) CYCLE f, t SET is_cycle TO 'Y'::text DEFAULT 'N'::text USING path+
-  SELECT search_graph.f,                                                    +
-     search_graph.t,                                                        +
-     search_graph.label                                                     +
-    FROM search_graph;
-(1 row)
-
-select * from v_cycle1;
- f | t |   label    
----+---+------------
- 1 | 2 | arc 1 -> 2
- 1 | 3 | arc 1 -> 3
- 2 | 3 | arc 2 -> 3
- 1 | 4 | arc 1 -> 4
- 4 | 5 | arc 4 -> 5
- 5 | 1 | arc 5 -> 1
- 1 | 2 | arc 1 -> 2
- 1 | 3 | arc 1 -> 3
- 1 | 4 | arc 1 -> 4
- 2 | 3 | arc 2 -> 3
- 4 | 5 | arc 4 -> 5
- 5 | 1 | arc 5 -> 1
- 1 | 2 | arc 1 -> 2
- 1 | 3 | arc 1 -> 3
- 1 | 4 | arc 1 -> 4
- 2 | 3 | arc 2 -> 3
- 4 | 5 | arc 4 -> 5
- 5 | 1 | arc 5 -> 1
- 1 | 2 | arc 1 -> 2
- 1 | 3 | arc 1 -> 3
- 1 | 4 | arc 1 -> 4
- 2 | 3 | arc 2 -> 3
- 4 | 5 | arc 4 -> 5
- 5 | 1 | arc 5 -> 1
- 2 | 3 | arc 2 -> 3
-(25 rows)
-
-select * from v_cycle2;
- f | t |   label    
----+---+------------
- 1 | 2 | arc 1 -> 2
- 1 | 3 | arc 1 -> 3
- 2 | 3 | arc 2 -> 3
- 1 | 4 | arc 1 -> 4
- 4 | 5 | arc 4 -> 5
- 5 | 1 | arc 5 -> 1
- 1 | 2 | arc 1 -> 2
- 1 | 3 | arc 1 -> 3
- 1 | 4 | arc 1 -> 4
- 2 | 3 | arc 2 -> 3
- 4 | 5 | arc 4 -> 5
- 5 | 1 | arc 5 -> 1
- 1 | 2 | arc 1 -> 2
- 1 | 3 | arc 1 -> 3
- 1 | 4 | arc 1 -> 4
- 2 | 3 | arc 2 -> 3
- 4 | 5 | arc 4 -> 5
- 5 | 1 | arc 5 -> 1
- 1 | 2 | arc 1 -> 2
- 1 | 3 | arc 1 -> 3
- 1 | 4 | arc 1 -> 4
- 2 | 3 | arc 2 -> 3
- 4 | 5 | arc 4 -> 5
- 5 | 1 | arc 5 -> 1
- 2 | 3 | arc 2 -> 3
-(25 rows)
-
---
--- test multiple WITH queries
---
-WITH RECURSIVE
-  y (id) AS (VALUES (1)),
-  x (id) AS (SELECT * FROM y UNION ALL SELECT id+1 FROM x WHERE id < 5)
-SELECT * FROM x;
- id 
-----
-  1
-  2
-  3
-  4
-  5
-(5 rows)
-
--- forward reference OK
-WITH RECURSIVE
-    x(id) AS (SELECT * FROM y UNION ALL SELECT id+1 FROM x WHERE id < 5),
-    y(id) AS (values (1))
- SELECT * FROM x;
- id 
-----
-  1
-  2
-  3
-  4
-  5
-(5 rows)
-
-WITH RECURSIVE
-   x(id) AS
-     (VALUES (1) UNION ALL SELECT id+1 FROM x WHERE id < 5),
-   y(id) AS
-     (VALUES (1) UNION ALL SELECT id+1 FROM y WHERE id < 10)
- SELECT y.*, x.* FROM y LEFT JOIN x USING (id);
- id | id 
-----+----
-  1 |  1
-  2 |  2
-  3 |  3
-  4 |  4
-  5 |  5
-  6 |   
-  7 |   
-  8 |   
-  9 |   
- 10 |   
-(10 rows)
-
-WITH RECURSIVE
-   x(id) AS
-     (VALUES (1) UNION ALL SELECT id+1 FROM x WHERE id < 5),
-   y(id) AS
-     (VALUES (1) UNION ALL SELECT id+1 FROM x WHERE id < 10)
- SELECT y.*, x.* FROM y LEFT JOIN x USING (id);
- id | id 
-----+----
-  1 |  1
-  2 |  2
-  3 |  3
-  4 |  4
-  5 |  5
-  6 |   
-(6 rows)
-
-WITH RECURSIVE
-   x(id) AS
-     (SELECT 1 UNION ALL SELECT id+1 FROM x WHERE id < 3 ),
-   y(id) AS
-     (SELECT * FROM x UNION ALL SELECT * FROM x),
-   z(id) AS
-     (SELECT * FROM x UNION ALL SELECT id+1 FROM z WHERE id < 10)
- SELECT * FROM z;
- id 
-----
-  1
-  2
-  3
-  2
-  3
-  4
-  3
-  4
-  5
-  4
-  5
-  6
-  5
-  6
-  7
-  6
-  7
-  8
-  7
-  8
-  9
-  8
-  9
- 10
-  9
- 10
- 10
-(27 rows)
-
-WITH RECURSIVE
-   x(id) AS
-     (SELECT 1 UNION ALL SELECT id+1 FROM x WHERE id < 3 ),
-   y(id) AS
-     (SELECT * FROM x UNION ALL SELECT * FROM x),
-   z(id) AS
-     (SELECT * FROM y UNION ALL SELECT id+1 FROM z WHERE id < 10)
- SELECT * FROM z;
- id 
-----
-  1
-  2
-  3
-  1
-  2
-  3
-  2
-  3
-  4
-  2
-  3
-  4
-  3
-  4
-  5
-  3
-  4
-  5
-  4
-  5
-  6
-  4
-  5
-  6
-  5
-  6
-  7
-  5
-  6
-  7
-  6
-  7
-  8
-  6
-  7
-  8
-  7
-  8
-  9
-  7
-  8
-  9
-  8
-  9
- 10
-  8
-  9
- 10
-  9
- 10
-  9
- 10
- 10
- 10
-(54 rows)
-
---
--- Test WITH attached to a data-modifying statement
---
-CREATE TEMPORARY TABLE y (a INTEGER);
-INSERT INTO y SELECT generate_series(1, 10);
-WITH t AS (
-	SELECT a FROM y
-)
-INSERT INTO y
-SELECT a+20 FROM t RETURNING *;
- a  
-----
- 21
- 22
- 23
- 24
- 25
- 26
- 27
- 28
- 29
- 30
-(10 rows)
-
-SELECT * FROM y;
- a  
-----
-  1
-  2
-  3
-  4
-  5
-  6
-  7
-  8
-  9
- 10
- 21
- 22
- 23
- 24
- 25
- 26
- 27
- 28
- 29
- 30
-(20 rows)
-
-WITH t AS (
-	SELECT a FROM y
-)
-UPDATE y SET a = y.a-10 FROM t WHERE y.a > 20 AND t.a = y.a RETURNING y.a;
- a  
-----
- 11
- 12
- 13
- 14
- 15
- 16
- 17
- 18
- 19
- 20
-(10 rows)
-
-SELECT * FROM y;
- a  
-----
-  1
-  2
-  3
-  4
-  5
-  6
-  7
-  8
-  9
- 10
- 11
- 12
- 13
- 14
- 15
- 16
- 17
- 18
- 19
- 20
-(20 rows)
-
-WITH RECURSIVE t(a) AS (
-	SELECT 11
-	UNION ALL
-	SELECT a+1 FROM t WHERE a < 50
-)
-DELETE FROM y USING t WHERE t.a = y.a RETURNING y.a;
- a  
-----
- 11
- 12
- 13
- 14
- 15
- 16
- 17
- 18
- 19
- 20
-(10 rows)
-
-SELECT * FROM y;
- a  
-----
-  1
-  2
-  3
-  4
-  5
-  6
-  7
-  8
-  9
- 10
-(10 rows)
-
-DROP TABLE y;
---
--- error cases
---
--- INTERSECT
-WITH RECURSIVE x(n) AS (SELECT 1 INTERSECT SELECT n+1 FROM x)
-	SELECT * FROM x;
-ERROR:  recursive query "x" does not have the form non-recursive-term UNION [ALL] recursive-term
-LINE 1: WITH RECURSIVE x(n) AS (SELECT 1 INTERSECT SELECT n+1 FROM x...
-                       ^
-WITH RECURSIVE x(n) AS (SELECT 1 INTERSECT ALL SELECT n+1 FROM x)
-	SELECT * FROM x;
-ERROR:  recursive query "x" does not have the form non-recursive-term UNION [ALL] recursive-term
-LINE 1: WITH RECURSIVE x(n) AS (SELECT 1 INTERSECT ALL SELECT n+1 FR...
-                       ^
--- EXCEPT
-WITH RECURSIVE x(n) AS (SELECT 1 EXCEPT SELECT n+1 FROM x)
-	SELECT * FROM x;
-ERROR:  recursive query "x" does not have the form non-recursive-term UNION [ALL] recursive-term
-LINE 1: WITH RECURSIVE x(n) AS (SELECT 1 EXCEPT SELECT n+1 FROM x)
-                       ^
-WITH RECURSIVE x(n) AS (SELECT 1 EXCEPT ALL SELECT n+1 FROM x)
-	SELECT * FROM x;
-ERROR:  recursive query "x" does not have the form non-recursive-term UNION [ALL] recursive-term
-LINE 1: WITH RECURSIVE x(n) AS (SELECT 1 EXCEPT ALL SELECT n+1 FROM ...
-                       ^
--- no non-recursive term
-WITH RECURSIVE x(n) AS (SELECT n FROM x)
-	SELECT * FROM x;
-ERROR:  recursive query "x" does not have the form non-recursive-term UNION [ALL] recursive-term
-LINE 1: WITH RECURSIVE x(n) AS (SELECT n FROM x)
-                       ^
--- recursive term in the left hand side (strictly speaking, should allow this)
-WITH RECURSIVE x(n) AS (SELECT n FROM x UNION ALL SELECT 1)
-	SELECT * FROM x;
-ERROR:  recursive reference to query "x" must not appear within its non-recursive term
-LINE 1: WITH RECURSIVE x(n) AS (SELECT n FROM x UNION ALL SELECT 1)
-                                              ^
-CREATE TEMPORARY TABLE y (a INTEGER);
-INSERT INTO y SELECT generate_series(1, 10);
--- LEFT JOIN
-WITH RECURSIVE x(n) AS (SELECT a FROM y WHERE a = 1
-	UNION ALL
-	SELECT x.n+1 FROM y LEFT JOIN x ON x.n = y.a WHERE n < 10)
-SELECT * FROM x;
-ERROR:  recursive reference to query "x" must not appear within an outer join
-LINE 3:  SELECT x.n+1 FROM y LEFT JOIN x ON x.n = y.a WHERE n < 10)
-                                       ^
--- RIGHT JOIN
-WITH RECURSIVE x(n) AS (SELECT a FROM y WHERE a = 1
-	UNION ALL
-	SELECT x.n+1 FROM x RIGHT JOIN y ON x.n = y.a WHERE n < 10)
-SELECT * FROM x;
-ERROR:  recursive reference to query "x" must not appear within an outer join
-LINE 3:  SELECT x.n+1 FROM x RIGHT JOIN y ON x.n = y.a WHERE n < 10)
-                           ^
--- FULL JOIN
-WITH RECURSIVE x(n) AS (SELECT a FROM y WHERE a = 1
-	UNION ALL
-	SELECT x.n+1 FROM x FULL JOIN y ON x.n = y.a WHERE n < 10)
-SELECT * FROM x;
-ERROR:  recursive reference to query "x" must not appear within an outer join
-LINE 3:  SELECT x.n+1 FROM x FULL JOIN y ON x.n = y.a WHERE n < 10)
-                           ^
--- subquery
-WITH RECURSIVE x(n) AS (SELECT 1 UNION ALL SELECT n+1 FROM x
-                          WHERE n IN (SELECT * FROM x))
-  SELECT * FROM x;
-ERROR:  recursive reference to query "x" must not appear within a subquery
-LINE 2:                           WHERE n IN (SELECT * FROM x))
-                                                            ^
--- aggregate functions
-WITH RECURSIVE x(n) AS (SELECT 1 UNION ALL SELECT count(*) FROM x)
-  SELECT * FROM x;
-ERROR:  aggregate functions are not allowed in a recursive query's recursive term
-LINE 1: WITH RECURSIVE x(n) AS (SELECT 1 UNION ALL SELECT count(*) F...
-                                                          ^
-WITH RECURSIVE x(n) AS (SELECT 1 UNION ALL SELECT sum(n) FROM x)
-  SELECT * FROM x;
-ERROR:  aggregate functions are not allowed in a recursive query's recursive term
-LINE 1: WITH RECURSIVE x(n) AS (SELECT 1 UNION ALL SELECT sum(n) FRO...
-                                                          ^
--- ORDER BY
-WITH RECURSIVE x(n) AS (SELECT 1 UNION ALL SELECT n+1 FROM x ORDER BY 1)
-  SELECT * FROM x;
-ERROR:  ORDER BY in a recursive query is not implemented
-LINE 1: ...VE x(n) AS (SELECT 1 UNION ALL SELECT n+1 FROM x ORDER BY 1)
-                                                                     ^
--- LIMIT/OFFSET
-WITH RECURSIVE x(n) AS (SELECT 1 UNION ALL SELECT n+1 FROM x LIMIT 10 OFFSET 1)
-  SELECT * FROM x;
-ERROR:  OFFSET in a recursive query is not implemented
-LINE 1: ... AS (SELECT 1 UNION ALL SELECT n+1 FROM x LIMIT 10 OFFSET 1)
-                                                                     ^
--- FOR UPDATE
-WITH RECURSIVE x(n) AS (SELECT 1 UNION ALL SELECT n+1 FROM x FOR UPDATE)
-  SELECT * FROM x;
-ERROR:  FOR UPDATE/SHARE in a recursive query is not implemented
--- target list has a recursive query name
-WITH RECURSIVE x(id) AS (values (1)
-    UNION ALL
-    SELECT (SELECT * FROM x) FROM x WHERE id < 5
-) SELECT * FROM x;
-ERROR:  recursive reference to query "x" must not appear within a subquery
-LINE 3:     SELECT (SELECT * FROM x) FROM x WHERE id < 5
-                                  ^
--- mutual recursive query (not implemented)
-WITH RECURSIVE
-  x (id) AS (SELECT 1 UNION ALL SELECT id+1 FROM y WHERE id < 5),
-  y (id) AS (SELECT 1 UNION ALL SELECT id+1 FROM x WHERE id < 5)
-SELECT * FROM x;
-ERROR:  mutual recursion between WITH items is not implemented
-LINE 2:   x (id) AS (SELECT 1 UNION ALL SELECT id+1 FROM y WHERE id ...
-          ^
--- non-linear recursion is not allowed
-WITH RECURSIVE foo(i) AS
-    (values (1)
-    UNION ALL
-       (SELECT i+1 FROM foo WHERE i < 10
-          UNION ALL
-       SELECT i+1 FROM foo WHERE i < 5)
-) SELECT * FROM foo;
-ERROR:  recursive reference to query "foo" must not appear more than once
-LINE 6:        SELECT i+1 FROM foo WHERE i < 5)
-                               ^
-WITH RECURSIVE foo(i) AS
-    (values (1)
-    UNION ALL
-	   SELECT * FROM
-       (SELECT i+1 FROM foo WHERE i < 10
-          UNION ALL
-       SELECT i+1 FROM foo WHERE i < 5) AS t
-) SELECT * FROM foo;
-ERROR:  recursive reference to query "foo" must not appear more than once
-LINE 7:        SELECT i+1 FROM foo WHERE i < 5) AS t
-                               ^
-WITH RECURSIVE foo(i) AS
-    (values (1)
-    UNION ALL
-       (SELECT i+1 FROM foo WHERE i < 10
-          EXCEPT
-       SELECT i+1 FROM foo WHERE i < 5)
-) SELECT * FROM foo;
-ERROR:  recursive reference to query "foo" must not appear within EXCEPT
-LINE 6:        SELECT i+1 FROM foo WHERE i < 5)
-                               ^
-WITH RECURSIVE foo(i) AS
-    (values (1)
-    UNION ALL
-       (SELECT i+1 FROM foo WHERE i < 10
-          INTERSECT
-       SELECT i+1 FROM foo WHERE i < 5)
-) SELECT * FROM foo;
-ERROR:  recursive reference to query "foo" must not appear more than once
-LINE 6:        SELECT i+1 FROM foo WHERE i < 5)
-                               ^
--- Wrong type induced from non-recursive term
-WITH RECURSIVE foo(i) AS
-   (SELECT i FROM (VALUES(1),(2)) t(i)
-   UNION ALL
-   SELECT (i+1)::numeric(10,0) FROM foo WHERE i < 10)
-SELECT * FROM foo;
-ERROR:  recursive query "foo" column 1 has type integer in non-recursive term but type numeric overall
-LINE 2:    (SELECT i FROM (VALUES(1),(2)) t(i)
-                   ^
-HINT:  Cast the output of the non-recursive term to the correct type.
--- rejects different typmod, too (should we allow this?)
-WITH RECURSIVE foo(i) AS
-   (SELECT i::numeric(3,0) FROM (VALUES(1),(2)) t(i)
-   UNION ALL
-   SELECT (i+1)::numeric(10,0) FROM foo WHERE i < 10)
-SELECT * FROM foo;
-ERROR:  recursive query "foo" column 1 has type numeric(3,0) in non-recursive term but type numeric overall
-LINE 2:    (SELECT i::numeric(3,0) FROM (VALUES(1),(2)) t(i)
-                   ^
-HINT:  Cast the output of the non-recursive term to the correct type.
--- disallow OLD/NEW reference in CTE
-CREATE TEMPORARY TABLE x (n integer);
-CREATE RULE r2 AS ON UPDATE TO x DO INSTEAD
-    WITH t AS (SELECT OLD.*) UPDATE y SET a = t.n FROM t;
-ERROR:  cannot refer to OLD within WITH query
---
--- test for bug #4902
---
-with cte(foo) as ( values(42) ) values((select foo from cte));
- column1 
----------
-      42
-(1 row)
-
-with cte(foo) as ( select 42 ) select * from ((select foo from cte)) q;
- foo 
------
-  42
-(1 row)
-
--- test CTE referencing an outer-level variable (to see that changed-parameter
--- signaling still works properly after fixing this bug)
-select ( with cte(foo) as ( values(f1) )
-         select (select foo from cte) )
-from int4_tbl;
-     foo     
--------------
-           0
-      123456
-     -123456
-  2147483647
- -2147483647
-(5 rows)
-
-select ( with cte(foo) as ( values(f1) )
-          values((select foo from cte)) )
-from int4_tbl;
-   column1   
--------------
-           0
-      123456
-     -123456
-  2147483647
- -2147483647
-(5 rows)
-
---
--- test for nested-recursive-WITH bug
---
-WITH RECURSIVE t(j) AS (
-    WITH RECURSIVE s(i) AS (
-        VALUES (1)
-        UNION ALL
-        SELECT i+1 FROM s WHERE i < 10
-    )
-    SELECT i FROM s
-    UNION ALL
-    SELECT j+1 FROM t WHERE j < 10
-)
-SELECT * FROM t;
- j  
-----
-  1
-  2
-  3
-  4
-  5
-  6
-  7
-  8
-  9
- 10
-  2
-  3
-  4
-  5
-  6
-  7
-  8
-  9
- 10
-  3
-  4
-  5
-  6
-  7
-  8
-  9
- 10
-  4
-  5
-  6
-  7
-  8
-  9
- 10
-  5
-  6
-  7
-  8
-  9
- 10
-  6
-  7
-  8
-  9
- 10
-  7
-  8
-  9
- 10
-  8
-  9
- 10
-  9
- 10
- 10
-(55 rows)
-
---
--- test WITH attached to intermediate-level set operation
---
-WITH outermost(x) AS (
-  SELECT 1
-  UNION (WITH innermost as (SELECT 2)
-         SELECT * FROM innermost
-         UNION SELECT 3)
-)
-SELECT * FROM outermost ORDER BY 1;
- x 
----
- 1
- 2
- 3
-(3 rows)
-
-WITH outermost(x) AS (
-  SELECT 1
-  UNION (WITH innermost as (SELECT 2)
-         SELECT * FROM outermost  -- fail
-         UNION SELECT * FROM innermost)
-)
-SELECT * FROM outermost ORDER BY 1;
-ERROR:  relation "outermost" does not exist
-LINE 4:          SELECT * FROM outermost  
-                               ^
-DETAIL:  There is a WITH item named "outermost", but it cannot be referenced from this part of the query.
-HINT:  Use WITH RECURSIVE, or re-order the WITH items to remove forward references.
-WITH RECURSIVE outermost(x) AS (
-  SELECT 1
-  UNION (WITH innermost as (SELECT 2)
-         SELECT * FROM outermost
-         UNION SELECT * FROM innermost)
-)
-SELECT * FROM outermost ORDER BY 1;
- x 
----
- 1
- 2
-(2 rows)
-
-WITH RECURSIVE outermost(x) AS (
-  WITH innermost as (SELECT 2 FROM outermost) -- fail
-    SELECT * FROM innermost
-    UNION SELECT * from outermost
-)
-SELECT * FROM outermost ORDER BY 1;
-ERROR:  recursive reference to query "outermost" must not appear within a subquery
-LINE 2:   WITH innermost as (SELECT 2 FROM outermost) 
-                                           ^
---
--- This test will fail with the old implementation of PARAM_EXEC parameter
--- assignment, because the "q1" Var passed down to A's targetlist subselect
--- looks exactly like the "A.id" Var passed down to C's subselect, causing
--- the old code to give them the same runtime PARAM_EXEC slot.  But the
--- lifespans of the two parameters overlap, thanks to B also reading A.
---
-with
-A as ( select q2 as id, (select q1) as x from int8_tbl ),
-B as ( select id, row_number() over (partition by id) as r from A ),
-C as ( select A.id, array(select B.id from B where B.id = A.id) from A )
-select * from C;
-        id         |                array                
--------------------+-------------------------------------
-               456 | {456}
-  4567890123456789 | {4567890123456789,4567890123456789}
-               123 | {123}
-  4567890123456789 | {4567890123456789,4567890123456789}
- -4567890123456789 | {-4567890123456789}
-(5 rows)
-
---
--- Test CTEs read in non-initialization orders
---
-WITH RECURSIVE
-  tab(id_key,link) AS (VALUES (1,17), (2,17), (3,17), (4,17), (6,17), (5,17)),
-  iter (id_key, row_type, link) AS (
-      SELECT 0, 'base', 17
-    UNION ALL (
-      WITH remaining(id_key, row_type, link, min) AS (
-        SELECT tab.id_key, 'true'::text, iter.link, MIN(tab.id_key) OVER ()
-        FROM tab INNER JOIN iter USING (link)
-        WHERE tab.id_key > iter.id_key
-      ),
-      first_remaining AS (
-        SELECT id_key, row_type, link
-        FROM remaining
-        WHERE id_key=min
-      ),
-      effect AS (
-        SELECT tab.id_key, 'new'::text, tab.link
-        FROM first_remaining e INNER JOIN tab ON e.id_key=tab.id_key
-        WHERE e.row_type = 'false'
-      )
-      SELECT * FROM first_remaining
-      UNION ALL SELECT * FROM effect
-    )
-  )
-SELECT * FROM iter;
- id_key | row_type | link 
---------+----------+------
-      0 | base     |   17
-      1 | true     |   17
-      2 | true     |   17
-      3 | true     |   17
-      4 | true     |   17
-      5 | true     |   17
-      6 | true     |   17
-(7 rows)
-
-WITH RECURSIVE
-  tab(id_key,link) AS (VALUES (1,17), (2,17), (3,17), (4,17), (6,17), (5,17)),
-  iter (id_key, row_type, link) AS (
-      SELECT 0, 'base', 17
-    UNION (
-      WITH remaining(id_key, row_type, link, min) AS (
-        SELECT tab.id_key, 'true'::text, iter.link, MIN(tab.id_key) OVER ()
-        FROM tab INNER JOIN iter USING (link)
-        WHERE tab.id_key > iter.id_key
-      ),
-      first_remaining AS (
-        SELECT id_key, row_type, link
-        FROM remaining
-        WHERE id_key=min
-      ),
-      effect AS (
-        SELECT tab.id_key, 'new'::text, tab.link
-        FROM first_remaining e INNER JOIN tab ON e.id_key=tab.id_key
-        WHERE e.row_type = 'false'
-      )
-      SELECT * FROM first_remaining
-      UNION ALL SELECT * FROM effect
-    )
-  )
-SELECT * FROM iter;
- id_key | row_type | link 
---------+----------+------
-      0 | base     |   17
-      1 | true     |   17
-      2 | true     |   17
-      3 | true     |   17
-      4 | true     |   17
-      5 | true     |   17
-      6 | true     |   17
-(7 rows)
-
---
--- Data-modifying statements in WITH
---
--- INSERT ... RETURNING
-WITH t AS (
-    INSERT INTO y
-    VALUES
-        (11),
-        (12),
-        (13),
-        (14),
-        (15),
-        (16),
-        (17),
-        (18),
-        (19),
-        (20)
-    RETURNING *
-)
-SELECT * FROM t;
- a  
-----
- 11
- 12
- 13
- 14
- 15
- 16
- 17
- 18
- 19
- 20
-(10 rows)
-
-SELECT * FROM y;
- a  
-----
-  1
-  2
-  3
-  4
-  5
-  6
-  7
-  8
-  9
- 10
- 11
- 12
- 13
- 14
- 15
- 16
- 17
- 18
- 19
- 20
-(20 rows)
-
--- UPDATE ... RETURNING
-WITH t AS (
-    UPDATE y
-    SET a=a+1
-    RETURNING *
-)
-SELECT * FROM t;
- a  
-----
-  2
-  3
-  4
-  5
-  6
-  7
-  8
-  9
- 10
- 11
- 12
- 13
- 14
- 15
- 16
- 17
- 18
- 19
- 20
- 21
-(20 rows)
-
-SELECT * FROM y;
- a  
-----
-  2
-  3
-  4
-  5
-  6
-  7
-  8
-  9
- 10
- 11
- 12
- 13
- 14
- 15
- 16
- 17
- 18
- 19
- 20
- 21
-(20 rows)
-
--- DELETE ... RETURNING
-WITH t AS (
-    DELETE FROM y
-    WHERE a <= 10
-    RETURNING *
-)
-SELECT * FROM t;
- a  
-----
-  2
-  3
-  4
-  5
-  6
-  7
-  8
-  9
- 10
-(9 rows)
-
-SELECT * FROM y;
- a  
-----
- 11
- 12
- 13
- 14
- 15
- 16
- 17
- 18
- 19
- 20
- 21
-(11 rows)
-
--- forward reference
-WITH RECURSIVE t AS (
-	INSERT INTO y
-		SELECT a+5 FROM t2 WHERE a > 5
-	RETURNING *
-), t2 AS (
-	UPDATE y SET a=a-11 RETURNING *
-)
-SELECT * FROM t
-UNION ALL
-SELECT * FROM t2;
- a  
-----
- 11
- 12
- 13
- 14
- 15
-  0
-  1
-  2
-  3
-  4
-  5
-  6
-  7
-  8
-  9
- 10
-(16 rows)
-
-SELECT * FROM y;
- a  
-----
-  0
-  1
-  2
-  3
-  4
-  5
-  6
- 11
-  7
- 12
-  8
- 13
-  9
- 14
- 10
- 15
-(16 rows)
-
--- unconditional DO INSTEAD rule
-CREATE RULE y_rule AS ON DELETE TO y DO INSTEAD
-  INSERT INTO y VALUES(42) RETURNING *;
-WITH t AS (
-	DELETE FROM y RETURNING *
-)
-SELECT * FROM t;
- a  
-----
- 42
-(1 row)
-
-SELECT * FROM y;
- a  
-----
-  0
-  1
-  2
-  3
-  4
-  5
-  6
- 11
-  7
- 12
-  8
- 13
-  9
- 14
- 10
- 15
- 42
-(17 rows)
-
-DROP RULE y_rule ON y;
--- check merging of outer CTE with CTE in a rule action
-CREATE TEMP TABLE bug6051 AS
-  select i from generate_series(1,3) as t(i);
-SELECT * FROM bug6051;
- i 
----
- 1
- 2
- 3
-(3 rows)
-
-WITH t1 AS ( DELETE FROM bug6051 RETURNING * )
-INSERT INTO bug6051 SELECT * FROM t1;
-SELECT * FROM bug6051;
- i 
----
- 1
- 2
- 3
-(3 rows)
-
-CREATE TEMP TABLE bug6051_2 (i int);
-CREATE RULE bug6051_ins AS ON INSERT TO bug6051 DO INSTEAD
- INSERT INTO bug6051_2
- VALUES(NEW.i);
-WITH t1 AS ( DELETE FROM bug6051 RETURNING * )
-INSERT INTO bug6051 SELECT * FROM t1;
-SELECT * FROM bug6051;
- i 
----
-(0 rows)
-
-SELECT * FROM bug6051_2;
- i 
----
- 1
- 2
- 3
-(3 rows)
-
--- check INSERT...SELECT rule actions are disallowed on commands
--- that have modifyingCTEs
-CREATE OR REPLACE RULE bug6051_ins AS ON INSERT TO bug6051 DO INSTEAD
- INSERT INTO bug6051_2
- SELECT NEW.i;
-WITH t1 AS ( DELETE FROM bug6051 RETURNING * )
-INSERT INTO bug6051 SELECT * FROM t1;
-ERROR:  INSERT...SELECT rule actions are not supported for queries having data-modifying statements in WITH
--- silly example to verify that hasModifyingCTE flag is propagated
-CREATE TEMP TABLE bug6051_3 AS
-  SELECT a FROM generate_series(11,13) AS a;
-CREATE RULE bug6051_3_ins AS ON INSERT TO bug6051_3 DO INSTEAD
-  SELECT i FROM bug6051_2;
-BEGIN; SET LOCAL force_parallel_mode = on;
-WITH t1 AS ( DELETE FROM bug6051_3 RETURNING * )
-  INSERT INTO bug6051_3 SELECT * FROM t1;
- i 
----
- 1
- 2
- 3
- 1
- 2
- 3
- 1
- 2
- 3
-(9 rows)
-
-COMMIT;
-SELECT * FROM bug6051_3;
- a 
----
-(0 rows)
-
--- a truly recursive CTE in the same list
-WITH RECURSIVE t(a) AS (
-	SELECT 0
-		UNION ALL
-	SELECT a+1 FROM t WHERE a+1 < 5
-), t2 as (
-	INSERT INTO y
-		SELECT * FROM t RETURNING *
-)
-SELECT * FROM t2 JOIN y USING (a) ORDER BY a;
- a 
----
- 0
- 1
- 2
- 3
- 4
-(5 rows)
-
-SELECT * FROM y;
- a  
-----
-  0
-  1
-  2
-  3
-  4
-  5
-  6
- 11
-  7
- 12
-  8
- 13
-  9
- 14
- 10
- 15
- 42
-  0
-  1
-  2
-  3
-  4
-(22 rows)
-
--- data-modifying WITH in a modifying statement
-WITH t AS (
-    DELETE FROM y
-    WHERE a <= 10
-    RETURNING *
-)
-INSERT INTO y SELECT -a FROM t RETURNING *;
-  a  
------
-   0
-  -1
-  -2
-  -3
-  -4
-  -5
-  -6
-  -7
-  -8
-  -9
- -10
-   0
-  -1
-  -2
-  -3
-  -4
-(16 rows)
-
-SELECT * FROM y;
-  a  
------
-  11
-  12
-  13
-  14
-  15
-  42
-   0
-  -1
-  -2
-  -3
-  -4
-  -5
-  -6
-  -7
-  -8
-  -9
- -10
-   0
-  -1
-  -2
-  -3
-  -4
-(22 rows)
-
--- check that WITH query is run to completion even if outer query isn't
-WITH t AS (
-    UPDATE y SET a = a * 100 RETURNING *
-)
-SELECT * FROM t LIMIT 10;
-  a   
-------
- 1100
- 1200
- 1300
- 1400
- 1500
- 4200
-    0
- -100
- -200
- -300
-(10 rows)
-
-SELECT * FROM y;
-   a   
--------
-  1100
-  1200
-  1300
-  1400
-  1500
-  4200
-     0
-  -100
-  -200
-  -300
-  -400
-  -500
-  -600
-  -700
-  -800
-  -900
- -1000
-     0
-  -100
-  -200
-  -300
-  -400
-(22 rows)
-
--- data-modifying WITH containing INSERT...ON CONFLICT DO UPDATE
-CREATE TABLE withz AS SELECT i AS k, (i || ' v')::text v FROM generate_series(1, 16, 3) i;
-ALTER TABLE withz ADD UNIQUE (k);
-WITH t AS (
-    INSERT INTO withz SELECT i, 'insert'
-    FROM generate_series(0, 16) i
-    ON CONFLICT (k) DO UPDATE SET v = withz.v || ', now update'
-    RETURNING *
-)
-SELECT * FROM t JOIN y ON t.k = y.a ORDER BY a, k;
- k |   v    | a 
----+--------+---
- 0 | insert | 0
- 0 | insert | 0
-(2 rows)
-
--- Test EXCLUDED.* reference within CTE
-WITH aa AS (
-    INSERT INTO withz VALUES(1, 5) ON CONFLICT (k) DO UPDATE SET v = EXCLUDED.v
-    WHERE withz.k != EXCLUDED.k
-    RETURNING *
-)
-SELECT * FROM aa;
- k | v 
----+---
-(0 rows)
-
--- New query/snapshot demonstrates side-effects of previous query.
-SELECT * FROM withz ORDER BY k;
- k  |        v         
-----+------------------
-  0 | insert
-  1 | 1 v, now update
-  2 | insert
-  3 | insert
-  4 | 4 v, now update
-  5 | insert
-  6 | insert
-  7 | 7 v, now update
-  8 | insert
-  9 | insert
- 10 | 10 v, now update
- 11 | insert
- 12 | insert
- 13 | 13 v, now update
- 14 | insert
- 15 | insert
- 16 | 16 v, now update
-(17 rows)
-
---
--- Ensure subqueries within the update clause work, even if they
--- reference outside values
---
-WITH aa AS (SELECT 1 a, 2 b)
-INSERT INTO withz VALUES(1, 'insert')
-ON CONFLICT (k) DO UPDATE SET v = (SELECT b || ' update' FROM aa WHERE a = 1 LIMIT 1);
-WITH aa AS (SELECT 1 a, 2 b)
-INSERT INTO withz VALUES(1, 'insert')
-ON CONFLICT (k) DO UPDATE SET v = ' update' WHERE withz.k = (SELECT a FROM aa);
-WITH aa AS (SELECT 1 a, 2 b)
-INSERT INTO withz VALUES(1, 'insert')
-ON CONFLICT (k) DO UPDATE SET v = (SELECT b || ' update' FROM aa WHERE a = 1 LIMIT 1);
-WITH aa AS (SELECT 'a' a, 'b' b UNION ALL SELECT 'a' a, 'b' b)
-INSERT INTO withz VALUES(1, 'insert')
-ON CONFLICT (k) DO UPDATE SET v = (SELECT b || ' update' FROM aa WHERE a = 'a' LIMIT 1);
-WITH aa AS (SELECT 1 a, 2 b)
-INSERT INTO withz VALUES(1, (SELECT b || ' insert' FROM aa WHERE a = 1 ))
-ON CONFLICT (k) DO UPDATE SET v = (SELECT b || ' update' FROM aa WHERE a = 1 LIMIT 1);
--- Update a row more than once, in different parts of a wCTE. That is
--- an allowed, presumably very rare, edge case, but since it was
--- broken in the past, having a test seems worthwhile.
-WITH simpletup AS (
-  SELECT 2 k, 'Green' v),
-upsert_cte AS (
-  INSERT INTO withz VALUES(2, 'Blue') ON CONFLICT (k) DO
-    UPDATE SET (k, v) = (SELECT k, v FROM simpletup WHERE simpletup.k = withz.k)
-    RETURNING k, v)
-INSERT INTO withz VALUES(2, 'Red') ON CONFLICT (k) DO
-UPDATE SET (k, v) = (SELECT k, v FROM upsert_cte WHERE upsert_cte.k = withz.k)
-RETURNING k, v;
- k | v 
----+---
-(0 rows)
-
-DROP TABLE withz;
--- check that run to completion happens in proper ordering
-TRUNCATE TABLE y;
-INSERT INTO y SELECT generate_series(1, 3);
-CREATE TEMPORARY TABLE yy (a INTEGER);
-WITH RECURSIVE t1 AS (
-  INSERT INTO y SELECT * FROM y RETURNING *
-), t2 AS (
-  INSERT INTO yy SELECT * FROM t1 RETURNING *
-)
-SELECT 1;
- ?column? 
-----------
-        1
-(1 row)
-
-SELECT * FROM y;
- a 
----
- 1
- 2
- 3
- 1
- 2
- 3
-(6 rows)
-
-SELECT * FROM yy;
- a 
----
- 1
- 2
- 3
-(3 rows)
-
-WITH RECURSIVE t1 AS (
-  INSERT INTO yy SELECT * FROM t2 RETURNING *
-), t2 AS (
-  INSERT INTO y SELECT * FROM y RETURNING *
-)
-SELECT 1;
- ?column? 
-----------
-        1
-(1 row)
-
-SELECT * FROM y;
- a 
----
- 1
- 2
- 3
- 1
- 2
- 3
- 1
- 2
- 3
- 1
- 2
- 3
-(12 rows)
-
-SELECT * FROM yy;
- a 
----
- 1
- 2
- 3
- 1
- 2
- 3
- 1
- 2
- 3
-(9 rows)
-
--- triggers
-TRUNCATE TABLE y;
-INSERT INTO y SELECT generate_series(1, 10);
-CREATE FUNCTION y_trigger() RETURNS trigger AS $$
-begin
-  raise notice 'y_trigger: a = %', new.a;
-  return new;
-end;
-$$ LANGUAGE plpgsql;
-CREATE TRIGGER y_trig BEFORE INSERT ON y FOR EACH ROW
-    EXECUTE PROCEDURE y_trigger();
-WITH t AS (
-    INSERT INTO y
-    VALUES
-        (21),
-        (22),
-        (23)
-    RETURNING *
-)
-SELECT * FROM t;
-NOTICE:  y_trigger: a = 21
-NOTICE:  y_trigger: a = 22
-NOTICE:  y_trigger: a = 23
- a  
-----
- 21
- 22
- 23
-(3 rows)
-
-SELECT * FROM y;
- a  
-----
-  1
-  2
-  3
-  4
-  5
-  6
-  7
-  8
-  9
- 10
- 21
- 22
- 23
-(13 rows)
-
-DROP TRIGGER y_trig ON y;
-CREATE TRIGGER y_trig AFTER INSERT ON y FOR EACH ROW
-    EXECUTE PROCEDURE y_trigger();
-WITH t AS (
-    INSERT INTO y
-    VALUES
-        (31),
-        (32),
-        (33)
-    RETURNING *
-)
-SELECT * FROM t LIMIT 1;
-NOTICE:  y_trigger: a = 31
-NOTICE:  y_trigger: a = 32
-NOTICE:  y_trigger: a = 33
- a  
-----
- 31
-(1 row)
-
-SELECT * FROM y;
- a  
-----
-  1
-  2
-  3
-  4
-  5
-  6
-  7
-  8
-  9
- 10
- 21
- 22
- 23
- 31
- 32
- 33
-(16 rows)
-
-DROP TRIGGER y_trig ON y;
-CREATE OR REPLACE FUNCTION y_trigger() RETURNS trigger AS $$
-begin
-  raise notice 'y_trigger';
-  return null;
-end;
-$$ LANGUAGE plpgsql;
-CREATE TRIGGER y_trig AFTER INSERT ON y FOR EACH STATEMENT
-    EXECUTE PROCEDURE y_trigger();
-WITH t AS (
-    INSERT INTO y
-    VALUES
-        (41),
-        (42),
-        (43)
-    RETURNING *
-)
-SELECT * FROM t;
-NOTICE:  y_trigger
- a  
-----
- 41
- 42
- 43
-(3 rows)
-
-SELECT * FROM y;
- a  
-----
-  1
-  2
-  3
-  4
-  5
-  6
-  7
-  8
-  9
- 10
- 21
- 22
- 23
- 31
- 32
- 33
- 41
- 42
- 43
-(19 rows)
-
-DROP TRIGGER y_trig ON y;
-DROP FUNCTION y_trigger();
--- WITH attached to inherited UPDATE or DELETE
-CREATE TEMP TABLE parent ( id int, val text );
-CREATE TEMP TABLE child1 ( ) INHERITS ( parent );
-CREATE TEMP TABLE child2 ( ) INHERITS ( parent );
-INSERT INTO parent VALUES ( 1, 'p1' );
-INSERT INTO child1 VALUES ( 11, 'c11' ),( 12, 'c12' );
-INSERT INTO child2 VALUES ( 23, 'c21' ),( 24, 'c22' );
-WITH rcte AS ( SELECT sum(id) AS totalid FROM parent )
-UPDATE parent SET id = id + totalid FROM rcte;
-SELECT * FROM parent;
- id | val 
-----+-----
- 72 | p1
- 82 | c11
- 83 | c12
- 94 | c21
- 95 | c22
-(5 rows)
-
-WITH wcte AS ( INSERT INTO child1 VALUES ( 42, 'new' ) RETURNING id AS newid )
-UPDATE parent SET id = id + newid FROM wcte;
-SELECT * FROM parent;
- id  | val 
------+-----
- 114 | p1
-  42 | new
- 124 | c11
- 125 | c12
- 136 | c21
- 137 | c22
-(6 rows)
-
-WITH rcte AS ( SELECT max(id) AS maxid FROM parent )
-DELETE FROM parent USING rcte WHERE id = maxid;
-SELECT * FROM parent;
- id  | val 
------+-----
- 114 | p1
-  42 | new
- 124 | c11
- 125 | c12
- 136 | c21
-(5 rows)
-
-WITH wcte AS ( INSERT INTO child2 VALUES ( 42, 'new2' ) RETURNING id AS newid )
-DELETE FROM parent USING wcte WHERE id = newid;
-SELECT * FROM parent;
- id  | val  
------+------
- 114 | p1
- 124 | c11
- 125 | c12
- 136 | c21
-  42 | new2
-(5 rows)
-
--- check EXPLAIN VERBOSE for a wCTE with RETURNING
-EXPLAIN (VERBOSE, COSTS OFF)
-WITH wcte AS ( INSERT INTO int8_tbl VALUES ( 42, 47 ) RETURNING q2 )
-DELETE FROM a USING wcte WHERE aa = q2;
-                         QUERY PLAN                         
-------------------------------------------------------------
- Delete on public.a
-   Delete on public.a a_1
-   Delete on public.b a_2
-   Delete on public.c a_3
-   Delete on public.d a_4
-   CTE wcte
-     ->  Insert on public.int8_tbl
-           Output: int8_tbl.q2
-           ->  Result
-                 Output: '42'::bigint, '47'::bigint
-   ->  Hash Join
-         Output: wcte.*, a.tableoid, a.ctid
-         Hash Cond: (a.aa = wcte.q2)
-         ->  Append
-               ->  Seq Scan on public.a a_1
-                     Output: a_1.aa, a_1.tableoid, a_1.ctid
-               ->  Seq Scan on public.b a_2
-                     Output: a_2.aa, a_2.tableoid, a_2.ctid
-               ->  Seq Scan on public.c a_3
-                     Output: a_3.aa, a_3.tableoid, a_3.ctid
-               ->  Seq Scan on public.d a_4
-                     Output: a_4.aa, a_4.tableoid, a_4.ctid
-         ->  Hash
-               Output: wcte.*, wcte.q2
-               ->  CTE Scan on wcte
-                     Output: wcte.*, wcte.q2
-(26 rows)
-
--- error cases
--- data-modifying WITH tries to use its own output
-WITH RECURSIVE t AS (
-	INSERT INTO y
-		SELECT * FROM t
-)
-VALUES(FALSE);
-ERROR:  recursive query "t" must not contain data-modifying statements
-LINE 1: WITH RECURSIVE t AS (
-                       ^
--- no RETURNING in a referenced data-modifying WITH
-WITH t AS (
-	INSERT INTO y VALUES(0)
-)
-SELECT * FROM t;
-ERROR:  WITH query "t" does not have a RETURNING clause
-LINE 4: SELECT * FROM t;
-                      ^
--- data-modifying WITH allowed only at the top level
-SELECT * FROM (
-	WITH t AS (UPDATE y SET a=a+1 RETURNING *)
-	SELECT * FROM t
-) ss;
-ERROR:  WITH clause containing a data-modifying statement must be at the top level
-LINE 2:  WITH t AS (UPDATE y SET a=a+1 RETURNING *)
-              ^
--- most variants of rules aren't allowed
-CREATE RULE y_rule AS ON INSERT TO y WHERE a=0 DO INSTEAD DELETE FROM y;
-WITH t AS (
-	INSERT INTO y VALUES(0)
-)
-VALUES(FALSE);
-ERROR:  conditional DO INSTEAD rules are not supported for data-modifying statements in WITH
-CREATE OR REPLACE RULE y_rule AS ON INSERT TO y DO INSTEAD NOTHING;
-WITH t AS (
-	INSERT INTO y VALUES(0)
-)
-VALUES(FALSE);
-ERROR:  DO INSTEAD NOTHING rules are not supported for data-modifying statements in WITH
-CREATE OR REPLACE RULE y_rule AS ON INSERT TO y DO INSTEAD NOTIFY foo;
-WITH t AS (
-	INSERT INTO y VALUES(0)
-)
-VALUES(FALSE);
-ERROR:  DO INSTEAD NOTIFY rules are not supported for data-modifying statements in WITH
-CREATE OR REPLACE RULE y_rule AS ON INSERT TO y DO ALSO NOTIFY foo;
-WITH t AS (
-	INSERT INTO y VALUES(0)
-)
-VALUES(FALSE);
-ERROR:  DO ALSO rules are not supported for data-modifying statements in WITH
-CREATE OR REPLACE RULE y_rule AS ON INSERT TO y
-  DO INSTEAD (NOTIFY foo; NOTIFY bar);
-WITH t AS (
-	INSERT INTO y VALUES(0)
-)
-VALUES(FALSE);
-ERROR:  multi-statement DO INSTEAD rules are not supported for data-modifying statements in WITH
-DROP RULE y_rule ON y;
--- check that parser lookahead for WITH doesn't cause any odd behavior
-create table foo (with baz);  -- fail, WITH is a reserved word
-ERROR:  syntax error at or near "with"
-LINE 1: create table foo (with baz);
-                          ^
-create table foo (with ordinality);  -- fail, WITH is a reserved word
-ERROR:  syntax error at or near "with"
-LINE 1: create table foo (with ordinality);
-                          ^
-with ordinality as (select 1 as x) select * from ordinality;
- x 
----
- 1
-(1 row)
-
--- check sane response to attempt to modify CTE relation
-WITH test AS (SELECT 42) INSERT INTO test VALUES (1);
-ERROR:  relation "test" does not exist
-LINE 1: WITH test AS (SELECT 42) INSERT INTO test VALUES (1);
-                                             ^
--- check response to attempt to modify table with same name as a CTE (perhaps
--- surprisingly it works, because CTEs don't hide tables from data-modifying
--- statements)
-create temp table test (i int);
-with test as (select 42) insert into test select * from test;
-select * from test;
- i  
-----
- 42
-(1 row)
-
-drop table test;
diff -U3 /Users/kenaniah/workspace/postgres/src/test/regress/expected/partition_prune.out /Users/kenaniah/workspace/postgres/src/test/regress/results/partition_prune.out
--- /Users/kenaniah/workspace/postgres/src/test/regress/expected/partition_prune.out	2021-10-03 17:41:49.000000000 -0700
+++ /Users/kenaniah/workspace/postgres/src/test/regress/results/partition_prune.out	2021-10-03 20:08:25.000000000 -0700
@@ -1540,210 +1540,125 @@
 --
 create table hp (a int, b text, c int)
   partition by hash (a part_test_int4_ops, b part_test_text_ops);
+ERROR:  operator class "part_test_int4_ops" does not exist for access method "hash"
 create table hp0 partition of hp for values with (modulus 4, remainder 0);
+ERROR:  relation "hp" does not exist
 create table hp3 partition of hp for values with (modulus 4, remainder 3);
+ERROR:  relation "hp" does not exist
 create table hp1 partition of hp for values with (modulus 4, remainder 1);
+ERROR:  relation "hp" does not exist
 create table hp2 partition of hp for values with (modulus 4, remainder 2);
+ERROR:  relation "hp" does not exist
 insert into hp values (null, null, 0);
+ERROR:  relation "hp" does not exist
+LINE 1: insert into hp values (null, null, 0);
+                    ^
 insert into hp values (1, null, 1);
+ERROR:  relation "hp" does not exist
+LINE 1: insert into hp values (1, null, 1);
+                    ^
 insert into hp values (1, 'xxx', 2);
+ERROR:  relation "hp" does not exist
+LINE 1: insert into hp values (1, 'xxx', 2);
+                    ^
 insert into hp values (null, 'xxx', 3);
+ERROR:  relation "hp" does not exist
+LINE 1: insert into hp values (null, 'xxx', 3);
+                    ^
 insert into hp values (2, 'xxx', 4);
+ERROR:  relation "hp" does not exist
+LINE 1: insert into hp values (2, 'xxx', 4);
+                    ^
 insert into hp values (1, 'abcde', 5);
+ERROR:  relation "hp" does not exist
+LINE 1: insert into hp values (1, 'abcde', 5);
+                    ^
 select tableoid::regclass, * from hp order by c;
- tableoid | a |   b   | c 
-----------+---+-------+---
- hp0      |   |       | 0
- hp1      | 1 |       | 1
- hp0      | 1 | xxx   | 2
- hp2      |   | xxx   | 3
- hp3      | 2 | xxx   | 4
- hp2      | 1 | abcde | 5
-(6 rows)
-
+ERROR:  relation "hp" does not exist
+LINE 1: select tableoid::regclass, * from hp order by c;
+                                          ^
 -- partial keys won't prune, nor would non-equality conditions
 explain (costs off) select * from hp where a = 1;
-         QUERY PLAN         
-----------------------------
- Append
-   ->  Seq Scan on hp0 hp_1
-         Filter: (a = 1)
-   ->  Seq Scan on hp1 hp_2
-         Filter: (a = 1)
-   ->  Seq Scan on hp2 hp_3
-         Filter: (a = 1)
-   ->  Seq Scan on hp3 hp_4
-         Filter: (a = 1)
-(9 rows)
-
+ERROR:  relation "hp" does not exist
+LINE 1: explain (costs off) select * from hp where a = 1;
+                                          ^
 explain (costs off) select * from hp where b = 'xxx';
-            QUERY PLAN             
------------------------------------
- Append
-   ->  Seq Scan on hp0 hp_1
-         Filter: (b = 'xxx'::text)
-   ->  Seq Scan on hp1 hp_2
-         Filter: (b = 'xxx'::text)
-   ->  Seq Scan on hp2 hp_3
-         Filter: (b = 'xxx'::text)
-   ->  Seq Scan on hp3 hp_4
-         Filter: (b = 'xxx'::text)
-(9 rows)
-
+ERROR:  relation "hp" does not exist
+LINE 1: explain (costs off) select * from hp where b = 'xxx';
+                                          ^
 explain (costs off) select * from hp where a is null;
-         QUERY PLAN          
------------------------------
- Append
-   ->  Seq Scan on hp0 hp_1
-         Filter: (a IS NULL)
-   ->  Seq Scan on hp1 hp_2
-         Filter: (a IS NULL)
-   ->  Seq Scan on hp2 hp_3
-         Filter: (a IS NULL)
-   ->  Seq Scan on hp3 hp_4
-         Filter: (a IS NULL)
-(9 rows)
-
+ERROR:  relation "hp" does not exist
+LINE 1: explain (costs off) select * from hp where a is null;
+                                          ^
 explain (costs off) select * from hp where b is null;
-         QUERY PLAN          
------------------------------
- Append
-   ->  Seq Scan on hp0 hp_1
-         Filter: (b IS NULL)
-   ->  Seq Scan on hp1 hp_2
-         Filter: (b IS NULL)
-   ->  Seq Scan on hp2 hp_3
-         Filter: (b IS NULL)
-   ->  Seq Scan on hp3 hp_4
-         Filter: (b IS NULL)
-(9 rows)
-
+ERROR:  relation "hp" does not exist
+LINE 1: explain (costs off) select * from hp where b is null;
+                                          ^
 explain (costs off) select * from hp where a < 1 and b = 'xxx';
-                   QUERY PLAN                    
--------------------------------------------------
- Append
-   ->  Seq Scan on hp0 hp_1
-         Filter: ((a < 1) AND (b = 'xxx'::text))
-   ->  Seq Scan on hp1 hp_2
-         Filter: ((a < 1) AND (b = 'xxx'::text))
-   ->  Seq Scan on hp2 hp_3
-         Filter: ((a < 1) AND (b = 'xxx'::text))
-   ->  Seq Scan on hp3 hp_4
-         Filter: ((a < 1) AND (b = 'xxx'::text))
-(9 rows)
-
+ERROR:  relation "hp" does not exist
+LINE 1: explain (costs off) select * from hp where a < 1 and b = 'xx...
+                                          ^
 explain (costs off) select * from hp where a <> 1 and b = 'yyy';
-                    QUERY PLAN                    
---------------------------------------------------
- Append
-   ->  Seq Scan on hp0 hp_1
-         Filter: ((a <> 1) AND (b = 'yyy'::text))
-   ->  Seq Scan on hp1 hp_2
-         Filter: ((a <> 1) AND (b = 'yyy'::text))
-   ->  Seq Scan on hp2 hp_3
-         Filter: ((a <> 1) AND (b = 'yyy'::text))
-   ->  Seq Scan on hp3 hp_4
-         Filter: ((a <> 1) AND (b = 'yyy'::text))
-(9 rows)
-
+ERROR:  relation "hp" does not exist
+LINE 1: explain (costs off) select * from hp where a <> 1 and b = 'y...
+                                          ^
 explain (costs off) select * from hp where a <> 1 and b <> 'xxx';
-                    QUERY PLAN                     
----------------------------------------------------
- Append
-   ->  Seq Scan on hp0 hp_1
-         Filter: ((a <> 1) AND (b <> 'xxx'::text))
-   ->  Seq Scan on hp1 hp_2
-         Filter: ((a <> 1) AND (b <> 'xxx'::text))
-   ->  Seq Scan on hp2 hp_3
-         Filter: ((a <> 1) AND (b <> 'xxx'::text))
-   ->  Seq Scan on hp3 hp_4
-         Filter: ((a <> 1) AND (b <> 'xxx'::text))
-(9 rows)
-
+ERROR:  relation "hp" does not exist
+LINE 1: explain (costs off) select * from hp where a <> 1 and b <> '...
+                                          ^
 -- pruning should work if either a value or a IS NULL clause is provided for
 -- each of the keys
 explain (costs off) select * from hp where a is null and b is null;
-               QUERY PLAN                
------------------------------------------
- Seq Scan on hp0 hp
-   Filter: ((a IS NULL) AND (b IS NULL))
-(2 rows)
-
+ERROR:  relation "hp" does not exist
+LINE 1: explain (costs off) select * from hp where a is null and b i...
+                                          ^
 explain (costs off) select * from hp where a = 1 and b is null;
-             QUERY PLAN              
--------------------------------------
- Seq Scan on hp1 hp
-   Filter: ((b IS NULL) AND (a = 1))
-(2 rows)
-
+ERROR:  relation "hp" does not exist
+LINE 1: explain (costs off) select * from hp where a = 1 and b is nu...
+                                          ^
 explain (costs off) select * from hp where a = 1 and b = 'xxx';
-                QUERY PLAN                 
--------------------------------------------
- Seq Scan on hp0 hp
-   Filter: ((a = 1) AND (b = 'xxx'::text))
-(2 rows)
-
+ERROR:  relation "hp" does not exist
+LINE 1: explain (costs off) select * from hp where a = 1 and b = 'xx...
+                                          ^
 explain (costs off) select * from hp where a is null and b = 'xxx';
-                  QUERY PLAN                   
------------------------------------------------
- Seq Scan on hp2 hp
-   Filter: ((a IS NULL) AND (b = 'xxx'::text))
-(2 rows)
-
+ERROR:  relation "hp" does not exist
+LINE 1: explain (costs off) select * from hp where a is null and b =...
+                                          ^
 explain (costs off) select * from hp where a = 2 and b = 'xxx';
-                QUERY PLAN                 
--------------------------------------------
- Seq Scan on hp3 hp
-   Filter: ((a = 2) AND (b = 'xxx'::text))
-(2 rows)
-
+ERROR:  relation "hp" does not exist
+LINE 1: explain (costs off) select * from hp where a = 2 and b = 'xx...
+                                          ^
 explain (costs off) select * from hp where a = 1 and b = 'abcde';
-                 QUERY PLAN                  
----------------------------------------------
- Seq Scan on hp2 hp
-   Filter: ((a = 1) AND (b = 'abcde'::text))
-(2 rows)
-
+ERROR:  relation "hp" does not exist
+LINE 1: explain (costs off) select * from hp where a = 1 and b = 'ab...
+                                          ^
 explain (costs off) select * from hp where (a = 1 and b = 'abcde') or (a = 2 and b = 'xxx') or (a is null and b is null);
-                                                       QUERY PLAN                                                        
--------------------------------------------------------------------------------------------------------------------------
- Append
-   ->  Seq Scan on hp0 hp_1
-         Filter: (((a = 1) AND (b = 'abcde'::text)) OR ((a = 2) AND (b = 'xxx'::text)) OR ((a IS NULL) AND (b IS NULL)))
-   ->  Seq Scan on hp2 hp_2
-         Filter: (((a = 1) AND (b = 'abcde'::text)) OR ((a = 2) AND (b = 'xxx'::text)) OR ((a IS NULL) AND (b IS NULL)))
-   ->  Seq Scan on hp3 hp_3
-         Filter: (((a = 1) AND (b = 'abcde'::text)) OR ((a = 2) AND (b = 'xxx'::text)) OR ((a IS NULL) AND (b IS NULL)))
-(7 rows)
-
+ERROR:  relation "hp" does not exist
+LINE 1: explain (costs off) select * from hp where (a = 1 and b = 'a...
+                                          ^
 -- test pruning when not all the partitions exist
 drop table hp1;
+ERROR:  table "hp1" does not exist
 drop table hp3;
+ERROR:  table "hp3" does not exist
 explain (costs off) select * from hp where a = 1 and b = 'abcde';
-                 QUERY PLAN                  
----------------------------------------------
- Seq Scan on hp2 hp
-   Filter: ((a = 1) AND (b = 'abcde'::text))
-(2 rows)
-
+ERROR:  relation "hp" does not exist
+LINE 1: explain (costs off) select * from hp where a = 1 and b = 'ab...
+                                          ^
 explain (costs off) select * from hp where a = 1 and b = 'abcde' and
   (c = 2 or c = 3);
-                              QUERY PLAN                              
-----------------------------------------------------------------------
- Seq Scan on hp2 hp
-   Filter: ((a = 1) AND (b = 'abcde'::text) AND ((c = 2) OR (c = 3)))
-(2 rows)
-
+ERROR:  relation "hp" does not exist
+LINE 1: explain (costs off) select * from hp where a = 1 and b = 'ab...
+                                          ^
 drop table hp2;
+ERROR:  table "hp2" does not exist
 explain (costs off) select * from hp where a = 1 and b = 'abcde' and
   (c = 2 or c = 3);
-        QUERY PLAN        
---------------------------
- Result
-   One-Time Filter: false
-(2 rows)
-
+ERROR:  relation "hp" does not exist
+LINE 1: explain (costs off) select * from hp where a = 1 and b = 'ab...
+                                          ^
 drop table hp;
+ERROR:  table "hp" does not exist
 --
 -- Test runtime partition pruning
 --
@@ -2465,48 +2380,12 @@
 insert into ab values (1,2);
 explain (analyze, costs off, summary off, timing off)
 update ab_a1 set b = 3 from ab where ab.a = 1 and ab.a = ab_a1.a;
-                                        QUERY PLAN                                         
--------------------------------------------------------------------------------------------
- Update on ab_a1 (actual rows=0 loops=1)
-   Update on ab_a1_b1 ab_a1_1
-   Update on ab_a1_b2 ab_a1_2
-   Update on ab_a1_b3 ab_a1_3
-   ->  Nested Loop (actual rows=1 loops=1)
-         ->  Append (actual rows=1 loops=1)
-               ->  Bitmap Heap Scan on ab_a1_b1 ab_a1_1 (actual rows=0 loops=1)
-                     Recheck Cond: (a = 1)
-                     ->  Bitmap Index Scan on ab_a1_b1_a_idx (actual rows=0 loops=1)
-                           Index Cond: (a = 1)
-               ->  Bitmap Heap Scan on ab_a1_b2 ab_a1_2 (actual rows=1 loops=1)
-                     Recheck Cond: (a = 1)
-                     Heap Blocks: exact=1
-                     ->  Bitmap Index Scan on ab_a1_b2_a_idx (actual rows=1 loops=1)
-                           Index Cond: (a = 1)
-               ->  Bitmap Heap Scan on ab_a1_b3 ab_a1_3 (actual rows=0 loops=1)
-                     Recheck Cond: (a = 1)
-                     ->  Bitmap Index Scan on ab_a1_b3_a_idx (actual rows=1 loops=1)
-                           Index Cond: (a = 1)
-         ->  Materialize (actual rows=1 loops=1)
-               ->  Append (actual rows=1 loops=1)
-                     ->  Bitmap Heap Scan on ab_a1_b1 ab_1 (actual rows=0 loops=1)
-                           Recheck Cond: (a = 1)
-                           ->  Bitmap Index Scan on ab_a1_b1_a_idx (actual rows=0 loops=1)
-                                 Index Cond: (a = 1)
-                     ->  Bitmap Heap Scan on ab_a1_b2 ab_2 (actual rows=1 loops=1)
-                           Recheck Cond: (a = 1)
-                           Heap Blocks: exact=1
-                           ->  Bitmap Index Scan on ab_a1_b2_a_idx (actual rows=1 loops=1)
-                                 Index Cond: (a = 1)
-                     ->  Bitmap Heap Scan on ab_a1_b3 ab_3 (actual rows=0 loops=1)
-                           Recheck Cond: (a = 1)
-                           ->  Bitmap Index Scan on ab_a1_b3_a_idx (actual rows=1 loops=1)
-                                 Index Cond: (a = 1)
-(34 rows)
-
+ERROR:  cannot update table "ab_a1_b1" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
 table ab;
  a | b 
 ---+---
- 1 | 3
+ 1 | 2
 (1 row)
 
 -- Test UPDATE where source relation has run-time pruning enabled
@@ -2514,34 +2393,13 @@
 insert into ab values (1, 1), (1, 2), (1, 3), (2, 1);
 explain (analyze, costs off, summary off, timing off)
 update ab_a1 set b = 3 from ab_a2 where ab_a2.b = (select 1);
-                                  QUERY PLAN                                  
-------------------------------------------------------------------------------
- Update on ab_a1 (actual rows=0 loops=1)
-   Update on ab_a1_b1 ab_a1_1
-   Update on ab_a1_b2 ab_a1_2
-   Update on ab_a1_b3 ab_a1_3
-   InitPlan 1 (returns $0)
-     ->  Result (actual rows=1 loops=1)
-   ->  Nested Loop (actual rows=3 loops=1)
-         ->  Append (actual rows=3 loops=1)
-               ->  Seq Scan on ab_a1_b1 ab_a1_1 (actual rows=1 loops=1)
-               ->  Seq Scan on ab_a1_b2 ab_a1_2 (actual rows=1 loops=1)
-               ->  Seq Scan on ab_a1_b3 ab_a1_3 (actual rows=1 loops=1)
-         ->  Materialize (actual rows=1 loops=3)
-               ->  Append (actual rows=1 loops=1)
-                     ->  Seq Scan on ab_a2_b1 ab_a2_1 (actual rows=1 loops=1)
-                           Filter: (b = $0)
-                     ->  Seq Scan on ab_a2_b2 ab_a2_2 (never executed)
-                           Filter: (b = $0)
-                     ->  Seq Scan on ab_a2_b3 ab_a2_3 (never executed)
-                           Filter: (b = $0)
-(19 rows)
-
+ERROR:  cannot update table "ab_a1_b1" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
 select tableoid::regclass, * from ab;
  tableoid | a | b 
 ----------+---+---
- ab_a1_b3 | 1 | 3
- ab_a1_b3 | 1 | 3
+ ab_a1_b1 | 1 | 1
+ ab_a1_b2 | 1 | 2
  ab_a1_b3 | 1 | 3
  ab_a2_b1 | 2 | 1
 (4 rows)
@@ -3213,14 +3071,8 @@
 (5 rows)
 
 explain (costs off) update pp_arrpart set a = a where a = '{1}';
-                 QUERY PLAN                 
---------------------------------------------
- Update on pp_arrpart
-   Update on pp_arrpart1 pp_arrpart_1
-   ->  Seq Scan on pp_arrpart1 pp_arrpart_1
-         Filter: (a = '{1}'::integer[])
-(4 rows)
-
+ERROR:  cannot update table "pp_arrpart1" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
 explain (costs off) delete from pp_arrpart where a = '{1}';
                  QUERY PLAN                 
 --------------------------------------------
@@ -3344,14 +3196,8 @@
 (2 rows)
 
 explain (costs off) update pp_lp set value = 10 where a = 1;
-            QUERY PLAN            
-----------------------------------
- Update on pp_lp
-   Update on pp_lp1 pp_lp_1
-   ->  Seq Scan on pp_lp1 pp_lp_1
-         Filter: (a = 1)
-(4 rows)
-
+ERROR:  cannot update table "pp_lp1" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
 explain (costs off) delete from pp_lp where a = 1;
             QUERY PLAN            
 ----------------------------------
@@ -3374,18 +3220,8 @@
 (5 rows)
 
 explain (costs off) update pp_lp set value = 10 where a = 1;
-               QUERY PLAN               
-----------------------------------------
- Update on pp_lp
-   Update on pp_lp1 pp_lp_1
-   Update on pp_lp2 pp_lp_2
-   ->  Append
-         ->  Seq Scan on pp_lp1 pp_lp_1
-               Filter: (a = 1)
-         ->  Seq Scan on pp_lp2 pp_lp_2
-               Filter: (a = 1)
-(8 rows)
-
+ERROR:  cannot update table "pp_lp1" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
 explain (costs off) delete from pp_lp where a = 1;
                QUERY PLAN               
 ----------------------------------------
@@ -3411,18 +3247,8 @@
 (5 rows)
 
 explain (costs off) update pp_lp set value = 10 where a = 1;
-               QUERY PLAN               
-----------------------------------------
- Update on pp_lp
-   Update on pp_lp1 pp_lp_1
-   Update on pp_lp2 pp_lp_2
-   ->  Append
-         ->  Seq Scan on pp_lp1 pp_lp_1
-               Filter: (a = 1)
-         ->  Seq Scan on pp_lp2 pp_lp_2
-               Filter: (a = 1)
-(8 rows)
-
+ERROR:  cannot update table "pp_lp1" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
 explain (costs off) delete from pp_lp where a = 1;
                QUERY PLAN               
 ----------------------------------------
@@ -3458,19 +3284,8 @@
 (5 rows)
 
 explain (costs off) update inh_lp set value = 10 where a = 1;
-                   QUERY PLAN                   
-------------------------------------------------
- Update on inh_lp
-   Update on inh_lp inh_lp_1
-   Update on inh_lp1 inh_lp_2
-   ->  Result
-         ->  Append
-               ->  Seq Scan on inh_lp inh_lp_1
-                     Filter: (a = 1)
-               ->  Seq Scan on inh_lp1 inh_lp_2
-                     Filter: (a = 1)
-(9 rows)
-
+ERROR:  cannot update table "inh_lp" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
 explain (costs off) delete from inh_lp where a = 1;
                 QUERY PLAN                
 ------------------------------------------
@@ -3487,13 +3302,8 @@
 -- Ensure we don't exclude normal relations when we only expect to exclude
 -- inheritance children
 explain (costs off) update inh_lp1 set value = 10 where a = 2;
-        QUERY PLAN         
----------------------------
- Update on inh_lp1
-   ->  Seq Scan on inh_lp1
-         Filter: (a = 2)
-(3 rows)
-
+ERROR:  cannot update table "inh_lp1" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
 drop table inh_lp cascade;
 NOTICE:  drop cascades to 2 other objects
 DETAIL:  drop cascades to table inh_lp1
@@ -3633,13 +3443,8 @@
 (2 rows)
 
 explain (costs off) update listp1 set a = 1 where a = 2;
-        QUERY PLAN        
---------------------------
- Update on listp1
-   ->  Seq Scan on listp1
-         Filter: (a = 2)
-(3 rows)
-
+ERROR:  cannot update table "listp1" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
 -- constraint exclusion enabled
 set constraint_exclusion to 'on';
 explain (costs off) select * from listp1 where a = 2;
@@ -3650,13 +3455,8 @@
 (2 rows)
 
 explain (costs off) update listp1 set a = 1 where a = 2;
-           QUERY PLAN           
---------------------------------
- Update on listp1
-   ->  Result
-         One-Time Filter: false
-(3 rows)
-
+ERROR:  cannot update table "listp1" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
 reset constraint_exclusion;
 reset enable_partition_pruning;
 drop table listp;
@@ -3812,20 +3612,21 @@
 (2 rows)
 
 create table hp_prefix_test (a int, b int, c int, d int) partition by hash (a part_test_int4_ops, b part_test_int4_ops, c part_test_int4_ops, d part_test_int4_ops);
+ERROR:  operator class "part_test_int4_ops" does not exist for access method "hash"
 create table hp_prefix_test_p1 partition of hp_prefix_test for values with (modulus 2, remainder 0);
+ERROR:  relation "hp_prefix_test" does not exist
 create table hp_prefix_test_p2 partition of hp_prefix_test for values with (modulus 2, remainder 1);
+ERROR:  relation "hp_prefix_test" does not exist
 -- Test that get_steps_using_prefix() handles non-NULL step_nullkeys
 explain (costs off) select * from hp_prefix_test where a = 1 and b is null and c = 1 and d = 1;
-                         QUERY PLAN                          
--------------------------------------------------------------
- Seq Scan on hp_prefix_test_p1 hp_prefix_test
-   Filter: ((b IS NULL) AND (a = 1) AND (c = 1) AND (d = 1))
-(2 rows)
-
+ERROR:  relation "hp_prefix_test" does not exist
+LINE 1: explain (costs off) select * from hp_prefix_test where a = 1...
+                                          ^
 drop table rp_prefix_test1;
 drop table rp_prefix_test2;
 drop table rp_prefix_test3;
 drop table hp_prefix_test;
+ERROR:  table "hp_prefix_test" does not exist
 --
 -- Check that gen_partprune_steps() detects self-contradiction from clauses
 -- regardless of the order of the clauses (Here we use a custom operator to
@@ -3843,23 +3644,23 @@
 using hash as
 operator 1 ===,
 function 2 part_hashint4_noop(int4, int8);
+ERROR:  function part_hashint4_noop(integer, bigint) does not exist
 create table hp_contradict_test (a int, b int) partition by hash (a part_test_int4_ops2, b part_test_int4_ops2);
+ERROR:  operator class "part_test_int4_ops2" does not exist for access method "hash"
 create table hp_contradict_test_p1 partition of hp_contradict_test for values with (modulus 2, remainder 0);
+ERROR:  relation "hp_contradict_test" does not exist
 create table hp_contradict_test_p2 partition of hp_contradict_test for values with (modulus 2, remainder 1);
+ERROR:  relation "hp_contradict_test" does not exist
 explain (costs off) select * from hp_contradict_test where a is null and a === 1 and b === 1;
-        QUERY PLAN        
---------------------------
- Result
-   One-Time Filter: false
-(2 rows)
-
+ERROR:  relation "hp_contradict_test" does not exist
+LINE 1: explain (costs off) select * from hp_contradict_test where a...
+                                          ^
 explain (costs off) select * from hp_contradict_test where a === 1 and b === 1 and a is null;
-        QUERY PLAN        
---------------------------
- Result
-   One-Time Filter: false
-(2 rows)
-
+ERROR:  relation "hp_contradict_test" does not exist
+LINE 1: explain (costs off) select * from hp_contradict_test where a...
+                                          ^
 drop table hp_contradict_test;
+ERROR:  table "hp_contradict_test" does not exist
 drop operator class part_test_int4_ops2 using hash;
+ERROR:  operator class "part_test_int4_ops2" does not exist for access method "hash"
 drop operator ===(int4, int4);
diff -U3 /Users/kenaniah/workspace/postgres/src/test/regress/expected/hash_part.out /Users/kenaniah/workspace/postgres/src/test/regress/results/hash_part.out
--- /Users/kenaniah/workspace/postgres/src/test/regress/expected/hash_part.out	2021-10-03 17:41:49.000000000 -0700
+++ /Users/kenaniah/workspace/postgres/src/test/regress/results/hash_part.out	2021-10-03 20:08:24.000000000 -0700
@@ -6,8 +6,10 @@
 -- part_part_test_int4_ops and part_test_text_ops in insert.sql.
 CREATE TABLE mchash (a int, b text, c jsonb)
   PARTITION BY HASH (a part_test_int4_ops, b part_test_text_ops);
+ERROR:  operator class "part_test_int4_ops" does not exist for access method "hash"
 CREATE TABLE mchash1
   PARTITION OF mchash FOR VALUES WITH (MODULUS 4, REMAINDER 0);
+ERROR:  relation "mchash" does not exist
 -- invalid OID, no such table
 SELECT satisfies_hash_partition(0, 4, 0, NULL);
 ERROR:  could not open relation with OID 0
@@ -16,85 +18,94 @@
 ERROR:  "tenk1" is not a hash partitioned table
 -- partition rather than the parent
 SELECT satisfies_hash_partition('mchash1'::regclass, 4, 0, NULL);
-ERROR:  "mchash1" is not a hash partitioned table
+ERROR:  relation "mchash1" does not exist
+LINE 1: SELECT satisfies_hash_partition('mchash1'::regclass, 4, 0, N...
+                                        ^
 -- invalid modulus
 SELECT satisfies_hash_partition('mchash'::regclass, 0, 0, NULL);
-ERROR:  modulus for hash partition must be an integer value greater than zero
+ERROR:  relation "mchash" does not exist
+LINE 1: SELECT satisfies_hash_partition('mchash'::regclass, 0, 0, NU...
+                                        ^
 -- remainder too small
 SELECT satisfies_hash_partition('mchash'::regclass, 1, -1, NULL);
-ERROR:  remainder for hash partition must be an integer value greater than or equal to zero
+ERROR:  relation "mchash" does not exist
+LINE 1: SELECT satisfies_hash_partition('mchash'::regclass, 1, -1, N...
+                                        ^
 -- remainder too large
 SELECT satisfies_hash_partition('mchash'::regclass, 1, 1, NULL);
-ERROR:  remainder for hash partition must be less than modulus
+ERROR:  relation "mchash" does not exist
+LINE 1: SELECT satisfies_hash_partition('mchash'::regclass, 1, 1, NU...
+                                        ^
 -- modulus is null
 SELECT satisfies_hash_partition('mchash'::regclass, NULL, 0, NULL);
- satisfies_hash_partition 
---------------------------
- f
-(1 row)
-
+ERROR:  relation "mchash" does not exist
+LINE 1: SELECT satisfies_hash_partition('mchash'::regclass, NULL, 0,...
+                                        ^
 -- remainder is null
 SELECT satisfies_hash_partition('mchash'::regclass, 4, NULL, NULL);
- satisfies_hash_partition 
---------------------------
- f
-(1 row)
-
+ERROR:  relation "mchash" does not exist
+LINE 1: SELECT satisfies_hash_partition('mchash'::regclass, 4, NULL,...
+                                        ^
 -- too many arguments
 SELECT satisfies_hash_partition('mchash'::regclass, 4, 0, NULL::int, NULL::text, NULL::json);
-ERROR:  number of partitioning columns (2) does not match number of partition keys provided (3)
+ERROR:  relation "mchash" does not exist
+LINE 1: SELECT satisfies_hash_partition('mchash'::regclass, 4, 0, NU...
+                                        ^
 -- too few arguments
 SELECT satisfies_hash_partition('mchash'::regclass, 3, 1, NULL::int);
-ERROR:  number of partitioning columns (2) does not match number of partition keys provided (1)
+ERROR:  relation "mchash" does not exist
+LINE 1: SELECT satisfies_hash_partition('mchash'::regclass, 3, 1, NU...
+                                        ^
 -- wrong argument type
 SELECT satisfies_hash_partition('mchash'::regclass, 2, 1, NULL::int, NULL::int);
-ERROR:  column 2 of the partition key has type text, but supplied value is of type integer
+ERROR:  relation "mchash" does not exist
+LINE 1: SELECT satisfies_hash_partition('mchash'::regclass, 2, 1, NU...
+                                        ^
 -- ok, should be false
 SELECT satisfies_hash_partition('mchash'::regclass, 4, 0, 0, ''::text);
- satisfies_hash_partition 
---------------------------
- f
-(1 row)
-
+ERROR:  relation "mchash" does not exist
+LINE 1: SELECT satisfies_hash_partition('mchash'::regclass, 4, 0, 0,...
+                                        ^
 -- ok, should be true
 SELECT satisfies_hash_partition('mchash'::regclass, 4, 0, 2, ''::text);
- satisfies_hash_partition 
---------------------------
- t
-(1 row)
-
+ERROR:  relation "mchash" does not exist
+LINE 1: SELECT satisfies_hash_partition('mchash'::regclass, 4, 0, 2,...
+                                        ^
 -- argument via variadic syntax, should fail because not all partitioning
 -- columns are of the correct type
 SELECT satisfies_hash_partition('mchash'::regclass, 2, 1,
 								variadic array[1,2]::int[]);
-ERROR:  column 2 of the partition key has type "text", but supplied value is of type "integer"
+ERROR:  relation "mchash" does not exist
+LINE 1: SELECT satisfies_hash_partition('mchash'::regclass, 2, 1,
+                                        ^
 -- multiple partitioning columns of the same type
 CREATE TABLE mcinthash (a int, b int, c jsonb)
   PARTITION BY HASH (a part_test_int4_ops, b part_test_int4_ops);
+ERROR:  operator class "part_test_int4_ops" does not exist for access method "hash"
 -- now variadic should work, should be false
 SELECT satisfies_hash_partition('mcinthash'::regclass, 4, 0,
 								variadic array[0, 0]);
- satisfies_hash_partition 
---------------------------
- f
-(1 row)
-
+ERROR:  relation "mcinthash" does not exist
+LINE 1: SELECT satisfies_hash_partition('mcinthash'::regclass, 4, 0,
+                                        ^
 -- should be true
 SELECT satisfies_hash_partition('mcinthash'::regclass, 4, 0,
 								variadic array[0, 1]);
- satisfies_hash_partition 
---------------------------
- t
-(1 row)
-
+ERROR:  relation "mcinthash" does not exist
+LINE 1: SELECT satisfies_hash_partition('mcinthash'::regclass, 4, 0,
+                                        ^
 -- wrong length
 SELECT satisfies_hash_partition('mcinthash'::regclass, 4, 0,
 								variadic array[]::int[]);
-ERROR:  number of partitioning columns (2) does not match number of partition keys provided (0)
+ERROR:  relation "mcinthash" does not exist
+LINE 1: SELECT satisfies_hash_partition('mcinthash'::regclass, 4, 0,
+                                        ^
 -- wrong type
 SELECT satisfies_hash_partition('mcinthash'::regclass, 4, 0,
 								variadic array[now(), now()]);
-ERROR:  column 1 of the partition key has type "integer", but supplied value is of type "timestamp with time zone"
+ERROR:  relation "mcinthash" does not exist
+LINE 1: SELECT satisfies_hash_partition('mcinthash'::regclass, 4, 0,
+                                        ^
 -- check satisfies_hash_partition passes correct collation
 create table text_hashp (a text) partition by hash (a);
 create table text_hashp0 partition of text_hashp for values with (modulus 2, remainder 0);
@@ -110,5 +121,7 @@
 
 -- cleanup
 DROP TABLE mchash;
+ERROR:  table "mchash" does not exist
 DROP TABLE mcinthash;
+ERROR:  table "mcinthash" does not exist
 DROP TABLE text_hashp;
diff -U3 /Users/kenaniah/workspace/postgres/src/test/regress/expected/indexing.out /Users/kenaniah/workspace/postgres/src/test/regress/results/indexing.out
--- /Users/kenaniah/workspace/postgres/src/test/regress/expected/indexing.out	2021-10-03 18:09:17.000000000 -0700
+++ /Users/kenaniah/workspace/postgres/src/test/regress/results/indexing.out	2021-10-03 20:08:24.000000000 -0700
@@ -82,1278 +82,11 @@
 create index idxparti2 on idxpart (b, c);
 create table idxpart1 (like idxpart);
 \d idxpart1
-              Table "public.idxpart1"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
- b      | integer |           |          | 
- c      | text    |           |          | 
+dyld: lazy symbol binding failed: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
+
+dyld: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
 
-alter table idxpart attach partition idxpart1 for values from (0) to (10);
-\d idxpart1
-              Table "public.idxpart1"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
- b      | integer |           |          | 
- c      | text    |           |          | 
-Partition of: idxpart FOR VALUES FROM (0) TO (10)
-Indexes:
-    "idxpart1_a_idx" btree (a)
-    "idxpart1_b_c_idx" btree (b, c)
-
-\d+ idxpart1_a_idx
-                 Index "public.idxpart1_a_idx"
- Column |  Type   | Key? | Definition | Storage | Stats target 
---------+---------+------+------------+---------+--------------
- a      | integer | yes  | a          | plain   | 
-Partition of: idxparti 
-No partition constraint
-btree, for table "public.idxpart1"
-
-\d+ idxpart1_b_c_idx
-                Index "public.idxpart1_b_c_idx"
- Column |  Type   | Key? | Definition | Storage  | Stats target 
---------+---------+------+------------+----------+--------------
- b      | integer | yes  | b          | plain    | 
- c      | text    | yes  | c          | extended | 
-Partition of: idxparti2 
-No partition constraint
-btree, for table "public.idxpart1"
-
--- Forbid ALTER TABLE when attaching or detaching an index to a partition.
-create index idxpart_c on only idxpart (c);
-create index idxpart1_c on idxpart1 (c);
-alter table idxpart_c attach partition idxpart1_c for values from (10) to (20);
-ERROR:  "idxpart_c" is not a partitioned table
-alter index idxpart_c attach partition idxpart1_c;
-select relname, relpartbound from pg_class
-  where relname in ('idxpart_c', 'idxpart1_c')
-  order by relname;
-  relname   | relpartbound 
-------------+--------------
- idxpart1_c | 
- idxpart_c  | 
-(2 rows)
-
-alter table idxpart_c detach partition idxpart1_c;
-ERROR:  ALTER action DETACH PARTITION cannot be performed on relation "idxpart_c"
-DETAIL:  This operation is not supported for partitioned indexes.
-drop table idxpart;
--- If a partition already has an index, don't create a duplicative one
-create table idxpart (a int, b int) partition by range (a, b);
-create table idxpart1 partition of idxpart for values from (0, 0) to (10, 10);
-create index on idxpart1 (a, b);
-create index on idxpart (a, b);
-\d idxpart1
-              Table "public.idxpart1"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
- b      | integer |           |          | 
-Partition of: idxpart FOR VALUES FROM (0, 0) TO (10, 10)
-Indexes:
-    "idxpart1_a_b_idx" btree (a, b)
-
-select relname, relkind, relhassubclass, inhparent::regclass
-    from pg_class left join pg_index ix on (indexrelid = oid)
-	left join pg_inherits on (ix.indexrelid = inhrelid)
-	where relname like 'idxpart%' order by relname;
-     relname      | relkind | relhassubclass |    inhparent    
-------------------+---------+----------------+-----------------
- idxpart          | p       | t              | 
- idxpart1         | r       | f              | 
- idxpart1_a_b_idx | i       | f              | idxpart_a_b_idx
- idxpart_a_b_idx  | I       | t              | 
-(4 rows)
-
-drop table idxpart;
--- DROP behavior for partitioned indexes
-create table idxpart (a int) partition by range (a);
-create index on idxpart (a);
-create table idxpart1 partition of idxpart for values from (0) to (10);
-drop index idxpart1_a_idx;	-- no way
-ERROR:  cannot drop index idxpart1_a_idx because index idxpart_a_idx requires it
-HINT:  You can drop index idxpart_a_idx instead.
-drop index concurrently idxpart_a_idx;	-- unsupported
-ERROR:  cannot drop partitioned index "idxpart_a_idx" concurrently
-drop index idxpart_a_idx;	-- both indexes go away
-select relname, relkind from pg_class
-  where relname like 'idxpart%' order by relname;
- relname  | relkind 
-----------+---------
- idxpart  | p
- idxpart1 | r
-(2 rows)
-
-create index on idxpart (a);
-drop table idxpart1;		-- the index on partition goes away too
-select relname, relkind from pg_class
-  where relname like 'idxpart%' order by relname;
-    relname    | relkind 
----------------+---------
- idxpart       | p
- idxpart_a_idx | I
-(2 rows)
-
-drop table idxpart;
--- DROP behavior with temporary partitioned indexes
-create temp table idxpart_temp (a int) partition by range (a);
-create index on idxpart_temp(a);
-create temp table idxpart1_temp partition of idxpart_temp
-  for values from (0) to (10);
-drop index idxpart1_temp_a_idx; -- error
-ERROR:  cannot drop index idxpart1_temp_a_idx because index idxpart_temp_a_idx requires it
-HINT:  You can drop index idxpart_temp_a_idx instead.
--- non-concurrent drop is enforced here, so it is a valid case.
-drop index concurrently idxpart_temp_a_idx;
-select relname, relkind from pg_class
-  where relname like 'idxpart_temp%' order by relname;
-   relname    | relkind 
---------------+---------
- idxpart_temp | p
-(1 row)
-
-drop table idxpart_temp;
--- ALTER INDEX .. ATTACH, error cases
-create table idxpart (a int, b int) partition by range (a, b);
-create table idxpart1 partition of idxpart for values from (0, 0) to (10, 10);
-create index idxpart_a_b_idx on only idxpart (a, b);
-create index idxpart1_a_b_idx on idxpart1 (a, b);
-create index idxpart1_tst1 on idxpart1 (b, a);
-create index idxpart1_tst2 on idxpart1 using hash (a);
-create index idxpart1_tst3 on idxpart1 (a, b) where a > 10;
-alter index idxpart attach partition idxpart1;
-ERROR:  "idxpart" is not an index
-alter index idxpart_a_b_idx attach partition idxpart1;
-ERROR:  "idxpart1" is not an index
-alter index idxpart_a_b_idx attach partition idxpart_a_b_idx;
-ERROR:  cannot attach index "idxpart_a_b_idx" as a partition of index "idxpart_a_b_idx"
-DETAIL:  Index "idxpart_a_b_idx" is not an index on any partition of table "idxpart".
-alter index idxpart_a_b_idx attach partition idxpart1_b_idx;
-ERROR:  relation "idxpart1_b_idx" does not exist
-alter index idxpart_a_b_idx attach partition idxpart1_tst1;
-ERROR:  cannot attach index "idxpart1_tst1" as a partition of index "idxpart_a_b_idx"
-DETAIL:  The index definitions do not match.
-alter index idxpart_a_b_idx attach partition idxpart1_tst2;
-ERROR:  cannot attach index "idxpart1_tst2" as a partition of index "idxpart_a_b_idx"
-DETAIL:  The index definitions do not match.
-alter index idxpart_a_b_idx attach partition idxpart1_tst3;
-ERROR:  cannot attach index "idxpart1_tst3" as a partition of index "idxpart_a_b_idx"
-DETAIL:  The index definitions do not match.
--- OK
-alter index idxpart_a_b_idx attach partition idxpart1_a_b_idx;
-alter index idxpart_a_b_idx attach partition idxpart1_a_b_idx; -- quiet
--- reject dupe
-create index idxpart1_2_a_b on idxpart1 (a, b);
-alter index idxpart_a_b_idx attach partition idxpart1_2_a_b;
-ERROR:  cannot attach index "idxpart1_2_a_b" as a partition of index "idxpart_a_b_idx"
-DETAIL:  Another index is already attached for partition "idxpart1".
-drop table idxpart;
--- make sure everything's gone
-select indexrelid::regclass, indrelid::regclass
-  from pg_index where indexrelid::regclass::text like 'idxpart%';
- indexrelid | indrelid 
-------------+----------
-(0 rows)
-
--- Don't auto-attach incompatible indexes
-create table idxpart (a int, b int) partition by range (a);
-create table idxpart1 (a int, b int);
-create index on idxpart1 using hash (a);
-create index on idxpart1 (a) where b > 1;
-create index on idxpart1 ((a + 0));
-create index on idxpart1 (a, a);
-create index on idxpart (a);
-alter table idxpart attach partition idxpart1 for values from (0) to (1000);
-\d idxpart1
-              Table "public.idxpart1"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
- b      | integer |           |          | 
-Partition of: idxpart FOR VALUES FROM (0) TO (1000)
-Indexes:
-    "idxpart1_a_a1_idx" btree (a, a)
-    "idxpart1_a_idx" hash (a)
-    "idxpart1_a_idx1" btree (a) WHERE b > 1
-    "idxpart1_a_idx2" btree (a)
-    "idxpart1_expr_idx" btree ((a + 0))
-
-drop table idxpart;
--- If CREATE INDEX ONLY, don't create indexes on partitions; and existing
--- indexes on partitions don't change parent.  ALTER INDEX ATTACH can change
--- the parent after the fact.
-create table idxpart (a int) partition by range (a);
-create table idxpart1 partition of idxpart for values from (0) to (100);
-create table idxpart2 partition of idxpart for values from (100) to (1000)
-  partition by range (a);
-create table idxpart21 partition of idxpart2 for values from (100) to (200);
-create table idxpart22 partition of idxpart2 for values from (200) to (300);
-create index on idxpart22 (a);
-create index on only idxpart2 (a);
-create index on idxpart (a);
--- Here we expect that idxpart1 and idxpart2 have a new index, but idxpart21
--- does not; also, idxpart22 is not attached.
-\d idxpart1
-              Table "public.idxpart1"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
-Partition of: idxpart FOR VALUES FROM (0) TO (100)
-Indexes:
-    "idxpart1_a_idx" btree (a)
-
-\d idxpart2
-        Partitioned table "public.idxpart2"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
-Partition of: idxpart FOR VALUES FROM (100) TO (1000)
-Partition key: RANGE (a)
-Indexes:
-    "idxpart2_a_idx" btree (a) INVALID
-Number of partitions: 2 (Use \d+ to list them.)
-
-\d idxpart21
-             Table "public.idxpart21"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
-Partition of: idxpart2 FOR VALUES FROM (100) TO (200)
-
-select indexrelid::regclass, indrelid::regclass, inhparent::regclass
-  from pg_index idx left join pg_inherits inh on (idx.indexrelid = inh.inhrelid)
-where indexrelid::regclass::text like 'idxpart%'
-  order by indexrelid::regclass::text collate "C";
-   indexrelid    | indrelid  |   inhparent   
------------------+-----------+---------------
- idxpart1_a_idx  | idxpart1  | idxpart_a_idx
- idxpart22_a_idx | idxpart22 | 
- idxpart2_a_idx  | idxpart2  | idxpart_a_idx
- idxpart_a_idx   | idxpart   | 
-(4 rows)
-
-alter index idxpart2_a_idx attach partition idxpart22_a_idx;
-select indexrelid::regclass, indrelid::regclass, inhparent::regclass
-  from pg_index idx left join pg_inherits inh on (idx.indexrelid = inh.inhrelid)
-where indexrelid::regclass::text like 'idxpart%'
-  order by indexrelid::regclass::text collate "C";
-   indexrelid    | indrelid  |   inhparent    
------------------+-----------+----------------
- idxpart1_a_idx  | idxpart1  | idxpart_a_idx
- idxpart22_a_idx | idxpart22 | idxpart2_a_idx
- idxpart2_a_idx  | idxpart2  | idxpart_a_idx
- idxpart_a_idx   | idxpart   | 
-(4 rows)
-
--- attaching idxpart22 is not enough to set idxpart22_a_idx valid ...
-alter index idxpart2_a_idx attach partition idxpart22_a_idx;
-\d idxpart2
-        Partitioned table "public.idxpart2"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
-Partition of: idxpart FOR VALUES FROM (100) TO (1000)
-Partition key: RANGE (a)
-Indexes:
-    "idxpart2_a_idx" btree (a) INVALID
-Number of partitions: 2 (Use \d+ to list them.)
-
--- ... but this one is.
-create index on idxpart21 (a);
-alter index idxpart2_a_idx attach partition idxpart21_a_idx;
-\d idxpart2
-        Partitioned table "public.idxpart2"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
-Partition of: idxpart FOR VALUES FROM (100) TO (1000)
-Partition key: RANGE (a)
-Indexes:
-    "idxpart2_a_idx" btree (a)
-Number of partitions: 2 (Use \d+ to list them.)
-
-drop table idxpart;
--- When a table is attached a partition and it already has an index, a
--- duplicate index should not get created, but rather the index becomes
--- attached to the parent's index.
-create table idxpart (a int, b int, c text) partition by range (a);
-create index idxparti on idxpart (a);
-create index idxparti2 on idxpart (b, c);
-create table idxpart1 (like idxpart including indexes);
-\d idxpart1
-              Table "public.idxpart1"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
- b      | integer |           |          | 
- c      | text    |           |          | 
-Indexes:
-    "idxpart1_a_idx" btree (a)
-    "idxpart1_b_c_idx" btree (b, c)
-
-select relname, relkind, inhparent::regclass
-    from pg_class left join pg_index ix on (indexrelid = oid)
-	left join pg_inherits on (ix.indexrelid = inhrelid)
-	where relname like 'idxpart%' order by relname;
-     relname      | relkind | inhparent 
-------------------+---------+-----------
- idxpart          | p       | 
- idxpart1         | r       | 
- idxpart1_a_idx   | i       | 
- idxpart1_b_c_idx | i       | 
- idxparti         | I       | 
- idxparti2        | I       | 
-(6 rows)
-
-alter table idxpart attach partition idxpart1 for values from (0) to (10);
-\d idxpart1
-              Table "public.idxpart1"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
- b      | integer |           |          | 
- c      | text    |           |          | 
-Partition of: idxpart FOR VALUES FROM (0) TO (10)
-Indexes:
-    "idxpart1_a_idx" btree (a)
-    "idxpart1_b_c_idx" btree (b, c)
-
-select relname, relkind, inhparent::regclass
-    from pg_class left join pg_index ix on (indexrelid = oid)
-	left join pg_inherits on (ix.indexrelid = inhrelid)
-	where relname like 'idxpart%' order by relname;
-     relname      | relkind | inhparent 
-------------------+---------+-----------
- idxpart          | p       | 
- idxpart1         | r       | 
- idxpart1_a_idx   | i       | idxparti
- idxpart1_b_c_idx | i       | idxparti2
- idxparti         | I       | 
- idxparti2        | I       | 
-(6 rows)
-
-drop table idxpart;
--- Verify that attaching an invalid index does not mark the parent index valid.
--- On the other hand, attaching a valid index marks not only its direct
--- ancestor valid, but also any indirect ancestor that was only missing the one
--- that was just made valid
-create table idxpart (a int, b int) partition by range (a);
-create table idxpart1 partition of idxpart for values from (1) to (1000) partition by range (a);
-create table idxpart11 partition of idxpart1 for values from (1) to (100);
-create index on only idxpart1 (a);
-create index on only idxpart (a);
--- this results in two invalid indexes:
-select relname, indisvalid from pg_class join pg_index on indexrelid = oid
-   where relname like 'idxpart%' order by relname;
-    relname     | indisvalid 
-----------------+------------
- idxpart1_a_idx | f
- idxpart_a_idx  | f
-(2 rows)
-
--- idxpart1_a_idx is not valid, so idxpart_a_idx should not become valid:
-alter index idxpart_a_idx attach partition idxpart1_a_idx;
-select relname, indisvalid from pg_class join pg_index on indexrelid = oid
-   where relname like 'idxpart%' order by relname;
-    relname     | indisvalid 
-----------------+------------
- idxpart1_a_idx | f
- idxpart_a_idx  | f
-(2 rows)
-
--- after creating and attaching this, both idxpart1_a_idx and idxpart_a_idx
--- should become valid
-create index on idxpart11 (a);
-alter index idxpart1_a_idx attach partition idxpart11_a_idx;
-select relname, indisvalid from pg_class join pg_index on indexrelid = oid
-   where relname like 'idxpart%' order by relname;
-     relname     | indisvalid 
------------------+------------
- idxpart11_a_idx | t
- idxpart1_a_idx  | t
- idxpart_a_idx   | t
-(3 rows)
-
-drop table idxpart;
--- verify dependency handling during ALTER TABLE DETACH PARTITION
-create table idxpart (a int) partition by range (a);
-create table idxpart1 (like idxpart);
-create index on idxpart1 (a);
-create index on idxpart (a);
-create table idxpart2 (like idxpart);
-alter table idxpart attach partition idxpart1 for values from (0000) to (1000);
-alter table idxpart attach partition idxpart2 for values from (1000) to (2000);
-create table idxpart3 partition of idxpart for values from (2000) to (3000);
-select relname, relkind from pg_class where relname like 'idxpart%' order by relname;
-    relname     | relkind 
-----------------+---------
- idxpart        | p
- idxpart1       | r
- idxpart1_a_idx | i
- idxpart2       | r
- idxpart2_a_idx | i
- idxpart3       | r
- idxpart3_a_idx | i
- idxpart_a_idx  | I
-(8 rows)
-
--- a) after detaching partitions, the indexes can be dropped independently
-alter table idxpart detach partition idxpart1;
-alter table idxpart detach partition idxpart2;
-alter table idxpart detach partition idxpart3;
-drop index idxpart1_a_idx;
-drop index idxpart2_a_idx;
-drop index idxpart3_a_idx;
-select relname, relkind from pg_class where relname like 'idxpart%' order by relname;
-    relname    | relkind 
----------------+---------
- idxpart       | p
- idxpart1      | r
- idxpart2      | r
- idxpart3      | r
- idxpart_a_idx | I
-(5 rows)
-
-drop table idxpart, idxpart1, idxpart2, idxpart3;
-select relname, relkind from pg_class where relname like 'idxpart%' order by relname;
- relname | relkind 
----------+---------
-(0 rows)
-
-create table idxpart (a int) partition by range (a);
-create table idxpart1 (like idxpart);
-create index on idxpart1 (a);
-create index on idxpart (a);
-create table idxpart2 (like idxpart);
-alter table idxpart attach partition idxpart1 for values from (0000) to (1000);
-alter table idxpart attach partition idxpart2 for values from (1000) to (2000);
-create table idxpart3 partition of idxpart for values from (2000) to (3000);
--- b) after detaching, dropping the index on parent does not remove the others
-select relname, relkind from pg_class where relname like 'idxpart%' order by relname;
-    relname     | relkind 
-----------------+---------
- idxpart        | p
- idxpart1       | r
- idxpart1_a_idx | i
- idxpart2       | r
- idxpart2_a_idx | i
- idxpart3       | r
- idxpart3_a_idx | i
- idxpart_a_idx  | I
-(8 rows)
-
-alter table idxpart detach partition idxpart1;
-alter table idxpart detach partition idxpart2;
-alter table idxpart detach partition idxpart3;
-drop index idxpart_a_idx;
-select relname, relkind from pg_class where relname like 'idxpart%' order by relname;
-    relname     | relkind 
-----------------+---------
- idxpart        | p
- idxpart1       | r
- idxpart1_a_idx | i
- idxpart2       | r
- idxpart2_a_idx | i
- idxpart3       | r
- idxpart3_a_idx | i
-(7 rows)
-
-drop table idxpart, idxpart1, idxpart2, idxpart3;
-select relname, relkind from pg_class where relname like 'idxpart%' order by relname;
- relname | relkind 
----------+---------
-(0 rows)
-
-create table idxpart (a int, b int, c int) partition by range(a);
-create index on idxpart(c);
-create table idxpart1 partition of idxpart for values from (0) to (250);
-create table idxpart2 partition of idxpart for values from (250) to (500);
-alter table idxpart detach partition idxpart2;
-\d idxpart2
-              Table "public.idxpart2"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
- b      | integer |           |          | 
- c      | integer |           |          | 
-Indexes:
-    "idxpart2_c_idx" btree (c)
-
-alter table idxpart2 drop column c;
-\d idxpart2
-              Table "public.idxpart2"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
- b      | integer |           |          | 
-
-drop table idxpart, idxpart2;
--- Verify that expression indexes inherit correctly
-create table idxpart (a int, b int) partition by range (a);
-create table idxpart1 (like idxpart);
-create index on idxpart1 ((a + b));
-create index on idxpart ((a + b));
-create table idxpart2 (like idxpart);
-alter table idxpart attach partition idxpart1 for values from (0000) to (1000);
-alter table idxpart attach partition idxpart2 for values from (1000) to (2000);
-create table idxpart3 partition of idxpart for values from (2000) to (3000);
-select relname as child, inhparent::regclass as parent, pg_get_indexdef as childdef
-  from pg_class join pg_inherits on inhrelid = oid,
-  lateral pg_get_indexdef(pg_class.oid)
-  where relkind in ('i', 'I') and relname like 'idxpart%' order by relname;
-       child       |      parent      |                                 childdef                                  
--------------------+------------------+---------------------------------------------------------------------------
- idxpart1_expr_idx | idxpart_expr_idx | CREATE INDEX idxpart1_expr_idx ON public.idxpart1 USING btree (((a + b)))
- idxpart2_expr_idx | idxpart_expr_idx | CREATE INDEX idxpart2_expr_idx ON public.idxpart2 USING btree (((a + b)))
- idxpart3_expr_idx | idxpart_expr_idx | CREATE INDEX idxpart3_expr_idx ON public.idxpart3 USING btree (((a + b)))
-(3 rows)
-
-drop table idxpart;
--- Verify behavior for collation (mis)matches
-create table idxpart (a text) partition by range (a);
-create table idxpart1 (like idxpart);
-create table idxpart2 (like idxpart);
-create index on idxpart2 (a collate "POSIX");
-create index on idxpart2 (a);
-create index on idxpart2 (a collate "C");
-alter table idxpart attach partition idxpart1 for values from ('aaa') to ('bbb');
-alter table idxpart attach partition idxpart2 for values from ('bbb') to ('ccc');
-create table idxpart3 partition of idxpart for values from ('ccc') to ('ddd');
-create index on idxpart (a collate "C");
-create table idxpart4 partition of idxpart for values from ('ddd') to ('eee');
-select relname as child, inhparent::regclass as parent, pg_get_indexdef as childdef
-  from pg_class left join pg_inherits on inhrelid = oid,
-  lateral pg_get_indexdef(pg_class.oid)
-  where relkind in ('i', 'I') and relname like 'idxpart%' order by relname;
-      child      |    parent     |                                    childdef                                    
------------------+---------------+--------------------------------------------------------------------------------
- idxpart1_a_idx  | idxpart_a_idx | CREATE INDEX idxpart1_a_idx ON public.idxpart1 USING btree (a COLLATE "C")
- idxpart2_a_idx  |               | CREATE INDEX idxpart2_a_idx ON public.idxpart2 USING btree (a COLLATE "POSIX")
- idxpart2_a_idx1 |               | CREATE INDEX idxpart2_a_idx1 ON public.idxpart2 USING btree (a)
- idxpart2_a_idx2 | idxpart_a_idx | CREATE INDEX idxpart2_a_idx2 ON public.idxpart2 USING btree (a COLLATE "C")
- idxpart3_a_idx  | idxpart_a_idx | CREATE INDEX idxpart3_a_idx ON public.idxpart3 USING btree (a COLLATE "C")
- idxpart4_a_idx  | idxpart_a_idx | CREATE INDEX idxpart4_a_idx ON public.idxpart4 USING btree (a COLLATE "C")
- idxpart_a_idx   |               | CREATE INDEX idxpart_a_idx ON ONLY public.idxpart USING btree (a COLLATE "C")
-(7 rows)
-
-drop table idxpart;
--- Verify behavior for opclass (mis)matches
-create table idxpart (a text) partition by range (a);
-create table idxpart1 (like idxpart);
-create table idxpart2 (like idxpart);
-create index on idxpart2 (a);
-alter table idxpart attach partition idxpart1 for values from ('aaa') to ('bbb');
-alter table idxpart attach partition idxpart2 for values from ('bbb') to ('ccc');
-create table idxpart3 partition of idxpart for values from ('ccc') to ('ddd');
-create index on idxpart (a text_pattern_ops);
-create table idxpart4 partition of idxpart for values from ('ddd') to ('eee');
--- must *not* have attached the index we created on idxpart2
-select relname as child, inhparent::regclass as parent, pg_get_indexdef as childdef
-  from pg_class left join pg_inherits on inhrelid = oid,
-  lateral pg_get_indexdef(pg_class.oid)
-  where relkind in ('i', 'I') and relname like 'idxpart%' order by relname;
-      child      |    parent     |                                      childdef                                      
------------------+---------------+------------------------------------------------------------------------------------
- idxpart1_a_idx  | idxpart_a_idx | CREATE INDEX idxpart1_a_idx ON public.idxpart1 USING btree (a text_pattern_ops)
- idxpart2_a_idx  |               | CREATE INDEX idxpart2_a_idx ON public.idxpart2 USING btree (a)
- idxpart2_a_idx1 | idxpart_a_idx | CREATE INDEX idxpart2_a_idx1 ON public.idxpart2 USING btree (a text_pattern_ops)
- idxpart3_a_idx  | idxpart_a_idx | CREATE INDEX idxpart3_a_idx ON public.idxpart3 USING btree (a text_pattern_ops)
- idxpart4_a_idx  | idxpart_a_idx | CREATE INDEX idxpart4_a_idx ON public.idxpart4 USING btree (a text_pattern_ops)
- idxpart_a_idx   |               | CREATE INDEX idxpart_a_idx ON ONLY public.idxpart USING btree (a text_pattern_ops)
-(6 rows)
-
-drop index idxpart_a_idx;
-create index on only idxpart (a text_pattern_ops);
--- must reject
-alter index idxpart_a_idx attach partition idxpart2_a_idx;
-ERROR:  cannot attach index "idxpart2_a_idx" as a partition of index "idxpart_a_idx"
-DETAIL:  The index definitions do not match.
-drop table idxpart;
--- Verify that attaching indexes maps attribute numbers correctly
-create table idxpart (col1 int, a int, col2 int, b int) partition by range (a);
-create table idxpart1 (b int, col1 int, col2 int, col3 int, a int);
-alter table idxpart drop column col1, drop column col2;
-alter table idxpart1 drop column col1, drop column col2, drop column col3;
-alter table idxpart attach partition idxpart1 for values from (0) to (1000);
-create index idxpart_1_idx on only idxpart (b, a);
-create index idxpart1_1_idx on idxpart1 (b, a);
-create index idxpart1_1b_idx on idxpart1 (b);
--- test expressions and partial-index predicate, too
-create index idxpart_2_idx on only idxpart ((b + a)) where a > 1;
-create index idxpart1_2_idx on idxpart1 ((b + a)) where a > 1;
-create index idxpart1_2b_idx on idxpart1 ((a + b)) where a > 1;
-create index idxpart1_2c_idx on idxpart1 ((b + a)) where b > 1;
-alter index idxpart_1_idx attach partition idxpart1_1b_idx;	-- fail
-ERROR:  cannot attach index "idxpart1_1b_idx" as a partition of index "idxpart_1_idx"
-DETAIL:  The index definitions do not match.
-alter index idxpart_1_idx attach partition idxpart1_1_idx;
-alter index idxpart_2_idx attach partition idxpart1_2b_idx;	-- fail
-ERROR:  cannot attach index "idxpart1_2b_idx" as a partition of index "idxpart_2_idx"
-DETAIL:  The index definitions do not match.
-alter index idxpart_2_idx attach partition idxpart1_2c_idx;	-- fail
-ERROR:  cannot attach index "idxpart1_2c_idx" as a partition of index "idxpart_2_idx"
-DETAIL:  The index definitions do not match.
-alter index idxpart_2_idx attach partition idxpart1_2_idx;	-- ok
-select relname as child, inhparent::regclass as parent, pg_get_indexdef as childdef
-  from pg_class left join pg_inherits on inhrelid = oid,
-  lateral pg_get_indexdef(pg_class.oid)
-  where relkind in ('i', 'I') and relname like 'idxpart%' order by relname;
-      child      |    parent     |                                        childdef                                         
------------------+---------------+-----------------------------------------------------------------------------------------
- idxpart1_1_idx  | idxpart_1_idx | CREATE INDEX idxpart1_1_idx ON public.idxpart1 USING btree (b, a)
- idxpart1_1b_idx |               | CREATE INDEX idxpart1_1b_idx ON public.idxpart1 USING btree (b)
- idxpart1_2_idx  | idxpart_2_idx | CREATE INDEX idxpart1_2_idx ON public.idxpart1 USING btree (((b + a))) WHERE (a > 1)
- idxpart1_2b_idx |               | CREATE INDEX idxpart1_2b_idx ON public.idxpart1 USING btree (((a + b))) WHERE (a > 1)
- idxpart1_2c_idx |               | CREATE INDEX idxpart1_2c_idx ON public.idxpart1 USING btree (((b + a))) WHERE (b > 1)
- idxpart_1_idx   |               | CREATE INDEX idxpart_1_idx ON ONLY public.idxpart USING btree (b, a)
- idxpart_2_idx   |               | CREATE INDEX idxpart_2_idx ON ONLY public.idxpart USING btree (((b + a))) WHERE (a > 1)
-(7 rows)
-
-drop table idxpart;
--- Make sure the partition columns are mapped correctly
-create table idxpart (a int, b int, c text) partition by range (a);
-create index idxparti on idxpart (a);
-create index idxparti2 on idxpart (c, b);
-create table idxpart1 (c text, a int, b int);
-alter table idxpart attach partition idxpart1 for values from (0) to (10);
-create table idxpart2 (c text, a int, b int);
-create index on idxpart2 (a);
-create index on idxpart2 (c, b);
-alter table idxpart attach partition idxpart2 for values from (10) to (20);
-select c.relname, pg_get_indexdef(indexrelid)
-  from pg_class c join pg_index i on c.oid = i.indexrelid
-  where indrelid::regclass::text like 'idxpart%'
-  order by indexrelid::regclass::text collate "C";
-     relname      |                           pg_get_indexdef                           
-------------------+---------------------------------------------------------------------
- idxpart1_a_idx   | CREATE INDEX idxpart1_a_idx ON public.idxpart1 USING btree (a)
- idxpart1_c_b_idx | CREATE INDEX idxpart1_c_b_idx ON public.idxpart1 USING btree (c, b)
- idxpart2_a_idx   | CREATE INDEX idxpart2_a_idx ON public.idxpart2 USING btree (a)
- idxpart2_c_b_idx | CREATE INDEX idxpart2_c_b_idx ON public.idxpart2 USING btree (c, b)
- idxparti         | CREATE INDEX idxparti ON ONLY public.idxpart USING btree (a)
- idxparti2        | CREATE INDEX idxparti2 ON ONLY public.idxpart USING btree (c, b)
-(6 rows)
-
-drop table idxpart;
--- Verify that columns are mapped correctly in expression indexes
-create table idxpart (col1 int, col2 int, a int, b int) partition by range (a);
-create table idxpart1 (col2 int, b int, col1 int, a int);
-create table idxpart2 (col1 int, col2 int, b int, a int);
-alter table idxpart drop column col1, drop column col2;
-alter table idxpart1 drop column col1, drop column col2;
-alter table idxpart2 drop column col1, drop column col2;
-create index on idxpart2 (abs(b));
-alter table idxpart attach partition idxpart2 for values from (0) to (1);
-create index on idxpart (abs(b));
-create index on idxpart ((b + 1));
-alter table idxpart attach partition idxpart1 for values from (1) to (2);
-select c.relname, pg_get_indexdef(indexrelid)
-  from pg_class c join pg_index i on c.oid = i.indexrelid
-  where indrelid::regclass::text like 'idxpart%'
-  order by indexrelid::regclass::text collate "C";
-      relname      |                               pg_get_indexdef                                
--------------------+------------------------------------------------------------------------------
- idxpart1_abs_idx  | CREATE INDEX idxpart1_abs_idx ON public.idxpart1 USING btree (abs(b))
- idxpart1_expr_idx | CREATE INDEX idxpart1_expr_idx ON public.idxpart1 USING btree (((b + 1)))
- idxpart2_abs_idx  | CREATE INDEX idxpart2_abs_idx ON public.idxpart2 USING btree (abs(b))
- idxpart2_expr_idx | CREATE INDEX idxpart2_expr_idx ON public.idxpart2 USING btree (((b + 1)))
- idxpart_abs_idx   | CREATE INDEX idxpart_abs_idx ON ONLY public.idxpart USING btree (abs(b))
- idxpart_expr_idx  | CREATE INDEX idxpart_expr_idx ON ONLY public.idxpart USING btree (((b + 1)))
-(6 rows)
-
-drop table idxpart;
--- Verify that columns are mapped correctly for WHERE in a partial index
-create table idxpart (col1 int, a int, col3 int, b int) partition by range (a);
-alter table idxpart drop column col1, drop column col3;
-create table idxpart1 (col1 int, col2 int, col3 int, col4 int, b int, a int);
-alter table idxpart1 drop column col1, drop column col2, drop column col3, drop column col4;
-alter table idxpart attach partition idxpart1 for values from (0) to (1000);
-create table idxpart2 (col1 int, col2 int, b int, a int);
-create index on idxpart2 (a) where b > 1000;
-alter table idxpart2 drop column col1, drop column col2;
-alter table idxpart attach partition idxpart2 for values from (1000) to (2000);
-create index on idxpart (a) where b > 1000;
-select c.relname, pg_get_indexdef(indexrelid)
-  from pg_class c join pg_index i on c.oid = i.indexrelid
-  where indrelid::regclass::text like 'idxpart%'
-  order by indexrelid::regclass::text collate "C";
-    relname     |                                  pg_get_indexdef                                   
-----------------+------------------------------------------------------------------------------------
- idxpart1_a_idx | CREATE INDEX idxpart1_a_idx ON public.idxpart1 USING btree (a) WHERE (b > 1000)
- idxpart2_a_idx | CREATE INDEX idxpart2_a_idx ON public.idxpart2 USING btree (a) WHERE (b > 1000)
- idxpart_a_idx  | CREATE INDEX idxpart_a_idx ON ONLY public.idxpart USING btree (a) WHERE (b > 1000)
-(3 rows)
-
-drop table idxpart;
--- Column number mapping: dropped columns in the partition
-create table idxpart1 (drop_1 int, drop_2 int, col_keep int, drop_3 int);
-alter table idxpart1 drop column drop_1;
-alter table idxpart1 drop column drop_2;
-alter table idxpart1 drop column drop_3;
-create index on idxpart1 (col_keep);
-create table idxpart (col_keep int) partition by range (col_keep);
-create index on idxpart (col_keep);
-alter table idxpart attach partition idxpart1 for values from (0) to (1000);
-\d idxpart
-         Partitioned table "public.idxpart"
-  Column  |  Type   | Collation | Nullable | Default 
-----------+---------+-----------+----------+---------
- col_keep | integer |           |          | 
-Partition key: RANGE (col_keep)
-Indexes:
-    "idxpart_col_keep_idx" btree (col_keep)
-Number of partitions: 1 (Use \d+ to list them.)
-
-\d idxpart1
-               Table "public.idxpart1"
-  Column  |  Type   | Collation | Nullable | Default 
-----------+---------+-----------+----------+---------
- col_keep | integer |           |          | 
-Partition of: idxpart FOR VALUES FROM (0) TO (1000)
-Indexes:
-    "idxpart1_col_keep_idx" btree (col_keep)
-
-select attrelid::regclass, attname, attnum from pg_attribute
-  where attrelid::regclass::text like 'idxpart%' and attnum > 0
-  order by attrelid::regclass, attnum;
-       attrelid        |           attname            | attnum 
------------------------+------------------------------+--------
- idxpart1              | ........pg.dropped.1........ |      1
- idxpart1              | ........pg.dropped.2........ |      2
- idxpart1              | col_keep                     |      3
- idxpart1              | ........pg.dropped.4........ |      4
- idxpart1_col_keep_idx | col_keep                     |      1
- idxpart               | col_keep                     |      1
- idxpart_col_keep_idx  | col_keep                     |      1
-(7 rows)
-
-drop table idxpart;
--- Column number mapping: dropped columns in the parent table
-create table idxpart(drop_1 int, drop_2 int, col_keep int, drop_3 int) partition by range (col_keep);
-alter table idxpart drop column drop_1;
-alter table idxpart drop column drop_2;
-alter table idxpart drop column drop_3;
-create table idxpart1 (col_keep int);
-create index on idxpart1 (col_keep);
-create index on idxpart (col_keep);
-alter table idxpart attach partition idxpart1 for values from (0) to (1000);
-\d idxpart
-         Partitioned table "public.idxpart"
-  Column  |  Type   | Collation | Nullable | Default 
-----------+---------+-----------+----------+---------
- col_keep | integer |           |          | 
-Partition key: RANGE (col_keep)
-Indexes:
-    "idxpart_col_keep_idx" btree (col_keep)
-Number of partitions: 1 (Use \d+ to list them.)
-
-\d idxpart1
-               Table "public.idxpart1"
-  Column  |  Type   | Collation | Nullable | Default 
-----------+---------+-----------+----------+---------
- col_keep | integer |           |          | 
-Partition of: idxpart FOR VALUES FROM (0) TO (1000)
-Indexes:
-    "idxpart1_col_keep_idx" btree (col_keep)
-
-select attrelid::regclass, attname, attnum from pg_attribute
-  where attrelid::regclass::text like 'idxpart%' and attnum > 0
-  order by attrelid::regclass, attnum;
-       attrelid        |           attname            | attnum 
------------------------+------------------------------+--------
- idxpart               | ........pg.dropped.1........ |      1
- idxpart               | ........pg.dropped.2........ |      2
- idxpart               | col_keep                     |      3
- idxpart               | ........pg.dropped.4........ |      4
- idxpart1              | col_keep                     |      1
- idxpart1_col_keep_idx | col_keep                     |      1
- idxpart_col_keep_idx  | col_keep                     |      1
-(7 rows)
-
-drop table idxpart;
---
--- Constraint-related indexes
---
--- Verify that it works to add primary key / unique to partitioned tables
-create table idxpart (a int primary key, b int) partition by range (a);
-\d idxpart
-        Partitioned table "public.idxpart"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           | not null | 
- b      | integer |           |          | 
-Partition key: RANGE (a)
-Indexes:
-    "idxpart_pkey" PRIMARY KEY, btree (a)
-Number of partitions: 0
-
--- multiple primary key on child should fail
-create table failpart partition of idxpart (b primary key) for values from (0) to (100);
-ERROR:  multiple primary keys for table "failpart" are not allowed
-drop table idxpart;
--- primary key on child is okay if there's no PK in the parent, though
-create table idxpart (a int) partition by range (a);
-create table idxpart1pk partition of idxpart (a primary key) for values from (0) to (100);
-\d idxpart1pk
-             Table "public.idxpart1pk"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           | not null | 
-Partition of: idxpart FOR VALUES FROM (0) TO (100)
-Indexes:
-    "idxpart1pk_pkey" PRIMARY KEY, btree (a)
-
-drop table idxpart;
--- Failing to use the full partition key is not allowed
-create table idxpart (a int unique, b int) partition by range (a, b);
-ERROR:  unique constraint on partitioned table must include all partitioning columns
-DETAIL:  UNIQUE constraint on table "idxpart" lacks column "b" which is part of the partition key.
-create table idxpart (a int, b int unique) partition by range (a, b);
-ERROR:  unique constraint on partitioned table must include all partitioning columns
-DETAIL:  UNIQUE constraint on table "idxpart" lacks column "a" which is part of the partition key.
-create table idxpart (a int primary key, b int) partition by range (b, a);
-ERROR:  unique constraint on partitioned table must include all partitioning columns
-DETAIL:  PRIMARY KEY constraint on table "idxpart" lacks column "b" which is part of the partition key.
-create table idxpart (a int, b int primary key) partition by range (b, a);
-ERROR:  unique constraint on partitioned table must include all partitioning columns
-DETAIL:  PRIMARY KEY constraint on table "idxpart" lacks column "a" which is part of the partition key.
--- OK if you use them in some other order
-create table idxpart (a int, b int, c text, primary key  (a, b, c)) partition by range (b, c, a);
-drop table idxpart;
--- not other types of index-based constraints
-create table idxpart (a int, exclude (a with = )) partition by range (a);
-ERROR:  exclusion constraints are not supported on partitioned tables
-LINE 1: create table idxpart (a int, exclude (a with = )) partition ...
-                                     ^
--- no expressions in partition key for PK/UNIQUE
-create table idxpart (a int primary key, b int) partition by range ((b + a));
-ERROR:  unsupported PRIMARY KEY constraint with partition key definition
-DETAIL:  PRIMARY KEY constraints cannot be used when partition keys include expressions.
-create table idxpart (a int unique, b int) partition by range ((b + a));
-ERROR:  unsupported UNIQUE constraint with partition key definition
-DETAIL:  UNIQUE constraints cannot be used when partition keys include expressions.
--- use ALTER TABLE to add a primary key
-create table idxpart (a int, b int, c text) partition by range (a, b);
-alter table idxpart add primary key (a);	-- not an incomplete one though
-ERROR:  unique constraint on partitioned table must include all partitioning columns
-DETAIL:  PRIMARY KEY constraint on table "idxpart" lacks column "b" which is part of the partition key.
-alter table idxpart add primary key (a, b);	-- this works
-\d idxpart
-        Partitioned table "public.idxpart"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           | not null | 
- b      | integer |           | not null | 
- c      | text    |           |          | 
-Partition key: RANGE (a, b)
-Indexes:
-    "idxpart_pkey" PRIMARY KEY, btree (a, b)
-Number of partitions: 0
-
-create table idxpart1 partition of idxpart for values from (0, 0) to (1000, 1000);
-\d idxpart1
-              Table "public.idxpart1"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           | not null | 
- b      | integer |           | not null | 
- c      | text    |           |          | 
-Partition of: idxpart FOR VALUES FROM (0, 0) TO (1000, 1000)
-Indexes:
-    "idxpart1_pkey" PRIMARY KEY, btree (a, b)
-
-drop table idxpart;
--- use ALTER TABLE to add a unique constraint
-create table idxpart (a int, b int) partition by range (a, b);
-alter table idxpart add unique (a);			-- not an incomplete one though
-ERROR:  unique constraint on partitioned table must include all partitioning columns
-DETAIL:  UNIQUE constraint on table "idxpart" lacks column "b" which is part of the partition key.
-alter table idxpart add unique (b, a);		-- this works
-\d idxpart
-        Partitioned table "public.idxpart"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
- b      | integer |           |          | 
-Partition key: RANGE (a, b)
-Indexes:
-    "idxpart_b_a_key" UNIQUE CONSTRAINT, btree (b, a)
-Number of partitions: 0
-
-drop table idxpart;
--- Exclusion constraints cannot be added
-create table idxpart (a int, b int) partition by range (a);
-alter table idxpart add exclude (a with =);
-ERROR:  exclusion constraints are not supported on partitioned tables
-LINE 1: alter table idxpart add exclude (a with =);
-                                ^
-drop table idxpart;
--- When (sub)partitions are created, they also contain the constraint
-create table idxpart (a int, b int, primary key (a, b)) partition by range (a, b);
-create table idxpart1 partition of idxpart for values from (1, 1) to (10, 10);
-create table idxpart2 partition of idxpart for values from (10, 10) to (20, 20)
-  partition by range (b);
-create table idxpart21 partition of idxpart2 for values from (10) to (15);
-create table idxpart22 partition of idxpart2 for values from (15) to (20);
-create table idxpart3 (b int not null, a int not null);
-alter table idxpart attach partition idxpart3 for values from (20, 20) to (30, 30);
-select conname, contype, conrelid::regclass, conindid::regclass, conkey
-  from pg_constraint where conrelid::regclass::text like 'idxpart%'
-  order by conname;
-    conname     | contype | conrelid  |    conindid    | conkey 
-----------------+---------+-----------+----------------+--------
- idxpart1_pkey  | p       | idxpart1  | idxpart1_pkey  | {1,2}
- idxpart21_pkey | p       | idxpart21 | idxpart21_pkey | {1,2}
- idxpart22_pkey | p       | idxpart22 | idxpart22_pkey | {1,2}
- idxpart2_pkey  | p       | idxpart2  | idxpart2_pkey  | {1,2}
- idxpart3_pkey  | p       | idxpart3  | idxpart3_pkey  | {2,1}
- idxpart_pkey   | p       | idxpart   | idxpart_pkey   | {1,2}
-(6 rows)
-
-drop table idxpart;
--- Verify that multi-layer partitioning honors the requirement that all
--- columns in the partition key must appear in primary/unique key
-create table idxpart (a int, b int, primary key (a)) partition by range (a);
-create table idxpart2 partition of idxpart
-for values from (0) to (1000) partition by range (b); -- fail
-ERROR:  unique constraint on partitioned table must include all partitioning columns
-DETAIL:  PRIMARY KEY constraint on table "idxpart2" lacks column "b" which is part of the partition key.
-drop table idxpart;
--- Ditto for the ATTACH PARTITION case
-create table idxpart (a int unique, b int) partition by range (a);
-create table idxpart1 (a int not null, b int, unique (a, b))
-  partition by range (a, b);
-alter table idxpart attach partition idxpart1 for values from (1) to (1000);
-ERROR:  unique constraint on partitioned table must include all partitioning columns
-DETAIL:  UNIQUE constraint on table "idxpart1" lacks column "b" which is part of the partition key.
-DROP TABLE idxpart, idxpart1;
--- Multi-layer partitioning works correctly in this case:
-create table idxpart (a int, b int, primary key (a, b)) partition by range (a);
-create table idxpart2 partition of idxpart for values from (0) to (1000) partition by range (b);
-create table idxpart21 partition of idxpart2 for values from (0) to (1000);
-select conname, contype, conrelid::regclass, conindid::regclass, conkey
-  from pg_constraint where conrelid::regclass::text like 'idxpart%'
-  order by conname;
-    conname     | contype | conrelid  |    conindid    | conkey 
-----------------+---------+-----------+----------------+--------
- idxpart21_pkey | p       | idxpart21 | idxpart21_pkey | {1,2}
- idxpart2_pkey  | p       | idxpart2  | idxpart2_pkey  | {1,2}
- idxpart_pkey   | p       | idxpart   | idxpart_pkey   | {1,2}
-(3 rows)
-
-drop table idxpart;
--- If a partitioned table has a unique/PK constraint, then it's not possible
--- to drop the corresponding constraint in the children; nor it's possible
--- to drop the indexes individually.  Dropping the constraint in the parent
--- gets rid of the lot.
-create table idxpart (i int) partition by hash (i);
-create table idxpart0 partition of idxpart (i) for values with (modulus 2, remainder 0);
-create table idxpart1 partition of idxpart (i) for values with (modulus 2, remainder 1);
-alter table idxpart0 add primary key(i);
-alter table idxpart add primary key(i);
-select indrelid::regclass, indexrelid::regclass, inhparent::regclass, indisvalid,
-  conname, conislocal, coninhcount, connoinherit, convalidated
-  from pg_index idx left join pg_inherits inh on (idx.indexrelid = inh.inhrelid)
-  left join pg_constraint con on (idx.indexrelid = con.conindid)
-  where indrelid::regclass::text like 'idxpart%'
-  order by indexrelid::regclass::text collate "C";
- indrelid |  indexrelid   |  inhparent   | indisvalid |    conname    | conislocal | coninhcount | connoinherit | convalidated 
-----------+---------------+--------------+------------+---------------+------------+-------------+--------------+--------------
- idxpart0 | idxpart0_pkey | idxpart_pkey | t          | idxpart0_pkey | f          |           1 | t            | t
- idxpart1 | idxpart1_pkey | idxpart_pkey | t          | idxpart1_pkey | f          |           1 | f            | t
- idxpart  | idxpart_pkey  |              | t          | idxpart_pkey  | t          |           0 | t            | t
-(3 rows)
-
-drop index idxpart0_pkey;								-- fail
-ERROR:  cannot drop index idxpart0_pkey because index idxpart_pkey requires it
-HINT:  You can drop index idxpart_pkey instead.
-drop index idxpart1_pkey;								-- fail
-ERROR:  cannot drop index idxpart1_pkey because index idxpart_pkey requires it
-HINT:  You can drop index idxpart_pkey instead.
-alter table idxpart0 drop constraint idxpart0_pkey;		-- fail
-ERROR:  cannot drop inherited constraint "idxpart0_pkey" of relation "idxpart0"
-alter table idxpart1 drop constraint idxpart1_pkey;		-- fail
-ERROR:  cannot drop inherited constraint "idxpart1_pkey" of relation "idxpart1"
-alter table idxpart drop constraint idxpart_pkey;		-- ok
-select indrelid::regclass, indexrelid::regclass, inhparent::regclass, indisvalid,
-  conname, conislocal, coninhcount, connoinherit, convalidated
-  from pg_index idx left join pg_inherits inh on (idx.indexrelid = inh.inhrelid)
-  left join pg_constraint con on (idx.indexrelid = con.conindid)
-  where indrelid::regclass::text like 'idxpart%'
-  order by indexrelid::regclass::text collate "C";
- indrelid | indexrelid | inhparent | indisvalid | conname | conislocal | coninhcount | connoinherit | convalidated 
-----------+------------+-----------+------------+---------+------------+-------------+--------------+--------------
-(0 rows)
-
-drop table idxpart;
--- If the partition to be attached already has a primary key, fail if
--- it doesn't match the parent's PK.
-CREATE TABLE idxpart (c1 INT PRIMARY KEY, c2 INT, c3 VARCHAR(10)) PARTITION BY RANGE(c1);
-CREATE TABLE idxpart1 (LIKE idxpart);
-ALTER TABLE idxpart1 ADD PRIMARY KEY (c1, c2);
-ALTER TABLE idxpart ATTACH PARTITION idxpart1 FOR VALUES FROM (100) TO (200);
-ERROR:  multiple primary keys for table "idxpart1" are not allowed
-DROP TABLE idxpart, idxpart1;
--- Ditto if there is some distance between the PKs (subpartitioning)
-create table idxpart (a int, b int, primary key (a)) partition by range (a);
-create table idxpart1 (a int not null, b int) partition by range (a);
-create table idxpart11 (a int not null, b int primary key);
-alter table idxpart1 attach partition idxpart11 for values from (0) to (1000);
-alter table idxpart attach partition idxpart1 for values from (0) to (10000);
-ERROR:  multiple primary keys for table "idxpart11" are not allowed
-drop table idxpart, idxpart1, idxpart11;
--- If a partitioned table has a constraint whose index is not valid,
--- attaching a missing partition makes it valid.
-create table idxpart (a int) partition by range (a);
-create table idxpart0 (like idxpart);
-alter table idxpart0 add primary key (a);
-alter table idxpart attach partition idxpart0 for values from (0) to (1000);
-alter table only idxpart add primary key (a);
-select indrelid::regclass, indexrelid::regclass, inhparent::regclass, indisvalid,
-  conname, conislocal, coninhcount, connoinherit, convalidated
-  from pg_index idx left join pg_inherits inh on (idx.indexrelid = inh.inhrelid)
-  left join pg_constraint con on (idx.indexrelid = con.conindid)
-  where indrelid::regclass::text like 'idxpart%'
-  order by indexrelid::regclass::text collate "C";
- indrelid |  indexrelid   | inhparent | indisvalid |    conname    | conislocal | coninhcount | connoinherit | convalidated 
-----------+---------------+-----------+------------+---------------+------------+-------------+--------------+--------------
- idxpart0 | idxpart0_pkey |           | t          | idxpart0_pkey | t          |           0 | t            | t
- idxpart  | idxpart_pkey  |           | f          | idxpart_pkey  | t          |           0 | t            | t
-(2 rows)
-
-alter index idxpart_pkey attach partition idxpart0_pkey;
-select indrelid::regclass, indexrelid::regclass, inhparent::regclass, indisvalid,
-  conname, conislocal, coninhcount, connoinherit, convalidated
-  from pg_index idx left join pg_inherits inh on (idx.indexrelid = inh.inhrelid)
-  left join pg_constraint con on (idx.indexrelid = con.conindid)
-  where indrelid::regclass::text like 'idxpart%'
-  order by indexrelid::regclass::text collate "C";
- indrelid |  indexrelid   |  inhparent   | indisvalid |    conname    | conislocal | coninhcount | connoinherit | convalidated 
-----------+---------------+--------------+------------+---------------+------------+-------------+--------------+--------------
- idxpart0 | idxpart0_pkey | idxpart_pkey | t          | idxpart0_pkey | f          |           1 | t            | t
- idxpart  | idxpart_pkey  |              | t          | idxpart_pkey  | t          |           0 | t            | t
-(2 rows)
-
-drop table idxpart;
--- Related to the above scenario: ADD PRIMARY KEY on the parent mustn't
--- automatically propagate NOT NULL to child columns.
-create table idxpart (a int) partition by range (a);
-create table idxpart0 (like idxpart);
-alter table idxpart0 add unique (a);
-alter table idxpart attach partition idxpart0 default;
-alter table only idxpart add primary key (a);  -- fail, no NOT NULL constraint
-ERROR:  constraint must be added to child tables too
-DETAIL:  Column "a" of relation "idxpart0" is not already NOT NULL.
-HINT:  Do not specify the ONLY keyword.
-alter table idxpart0 alter column a set not null;
-alter table only idxpart add primary key (a);  -- now it works
-alter table idxpart0 alter column a drop not null;  -- fail, pkey needs it
-ERROR:  column "a" is marked NOT NULL in parent table
-drop table idxpart;
--- if a partition has a unique index without a constraint, does not attach
--- automatically; creates a new index instead.
-create table idxpart (a int, b int) partition by range (a);
-create table idxpart1 (a int not null, b int);
-create unique index on idxpart1 (a);
-alter table idxpart add primary key (a);
-alter table idxpart attach partition idxpart1 for values from (1) to (1000);
-select indrelid::regclass, indexrelid::regclass, inhparent::regclass, indisvalid,
-  conname, conislocal, coninhcount, connoinherit, convalidated
-  from pg_index idx left join pg_inherits inh on (idx.indexrelid = inh.inhrelid)
-  left join pg_constraint con on (idx.indexrelid = con.conindid)
-  where indrelid::regclass::text like 'idxpart%'
-  order by indexrelid::regclass::text collate "C";
- indrelid |   indexrelid   |  inhparent   | indisvalid |    conname    | conislocal | coninhcount | connoinherit | convalidated 
-----------+----------------+--------------+------------+---------------+------------+-------------+--------------+--------------
- idxpart1 | idxpart1_a_idx |              | t          |               |            |             |              | 
- idxpart1 | idxpart1_pkey  | idxpart_pkey | t          | idxpart1_pkey | f          |           1 | f            | t
- idxpart  | idxpart_pkey   |              | t          | idxpart_pkey  | t          |           0 | t            | t
-(3 rows)
-
-drop table idxpart;
--- Can't attach an index without a corresponding constraint
-create table idxpart (a int, b int) partition by range (a);
-create table idxpart1 (a int not null, b int);
-create unique index on idxpart1 (a);
-alter table idxpart attach partition idxpart1 for values from (1) to (1000);
-alter table only idxpart add primary key (a);
-alter index idxpart_pkey attach partition idxpart1_a_idx;	-- fail
-ERROR:  cannot attach index "idxpart1_a_idx" as a partition of index "idxpart_pkey"
-DETAIL:  The index "idxpart_pkey" belongs to a constraint in table "idxpart" but no constraint exists for index "idxpart1_a_idx".
-drop table idxpart;
--- Test that unique constraints are working
-create table idxpart (a int, b text, primary key (a, b)) partition by range (a);
-create table idxpart1 partition of idxpart for values from (0) to (100000);
-create table idxpart2 (c int, like idxpart);
-insert into idxpart2 (c, a, b) values (42, 572814, 'inserted first');
-alter table idxpart2 drop column c;
-create unique index on idxpart (a);
-alter table idxpart attach partition idxpart2 for values from (100000) to (1000000);
-insert into idxpart values (0, 'zero'), (42, 'life'), (2^16, 'sixteen');
-insert into idxpart select 2^g, format('two to power of %s', g) from generate_series(15, 17) g;
-ERROR:  duplicate key value violates unique constraint "idxpart1_a_idx"
-DETAIL:  Key (a)=(65536) already exists.
-insert into idxpart values (16, 'sixteen');
-insert into idxpart (b, a) values ('one', 142857), ('two', 285714);
-insert into idxpart select a * 2, b || b from idxpart where a between 2^16 and 2^19;
-ERROR:  duplicate key value violates unique constraint "idxpart2_a_idx"
-DETAIL:  Key (a)=(285714) already exists.
-insert into idxpart values (572814, 'five');
-ERROR:  duplicate key value violates unique constraint "idxpart2_a_idx"
-DETAIL:  Key (a)=(572814) already exists.
-insert into idxpart values (857142, 'six');
-select tableoid::regclass, * from idxpart order by a;
- tableoid |   a    |       b        
-----------+--------+----------------
- idxpart1 |      0 | zero
- idxpart1 |     16 | sixteen
- idxpart1 |     42 | life
- idxpart1 |  65536 | sixteen
- idxpart2 | 142857 | one
- idxpart2 | 285714 | two
- idxpart2 | 572814 | inserted first
- idxpart2 | 857142 | six
-(8 rows)
-
-drop table idxpart;
--- intentionally leave some objects around
-create table idxpart (a int) partition by range (a);
-create table idxpart1 partition of idxpart for values from (0) to (100);
-create table idxpart2 partition of idxpart for values from (100) to (1000)
-  partition by range (a);
-create table idxpart21 partition of idxpart2 for values from (100) to (200);
-create table idxpart22 partition of idxpart2 for values from (200) to (300);
-create index on idxpart22 (a);
-create index on only idxpart2 (a);
-alter index idxpart2_a_idx attach partition idxpart22_a_idx;
-create index on idxpart (a);
-create table idxpart_another (a int, b int, primary key (a, b)) partition by range (a);
-create table idxpart_another_1 partition of idxpart_another for values from (0) to (100);
-create table idxpart3 (c int, b int, a int) partition by range (a);
-alter table idxpart3 drop column b, drop column c;
-create table idxpart31 partition of idxpart3 for values from (1000) to (1200);
-create table idxpart32 partition of idxpart3 for values from (1200) to (1400);
-alter table idxpart attach partition idxpart3 for values from (1000) to (2000);
--- More objects intentionally left behind, to verify some pg_dump/pg_upgrade
--- behavior; see https://postgr.es/m/20190321204928.GA17535@alvherre.pgsql
-create schema regress_indexing;
-set search_path to regress_indexing;
-create table pk (a int primary key) partition by range (a);
-create table pk1 partition of pk for values from (0) to (1000);
-create table pk2 (b int, a int);
-alter table pk2 drop column b;
-alter table pk2 alter a set not null;
-alter table pk attach partition pk2 for values from (1000) to (2000);
-create table pk3 partition of pk for values from (2000) to (3000);
-create table pk4 (like pk);
-alter table pk attach partition pk4 for values from (3000) to (4000);
-create table pk5 (like pk) partition by range (a);
-create table pk51 partition of pk5 for values from (4000) to (4500);
-create table pk52 partition of pk5 for values from (4500) to (5000);
-alter table pk attach partition pk5 for values from (4000) to (5000);
-reset search_path;
--- Test that covering partitioned indexes work in various cases
-create table covidxpart (a int, b int) partition by list (a);
-create unique index on covidxpart (a) include (b);
-create table covidxpart1 partition of covidxpart for values in (1);
-create table covidxpart2 partition of covidxpart for values in (2);
-insert into covidxpart values (1, 1);
-insert into covidxpart values (1, 1);
-ERROR:  duplicate key value violates unique constraint "covidxpart1_a_b_idx"
-DETAIL:  Key (a)=(1) already exists.
-create table covidxpart3 (b int, c int, a int);
-alter table covidxpart3 drop c;
-alter table covidxpart attach partition covidxpart3 for values in (3);
-insert into covidxpart values (3, 1);
-insert into covidxpart values (3, 1);
-ERROR:  duplicate key value violates unique constraint "covidxpart3_a_b_idx"
-DETAIL:  Key (a)=(3) already exists.
-create table covidxpart4 (b int, a int);
-create unique index on covidxpart4 (a) include (b);
-create unique index on covidxpart4 (a);
-alter table covidxpart attach partition covidxpart4 for values in (4);
-insert into covidxpart values (4, 1);
-insert into covidxpart values (4, 1);
-ERROR:  duplicate key value violates unique constraint "covidxpart4_a_b_idx"
-DETAIL:  Key (a)=(4) already exists.
-create unique index on covidxpart (b) include (a); -- should fail
-ERROR:  unique constraint on partitioned table must include all partitioning columns
-DETAIL:  UNIQUE constraint on table "covidxpart" lacks column "a" which is part of the partition key.
--- check that detaching a partition also detaches the primary key constraint
-create table parted_pk_detach_test (a int primary key) partition by list (a);
-create table parted_pk_detach_test1 partition of parted_pk_detach_test for values in (1);
-alter table parted_pk_detach_test1 drop constraint parted_pk_detach_test1_pkey;	-- should fail
-ERROR:  cannot drop inherited constraint "parted_pk_detach_test1_pkey" of relation "parted_pk_detach_test1"
-alter table parted_pk_detach_test detach partition parted_pk_detach_test1;
-alter table parted_pk_detach_test1 drop constraint parted_pk_detach_test1_pkey;
-drop table parted_pk_detach_test, parted_pk_detach_test1;
-create table parted_uniq_detach_test (a int unique) partition by list (a);
-create table parted_uniq_detach_test1 partition of parted_uniq_detach_test for values in (1);
-alter table parted_uniq_detach_test1 drop constraint parted_uniq_detach_test1_a_key;	-- should fail
-ERROR:  cannot drop inherited constraint "parted_uniq_detach_test1_a_key" of relation "parted_uniq_detach_test1"
-alter table parted_uniq_detach_test detach partition parted_uniq_detach_test1;
-alter table parted_uniq_detach_test1 drop constraint parted_uniq_detach_test1_a_key;
-drop table parted_uniq_detach_test, parted_uniq_detach_test1;
--- check that dropping a column takes with it any partitioned indexes
--- depending on it.
-create table parted_index_col_drop(a int, b int, c int)
-  partition by list (a);
-create table parted_index_col_drop1 partition of parted_index_col_drop
-  for values in (1) partition by list (a);
--- leave this partition without children.
-create table parted_index_col_drop2 partition of parted_index_col_drop
-  for values in (2) partition by list (a);
-create table parted_index_col_drop11 partition of parted_index_col_drop1
-  for values in (1);
-create index on parted_index_col_drop (b);
-create index on parted_index_col_drop (c);
-create index on parted_index_col_drop (b, c);
-alter table parted_index_col_drop drop column c;
-\d parted_index_col_drop
- Partitioned table "public.parted_index_col_drop"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
- b      | integer |           |          | 
-Partition key: LIST (a)
-Indexes:
-    "parted_index_col_drop_b_idx" btree (b)
-Number of partitions: 2 (Use \d+ to list them.)
-
-\d parted_index_col_drop1
- Partitioned table "public.parted_index_col_drop1"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
- b      | integer |           |          | 
-Partition of: parted_index_col_drop FOR VALUES IN (1)
-Partition key: LIST (a)
-Indexes:
-    "parted_index_col_drop1_b_idx" btree (b)
-Number of partitions: 1 (Use \d+ to list them.)
-
-\d parted_index_col_drop2
- Partitioned table "public.parted_index_col_drop2"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
- b      | integer |           |          | 
-Partition of: parted_index_col_drop FOR VALUES IN (2)
-Partition key: LIST (a)
-Indexes:
-    "parted_index_col_drop2_b_idx" btree (b)
-Number of partitions: 0
-
-\d parted_index_col_drop11
-      Table "public.parted_index_col_drop11"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
- b      | integer |           |          | 
-Partition of: parted_index_col_drop1 FOR VALUES IN (1)
-Indexes:
-    "parted_index_col_drop11_b_idx" btree (b)
-
-drop table parted_index_col_drop;
diff -U3 /Users/kenaniah/workspace/postgres/src/test/regress/expected/compression_1.out /Users/kenaniah/workspace/postgres/src/test/regress/results/compression.out
--- /Users/kenaniah/workspace/postgres/src/test/regress/expected/compression_1.out	2021-10-03 17:41:49.000000000 -0700
+++ /Users/kenaniah/workspace/postgres/src/test/regress/results/compression.out	2021-10-03 20:08:24.000000000 -0700
@@ -6,356 +6,11 @@
 CREATE INDEX idx ON cmdata(f1);
 INSERT INTO cmdata VALUES(repeat('1234567890', 1000));
 \d+ cmdata
-                                        Table "public.cmdata"
- Column | Type | Collation | Nullable | Default | Storage  | Compression | Stats target | Description 
---------+------+-----------+----------+---------+----------+-------------+--------------+-------------
- f1     | text |           |          |         | extended | pglz        |              | 
-Indexes:
-    "idx" btree (f1)
+dyld: lazy symbol binding failed: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
+
+dyld: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
 
-CREATE TABLE cmdata1(f1 TEXT COMPRESSION lz4);
-ERROR:  compression method lz4 not supported
-DETAIL:  This functionality requires the server to be built with lz4 support.
-HINT:  You need to rebuild PostgreSQL using --with-lz4.
-INSERT INTO cmdata1 VALUES(repeat('1234567890', 1004));
-ERROR:  relation "cmdata1" does not exist
-LINE 1: INSERT INTO cmdata1 VALUES(repeat('1234567890', 1004));
-                    ^
-\d+ cmdata1
--- verify stored compression method in the data
-SELECT pg_column_compression(f1) FROM cmdata;
- pg_column_compression 
------------------------
- pglz
-(1 row)
-
-SELECT pg_column_compression(f1) FROM cmdata1;
-ERROR:  relation "cmdata1" does not exist
-LINE 1: SELECT pg_column_compression(f1) FROM cmdata1;
-                                              ^
--- decompress data slice
-SELECT SUBSTR(f1, 200, 5) FROM cmdata;
- substr 
---------
- 01234
-(1 row)
-
-SELECT SUBSTR(f1, 2000, 50) FROM cmdata1;
-ERROR:  relation "cmdata1" does not exist
-LINE 1: SELECT SUBSTR(f1, 2000, 50) FROM cmdata1;
-                                         ^
--- copy with table creation
-SELECT * INTO cmmove1 FROM cmdata;
-\d+ cmmove1
-                                        Table "public.cmmove1"
- Column | Type | Collation | Nullable | Default | Storage  | Compression | Stats target | Description 
---------+------+-----------+----------+---------+----------+-------------+--------------+-------------
- f1     | text |           |          |         | extended |             |              | 
-
-SELECT pg_column_compression(f1) FROM cmmove1;
- pg_column_compression 
------------------------
- pglz
-(1 row)
-
--- copy to existing table
-CREATE TABLE cmmove3(f1 text COMPRESSION pglz);
-INSERT INTO cmmove3 SELECT * FROM cmdata;
-INSERT INTO cmmove3 SELECT * FROM cmdata1;
-ERROR:  relation "cmdata1" does not exist
-LINE 1: INSERT INTO cmmove3 SELECT * FROM cmdata1;
-                                          ^
-SELECT pg_column_compression(f1) FROM cmmove3;
- pg_column_compression 
------------------------
- pglz
-(1 row)
-
--- test LIKE INCLUDING COMPRESSION
-CREATE TABLE cmdata2 (LIKE cmdata1 INCLUDING COMPRESSION);
-ERROR:  relation "cmdata1" does not exist
-LINE 1: CREATE TABLE cmdata2 (LIKE cmdata1 INCLUDING COMPRESSION);
-                                   ^
-\d+ cmdata2
-DROP TABLE cmdata2;
-ERROR:  table "cmdata2" does not exist
--- try setting compression for incompressible data type
-CREATE TABLE cmdata2 (f1 int COMPRESSION pglz);
-ERROR:  column data type integer does not support compression
--- update using datum from different table
-CREATE TABLE cmmove2(f1 text COMPRESSION pglz);
-INSERT INTO cmmove2 VALUES (repeat('1234567890', 1004));
-SELECT pg_column_compression(f1) FROM cmmove2;
- pg_column_compression 
------------------------
- pglz
-(1 row)
-
-UPDATE cmmove2 SET f1 = cmdata1.f1 FROM cmdata1;
-ERROR:  relation "cmdata1" does not exist
-LINE 1: UPDATE cmmove2 SET f1 = cmdata1.f1 FROM cmdata1;
-                                                ^
-SELECT pg_column_compression(f1) FROM cmmove2;
- pg_column_compression 
------------------------
- pglz
-(1 row)
-
--- test externally stored compressed data
-CREATE OR REPLACE FUNCTION large_val() RETURNS TEXT LANGUAGE SQL AS
-'select array_agg(md5(g::text))::text from generate_series(1, 256) g';
-CREATE TABLE cmdata2 (f1 text COMPRESSION pglz);
-INSERT INTO cmdata2 SELECT large_val() || repeat('a', 4000);
-SELECT pg_column_compression(f1) FROM cmdata2;
- pg_column_compression 
------------------------
- pglz
-(1 row)
-
-INSERT INTO cmdata1 SELECT large_val() || repeat('a', 4000);
-ERROR:  relation "cmdata1" does not exist
-LINE 1: INSERT INTO cmdata1 SELECT large_val() || repeat('a', 4000);
-                    ^
-SELECT pg_column_compression(f1) FROM cmdata1;
-ERROR:  relation "cmdata1" does not exist
-LINE 1: SELECT pg_column_compression(f1) FROM cmdata1;
-                                              ^
-SELECT SUBSTR(f1, 200, 5) FROM cmdata1;
-ERROR:  relation "cmdata1" does not exist
-LINE 1: SELECT SUBSTR(f1, 200, 5) FROM cmdata1;
-                                       ^
-SELECT SUBSTR(f1, 200, 5) FROM cmdata2;
- substr 
---------
- 8f14e
-(1 row)
-
-DROP TABLE cmdata2;
---test column type update varlena/non-varlena
-CREATE TABLE cmdata2 (f1 int);
-\d+ cmdata2
-                                         Table "public.cmdata2"
- Column |  Type   | Collation | Nullable | Default | Storage | Compression | Stats target | Description 
---------+---------+-----------+----------+---------+---------+-------------+--------------+-------------
- f1     | integer |           |          |         | plain   |             |              | 
-
-ALTER TABLE cmdata2 ALTER COLUMN f1 TYPE varchar;
-\d+ cmdata2
-                                              Table "public.cmdata2"
- Column |       Type        | Collation | Nullable | Default | Storage  | Compression | Stats target | Description 
---------+-------------------+-----------+----------+---------+----------+-------------+--------------+-------------
- f1     | character varying |           |          |         | extended |             |              | 
-
-ALTER TABLE cmdata2 ALTER COLUMN f1 TYPE int USING f1::integer;
-\d+ cmdata2
-                                         Table "public.cmdata2"
- Column |  Type   | Collation | Nullable | Default | Storage | Compression | Stats target | Description 
---------+---------+-----------+----------+---------+---------+-------------+--------------+-------------
- f1     | integer |           |          |         | plain   |             |              | 
-
---changing column storage should not impact the compression method
---but the data should not be compressed
-ALTER TABLE cmdata2 ALTER COLUMN f1 TYPE varchar;
-ALTER TABLE cmdata2 ALTER COLUMN f1 SET COMPRESSION pglz;
-\d+ cmdata2
-                                              Table "public.cmdata2"
- Column |       Type        | Collation | Nullable | Default | Storage  | Compression | Stats target | Description 
---------+-------------------+-----------+----------+---------+----------+-------------+--------------+-------------
- f1     | character varying |           |          |         | extended | pglz        |              | 
-
-ALTER TABLE cmdata2 ALTER COLUMN f1 SET STORAGE plain;
-\d+ cmdata2
-                                              Table "public.cmdata2"
- Column |       Type        | Collation | Nullable | Default | Storage | Compression | Stats target | Description 
---------+-------------------+-----------+----------+---------+---------+-------------+--------------+-------------
- f1     | character varying |           |          |         | plain   | pglz        |              | 
-
-INSERT INTO cmdata2 VALUES (repeat('123456789', 800));
-SELECT pg_column_compression(f1) FROM cmdata2;
- pg_column_compression 
------------------------
- 
-(1 row)
-
--- test compression with materialized view
-CREATE MATERIALIZED VIEW compressmv(x) AS SELECT * FROM cmdata1;
-ERROR:  relation "cmdata1" does not exist
-LINE 1: ...TE MATERIALIZED VIEW compressmv(x) AS SELECT * FROM cmdata1;
-                                                               ^
-\d+ compressmv
-SELECT pg_column_compression(f1) FROM cmdata1;
-ERROR:  relation "cmdata1" does not exist
-LINE 1: SELECT pg_column_compression(f1) FROM cmdata1;
-                                              ^
-SELECT pg_column_compression(x) FROM compressmv;
-ERROR:  relation "compressmv" does not exist
-LINE 1: SELECT pg_column_compression(x) FROM compressmv;
-                                             ^
--- test compression with partition
-CREATE TABLE cmpart(f1 text COMPRESSION lz4) PARTITION BY HASH(f1);
-ERROR:  compression method lz4 not supported
-DETAIL:  This functionality requires the server to be built with lz4 support.
-HINT:  You need to rebuild PostgreSQL using --with-lz4.
-CREATE TABLE cmpart1 PARTITION OF cmpart FOR VALUES WITH (MODULUS 2, REMAINDER 0);
-ERROR:  relation "cmpart" does not exist
-CREATE TABLE cmpart2(f1 text COMPRESSION pglz);
-ALTER TABLE cmpart ATTACH PARTITION cmpart2 FOR VALUES WITH (MODULUS 2, REMAINDER 1);
-ERROR:  relation "cmpart" does not exist
-INSERT INTO cmpart VALUES (repeat('123456789', 1004));
-ERROR:  relation "cmpart" does not exist
-LINE 1: INSERT INTO cmpart VALUES (repeat('123456789', 1004));
-                    ^
-INSERT INTO cmpart VALUES (repeat('123456789', 4004));
-ERROR:  relation "cmpart" does not exist
-LINE 1: INSERT INTO cmpart VALUES (repeat('123456789', 4004));
-                    ^
-SELECT pg_column_compression(f1) FROM cmpart1;
-ERROR:  relation "cmpart1" does not exist
-LINE 1: SELECT pg_column_compression(f1) FROM cmpart1;
-                                              ^
-SELECT pg_column_compression(f1) FROM cmpart2;
- pg_column_compression 
------------------------
-(0 rows)
-
--- test compression with inheritance, error
-CREATE TABLE cminh() INHERITS(cmdata, cmdata1);
-ERROR:  relation "cmdata1" does not exist
-CREATE TABLE cminh(f1 TEXT COMPRESSION lz4) INHERITS(cmdata);
-NOTICE:  merging column "f1" with inherited definition
-ERROR:  column "f1" has a compression method conflict
-DETAIL:  pglz versus lz4
--- test default_toast_compression GUC
-SET default_toast_compression = '';
-ERROR:  invalid value for parameter "default_toast_compression": ""
-HINT:  Available values: pglz.
-SET default_toast_compression = 'I do not exist compression';
-ERROR:  invalid value for parameter "default_toast_compression": "I do not exist compression"
-HINT:  Available values: pglz.
-SET default_toast_compression = 'lz4';
-ERROR:  invalid value for parameter "default_toast_compression": "lz4"
-HINT:  Available values: pglz.
-SET default_toast_compression = 'pglz';
--- test alter compression method
-ALTER TABLE cmdata ALTER COLUMN f1 SET COMPRESSION lz4;
-ERROR:  compression method lz4 not supported
-DETAIL:  This functionality requires the server to be built with lz4 support.
-HINT:  You need to rebuild PostgreSQL using --with-lz4.
-INSERT INTO cmdata VALUES (repeat('123456789', 4004));
-\d+ cmdata
-                                        Table "public.cmdata"
- Column | Type | Collation | Nullable | Default | Storage  | Compression | Stats target | Description 
---------+------+-----------+----------+---------+----------+-------------+--------------+-------------
- f1     | text |           |          |         | extended | pglz        |              | 
-Indexes:
-    "idx" btree (f1)
-
-SELECT pg_column_compression(f1) FROM cmdata;
- pg_column_compression 
------------------------
- pglz
- pglz
-(2 rows)
-
-ALTER TABLE cmdata2 ALTER COLUMN f1 SET COMPRESSION default;
-\d+ cmdata2
-                                              Table "public.cmdata2"
- Column |       Type        | Collation | Nullable | Default | Storage | Compression | Stats target | Description 
---------+-------------------+-----------+----------+---------+---------+-------------+--------------+-------------
- f1     | character varying |           |          |         | plain   |             |              | 
-
--- test alter compression method for materialized views
-ALTER MATERIALIZED VIEW compressmv ALTER COLUMN x SET COMPRESSION lz4;
-ERROR:  relation "compressmv" does not exist
-\d+ compressmv
--- test alter compression method for partitioned tables
-ALTER TABLE cmpart1 ALTER COLUMN f1 SET COMPRESSION pglz;
-ERROR:  relation "cmpart1" does not exist
-ALTER TABLE cmpart2 ALTER COLUMN f1 SET COMPRESSION lz4;
-ERROR:  compression method lz4 not supported
-DETAIL:  This functionality requires the server to be built with lz4 support.
-HINT:  You need to rebuild PostgreSQL using --with-lz4.
--- new data should be compressed with the current compression method
-INSERT INTO cmpart VALUES (repeat('123456789', 1004));
-ERROR:  relation "cmpart" does not exist
-LINE 1: INSERT INTO cmpart VALUES (repeat('123456789', 1004));
-                    ^
-INSERT INTO cmpart VALUES (repeat('123456789', 4004));
-ERROR:  relation "cmpart" does not exist
-LINE 1: INSERT INTO cmpart VALUES (repeat('123456789', 4004));
-                    ^
-SELECT pg_column_compression(f1) FROM cmpart1;
-ERROR:  relation "cmpart1" does not exist
-LINE 1: SELECT pg_column_compression(f1) FROM cmpart1;
-                                              ^
-SELECT pg_column_compression(f1) FROM cmpart2;
- pg_column_compression 
------------------------
-(0 rows)
-
--- VACUUM FULL does not recompress
-SELECT pg_column_compression(f1) FROM cmdata;
- pg_column_compression 
------------------------
- pglz
- pglz
-(2 rows)
-
-VACUUM FULL cmdata;
-SELECT pg_column_compression(f1) FROM cmdata;
- pg_column_compression 
------------------------
- pglz
- pglz
-(2 rows)
-
--- test expression index
-DROP TABLE cmdata2;
-CREATE TABLE cmdata2 (f1 TEXT COMPRESSION pglz, f2 TEXT COMPRESSION lz4);
-ERROR:  compression method lz4 not supported
-DETAIL:  This functionality requires the server to be built with lz4 support.
-HINT:  You need to rebuild PostgreSQL using --with-lz4.
-CREATE UNIQUE INDEX idx1 ON cmdata2 ((f1 || f2));
-ERROR:  relation "cmdata2" does not exist
-INSERT INTO cmdata2 VALUES((SELECT array_agg(md5(g::TEXT))::TEXT FROM
-generate_series(1, 50) g), VERSION());
-ERROR:  relation "cmdata2" does not exist
-LINE 1: INSERT INTO cmdata2 VALUES((SELECT array_agg(md5(g::TEXT))::...
-                    ^
--- check data is ok
-SELECT length(f1) FROM cmdata;
- length 
---------
-  10000
-  36036
-(2 rows)
-
-SELECT length(f1) FROM cmdata1;
-ERROR:  relation "cmdata1" does not exist
-LINE 1: SELECT length(f1) FROM cmdata1;
-                               ^
-SELECT length(f1) FROM cmmove1;
- length 
---------
-  10000
-(1 row)
-
-SELECT length(f1) FROM cmmove2;
- length 
---------
-  10040
-(1 row)
-
-SELECT length(f1) FROM cmmove3;
- length 
---------
-  10000
-(1 row)
-
-CREATE TABLE badcompresstbl (a text COMPRESSION I_Do_Not_Exist_Compression); -- fails
-ERROR:  invalid compression method "i_do_not_exist_compression"
-CREATE TABLE badcompresstbl (a text);
-ALTER TABLE badcompresstbl ALTER a SET COMPRESSION I_Do_Not_Exist_Compression; -- fails
-ERROR:  invalid compression method "i_do_not_exist_compression"
-DROP TABLE badcompresstbl;
-\set HIDE_TOAST_COMPRESSION true
diff -U3 /Users/kenaniah/workspace/postgres/src/test/regress/expected/fast_default.out /Users/kenaniah/workspace/postgres/src/test/regress/results/fast_default.out
--- /Users/kenaniah/workspace/postgres/src/test/regress/expected/fast_default.out	2021-10-03 17:41:49.000000000 -0700
+++ /Users/kenaniah/workspace/postgres/src/test/regress/results/fast_default.out	2021-10-03 20:08:26.000000000 -0700
@@ -61,11 +61,15 @@
 -- Test a large sample of different datatypes
 CREATE TABLE T(pk INT NOT NULL PRIMARY KEY, c_int INT DEFAULT 1);
 SELECT set('t');
- set 
------
- 
-(1 row)
-
+ERROR:  cannot update table "m" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "UPDATE m
+  SET id = (SELECT c.relfilenode
+            FROM pg_class AS c, pg_namespace AS s
+            WHERE c.relname = tabname
+                AND c.relnamespace = s.oid
+                AND s.nspname = 'fast_default')"
+PL/pgSQL function set(name) line 3 at SQL statement
 INSERT INTO T VALUES (1), (2);
 ALTER TABLE T ADD COLUMN c_bpchar BPCHAR(5) DEFAULT 'hello',
               ALTER COLUMN c_int SET DEFAULT 2;
@@ -161,7 +165,7 @@
 SELECT comp();
    comp    
 -----------
- Unchanged
+ Rewritten
 (1 row)
 
 DROP TABLE T;
@@ -179,11 +183,15 @@
 END; $$ LANGUAGE PLPGSQL STABLE;
 CREATE TABLE T(pk INT NOT NULL PRIMARY KEY, c_int INT DEFAULT LENGTH(foo(6)));
 SELECT set('t');
- set 
------
- 
-(1 row)
-
+ERROR:  cannot update table "m" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "UPDATE m
+  SET id = (SELECT c.relfilenode
+            FROM pg_class AS c, pg_namespace AS s
+            WHERE c.relname = tabname
+                AND c.relnamespace = s.oid
+                AND s.nspname = 'fast_default')"
+PL/pgSQL function set(name) line 3 at SQL statement
 INSERT INTO T VALUES (1), (2);
 ALTER TABLE T ADD COLUMN c_bpchar BPCHAR(5) DEFAULT foo(4),
               ALTER COLUMN c_int SET DEFAULT LENGTH(foo(8));
@@ -241,7 +249,7 @@
 SELECT comp();
    comp    
 -----------
- Unchanged
+ Rewritten
 (1 row)
 
 DROP TABLE T;
@@ -250,17 +258,21 @@
 CREATE TABLE T(pk INT NOT NULL PRIMARY KEY);
 INSERT INTO T VALUES (1);
 SELECT set('t');
- set 
------
- 
-(1 row)
-
+ERROR:  cannot update table "m" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "UPDATE m
+  SET id = (SELECT c.relfilenode
+            FROM pg_class AS c, pg_namespace AS s
+            WHERE c.relname = tabname
+                AND c.relnamespace = s.oid
+                AND s.nspname = 'fast_default')"
+PL/pgSQL function set(name) line 3 at SQL statement
 -- now() is stable, because it returns the transaction timestamp
 ALTER TABLE T ADD COLUMN c1 TIMESTAMP DEFAULT now();
 SELECT comp();
    comp    
 -----------
- Unchanged
+ Rewritten
 (1 row)
 
 -- clock_timestamp() is volatile
@@ -276,11 +288,15 @@
 -- Simple querie
 CREATE TABLE T (pk INT NOT NULL PRIMARY KEY);
 SELECT set('t');
- set 
------
- 
-(1 row)
-
+ERROR:  cannot update table "m" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "UPDATE m
+  SET id = (SELECT c.relfilenode
+            FROM pg_class AS c, pg_namespace AS s
+            WHERE c.relname = tabname
+                AND c.relnamespace = s.oid
+                AND s.nspname = 'fast_default')"
+PL/pgSQL function set(name) line 3 at SQL statement
 INSERT INTO T SELECT * FROM generate_series(1, 10) a;
 ALTER TABLE T ADD COLUMN c_bigint BIGINT NOT NULL DEFAULT -1;
 INSERT INTO T SELECT b, b - 10 FROM generate_series(11, 20) a(b);
@@ -453,18 +469,22 @@
 SELECT comp();
    comp    
 -----------
- Unchanged
+ Rewritten
 (1 row)
 
 DROP TABLE T;
 -- Combine with other DDL
 CREATE TABLE T(pk INT NOT NULL PRIMARY KEY);
 SELECT set('t');
- set 
------
- 
-(1 row)
-
+ERROR:  cannot update table "m" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
+CONTEXT:  SQL statement "UPDATE m
+  SET id = (SELECT c.relfilenode
+            FROM pg_class AS c, pg_namespace AS s
+            WHERE c.relname = tabname
+                AND c.relnamespace = s.oid
+                AND s.nspname = 'fast_default')"
+PL/pgSQL function set(name) line 3 at SQL statement
 INSERT INTO T VALUES (1), (2);
 ALTER TABLE T ADD COLUMN c_int INT NOT NULL DEFAULT -1;
 INSERT INTO T VALUES (3), (4);
@@ -502,7 +522,7 @@
 SELECT comp();
    comp    
 -----------
- Unchanged
+ Rewritten
 (1 row)
 
 -- query to exercise expand_tuple function
@@ -781,26 +801,24 @@
 -- set column with a default 1 to NULL, due to a bug that wasn't
 -- noticed has heap_getattr buggily returned NULL for default columns
 UPDATE t SET a = NULL;
+ERROR:  cannot update table "t" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
 -- verify that index and non-index scans show the same result
 SET LOCAL enable_seqscan = true;
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 SELECT * FROM t WHERE a IS NULL;
- a 
----
-  
-(1 row)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 SET LOCAL enable_seqscan = false;
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 SELECT * FROM t WHERE a IS NULL;
- a 
----
-  
-(1 row)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 ROLLBACK;
 -- verify that a default set on a non-plain table doesn't set a missing
 -- value on the attribute
 CREATE FOREIGN DATA WRAPPER dummy;
+ERROR:  foreign-data wrapper "dummy" already exists
 CREATE SERVER s0 FOREIGN DATA WRAPPER dummy;
+ERROR:  server "s0" already exists
 CREATE FOREIGN TABLE ft1 (c1 integer NOT NULL) SERVER s0;
 ALTER FOREIGN TABLE ft1 ADD COLUMN c8 integer DEFAULT 0;
 ALTER FOREIGN TABLE ft1 ALTER COLUMN c8 TYPE char(10);
@@ -816,7 +834,14 @@
 -- cleanup
 DROP FOREIGN TABLE ft1;
 DROP SERVER s0;
+ERROR:  cannot drop server s0 because other objects depend on it
+DETAIL:  foreign table public.ft1 depends on server s0
+HINT:  Use DROP ... CASCADE to drop the dependent objects too.
 DROP FOREIGN DATA WRAPPER dummy;
+ERROR:  cannot drop foreign-data wrapper dummy because other objects depend on it
+DETAIL:  server s0 depends on foreign-data wrapper dummy
+foreign table public.ft1 depends on server s0
+HINT:  Use DROP ... CASCADE to drop the dependent objects too.
 DROP TABLE vtype;
 DROP TABLE vtype2;
 DROP TABLE follower;
diff -U3 /Users/kenaniah/workspace/postgres/src/test/regress/expected/stats.out /Users/kenaniah/workspace/postgres/src/test/regress/results/stats.out
--- /Users/kenaniah/workspace/postgres/src/test/regress/expected/stats.out	2021-10-03 17:41:49.000000000 -0700
+++ /Users/kenaniah/workspace/postgres/src/test/regress/results/stats.out	2021-10-03 20:08:26.000000000 -0700
@@ -93,11 +93,17 @@
 INSERT INTO trunc_stats_test1 DEFAULT VALUES;
 INSERT INTO trunc_stats_test1 DEFAULT VALUES;
 UPDATE trunc_stats_test1 SET id = id + 10 WHERE id IN (1, 2);
+ERROR:  cannot update table "trunc_stats_test1" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
 DELETE FROM trunc_stats_test1 WHERE id = 3;
 BEGIN;
 UPDATE trunc_stats_test1 SET id = id + 100;
+ERROR:  cannot update table "trunc_stats_test1" because it does not have a replica identity and publishes updates
+HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
 TRUNCATE trunc_stats_test1;
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 INSERT INTO trunc_stats_test1 DEFAULT VALUES;
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 COMMIT;
 -- use a savepoint: 1 insert, 1 live
 BEGIN;
@@ -152,53 +158,11 @@
 -- timeout to elapse, let's just start a new session.  The old one will
 -- then send its stats before dying.
 \c -
--- wait for stats collector to update
-SELECT wait_for_stats();
- wait_for_stats 
-----------------
- 
-(1 row)
-
--- check effects
-SELECT relname, n_tup_ins, n_tup_upd, n_tup_del, n_live_tup, n_dead_tup
-  FROM pg_stat_user_tables
- WHERE relname like 'trunc_stats_test%' order by relname;
-      relname      | n_tup_ins | n_tup_upd | n_tup_del | n_live_tup | n_dead_tup 
--------------------+-----------+-----------+-----------+------------+------------
- trunc_stats_test  |         3 |         0 |         0 |          0 |          0
- trunc_stats_test1 |         4 |         2 |         1 |          1 |          0
- trunc_stats_test2 |         1 |         0 |         0 |          1 |          0
- trunc_stats_test3 |         4 |         0 |         0 |          2 |          2
- trunc_stats_test4 |         2 |         0 |         0 |          0 |          2
-(5 rows)
-
-SELECT st.seq_scan >= pr.seq_scan + 1,
-       st.seq_tup_read >= pr.seq_tup_read + cl.reltuples,
-       st.idx_scan >= pr.idx_scan + 1,
-       st.idx_tup_fetch >= pr.idx_tup_fetch + 1
-  FROM pg_stat_user_tables AS st, pg_class AS cl, prevstats AS pr
- WHERE st.relname='tenk2' AND cl.relname='tenk2';
- ?column? | ?column? | ?column? | ?column? 
-----------+----------+----------+----------
- t        | t        | t        | t
-(1 row)
-
-SELECT st.heap_blks_read + st.heap_blks_hit >= pr.heap_blks + cl.relpages,
-       st.idx_blks_read + st.idx_blks_hit >= pr.idx_blks + 1
-  FROM pg_statio_user_tables AS st, pg_class AS cl, prevstats AS pr
- WHERE st.relname='tenk2' AND cl.relname='tenk2';
- ?column? | ?column? 
-----------+----------
- t        | t
-(1 row)
-
-SELECT pr.snap_ts < pg_stat_get_snapshot_timestamp() as snapshot_newer
-FROM prevstats AS pr;
- snapshot_newer 
-----------------
- t
-(1 row)
+dyld: lazy symbol binding failed: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
+
+dyld: Symbol not found: _PQmblenBounded
+  Referenced from: /Users/kenaniah/workspace/postgres/tmp_install/Users/kenaniah/build/bin/psql
+  Expected in: /usr/local/lib/libpq.5.dylib
 
-DROP TABLE trunc_stats_test, trunc_stats_test1, trunc_stats_test2, trunc_stats_test3, trunc_stats_test4;
-DROP TABLE prevstats;
--- End of Stats Test
